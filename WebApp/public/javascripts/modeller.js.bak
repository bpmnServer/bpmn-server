(function e(t, n, r) { function s(o, u) { if (!n[o]) { if (!t[o]) { var a = typeof require == "function" && require; if (!u && a) return a(o, !0); if (i) return i(o, !0); var f = new Error("Cannot find module '" + o + "'"); throw f.code = "MODULE_NOT_FOUND", f } var l = n[o] = { exports: {} }; t[o][0].call(l.exports, function (e) { var n = t[o][1][e]; return s(n ? n : e) }, l, l.exports, e, t, n, r) } return n[o].exports } var i = typeof require == "function" && require; for (var o = 0; o < r.length; o++)s(r[o]); return s })({
    1: [function (require, module, exports) {
        'use strict';

        var $ = require('jquery'),
            BpmnModeler = require('bpmn-js/lib/Modeler');
        /* Start of OmniFlow Changes */

        function omniSaveSVG(svg, err) {
            OmniSVG = svg;
            return true
        }
        function omniSaveXML(xml, err) {
            /*
         * check modification
         */

            OmniXML = xml;

            window.onbeforeunload = function () {
                return 'Changes to your Model will be lost?';
            };


            return true
        }
        $(document).ready(function () {
            load();
        });
        function load() {
            var xml = document.getElementById('xmlSrc').innerHTML;
            openDiagram(xml);

        }

        /* end of OmniFlow Additions **** SEE Below */


        var container = $('#js-drop-zone');

        var canvas = $('#js-canvas');

        var modeler = new BpmnModeler({ container: canvas });

        var newDiagramXML = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<bpmn2:definitions xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:bpmn2=\"http://www.omg.org/spec/BPMN/20100524/MODEL\" xmlns:bpmndi=\"http://www.omg.org/spec/BPMN/20100524/DI\" xmlns:dc=\"http://www.omg.org/spec/DD/20100524/DC\" xmlns:di=\"http://www.omg.org/spec/DD/20100524/DI\" xsi:schemaLocation=\"http://www.omg.org/spec/BPMN/20100524/MODEL BPMN20.xsd\" id=\"sample-diagram\" targetNamespace=\"http://bpmn.io/schema/bpmn\">\n  <bpmn2:process id=\"Process_1\" isExecutable=\"false\">\n    <bpmn2:startEvent id=\"StartEvent_1\"/>\n  </bpmn2:process>\n  <bpmndi:BPMNDiagram id=\"BPMNDiagram_1\">\n    <bpmndi:BPMNPlane id=\"BPMNPlane_1\" bpmnElement=\"Process_1\">\n      <bpmndi:BPMNShape id=\"_BPMNShape_StartEvent_2\" bpmnElement=\"StartEvent_1\">\n        <dc:Bounds height=\"36.0\" width=\"36.0\" x=\"412.0\" y=\"240.0\"/>\n      </bpmndi:BPMNShape>\n    </bpmndi:BPMNPlane>\n  </bpmndi:BPMNDiagram>\n</bpmn2:definitions>";

        function createNewDiagram() {
            openDiagram(newDiagramXML);
        }

        function openDiagram(xml) {

            modeler.importXML(xml, function (err) {

                if (err) {
                    container
                        .removeClass('with-diagram')
                        .addClass('with-error');

                    container.find('.error pre').text(err.message);

                    console.error(err);
                } else {
                    container
                        .removeClass('with-error')
                        .addClass('with-diagram');
                }


            });
        }

    console.log('bpmnModeler', _Modeler);
    var bpmnModeler = new _Modeler.default({
  container: canvas,
  propertiesPanel: {
    parent: '#js-properties-panel'
  },
  additionalModules: [_bpmnJsPropertiesPanel.default, _camunda.default],
  moddleExtensions: {
    camunda: _camunda2.default
  }
});
  console.log('bpmnModeler', bpmnModeler);
>>>>>>> Stashed changes

        function saveSVG(done) {
            modeler.saveSVG(done);
        }

        function saveDiagram(done) {

            modeler.saveXML({ format: true }, function (err, xml) {
                done(err, xml);
            });
        }

        function registerFileDrop(container, callback) {

            function handleFileSelect(e) {
                e.stopPropagation();
                e.preventDefault();

                var files = e.dataTransfer.files;

                var file = files[0];

                var reader = new FileReader();

                reader.onload = function (e) {

                    var xml = e.target.result;

                    callback(xml);
                };

                reader.readAsText(file);
            }

            function handleDragOver(e) {
                e.stopPropagation();
                e.preventDefault();

                e.dataTransfer.dropEffect = 'copy'; // Explicitly show this is a copy.
            }

            container.get(0).addEventListener('dragover', handleDragOver, false);
            container.get(0).addEventListener('drop', handleFileSelect, false);
        }


        ////// file drag / drop ///////////////////////

        // check file api availability
        if (!window.FileList || !window.FileReader) {
            window.alert(
                'Looks like you use an older browser that does not support drag and drop. ' +
                'Try using Chrome, Firefox or the Internet Explorer > 10.');
        } else {
            registerFileDrop(container, openDiagram);
        }

        // bootstrap diagram functions

        $(document).on('ready', function () {

            $('#js-create-diagram').click(function (e) {
                e.stopPropagation();
                e.preventDefault();

                createNewDiagram();
            });

            var downloadLink = $('#js-download-diagram');
            var downloadSvgLink = $('#js-download-svg');

            $('.buttons a').click(function (e) {
                if (!$(this).is('.active')) {
                    e.preventDefault();
                    e.stopPropagation();
                }
            });

            function setEncoded(link, name, data) {
                var encodedData = encodeURIComponent(data);

                if (data) {
                    link.addClass('active').attr({
                        'href': 'data:application/bpmn20-xml;charset=UTF-8,' + encodedData,
                        'download': name
                    });
                } else {
                    link.removeClass('active');
                }
            }

            var _ = require('lodash');

            var exportArtifacts = _.debounce(function () {

                saveSVG(function (err, svg) {
                    // setEncoded(downloadSvgLink, 'diagram.svg', err ? null : svg);
                    // OmniFlow changes
                    omniSaveSVG(svg, err);
                    OmniChangesCallback();
                });

                saveDiagram(function (err, xml) {
                    //setEncoded(downloadLink, 'diagram.bpmn', err ? null : xml);
                    // OmniFlow changes
                    omniSaveXML(xml, err);

                });
            }, 500);

            modeler.on('commandStack.changed', exportArtifacts);
        });
    }, { "bpmn-js/lib/Modeler": 2, "jquery": 290, "lodash": 317 }], 2: [function (require, module, exports) {
        'use strict';

        var inherits = require('inherits');

        var Ids = require('ids');

        var Viewer = require('./Viewer');

        var NavigatedViewer = require('./NavigatedViewer');

        var initialDiagram =
            '<?xml version="1.0" encoding="UTF-8"?>' +
            '<bpmn:definitions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" ' +
            'xmlns:bpmn="http://www.omg.org/spec/BPMN/20100524/MODEL" ' +
            'xmlns:bpmndi="http://www.omg.org/spec/BPMN/20100524/DI" ' +
            'xmlns:dc="http://www.omg.org/spec/DD/20100524/DC" ' +
            'targetNamespace="http://bpmn.io/schema/bpmn" ' +
            'id="Definitions_1">' +
            '<bpmn:process id="Process_1" isExecutable="false">' +
            '<bpmn:startEvent id="StartEvent_1"/>' +
            '</bpmn:process>' +
            '<bpmndi:BPMNDiagram id="BPMNDiagram_1">' +
            '<bpmndi:BPMNPlane id="BPMNPlane_1" bpmnElement="Process_1">' +
            '<bpmndi:BPMNShape id="_BPMNShape_StartEvent_2" bpmnElement="StartEvent_1">' +
            '<dc:Bounds height="36.0" width="36.0" x="173.0" y="102.0"/>' +
            '</bpmndi:BPMNShape>' +
            '</bpmndi:BPMNPlane>' +
            '</bpmndi:BPMNDiagram>' +
            '</bpmn:definitions>';


        /**
         * A modeler for BPMN 2.0 diagrams.
         *
         *
         * ## Extending the Modeler
         *
         * In order to extend the viewer pass extension modules to bootstrap via the
         * `additionalModules` option. An extension module is an object that exposes
         * named services.
         *
         * The following example depicts the integration of a simple
         * logging component that integrates with interaction events:
         *
         *
         * ```javascript
         *
         * // logging component
         * function InteractionLogger(eventBus) {
         *   eventBus.on('element.hover', function(event) {
         *     console.log()
         *   })
         * }
         *
         * InteractionLogger.$inject = [ 'eventBus' ]; // minification save
         *
         * // extension module
         * var extensionModule = {
         *   __init__: [ 'interactionLogger' ],
         *   interactionLogger: [ 'type', InteractionLogger ]
         * };
         *
         * // extend the viewer
         * var bpmnModeler = new Modeler({ additionalModules: [ extensionModule ] });
         * bpmnModeler.importXML(...);
         * ```
         *
         *
         * ## Customizing / Replacing Components
         *
         * You can replace individual diagram components by redefining them in override modules.
         * This works for all components, including those defined in the core.
         *
         * Pass in override modules via the `options.additionalModules` flag like this:
         *
         * ```javascript
         * function CustomContextPadProvider(contextPad) {
         *
         *   contextPad.registerProvider(this);
         *
         *   this.getContextPadEntries = function(element) {
         *     // no entries, effectively disable the context pad
         *     return {};
         *   };
         * }
         *
         * CustomContextPadProvider.$inject = [ 'contextPad' ];
         *
         * var overrideModule = {
         *   contextPadProvider: [ 'type', CustomContextPadProvider ]
         * };
         *
         * var bpmnModeler = new Modeler({ additionalModules: [ overrideModule ]});
         * ```
         *
         * @param {Object} [options] configuration options to pass to the viewer
         * @param {DOMElement} [options.container] the container to render the viewer in, defaults to body.
         * @param {String|Number} [options.width] the width of the viewer
         * @param {String|Number} [options.height] the height of the viewer
         * @param {Object} [options.moddleExtensions] extension packages to provide
         * @param {Array<didi.Module>} [options.modules] a list of modules to override the default modules
         * @param {Array<didi.Module>} [options.additionalModules] a list of modules to use with the default modules
         */
        function Modeler(options) {
            Viewer.call(this, options);

            // hook ID collection into the modeler
            this.on('import.parse.complete', function (event) {
                if (!event.error) {
                    this._collectIds(event.definitions, event.context);
                }
            }, this);

            this.on('diagram.destroy', function () {
                this.moddle.ids.clear();
            }, this);
        }

        inherits(Modeler, Viewer);

        module.exports = Modeler;

        module.exports.Viewer = Viewer;

        module.exports.NavigatedViewer = NavigatedViewer;

        /**
         * Create a new diagram to start modeling.
         *
         * @param {Function} [done]
         */
        Modeler.prototype.createDiagram = function (done) {
            return this.importXML(initialDiagram, done);
        };

        /**
         * Create a moddle instance, attaching ids to it.
         *
         * @param {Object} options
         */
        Modeler.prototype._createModdle = function (options) {
            var moddle = Viewer.prototype._createModdle.call(this, options);

            // attach ids to moddle to be able to track
            // and validated ids in the BPMN 2.0 XML document
            // tree
            moddle.ids = new Ids([32, 36, 1]);

            return moddle;
        };

        /**
         * Collect ids processed during parsing of the
         * definitions object.
         *
         * @param {ModdleElement} definitions
         * @param {Context} context
         */
        Modeler.prototype._collectIds = function (definitions, context) {

            var moddle = definitions.$model,
                ids = moddle.ids,
                id;

            // remove references from previous import
            ids.clear();

            for (id in context.elementsById) {
                ids.claim(id, context.elementsById[id]);
            }
        };


        Modeler.prototype._interactionModules = [
            // non-modeling components
            require('diagram-js/lib/navigation/movecanvas'),
            require('diagram-js/lib/navigation/touch'),
            require('diagram-js/lib/navigation/zoomscroll')
        ];

        Modeler.prototype._modelingModules = [
            // modeling components
            require('diagram-js/lib/features/auto-scroll'),
            require('diagram-js/lib/features/bendpoints'),
            require('diagram-js/lib/features/move'),
            require('diagram-js/lib/features/resize'),
            require('./features/auto-resize'),
            require('./features/editor-actions'),
            require('./features/context-pad'),
            require('./features/keyboard'),
            require('./features/label-editing'),
            require('./features/modeling'),
            require('./features/palette'),
            require('./features/replace-preview'),
            require('./features/snapping')
        ];


        // modules the modeler is composed of
        //
        // - viewer modules
        // - interaction modules
        // - modeling modules

        Modeler.prototype._modules = [].concat(
            Modeler.prototype._modules,
            Modeler.prototype._interactionModules,
            Modeler.prototype._modelingModules);

    }, { "./NavigatedViewer": 3, "./Viewer": 4, "./features/auto-resize": 11, "./features/context-pad": 13, "./features/editor-actions": 19, "./features/keyboard": 23, "./features/label-editing": 27, "./features/modeling": 66, "./features/palette": 72, "./features/replace-preview": 77, "./features/snapping": 87, "diagram-js/lib/features/auto-scroll": 139, "diagram-js/lib/features/bendpoints": 145, "diagram-js/lib/features/move": 206, "diagram-js/lib/features/resize": 224, "diagram-js/lib/navigation/movecanvas": 256, "diagram-js/lib/navigation/touch": 257, "diagram-js/lib/navigation/zoomscroll": 260, "ids": 288, "inherits": 289 }], 3: [function (require, module, exports) {
        'use strict';

        var inherits = require('inherits');

        var Viewer = require('./Viewer');


        /**
         * A viewer that includes mouse navigation facilities
         *
         * @param {Object} options
         */
        function NavigatedViewer(options) {
            Viewer.call(this, options);
        }

        inherits(NavigatedViewer, Viewer);

        module.exports = NavigatedViewer;

        NavigatedViewer.prototype._navigationModules = [
            require('diagram-js/lib/navigation/zoomscroll'),
            require('diagram-js/lib/navigation/movecanvas')
        ];

        NavigatedViewer.prototype._modules = [].concat(
            NavigatedViewer.prototype._modules,
            NavigatedViewer.prototype._navigationModules);
    }, { "./Viewer": 4, "diagram-js/lib/navigation/movecanvas": 256, "diagram-js/lib/navigation/zoomscroll": 260, "inherits": 289 }], 4: [function (require, module, exports) {
        /**
         * The code in the <project-logo></project-logo> area
         * must not be changed.
         *
         * @see http://bpmn.io/license for more information.
         */
        'use strict';

        var assign = require('lodash/object/assign'),
            omit = require('lodash/object/omit'),
            isNumber = require('lodash/lang/isNumber');

        var domify = require('min-dom/lib/domify'),
            domQuery = require('min-dom/lib/query'),
            domRemove = require('min-dom/lib/remove');

        var innerSVG = require('tiny-svg/lib/innerSVG');

        var Diagram = require('diagram-js'),
            BpmnModdle = require('bpmn-moddle');


        var inherits = require('inherits');

        var Importer = require('./import/Importer');


        function checkValidationError(err) {

            // check if we can help the user by indicating wrong BPMN 2.0 xml
            // (in case he or the exporting tool did not get that right)

            var pattern = /unparsable content <([^>]+)> detected([\s\S]*)$/;
            var match = pattern.exec(err.message);

            if (match) {
                err.message =
                    'unparsable content <' + match[1] + '> detected; ' +
                    'this may indicate an invalid BPMN 2.0 diagram file' + match[2];
            }

            return err;
        }

        var DEFAULT_OPTIONS = {
            width: '100%',
            height: '100%',
            position: 'relative'
        };


        /**
         * Ensure the passed argument is a proper unit (defaulting to px)
         */
        function ensureUnit(val) {
            return val + (isNumber(val) ? 'px' : '');
        }

        /**
         * A viewer for BPMN 2.0 diagrams.
         *
         * Have a look at {@link NavigatedViewer} or {@link Modeler} for bundles that include
         * additional features.
         *
         *
         * ## Extending the Viewer
         *
         * In order to extend the viewer pass extension modules to bootstrap via the
         * `additionalModules` option. An extension module is an object that exposes
         * named services.
         *
         * The following example depicts the integration of a simple
         * logging component that integrates with interaction events:
         *
         *
         * ```javascript
         *
         * // logging component
         * function InteractionLogger(eventBus) {
         *   eventBus.on('element.hover', function(event) {
         *     console.log()
         *   })
         * }
         *
         * InteractionLogger.$inject = [ 'eventBus' ]; // minification save
         *
         * // extension module
         * var extensionModule = {
         *   __init__: [ 'interactionLogger' ],
         *   interactionLogger: [ 'type', InteractionLogger ]
         * };
         *
         * // extend the viewer
         * var bpmnViewer = new Viewer({ additionalModules: [ extensionModule ] });
         * bpmnViewer.importXML(...);
         * ```
         *
         * @param {Object} [options] configuration options to pass to the viewer
         * @param {DOMElement} [options.container] the container to render the viewer in, defaults to body.
         * @param {String|Number} [options.width] the width of the viewer
         * @param {String|Number} [options.height] the height of the viewer
         * @param {Object} [options.moddleExtensions] extension packages to provide
         * @param {Array<didi.Module>} [options.modules] a list of modules to override the default modules
         * @param {Array<didi.Module>} [options.additionalModules] a list of modules to use with the default modules
         */
        function Viewer(options) {

            options = assign({}, DEFAULT_OPTIONS, options);

            this.moddle = this._createModdle(options);

            this.container = this._createContainer(options);

            /* <project-logo> */

            addProjectLogo(this.container);

            /* </project-logo> */

            this._init(this.container, this.moddle, options);
        }

        inherits(Viewer, Diagram);

        module.exports = Viewer;


        /**
         * Parse and render a BPMN 2.0 diagram.
         *
         * Once finished the viewer reports back the result to the
         * provided callback function with (err, warnings).
         *
         * ## Life-Cycle Events
         *
         * During import the viewer will fire life-cycle events:
         *
         *   * import.parse.start (about to read model from xml)
         *   * import.parse.complete (model read; may have worked or not)
         *   * import.render.start (graphical import start)
         *   * import.render.complete (graphical import finished)
         *   * import.done (everything done)
         *
         * You can use these events to hook into the life-cycle.
         *
         * @param {String} xml the BPMN 2.0 xml
         * @param {Function} [done] invoked with (err, warnings=[])
         */
        Viewer.prototype.importXML = function (xml, done) {

            // done is optional
            done = done || function () { };

            var self = this;

            // hook in pre-parse listeners +
            // allow xml manipulation
            xml = this._emit('import.parse.start', { xml: xml }) || xml;

            this.moddle.fromXML(xml, 'bpmn:Definitions', function (err, definitions, context) {

                // hook in post parse listeners +
                // allow definitions manipulation
                definitions = self._emit('import.parse.complete', {
                    error: err,
                    definitions: definitions,
                    context: context
                }) || definitions;

                if (err) {
                    err = checkValidationError(err);

                    self._emit('import.done', { error: err });

                    return done(err);
                }

                var parseWarnings = context.warnings;

                self.importDefinitions(definitions, function (err, importWarnings) {
                    var allWarnings = [].concat(parseWarnings, importWarnings || []);

                    self._emit('import.done', { error: err, warnings: allWarnings });

                    done(err, allWarnings);
                });
            });
        };

        /**
         * Export the currently displayed BPMN 2.0 diagram as
         * a BPMN 2.0 XML document.
         *
         * @param {Object} [options] export options
         * @param {Boolean} [options.format=false] output formated XML
         * @param {Boolean} [options.preamble=true] output preamble
         *
         * @param {Function} done invoked with (err, xml)
         */
        Viewer.prototype.saveXML = function (options, done) {

            if (!done) {
                done = options;
                options = {};
            }

            var definitions = this.definitions;

            if (!definitions) {
                return done(new Error('no definitions loaded'));
            }

            this.moddle.toXML(definitions, options, done);
        };

        /**
         * Export the currently displayed BPMN 2.0 diagram as
         * an SVG image.
         *
         * @param {Object} [options]
         * @param {Function} done invoked with (err, svgStr)
         */
        Viewer.prototype.saveSVG = function (options, done) {

            if (!done) {
                done = options;
                options = {};
            }

            var canvas = this.get('canvas');

            var contentNode = canvas.getDefaultLayer(),
                defsNode = domQuery('defs', canvas._svg);

            var contents = innerSVG(contentNode),
                defs = (defsNode && defsNode.outerHTML) || '';

            var bbox = contentNode.getBBox();

            var svg =
                '<?xml version="1.0" encoding="utf-8"?>\n' +
                '<!-- created with bpmn-js / http://bpmn.io -->\n' +
                '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n' +
                '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" ' +
                'width="' + bbox.width + '" height="' + bbox.height + '" ' +
                'viewBox="' + bbox.x + ' ' + bbox.y + ' ' + bbox.width + ' ' + bbox.height + '" version="1.1">' +
                defs + contents +
                '</svg>';

            done(null, svg);
        };

        /**
         * Get a named diagram service.
         *
         * @example
         *
         * var elementRegistry = viewer.get('elementRegistry');
         * var startEventShape = elementRegistry.get('StartEvent_1');
         *
         * @param {String} name
         *
         * @return {Object} diagram service instance
         *
         * @method Viewer#get
         */

        /**
         * Invoke a function in the context of this viewer.
         *
         * @example
         *
         * viewer.invoke(function(elementRegistry) {
         *   var startEventShape = elementRegistry.get('StartEvent_1');
         * });
         *
         * @param {Function} fn to be invoked
         *
         * @return {Object} the functions return value
         *
         * @method Viewer#invoke
         */

        /**
         * Remove all drawn elements from the viewer.
         *
         * After calling this method the viewer can still
         * be reused for opening another diagram.
         *
         * @method Viewer#clear
         */

        Viewer.prototype.importDefinitions = function (definitions, done) {

            // use try/catch to not swallow synchronous exceptions
            // that may be raised during model parsing
            try {

                if (this.definitions) {
                    // clear existing rendered diagram
                    this.clear();
                }

                // update definitions
                this.definitions = definitions;

                // perform graphical import
                Importer.importBpmnDiagram(this, definitions, done);
            } catch (e) {

                // handle synchronous errors
                done(e);
            }
        };

        Viewer.prototype.getModules = function () {
            return this._modules;
        };

        /**
         * Destroy the viewer instance and remove all its
         * remainders from the document tree.
         */
        Viewer.prototype.destroy = function () {

            // diagram destroy
            Diagram.prototype.destroy.call(this);

            // dom detach
            domRemove(this.container);
        };

        /**
         * Register an event listener
         *
         * Remove a previously added listener via {@link #off(event, callback)}.
         *
         * @param {String} event
         * @param {Number} [priority]
         * @param {Function} callback
         * @param {Object} [that]
         */
        Viewer.prototype.on = function (event, priority, callback, target) {
            return this.get('eventBus').on(event, priority, callback, target);
        };

        /**
         * De-register an event listener
         *
         * @param {String} event
         * @param {Function} callback
         */
        Viewer.prototype.off = function (event, callback) {
            this.get('eventBus').off(event, callback);
        };

        Viewer.prototype.attachTo = function (parentNode) {

            if (!parentNode) {
                throw new Error('parentNode required');
            }

            // ensure we detach from the
            // previous, old parent
            this.detach();

            // unwrap jQuery if provided
            if (parentNode.get && parentNode.constructor.prototype.jquery) {
                parentNode = parentNode.get(0);
            }

            if (typeof parentNode === 'string') {
                parentNode = domQuery(parentNode);
            }

            var container = this._container;

            parentNode.appendChild(container);

            this._emit('attach', {});
        };

        Viewer.prototype.detach = function () {

            var container = this._container,
                parentNode = container.parentNode;

            if (!parentNode) {
                return;
            }

            this._emit('detach', {});

            parentNode.removeChild(container);
        };

        Viewer.prototype._init = function (container, moddle, options) {

            this._container = container;
            var baseModules = options.modules || this.getModules(),
                additionalModules = options.additionalModules || [],
                staticModules = [
                    {
                        bpmnjs: ['value', this],
                        moddle: ['value', moddle]
                    }
                ];

            var diagramModules = [].concat(staticModules, baseModules, additionalModules);

            var diagramOptions = assign(omit(options, 'additionalModules'), {
                canvas: assign({}, options.canvas, { container: container }),
                modules: diagramModules
            });

            // invoke diagram constructor
            Diagram.call(this, diagramOptions);

            if (options && options.container) {
                this.attachTo(options.container);
            }
        };

        /**
         * Emit an event on the underlying {@link EventBus}
         *
         * @param  {String} type
         * @param  {Object} event
         *
         * @return {Object} event processing result (if any)
         */
        Viewer.prototype._emit = function (type, event) {
            return this.get('eventBus').fire(type, event);
        };

        Viewer.prototype._createContainer = function (options) {

            var container = domify('<div class="bjs-container"></div>');

            assign(container.style, {
                width: ensureUnit(options.width),
                height: ensureUnit(options.height),
                position: options.position
            });

            return container;
        };

        Viewer.prototype._createModdle = function (options) {
            var moddleOptions = assign({}, this._moddleExtensions, options.moddleExtensions);

            return new BpmnModdle(moddleOptions);
        };


        // modules the viewer is composed of
        Viewer.prototype._modules = [
            require('./core'),
            require('diagram-js/lib/i18n/translate'),
            require('diagram-js/lib/features/selection'),
            require('diagram-js/lib/features/overlays')
        ];

        // default moddle extensions the viewer is composed of
        Viewer.prototype._moddleExtensions = {};

        /* <project-logo> */

        var PoweredBy = require('./util/PoweredByUtil'),
            domEvent = require('min-dom/lib/event');

        /**
         * Adds the project logo to the diagram container as
         * required by the bpmn.io license.
         *
         * @see http://bpmn.io/license
         *
         * @param {Element} container
         */
        function addProjectLogo(container) {
            var logoData = PoweredBy.BPMNIO_LOGO;

            var linkMarkup =
                '<a href="http://bpmn.io" ' +
                'target="_blank" ' +
                'class="bjs-powered-by" ' +
                'title="Powered by bpmn.io" ' +
                'style="position: absolute; bottom: 15px; right: 15px; z-index: 100">' +
                '<img src="data:image/png;base64,' + logoData + '">' +
                '</a>';

            var linkElement = domify(linkMarkup);

            container.appendChild(linkElement);

            domEvent.bind(linkElement, 'click', function (event) {
                PoweredBy.open();

                event.preventDefault();
            });
        }

        /* </project-logo> */

    }, { "./core": 5, "./import/Importer": 90, "./util/PoweredByUtil": 96, "bpmn-moddle": 99, "diagram-js": 117, "diagram-js/lib/features/overlays": 211, "diagram-js/lib/features/selection": 233, "diagram-js/lib/i18n/translate": 248, "inherits": 289, "lodash/lang/isNumber": 427, "lodash/object/assign": 433, "lodash/object/omit": 438, "min-dom/lib/domify": 451, "min-dom/lib/event": 452, "min-dom/lib/query": 454, "min-dom/lib/remove": 455, "tiny-svg/lib/innerSVG": 481 }], 5: [function (require, module, exports) {
        module.exports = {
            __depends__: [
                require('../draw'),
                require('../import')
            ]
        };
    }, { "../draw": 8, "../import": 92 }], 6: [function (require, module, exports) {
        'use strict';

        var inherits = require('inherits'),
            isObject = require('lodash/lang/isObject'),
            assign = require('lodash/object/assign'),
            forEach = require('lodash/collection/forEach'),
            every = require('lodash/collection/every'),
            some = require('lodash/collection/some');

        var BaseRenderer = require('diagram-js/lib/draw/BaseRenderer'),
            TextUtil = require('diagram-js/lib/util/Text'),
            DiUtil = require('../util/DiUtil');

        var getBusinessObject = require('../util/ModelUtil').getBusinessObject,
            is = require('../util/ModelUtil').is;

        var RenderUtil = require('diagram-js/lib/util/RenderUtil');

        var componentsToPath = RenderUtil.componentsToPath,
            createLine = RenderUtil.createLine;

        var domQuery = require('min-dom/lib/query');

        var svgAppend = require('tiny-svg/lib/append'),
            svgAttr = require('tiny-svg/lib/attr'),
            svgCreate = require('tiny-svg/lib/create'),
            svgClasses = require('tiny-svg/lib/classes');

        var rotate = require('diagram-js/lib/util/SvgTransformUtil').rotate,
            transform = require('diagram-js/lib/util/SvgTransformUtil').transform,
            translate = require('diagram-js/lib/util/SvgTransformUtil').translate;

        var TASK_BORDER_RADIUS = 10;
        var INNER_OUTER_DIST = 3;

        var LABEL_STYLE = {
            fontFamily: 'Arial, sans-serif',
            fontSize: 12
        };


        function BpmnRenderer(eventBus, styles, pathMap, canvas, priority) {

            BaseRenderer.call(this, eventBus, priority);

            var textUtil = new TextUtil({
                style: LABEL_STYLE,
                size: { width: 100 }
            });

            var markers = {};

            var computeStyle = styles.computeStyle;

            function addMarker(id, options) {
                var attrs = assign({
                    fill: 'black',
                    strokeWidth: 1,
                    strokeLinecap: 'round',
                    strokeDasharray: 'none'
                }, options.attrs);

                var ref = options.ref || { x: 0, y: 0 };

                var scale = options.scale || 1;

                // fix for safari / chrome / firefox bug not correctly
                // resetting stroke dash array
                if (attrs.strokeDasharray === 'none') {
                    attrs.strokeDasharray = [10000, 1];
                }

                var marker = svgCreate('marker');

                svgAttr(options.element, attrs);

                svgAppend(marker, options.element);

                svgAttr(marker, {
                    id: id,
                    viewBox: '0 0 20 20',
                    refX: ref.x,
                    refY: ref.y,
                    markerWidth: 20 * scale,
                    markerHeight: 20 * scale,
                    orient: 'auto'
                });

                var defs = domQuery('defs', canvas._svg);

                if (!defs) {
                    defs = svgCreate('defs');

                    svgAppend(canvas._svg, defs);
                }

                svgAppend(defs, marker);

                markers[id] = marker;
            }

            function marker(type, fill, stroke) {
                var id = type + '-' + fill + '-' + stroke;

                if (!markers[id]) {
                    createMarker(type, fill, stroke);
                }

                return 'url(#' + id + ')';
            }

            function createMarker(type, fill, stroke) {
                var id = type + '-' + fill + '-' + stroke;

                if (type === 'sequenceflow-end') {
                    var sequenceflowEnd = svgCreate('path');
                    svgAttr(sequenceflowEnd, { d: 'M 1 5 L 11 10 L 1 15 Z' });

                    addMarker(id, {
                        element: sequenceflowEnd,
                        ref: { x: 11, y: 10 },
                        scale: 0.5,
                        attrs: {
                            fill: stroke,
                            stroke: stroke
                        }
                    });
                }

                if (type === 'messageflow-start') {
                    var messageflowStart = svgCreate('circle');
                    svgAttr(messageflowStart, { cx: 6, cy: 6, r: 3.5 });

                    addMarker(id, {
                        element: messageflowStart,
                        attrs: {
                            fill: fill,
                            stroke: stroke
                        },
                        ref: { x: 6, y: 6 }
                    });
                }

                if (type === 'messageflow-end') {
                    var messageflowEnd = svgCreate('path');
                    svgAttr(messageflowEnd, { d: 'm 1 5 l 0 -3 l 7 3 l -7 3 z' });

                    addMarker(id, {
                        element: messageflowEnd,
                        attrs: {
                            fill: fill,
                            stroke: stroke,
                            strokeLinecap: 'butt'
                        },
                        ref: { x: 8.5, y: 5 }
                    });
                }

                if (type === 'association-start') {
                    var associationStart = svgCreate('path');
                    svgAttr(associationStart, { d: 'M 11 5 L 1 10 L 11 15' });

                    addMarker(id, {
                        element: associationStart,
                        attrs: {
                            fill: 'none',
                            stroke: stroke,
                            strokeWidth: 1.5
                        },
                        ref: { x: 1, y: 10 },
                        scale: 0.5
                    });
                }

                if (type === 'association-end') {
                    var associationEnd = svgCreate('path');
                    svgAttr(associationEnd, { d: 'M 1 5 L 11 10 L 1 15' });

                    addMarker(id, {
                        element: associationEnd,
                        attrs: {
                            fill: 'none',
                            stroke: stroke,
                            strokeWidth: 1.5
                        },
                        ref: { x: 12, y: 10 },
                        scale: 0.5
                    });
                }

                if (type === 'conditional-flow-marker') {
                    var conditionalflowMarker = svgCreate('path');
                    svgAttr(conditionalflowMarker, { d: 'M 0 10 L 8 6 L 16 10 L 8 14 Z' });

                    addMarker(id, {
                        element: conditionalflowMarker,
                        attrs: {
                            fill: fill,
                            stroke: stroke
                        },
                        ref: { x: -1, y: 10 },
                        scale: 0.5
                    });
                }

                if (type === 'conditional-default-flow-marker') {
                    var conditionaldefaultflowMarker = svgCreate('path');
                    svgAttr(conditionaldefaultflowMarker, { d: 'M 6 4 L 10 16' });

                    addMarker(id, {
                        element: conditionaldefaultflowMarker,
                        attrs: {
                            stroke: stroke
                        },
                        ref: { x: 0, y: 10 },
                        scale: 0.5
                    });
                }
            }

            function drawCircle(parentGfx, width, height, offset, attrs) {

                if (isObject(offset)) {
                    attrs = offset;
                    offset = 0;
                }

                offset = offset || 0;

                attrs = computeStyle(attrs, {
                    stroke: 'black',
                    strokeWidth: 2,
                    fill: 'white'
                });

                var cx = width / 2,
                    cy = height / 2;

                var circle = svgCreate('circle');
                svgAttr(circle, {
                    cx: cx,
                    cy: cy,
                    r: Math.round((width + height) / 4 - offset)
                });
                svgAttr(circle, attrs);

                svgAppend(parentGfx, circle);

                return circle;
            }

            function drawRect(parentGfx, width, height, r, offset, attrs) {

                if (isObject(offset)) {
                    attrs = offset;
                    offset = 0;
                }

                offset = offset || 0;

                attrs = computeStyle(attrs, {
                    stroke: 'black',
                    strokeWidth: 2,
                    fill: 'white'
                });

                var rect = svgCreate('rect');
                svgAttr(rect, {
                    x: offset,
                    y: offset,
                    width: width - offset * 2,
                    height: height - offset * 2,
                    rx: r,
                    ry: r
                });
                svgAttr(rect, attrs);

                svgAppend(parentGfx, rect);

                return rect;
            }

            function drawDiamond(parentGfx, width, height, attrs) {

                var x_2 = width / 2;
                var y_2 = height / 2;

                var points = [{ x: x_2, y: 0 }, { x: width, y: y_2 }, { x: x_2, y: height }, { x: 0, y: y_2 }];

                var pointsString = points.map(function (point) {
                    return point.x + ',' + point.y;
                }).join(' ');

                attrs = computeStyle(attrs, {
                    stroke: 'black',
                    strokeWidth: 2,
                    fill: 'white'
                });

                var polygon = svgCreate('polygon');
                svgAttr(polygon, {
                    points: pointsString
                });
                svgAttr(polygon, attrs);

                svgAppend(parentGfx, polygon);

                return polygon;
            }

            function drawLine(parentGfx, waypoints, attrs) {
                attrs = computeStyle(attrs, ['no-fill'], {
                    stroke: 'black',
                    strokeWidth: 2,
                    fill: 'none'
                });

                var line = createLine(waypoints, attrs);

                svgAppend(parentGfx, line);

                return line;
            }

            function drawPath(parentGfx, d, attrs) {

                attrs = computeStyle(attrs, ['no-fill'], {
                    strokeWidth: 2,
                    stroke: 'black'
                });

                var path = svgCreate('path');
                svgAttr(path, { d: d });
                svgAttr(path, attrs);

                svgAppend(parentGfx, path);

                return path;
            }

            function drawMarker(type, parentGfx, path, attrs) {
                return drawPath(parentGfx, path, assign({ 'data-marker': type }, attrs));
            }

            function as(type) {
                return function (parentGfx, element) {
                    return handlers[type](parentGfx, element);
                };
            }

            function renderer(type) {
                return handlers[type];
            }

            function renderEventContent(element, parentGfx) {

                var event = getSemantic(element);
                var isThrowing = isThrowEvent(event);

                if (isTypedEvent(event, 'bpmn:MessageEventDefinition')) {
                    return renderer('bpmn:MessageEventDefinition')(parentGfx, element, isThrowing);
                }

                if (isTypedEvent(event, 'bpmn:TimerEventDefinition')) {
                    return renderer('bpmn:TimerEventDefinition')(parentGfx, element, isThrowing);
                }

                if (isTypedEvent(event, 'bpmn:ConditionalEventDefinition')) {
                    return renderer('bpmn:ConditionalEventDefinition')(parentGfx, element);
                }

                if (isTypedEvent(event, 'bpmn:SignalEventDefinition')) {
                    return renderer('bpmn:SignalEventDefinition')(parentGfx, element, isThrowing);
                }

                if (isTypedEvent(event, 'bpmn:CancelEventDefinition') &&
                    isTypedEvent(event, 'bpmn:TerminateEventDefinition', { parallelMultiple: false })) {
                    return renderer('bpmn:MultipleEventDefinition')(parentGfx, element, isThrowing);
                }

                if (isTypedEvent(event, 'bpmn:CancelEventDefinition') &&
                    isTypedEvent(event, 'bpmn:TerminateEventDefinition', { parallelMultiple: true })) {
                    return renderer('bpmn:ParallelMultipleEventDefinition')(parentGfx, element, isThrowing);
                }

                if (isTypedEvent(event, 'bpmn:EscalationEventDefinition')) {
                    return renderer('bpmn:EscalationEventDefinition')(parentGfx, element, isThrowing);
                }

                if (isTypedEvent(event, 'bpmn:LinkEventDefinition')) {
                    return renderer('bpmn:LinkEventDefinition')(parentGfx, element, isThrowing);
                }

                if (isTypedEvent(event, 'bpmn:ErrorEventDefinition')) {
                    return renderer('bpmn:ErrorEventDefinition')(parentGfx, element, isThrowing);
                }

                if (isTypedEvent(event, 'bpmn:CancelEventDefinition')) {
                    return renderer('bpmn:CancelEventDefinition')(parentGfx, element, isThrowing);
                }

                if (isTypedEvent(event, 'bpmn:CompensateEventDefinition')) {
                    return renderer('bpmn:CompensateEventDefinition')(parentGfx, element, isThrowing);
                }

                if (isTypedEvent(event, 'bpmn:TerminateEventDefinition')) {
                    return renderer('bpmn:TerminateEventDefinition')(parentGfx, element, isThrowing);
                }

                return null;
            }

            function renderLabel(parentGfx, label, options) {
                var text = textUtil.createText(label || '', options);
                svgClasses(text).add('djs-label');
                svgAppend(parentGfx, text);

                return text;
            }

            function renderEmbeddedLabel(parentGfx, element, align) {
                var semantic = getSemantic(element);

                return renderLabel(parentGfx, semantic.name, {
                    box: element,
                    align: align,
                    padding: 5,
                    style: {
                        fill: getStrokeColor(element)
                    }
                });
            }

            function renderExternalLabel(parentGfx, element) {
                var semantic = getSemantic(element);
                var box = {
                    width: 90,
                    height: 30,
                    x: element.width / 2 + element.x,
                    y: element.height / 2 + element.y
                };

                return renderLabel(parentGfx, semantic.name, {
                    box: box,
                    fitBox: true,
                    style: { fontSize: '11px' }
                });
            }

            function renderLaneLabel(parentGfx, text, element) {
                var textBox = renderLabel(parentGfx, text, {
                    box: { height: 30, width: element.height },
                    align: 'center-middle',
                    style: {
                        fill: getStrokeColor(element)
                    }
                });

                var top = -1 * element.height;

                transform(textBox, 0, -top, 270);
            }

            function createPathFromConnection(connection) {
                var waypoints = connection.waypoints;

                var pathData = 'm  ' + waypoints[0].x + ',' + waypoints[0].y;
                for (var i = 1; i < waypoints.length; i++) {
                    pathData += 'L' + waypoints[i].x + ',' + waypoints[i].y + ' ';
                }
                return pathData;
            }

            var handlers = this.handlers = {
                'bpmn:Event': function (parentGfx, element, attrs) {
                    return drawCircle(parentGfx, element.width, element.height, attrs);
                },
                'bpmn:StartEvent': function (parentGfx, element) {
                    var attrs = {
                        fill: getFillColor(element),
                        stroke: getStrokeColor(element)
                    };

                    var semantic = getSemantic(element);

                    if (!semantic.isInterrupting) {
                        attrs = {
                            strokeDasharray: '6',
                            strokeLinecap: 'round'
                        };
                    }

                    var circle = renderer('bpmn:Event')(parentGfx, element, attrs);

                    renderEventContent(element, parentGfx);

                    return circle;
                },
                'bpmn:MessageEventDefinition': function (parentGfx, element, isThrowing) {
                    var pathData = pathMap.getScaledPath('EVENT_MESSAGE', {
                        xScaleFactor: 0.9,
                        yScaleFactor: 0.9,
                        containerWidth: element.width,
                        containerHeight: element.height,
                        position: {
                            mx: 0.235,
                            my: 0.315
                        }
                    });

                    var fill = isThrowing ? getStrokeColor(element) : getFillColor(element);
                    var stroke = isThrowing ? getFillColor(element) : getStrokeColor(element);

                    var messagePath = drawPath(parentGfx, pathData, {
                        strokeWidth: 1,
                        fill: fill,
                        stroke: stroke
                    });

                    return messagePath;
                },
                'bpmn:TimerEventDefinition': function (parentGfx, element) {
                    var circle = drawCircle(parentGfx, element.width, element.height, 0.2 * element.height, {
                        strokeWidth: 2,
                        fill: getFillColor(element),
                        stroke: getStrokeColor(element)
                    });

                    var pathData = pathMap.getScaledPath('EVENT_TIMER_WH', {
                        xScaleFactor: 0.75,
                        yScaleFactor: 0.75,
                        containerWidth: element.width,
                        containerHeight: element.height,
                        position: {
                            mx: 0.5,
                            my: 0.5
                        }
                    });

                    drawPath(parentGfx, pathData, {
                        strokeWidth: 2,
                        strokeLinecap: 'square',
                        stroke: getStrokeColor(element)
                    });

                    for (var i = 0; i < 12; i++) {

                        var linePathData = pathMap.getScaledPath('EVENT_TIMER_LINE', {
                            xScaleFactor: 0.75,
                            yScaleFactor: 0.75,
                            containerWidth: element.width,
                            containerHeight: element.height,
                            position: {
                                mx: 0.5,
                                my: 0.5
                            }
                        });

                        var width = element.width / 2;
                        var height = element.height / 2;

                        drawPath(parentGfx, linePathData, {
                            strokeWidth: 1,
                            strokeLinecap: 'square',
                            transform: 'rotate(' + (i * 30) + ',' + height + ',' + width + ')',
                            stroke: getStrokeColor(element)
                        });
                    }

                    return circle;
                },
                'bpmn:EscalationEventDefinition': function (parentGfx, event, isThrowing) {
                    var pathData = pathMap.getScaledPath('EVENT_ESCALATION', {
                        xScaleFactor: 1,
                        yScaleFactor: 1,
                        containerWidth: event.width,
                        containerHeight: event.height,
                        position: {
                            mx: 0.5,
                            my: 0.2
                        }
                    });

                    var fill = isThrowing ? getStrokeColor(event) : 'none';

                    return drawPath(parentGfx, pathData, {
                        strokeWidth: 1,
                        fill: fill,
                        stroke: getStrokeColor(event)
                    });
                },
                'bpmn:ConditionalEventDefinition': function (parentGfx, event) {
                    var pathData = pathMap.getScaledPath('EVENT_CONDITIONAL', {
                        xScaleFactor: 1,
                        yScaleFactor: 1,
                        containerWidth: event.width,
                        containerHeight: event.height,
                        position: {
                            mx: 0.5,
                            my: 0.222
                        }
                    });

                    return drawPath(parentGfx, pathData, {
                        strokeWidth: 1,
                        stroke: getStrokeColor(event)
                    });
                },
                'bpmn:LinkEventDefinition': function (parentGfx, event, isThrowing) {
                    var pathData = pathMap.getScaledPath('EVENT_LINK', {
                        xScaleFactor: 1,
                        yScaleFactor: 1,
                        containerWidth: event.width,
                        containerHeight: event.height,
                        position: {
                            mx: 0.57,
                            my: 0.263
                        }
                    });

                    var fill = isThrowing ? getStrokeColor(event) : 'none';

                    return drawPath(parentGfx, pathData, {
                        strokeWidth: 1,
                        fill: fill,
                        stroke: getStrokeColor(event)
                    });
                },
                'bpmn:ErrorEventDefinition': function (parentGfx, event, isThrowing) {
                    var pathData = pathMap.getScaledPath('EVENT_ERROR', {
                        xScaleFactor: 1.1,
                        yScaleFactor: 1.1,
                        containerWidth: event.width,
                        containerHeight: event.height,
                        position: {
                            mx: 0.2,
                            my: 0.722
                        }
                    });

                    var fill = isThrowing ? getStrokeColor(event) : 'none';

                    return drawPath(parentGfx, pathData, {
                        strokeWidth: 1,
                        fill: fill,
                        stroke: getStrokeColor(event)
                    });
                },
                'bpmn:CancelEventDefinition': function (parentGfx, event, isThrowing) {
                    var pathData = pathMap.getScaledPath('EVENT_CANCEL_45', {
                        xScaleFactor: 1.0,
                        yScaleFactor: 1.0,
                        containerWidth: event.width,
                        containerHeight: event.height,
                        position: {
                            mx: 0.638,
                            my: -0.055
                        }
                    });

                    var fill = isThrowing ? 'black' : 'none';

                    var path = drawPath(parentGfx, pathData, {
                        strokeWidth: 1,
                        fill: fill
                    });

                    rotate(path, 45);

                    return path;
                },
                'bpmn:CompensateEventDefinition': function (parentGfx, event, isThrowing) {
                    var pathData = pathMap.getScaledPath('EVENT_COMPENSATION', {
                        xScaleFactor: 1,
                        yScaleFactor: 1,
                        containerWidth: event.width,
                        containerHeight: event.height,
                        position: {
                            mx: 0.22,
                            my: 0.5
                        }
                    });

                    var fill = isThrowing ? getStrokeColor(event) : 'none';

                    return drawPath(parentGfx, pathData, {
                        strokeWidth: 1,
                        fill: fill,
                        stroke: getStrokeColor(event)
                    });
                },
                'bpmn:SignalEventDefinition': function (parentGfx, event, isThrowing) {
                    var pathData = pathMap.getScaledPath('EVENT_SIGNAL', {
                        xScaleFactor: 0.9,
                        yScaleFactor: 0.9,
                        containerWidth: event.width,
                        containerHeight: event.height,
                        position: {
                            mx: 0.5,
                            my: 0.2
                        }
                    });

                    var fill = isThrowing ? getStrokeColor(event) : 'none';

                    return drawPath(parentGfx, pathData, {
                        strokeWidth: 1,
                        fill: fill,
                        stroke: getStrokeColor(event)
                    });
                },
                'bpmn:MultipleEventDefinition': function (parentGfx, event, isThrowing) {
                    var pathData = pathMap.getScaledPath('EVENT_MULTIPLE', {
                        xScaleFactor: 1.1,
                        yScaleFactor: 1.1,
                        containerWidth: event.width,
                        containerHeight: event.height,
                        position: {
                            mx: 0.222,
                            my: 0.36
                        }
                    });

                    var fill = isThrowing ? 'black' : 'none';

                    return drawPath(parentGfx, pathData, {
                        strokeWidth: 1,
                        fill: fill
                    });
                },
                'bpmn:ParallelMultipleEventDefinition': function (parentGfx, event) {
                    var pathData = pathMap.getScaledPath('EVENT_PARALLEL_MULTIPLE', {
                        xScaleFactor: 1.2,
                        yScaleFactor: 1.2,
                        containerWidth: event.width,
                        containerHeight: event.height,
                        position: {
                            mx: 0.458,
                            my: 0.194
                        }
                    });

                    return drawPath(parentGfx, pathData, {
                        strokeWidth: 1,
                        fill: getStrokeColor(event),
                        stroke: getStrokeColor(event)
                    });
                },
                'bpmn:EndEvent': function (parentGfx, element) {
                    var circle = renderer('bpmn:Event')(parentGfx, element, {
                        strokeWidth: 4,
                        fill: getFillColor(element),
                        stroke: getStrokeColor(element)
                    });

                    renderEventContent(element, parentGfx, true);

                    return circle;
                },
                'bpmn:TerminateEventDefinition': function (parentGfx, element) {
                    var circle = drawCircle(parentGfx, element.width, element.height, 8, {
                        strokeWidth: 4,
                        fill: getStrokeColor(element),
                        stroke: getStrokeColor(element)
                    });

                    return circle;
                },
                'bpmn:IntermediateEvent': function (parentGfx, element) {
                    var outer = renderer('bpmn:Event')(parentGfx, element, {
                        strokeWidth: 1,
                        fill: getFillColor(element),
                        stroke: getStrokeColor(element)
                    });

      /* inner */ drawCircle(parentGfx, element.width, element.height, INNER_OUTER_DIST, {
                        strokeWidth: 1,
                        fill: getFillColor(element, 'none'),
                        stroke: getStrokeColor(element)
                    });

                    renderEventContent(element, parentGfx);

                    return outer;
                },
                'bpmn:IntermediateCatchEvent': as('bpmn:IntermediateEvent'),
                'bpmn:IntermediateThrowEvent': as('bpmn:IntermediateEvent'),

                'bpmn:Activity': function (parentGfx, element, attrs) {
                    return drawRect(parentGfx, element.width, element.height, TASK_BORDER_RADIUS, attrs);
                },

                'bpmn:Task': function (parentGfx, element) {
                    var attrs = {
                        fill: getFillColor(element),
                        stroke: getStrokeColor(element)
                    };

                    var rect = renderer('bpmn:Activity')(parentGfx, element, attrs);

                    renderEmbeddedLabel(parentGfx, element, 'center-middle');
                    attachTaskMarkers(parentGfx, element);

                    return rect;
                },
                'bpmn:ServiceTask': function (parentGfx, element) {
                    var task = renderer('bpmn:Task')(parentGfx, element);

                    var pathDataBG = pathMap.getScaledPath('TASK_TYPE_SERVICE', {
                        abspos: {
                            x: 12,
                            y: 18
                        }
                    });

      /* service bg */ drawPath(parentGfx, pathDataBG, {
                        strokeWidth: 1,
                        fill: getFillColor(element),
                        stroke: getStrokeColor(element)
                    });

                    var fillPathData = pathMap.getScaledPath('TASK_TYPE_SERVICE_FILL', {
                        abspos: {
                            x: 17.2,
                            y: 18
                        }
                    });

      /* service fill */ drawPath(parentGfx, fillPathData, {
                        strokeWidth: 0,
                        fill: getFillColor(element)
                    });

                    var pathData = pathMap.getScaledPath('TASK_TYPE_SERVICE', {
                        abspos: {
                            x: 17,
                            y: 22
                        }
                    });

      /* service */ drawPath(parentGfx, pathData, {
                        strokeWidth: 1,
                        fill: getFillColor(element),
                        stroke: getStrokeColor(element)
                    });

                    return task;
                },
                'bpmn:UserTask': function (parentGfx, element) {
                    var task = renderer('bpmn:Task')(parentGfx, element);

                    var x = 15;
                    var y = 12;

                    var pathData = pathMap.getScaledPath('TASK_TYPE_USER_1', {
                        abspos: {
                            x: x,
                            y: y
                        }
                    });

      /* user path */ drawPath(parentGfx, pathData, {
                        strokeWidth: 0.5,
                        fill: getFillColor(element),
                        stroke: getStrokeColor(element)
                    });

                    var pathData2 = pathMap.getScaledPath('TASK_TYPE_USER_2', {
                        abspos: {
                            x: x,
                            y: y
                        }
                    });

      /* user2 path */ drawPath(parentGfx, pathData2, {
                        strokeWidth: 0.5,
                        fill: getFillColor(element),
                        stroke: getStrokeColor(element)
                    });

                    var pathData3 = pathMap.getScaledPath('TASK_TYPE_USER_3', {
                        abspos: {
                            x: x,
                            y: y
                        }
                    });

      /* user3 path */ drawPath(parentGfx, pathData3, {
                        strokeWidth: 0.5,
                        fill: getStrokeColor(element),
                        stroke: getStrokeColor(element)
                    });

                    return task;
                },
                'bpmn:ManualTask': function (parentGfx, element) {
                    var task = renderer('bpmn:Task')(parentGfx, element);

                    var pathData = pathMap.getScaledPath('TASK_TYPE_MANUAL', {
                        abspos: {
                            x: 17,
                            y: 15
                        }
                    });

      /* manual path */ drawPath(parentGfx, pathData, {
                        strokeWidth: 0.5, // 0.25,
                        fill: getFillColor(element),
                        stroke: getStrokeColor(element)
                    });

                    return task;
                },
                'bpmn:SendTask': function (parentGfx, element) {
                    var task = renderer('bpmn:Task')(parentGfx, element);

                    var pathData = pathMap.getScaledPath('TASK_TYPE_SEND', {
                        xScaleFactor: 1,
                        yScaleFactor: 1,
                        containerWidth: 21,
                        containerHeight: 14,
                        position: {
                            mx: 0.285,
                            my: 0.357
                        }
                    });

      /* send path */ drawPath(parentGfx, pathData, {
                        strokeWidth: 1,
                        fill: getStrokeColor(element),
                        stroke: getFillColor(element)
                    });

                    return task;
                },
                'bpmn:ReceiveTask': function (parentGfx, element) {
                    var semantic = getSemantic(element);

                    var task = renderer('bpmn:Task')(parentGfx, element);
                    var pathData;

                    if (semantic.instantiate) {
                        drawCircle(parentGfx, 28, 28, 20 * 0.22, { strokeWidth: 1 });

                        pathData = pathMap.getScaledPath('TASK_TYPE_INSTANTIATING_SEND', {
                            abspos: {
                                x: 7.77,
                                y: 9.52
                            }
                        });
                    } else {

                        pathData = pathMap.getScaledPath('TASK_TYPE_SEND', {
                            xScaleFactor: 0.9,
                            yScaleFactor: 0.9,
                            containerWidth: 21,
                            containerHeight: 14,
                            position: {
                                mx: 0.3,
                                my: 0.4
                            }
                        });
                    }

      /* receive path */ drawPath(parentGfx, pathData, {
                        strokeWidth: 1,
                        fill: getFillColor(element),
                        stroke: getStrokeColor(element)
                    });

                    return task;
                },
                'bpmn:ScriptTask': function (parentGfx, element) {
                    var task = renderer('bpmn:Task')(parentGfx, element);

                    var pathData = pathMap.getScaledPath('TASK_TYPE_SCRIPT', {
                        abspos: {
                            x: 15,
                            y: 20
                        }
                    });

      /* script path */ drawPath(parentGfx, pathData, {
                        strokeWidth: 1,
                        stroke: getStrokeColor(element)
                    });

                    return task;
                },
                'bpmn:BusinessRuleTask': function (parentGfx, element) {
                    var task = renderer('bpmn:Task')(parentGfx, element);

                    var headerPathData = pathMap.getScaledPath('TASK_TYPE_BUSINESS_RULE_HEADER', {
                        abspos: {
                            x: 8,
                            y: 8
                        }
                    });

                    var businessHeaderPath = drawPath(parentGfx, headerPathData);
                    svgAttr(businessHeaderPath, {
                        strokeWidth: 1,
                        fill: getFillColor(element, '#aaaaaa'),
                        stroke: getStrokeColor(element)
                    });

                    var headerData = pathMap.getScaledPath('TASK_TYPE_BUSINESS_RULE_MAIN', {
                        abspos: {
                            x: 8,
                            y: 8
                        }
                    });

                    var businessPath = drawPath(parentGfx, headerData);
                    svgAttr(businessPath, {
                        strokeWidth: 1,
                        stroke: getStrokeColor(element)
                    });

                    return task;
                },
                'bpmn:SubProcess': function (parentGfx, element, attrs) {
                    attrs = assign({
                        fillOpacity: 0.95,
                        fill: getFillColor(element),
                        stroke: getStrokeColor(element)
                    }, attrs);

                    var rect = renderer('bpmn:Activity')(parentGfx, element, attrs);

                    var expanded = DiUtil.isExpanded(element);

                    var isEventSubProcess = DiUtil.isEventSubProcess(element);

                    if (isEventSubProcess) {
                        svgAttr(rect, {
                            strokeDasharray: '1,2'
                        });
                    }

                    renderEmbeddedLabel(parentGfx, element, expanded ? 'center-top' : 'center-middle');

                    if (expanded) {
                        attachTaskMarkers(parentGfx, element);
                    } else {
                        attachTaskMarkers(parentGfx, element, ['SubProcessMarker']);
                    }

                    return rect;
                },
                'bpmn:AdHocSubProcess': function (parentGfx, element) {
                    return renderer('bpmn:SubProcess')(parentGfx, element);
                },
                'bpmn:Transaction': function (parentGfx, element) {
                    var outer = renderer('bpmn:SubProcess')(parentGfx, element);

                    var innerAttrs = styles.style(['no-fill', 'no-events'], {
                        stroke: getStrokeColor(element)
                    });

      /* inner path */ drawRect(parentGfx, element.width, element.height, TASK_BORDER_RADIUS - 2, INNER_OUTER_DIST, innerAttrs);

                    return outer;
                },
                'bpmn:CallActivity': function (parentGfx, element) {
                    return renderer('bpmn:SubProcess')(parentGfx, element, {
                        strokeWidth: 5
                    });
                },
                'bpmn:Participant': function (parentGfx, element) {

                    var attrs = {
                        fillOpacity: 0.95,
                        fill: getFillColor(element),
                        stroke: getStrokeColor(element)
                    };

                    var lane = renderer('bpmn:Lane')(parentGfx, element, attrs);

                    var expandedPool = DiUtil.isExpanded(element);

                    if (expandedPool) {
                        drawLine(parentGfx, [
                            { x: 30, y: 0 },
                            { x: 30, y: element.height }
                        ], {
                            stroke: getStrokeColor(element)
                        });
                        var text = getSemantic(element).name;
                        renderLaneLabel(parentGfx, text, element);
                    } else {
                        // Collapsed pool draw text inline
                        var text2 = getSemantic(element).name;
                        renderLabel(parentGfx, text2, {
                            box: element, align: 'center-middle',
                            style: {
                                fill: getStrokeColor(element)
                            }
                        });
                    }

                    var participantMultiplicity = !!(getSemantic(element).participantMultiplicity);

                    if (participantMultiplicity) {
                        renderer('ParticipantMultiplicityMarker')(parentGfx, element);
                    }

                    return lane;
                },
                'bpmn:Lane': function (parentGfx, element, attrs) {
                    var rect = drawRect(parentGfx, element.width, element.height, 0, assign({
                        fill: getFillColor(element),
                        stroke: getStrokeColor(element)
                    }, attrs));

                    var semantic = getSemantic(element);

                    if (semantic.$type === 'bpmn:Lane') {
                        var text = semantic.name;
                        renderLaneLabel(parentGfx, text, element);
                    }

                    return rect;
                },
                'bpmn:InclusiveGateway': function (parentGfx, element) {
                    var attrs = {
                        fill: getFillColor(element),
                        stroke: getStrokeColor(element)
                    };

                    var diamond = drawDiamond(parentGfx, element.width, element.height, attrs);

                    /* circle path */
                    drawCircle(parentGfx, element.width, element.height, element.height * 0.24, {
                        strokeWidth: 2.5,
                        fill: getFillColor(element),
                        stroke: getStrokeColor(element)
                    });

                    return diamond;
                },
                'bpmn:ExclusiveGateway': function (parentGfx, element) {
                    var attrs = {
                        fill: getFillColor(element),
                        stroke: getStrokeColor(element)
                    };

                    var diamond = drawDiamond(parentGfx, element.width, element.height, attrs);

                    var pathData = pathMap.getScaledPath('GATEWAY_EXCLUSIVE', {
                        xScaleFactor: 0.4,
                        yScaleFactor: 0.4,
                        containerWidth: element.width,
                        containerHeight: element.height,
                        position: {
                            mx: 0.32,
                            my: 0.3
                        }
                    });

                    if ((getDi(element).isMarkerVisible)) {
                        drawPath(parentGfx, pathData, {
                            strokeWidth: 1,
                            fill: getStrokeColor(element),
                            stroke: getStrokeColor(element)
                        });
                    }

                    return diamond;
                },
                'bpmn:ComplexGateway': function (parentGfx, element) {
                    var attrs = {
                        fill: getFillColor(element),
                        stroke: getStrokeColor(element)
                    };

                    var diamond = drawDiamond(parentGfx, element.width, element.height, attrs);

                    var pathData = pathMap.getScaledPath('GATEWAY_COMPLEX', {
                        xScaleFactor: 0.5,
                        yScaleFactor: 0.5,
                        containerWidth: element.width,
                        containerHeight: element.height,
                        position: {
                            mx: 0.46,
                            my: 0.26
                        }
                    });

      /* complex path */ drawPath(parentGfx, pathData, {
                        strokeWidth: 1,
                        fill: getStrokeColor(element),
                        stroke: getStrokeColor(element)
                    });

                    return diamond;
                },
                'bpmn:ParallelGateway': function (parentGfx, element) {
                    var attrs = {
                        fill: getFillColor(element),
                        stroke: getStrokeColor(element)
                    };

                    var diamond = drawDiamond(parentGfx, element.width, element.height, attrs);

                    var pathData = pathMap.getScaledPath('GATEWAY_PARALLEL', {
                        xScaleFactor: 0.6,
                        yScaleFactor: 0.6,
                        containerWidth: element.width,
                        containerHeight: element.height,
                        position: {
                            mx: 0.46,
                            my: 0.2
                        }
                    });

      /* parallel path */ drawPath(parentGfx, pathData, {
                        strokeWidth: 1,
                        fill: getStrokeColor(element),
                        stroke: getStrokeColor(element)
                    });

                    return diamond;
                },
                'bpmn:EventBasedGateway': function (parentGfx, element) {

                    var semantic = getSemantic(element);

                    var attrs = {
                        fill: getFillColor(element),
                        stroke: getStrokeColor(element)
                    };

                    var diamond = drawDiamond(parentGfx, element.width, element.height, attrs);

      /* outer circle path */ drawCircle(parentGfx, element.width, element.height, element.height * 0.20, {
                        strokeWidth: 1,
                        fill: 'none',
                        stroke: getStrokeColor(element)
                    });

                    var type = semantic.eventGatewayType;
                    var instantiate = !!semantic.instantiate;

                    function drawEvent() {

                        var pathData = pathMap.getScaledPath('GATEWAY_EVENT_BASED', {
                            xScaleFactor: 0.18,
                            yScaleFactor: 0.18,
                            containerWidth: element.width,
                            containerHeight: element.height,
                            position: {
                                mx: 0.36,
                                my: 0.44
                            }
                        });

                        var attrs = {
                            strokeWidth: 2,
                            fill: getFillColor(element, 'none'),
                            stroke: getStrokeColor(element)
                        };

        /* event path */ drawPath(parentGfx, pathData, attrs);
                    }

                    if (type === 'Parallel') {

                        var pathData = pathMap.getScaledPath('GATEWAY_PARALLEL', {
                            xScaleFactor: 0.4,
                            yScaleFactor: 0.4,
                            containerWidth: element.width,
                            containerHeight: element.height,
                            position: {
                                mx: 0.474,
                                my: 0.296
                            }
                        });

                        var parallelPath = drawPath(parentGfx, pathData);
                        svgAttr(parallelPath, {
                            strokeWidth: 1,
                            fill: 'none'
                        });
                    } else if (type === 'Exclusive') {

                        if (!instantiate) {
                            var innerCircle = drawCircle(parentGfx, element.width, element.height, element.height * 0.26);
                            svgAttr(innerCircle, {
                                strokeWidth: 1,
                                fill: 'none',
                                stroke: getStrokeColor(element)
                            });
                        }

                        drawEvent();
                    }


                    return diamond;
                },
                'bpmn:Gateway': function (parentGfx, element) {
                    return drawDiamond(parentGfx, element.width, element.height);
                },
                'bpmn:SequenceFlow': function (parentGfx, element) {
                    var pathData = createPathFromConnection(element);

                    var fill = getFillColor(element),
                        stroke = getStrokeColor(element);

                    var attrs = {
                        strokeLinejoin: 'round',
                        markerEnd: marker('sequenceflow-end', fill, stroke),
                        stroke: getStrokeColor(element)
                    };

                    var path = drawPath(parentGfx, pathData, attrs);

                    var sequenceFlow = getSemantic(element);
                    var source = element.source.businessObject;

                    // conditional flow marker
                    if (sequenceFlow.conditionExpression && source.$instanceOf('bpmn:Activity')) {
                        svgAttr(path, {
                            markerStart: marker('conditional-flow-marker', fill, stroke)
                        });
                    }

                    // default marker
                    if (source.default && (source.$instanceOf('bpmn:Gateway') || source.$instanceOf('bpmn:Activity')) &&
                        source.default === sequenceFlow) {
                        svgAttr(path, {
                            markerStart: marker('conditional-default-flow-marker', fill, stroke)
                        });
                    }

                    return path;
                },
                'bpmn:Association': function (parentGfx, element, attrs) {

                    var semantic = getSemantic(element);

                    var fill = getFillColor(element),
                        stroke = getStrokeColor(element);

                    attrs = assign({
                        strokeDasharray: '0.5, 5',
                        strokeLinecap: 'round',
                        strokeLinejoin: 'round',
                        stroke: getStrokeColor(element)
                    }, attrs || {});

                    if (semantic.associationDirection === 'One' ||
                        semantic.associationDirection === 'Both') {
                        attrs.markerEnd = marker('association-end', fill, stroke);
                    }

                    if (semantic.associationDirection === 'Both') {
                        attrs.markerStart = marker('association-start', fill, stroke);
                    }

                    return drawLine(parentGfx, element.waypoints, attrs);
                },
                'bpmn:DataInputAssociation': function (parentGfx, element) {
                    var fill = getFillColor(element),
                        stroke = getStrokeColor(element);

                    return renderer('bpmn:Association')(parentGfx, element, {
                        markerEnd: marker('association-end', fill, stroke)
                    });
                },
                'bpmn:DataOutputAssociation': function (parentGfx, element) {
                    var fill = getFillColor(element),
                        stroke = getStrokeColor(element);

                    return renderer('bpmn:Association')(parentGfx, element, {
                        markerEnd: marker('association-end', fill, stroke)
                    });
                },
                'bpmn:MessageFlow': function (parentGfx, element) {

                    var semantic = getSemantic(element),
                        di = getDi(element);

                    var fill = getFillColor(element),
                        stroke = getStrokeColor(element);

                    var pathData = createPathFromConnection(element);

                    var attrs = {
                        markerEnd: marker('messageflow-end', fill, stroke),
                        markerStart: marker('messageflow-start', fill, stroke),
                        strokeDasharray: '10, 12',
                        strokeLinecap: 'round',
                        strokeLinejoin: 'round',
                        strokeWidth: '1.5px',
                        stroke: getStrokeColor(element)
                    };

                    var path = drawPath(parentGfx, pathData, attrs);

                    if (semantic.messageRef) {
                        var midPoint = path.getPointAtLength(path.getTotalLength() / 2);

                        var markerPathData = pathMap.getScaledPath('MESSAGE_FLOW_MARKER', {
                            abspos: {
                                x: midPoint.x,
                                y: midPoint.y
                            }
                        });

                        var messageAttrs = { strokeWidth: 1 };

                        if (di.messageVisibleKind === 'initiating') {
                            messageAttrs.fill = 'white';
                            messageAttrs.stroke = 'black';
                        } else {
                            messageAttrs.fill = '#888';
                            messageAttrs.stroke = 'white';
                        }

                        drawPath(parentGfx, markerPathData, messageAttrs);
                    }

                    return path;
                },
                'bpmn:DataObject': function (parentGfx, element) {
                    var pathData = pathMap.getScaledPath('DATA_OBJECT_PATH', {
                        xScaleFactor: 1,
                        yScaleFactor: 1,
                        containerWidth: element.width,
                        containerHeight: element.height,
                        position: {
                            mx: 0.474,
                            my: 0.296
                        }
                    });

                    var elementObject = drawPath(parentGfx, pathData, {
                        fill: getFillColor(element),
                        stroke: getStrokeColor(element)
                    });

                    var semantic = getSemantic(element);

                    if (isCollection(semantic)) {
                        renderDataItemCollection(parentGfx, element);
                    }

                    return elementObject;
                },
                'bpmn:DataObjectReference': as('bpmn:DataObject'),
                'bpmn:DataInput': function (parentGfx, element) {

                    var arrowPathData = pathMap.getRawPath('DATA_ARROW');

                    // page
                    var elementObject = renderer('bpmn:DataObject')(parentGfx, element);

      /* input arrow path */ drawPath(parentGfx, arrowPathData, { strokeWidth: 1 });

                    return elementObject;
                },
                'bpmn:DataOutput': function (parentGfx, element) {
                    var arrowPathData = pathMap.getRawPath('DATA_ARROW');

                    // page
                    var elementObject = renderer('bpmn:DataObject')(parentGfx, element);

      /* output arrow path */ drawPath(parentGfx, arrowPathData, {
                        strokeWidth: 1,
                        fill: 'black'
                    });

                    return elementObject;
                },
                'bpmn:DataStoreReference': function (parentGfx, element) {
                    var DATA_STORE_PATH = pathMap.getScaledPath('DATA_STORE', {
                        xScaleFactor: 1,
                        yScaleFactor: 1,
                        containerWidth: element.width,
                        containerHeight: element.height,
                        position: {
                            mx: 0,
                            my: 0.133
                        }
                    });

                    var elementStore = drawPath(parentGfx, DATA_STORE_PATH, {
                        strokeWidth: 2,
                        fill: getFillColor(element),
                        stroke: getStrokeColor(element)
                    });

                    return elementStore;
                },
                'bpmn:BoundaryEvent': function (parentGfx, element) {

                    var semantic = getSemantic(element),
                        cancel = semantic.cancelActivity;

                    var attrs = {
                        strokeWidth: 1,
                        fill: getFillColor(element),
                        stroke: getStrokeColor(element)
                    };

                    if (!cancel) {
                        attrs.strokeDasharray = '6';
                        attrs.strokeLinecap = 'round';
                    }

                    var outer = renderer('bpmn:Event')(parentGfx, element, attrs);
      /* inner path */ drawCircle(parentGfx, element.width, element.height, INNER_OUTER_DIST, assign(attrs, { fill: 'none' }));

                    renderEventContent(element, parentGfx);

                    return outer;
                },
                'bpmn:Group': function (parentGfx, element) {
                    return drawRect(parentGfx, element.width, element.height, TASK_BORDER_RADIUS, {
                        strokeWidth: 1,
                        strokeDasharray: '8,3,1,3',
                        fill: 'none',
                        pointerEvents: 'none'
                    });
                },
                'label': function (parentGfx, element) {
                    return renderExternalLabel(parentGfx, element);
                },
                'bpmn:TextAnnotation': function (parentGfx, element) {
                    var style = {
                        'fill': 'none',
                        'stroke': 'none'
                    };

                    var textElement = drawRect(parentGfx, element.width, element.height, 0, 0, style);

                    var textPathData = pathMap.getScaledPath('TEXT_ANNOTATION', {
                        xScaleFactor: 1,
                        yScaleFactor: 1,
                        containerWidth: element.width,
                        containerHeight: element.height,
                        position: {
                            mx: 0.0,
                            my: 0.0
                        }
                    });
                    drawPath(parentGfx, textPathData, {
                        stroke: getStrokeColor(element)
                    });

                    var text = getSemantic(element).text || '';
                    renderLabel(parentGfx, text, { box: element, align: 'left-middle', padding: 5 });

                    return textElement;
                },
                'ParticipantMultiplicityMarker': function (parentGfx, element) {
                    var markerPath = pathMap.getScaledPath('MARKER_PARALLEL', {
                        xScaleFactor: 1,
                        yScaleFactor: 1,
                        containerWidth: element.width,
                        containerHeight: element.height,
                        position: {
                            mx: ((element.width / 2) / element.width),
                            my: (element.height - 15) / element.height
                        }
                    });

                    drawMarker('participant-multiplicity', parentGfx, markerPath);
                },
                'SubProcessMarker': function (parentGfx, element) {
                    var markerRect = drawRect(parentGfx, 14, 14, 0, {
                        strokeWidth: 1,
                        fill: getFillColor(element),
                        stroke: getStrokeColor(element)
                    });

                    // Process marker is placed in the middle of the box
                    // therefore fixed values can be used here
                    translate(markerRect, element.width / 2 - 7.5, element.height - 20);

                    var markerPath = pathMap.getScaledPath('MARKER_SUB_PROCESS', {
                        xScaleFactor: 1.5,
                        yScaleFactor: 1.5,
                        containerWidth: element.width,
                        containerHeight: element.height,
                        position: {
                            mx: (element.width / 2 - 7.5) / element.width,
                            my: (element.height - 20) / element.height
                        }
                    });

                    drawMarker('sub-process', parentGfx, markerPath, {
                        fill: getFillColor(element),
                        stroke: getStrokeColor(element)
                    });
                },
                'ParallelMarker': function (parentGfx, element, position) {
                    var markerPath = pathMap.getScaledPath('MARKER_PARALLEL', {
                        xScaleFactor: 1,
                        yScaleFactor: 1,
                        containerWidth: element.width,
                        containerHeight: element.height,
                        position: {
                            mx: ((element.width / 2 + position.parallel) / element.width),
                            my: (element.height - 20) / element.height
                        }
                    });

                    drawMarker('parallel', parentGfx, markerPath);
                },
                'SequentialMarker': function (parentGfx, element, position) {
                    var markerPath = pathMap.getScaledPath('MARKER_SEQUENTIAL', {
                        xScaleFactor: 1,
                        yScaleFactor: 1,
                        containerWidth: element.width,
                        containerHeight: element.height,
                        position: {
                            mx: ((element.width / 2 + position.seq) / element.width),
                            my: (element.height - 19) / element.height
                        }
                    });

                    drawMarker('sequential', parentGfx, markerPath);
                },
                'CompensationMarker': function (parentGfx, element, position) {
                    var markerMath = pathMap.getScaledPath('MARKER_COMPENSATION', {
                        xScaleFactor: 1,
                        yScaleFactor: 1,
                        containerWidth: element.width,
                        containerHeight: element.height,
                        position: {
                            mx: ((element.width / 2 + position.compensation) / element.width),
                            my: (element.height - 13) / element.height
                        }
                    });

                    drawMarker('compensation', parentGfx, markerMath, { strokeWidth: 1 });
                },
                'LoopMarker': function (parentGfx, element, position) {
                    var markerPath = pathMap.getScaledPath('MARKER_LOOP', {
                        xScaleFactor: 1,
                        yScaleFactor: 1,
                        containerWidth: element.width,
                        containerHeight: element.height,
                        position: {
                            mx: ((element.width / 2 + position.loop) / element.width),
                            my: (element.height - 7) / element.height
                        }
                    });

                    drawMarker('loop', parentGfx, markerPath, {
                        strokeWidth: 1,
                        fill: 'none',
                        strokeLinecap: 'round',
                        strokeMiterlimit: 0.5
                    });
                },
                'AdhocMarker': function (parentGfx, element, position) {
                    var markerPath = pathMap.getScaledPath('MARKER_ADHOC', {
                        xScaleFactor: 1,
                        yScaleFactor: 1,
                        containerWidth: element.width,
                        containerHeight: element.height,
                        position: {
                            mx: ((element.width / 2 + position.adhoc) / element.width),
                            my: (element.height - 15) / element.height
                        }
                    });

                    drawMarker('adhoc', parentGfx, markerPath, {
                        strokeWidth: 1,
                        fill: 'black'
                    });
                }
            };

            function attachTaskMarkers(parentGfx, element, taskMarkers) {
                var obj = getSemantic(element);

                var subprocess = taskMarkers && taskMarkers.indexOf('SubProcessMarker') !== -1;
                var position;

                if (subprocess) {
                    position = {
                        seq: -21,
                        parallel: -22,
                        compensation: -42,
                        loop: -18,
                        adhoc: 10
                    };
                } else {
                    position = {
                        seq: -3,
                        parallel: -6,
                        compensation: -27,
                        loop: 0,
                        adhoc: 10
                    };
                }

                forEach(taskMarkers, function (marker) {
                    renderer(marker)(parentGfx, element, position);
                });

                if (obj.isForCompensation) {
                    renderer('CompensationMarker')(parentGfx, element, position);
                }

                if (obj.$type === 'bpmn:AdHocSubProcess') {
                    renderer('AdhocMarker')(parentGfx, element, position);
                }

                var loopCharacteristics = obj.loopCharacteristics,
                    isSequential = loopCharacteristics && loopCharacteristics.isSequential;

                if (loopCharacteristics) {

                    if (isSequential === undefined) {
                        renderer('LoopMarker')(parentGfx, element, position);
                    }

                    if (isSequential === false) {
                        renderer('ParallelMarker')(parentGfx, element, position);
                    }

                    if (isSequential === true) {
                        renderer('SequentialMarker')(parentGfx, element, position);
                    }
                }
            }

            function renderDataItemCollection(parentGfx, element) {

                var yPosition = (element.height - 16) / element.height;

                var pathData = pathMap.getScaledPath('DATA_OBJECT_COLLECTION_PATH', {
                    xScaleFactor: 1,
                    yScaleFactor: 1,
                    containerWidth: element.width,
                    containerHeight: element.height,
                    position: {
                        mx: 0.451,
                        my: yPosition
                    }
                });

    /* collection path */ drawPath(parentGfx, pathData, {
                    strokeWidth: 2
                });
            }
        }


        inherits(BpmnRenderer, BaseRenderer);

        BpmnRenderer.$inject = ['eventBus', 'styles', 'pathMap', 'canvas'];

        module.exports = BpmnRenderer;


        BpmnRenderer.prototype.canRender = function (element) {
            return is(element, 'bpmn:BaseElement');
        };

        BpmnRenderer.prototype.drawShape = function (parentGfx, element) {
            var type = element.type;
            var h = this.handlers[type];

            /* jshint -W040 */
            return h(parentGfx, element);
        };

        BpmnRenderer.prototype.drawConnection = function (parentGfx, element) {
            var type = element.type;
            var h = this.handlers[type];

            /* jshint -W040 */
            return h(parentGfx, element);
        };

        BpmnRenderer.prototype.getShapePath = function (element) {

            if (is(element, 'bpmn:Event')) {
                return getCirclePath(element);
            }

            if (is(element, 'bpmn:Activity')) {
                return getRoundRectPath(element, TASK_BORDER_RADIUS);
            }

            if (is(element, 'bpmn:Gateway')) {
                return getDiamondPath(element);
            }

            return getRectPath(element);
        };


        ///////// helper functions /////////////////////////////

        /**
         * Checks if eventDefinition of the given element matches with semantic type.
         *
         * @return {boolean} true if element is of the given semantic type
         */
        function isTypedEvent(event, eventDefinitionType, filter) {

            function matches(definition, filter) {
                return every(filter, function (val, key) {

                    // we want a == conversion here, to be able to catch
                    // undefined == false and friends
                    /* jshint -W116 */
                    return definition[key] == val;
                });
            }

            return some(event.eventDefinitions, function (definition) {
                return definition.$type === eventDefinitionType && matches(event, filter);
            });
        }

        function isThrowEvent(event) {
            return (event.$type === 'bpmn:IntermediateThrowEvent') || (event.$type === 'bpmn:EndEvent');
        }

        function isCollection(element) {
            var dataObject = element.dataObjectRef;

            return element.isCollection || (dataObject && dataObject.isCollection);
        }

        function getDi(element) {
            return element.businessObject.di;
        }

        function getSemantic(element) {
            return element.businessObject;
        }



        /////// cropping path customizations /////////////////////////

        function getCirclePath(shape) {

            var cx = shape.x + shape.width / 2,
                cy = shape.y + shape.height / 2,
                radius = shape.width / 2;

            var circlePath = [
                ['M', cx, cy],
                ['m', 0, -radius],
                ['a', radius, radius, 0, 1, 1, 0, 2 * radius],
                ['a', radius, radius, 0, 1, 1, 0, -2 * radius],
                ['z']
            ];

            return componentsToPath(circlePath);
        }

        function getRoundRectPath(shape, borderRadius) {

            var x = shape.x,
                y = shape.y,
                width = shape.width,
                height = shape.height;

            var roundRectPath = [
                ['M', x + borderRadius, y],
                ['l', width - borderRadius * 2, 0],
                ['a', borderRadius, borderRadius, 0, 0, 1, borderRadius, borderRadius],
                ['l', 0, height - borderRadius * 2],
                ['a', borderRadius, borderRadius, 0, 0, 1, -borderRadius, borderRadius],
                ['l', borderRadius * 2 - width, 0],
                ['a', borderRadius, borderRadius, 0, 0, 1, -borderRadius, -borderRadius],
                ['l', 0, borderRadius * 2 - height],
                ['a', borderRadius, borderRadius, 0, 0, 1, borderRadius, -borderRadius],
                ['z']
            ];

            return componentsToPath(roundRectPath);
        }

        function getDiamondPath(shape) {

            var width = shape.width,
                height = shape.height,
                x = shape.x,
                y = shape.y,
                halfWidth = width / 2,
                halfHeight = height / 2;

            var diamondPath = [
                ['M', x + halfWidth, y],
                ['l', halfWidth, halfHeight],
                ['l', -halfWidth, halfHeight],
                ['l', -halfWidth, -halfHeight],
                ['z']
            ];

            return componentsToPath(diamondPath);
        }

        function getRectPath(shape) {
            var x = shape.x,
                y = shape.y,
                width = shape.width,
                height = shape.height;

            var rectPath = [
                ['M', x, y],
                ['l', width, 0],
                ['l', 0, height],
                ['l', -width, 0],
                ['z']
            ];

            return componentsToPath(rectPath);
        }

        function getFillColor(element, defaultColor) {
            var bo = getBusinessObject(element);

            return bo.di.get('fill') || defaultColor || 'white';
        }

        function getStrokeColor(element, defaultColor) {
            var bo = getBusinessObject(element);

            return bo.di.get('stroke') || defaultColor || 'black';
        }

    }, { "../util/DiUtil": 93, "../util/ModelUtil": 95, "diagram-js/lib/draw/BaseRenderer": 128, "diagram-js/lib/util/RenderUtil": 278, "diagram-js/lib/util/SvgTransformUtil": 279, "diagram-js/lib/util/Text": 280, "inherits": 289, "lodash/collection/every": 301, "lodash/collection/forEach": 304, "lodash/collection/some": 310, "lodash/lang/isObject": 428, "lodash/object/assign": 433, "min-dom/lib/query": 454, "tiny-svg/lib/append": 473, "tiny-svg/lib/attr": 475, "tiny-svg/lib/classes": 476, "tiny-svg/lib/create": 479 }], 7: [function (require, module, exports) {
        'use strict';

        /**
         * Map containing SVG paths needed by BpmnRenderer.
         */

        function PathMap() {

            /**
             * Contains a map of path elements
             *
             * <h1>Path definition</h1>
             * A parameterized path is defined like this:
             * <pre>
             * 'GATEWAY_PARALLEL': {
             *   d: 'm {mx},{my} {e.x0},0 0,{e.x1} {e.x1},0 0,{e.y0} -{e.x1},0 0,{e.y1} ' +
                    '-{e.x0},0 0,-{e.y1} -{e.x1},0 0,-{e.y0} {e.x1},0 z',
             *   height: 17.5,
             *   width:  17.5,
             *   heightElements: [2.5, 7.5],
             *   widthElements: [2.5, 7.5]
             * }
             * </pre>
             * <p>It's important to specify a correct <b>height and width</b> for the path as the scaling
             * is based on the ratio between the specified height and width in this object and the
             * height and width that is set as scale target (Note x,y coordinates will be scaled with
             * individual ratios).</p>
             * <p>The '<b>heightElements</b>' and '<b>widthElements</b>' array must contain the values that will be scaled.
             * The scaling is based on the computed ratios.
             * Coordinates on the y axis should be in the <b>heightElement</b>'s array, they will be scaled using
             * the computed ratio coefficient.
             * In the parameterized path the scaled values can be accessed through the 'e' object in {} brackets.
             *   <ul>
             *    <li>The values for the y axis can be accessed in the path string using {e.y0}, {e.y1}, ....</li>
             *    <li>The values for the x axis can be accessed in the path string using {e.x0}, {e.x1}, ....</li>
             *   </ul>
             *   The numbers x0, x1 respectively y0, y1, ... map to the corresponding array index.
             * </p>
             */
            this.pathMap = {
                'EVENT_MESSAGE': {
                    d: 'm {mx},{my} l 0,{e.y1} l {e.x1},0 l 0,-{e.y1} z l {e.x0},{e.y0} l {e.x0},-{e.y0}',
                    height: 36,
                    width: 36,
                    heightElements: [6, 14],
                    widthElements: [10.5, 21]
                },
                'EVENT_SIGNAL': {
                    d: 'M {mx},{my} l {e.x0},{e.y0} l -{e.x1},0 Z',
                    height: 36,
                    width: 36,
                    heightElements: [18],
                    widthElements: [10, 20]
                },
                'EVENT_ESCALATION': {
                    d: 'M {mx},{my} l {e.x0},{e.y0} l -{e.x0},-{e.y1} l -{e.x0},{e.y1} Z',
                    height: 36,
                    width: 36,
                    heightElements: [20, 7],
                    widthElements: [8]
                },
                'EVENT_CONDITIONAL': {
                    d: 'M {e.x0},{e.y0} l {e.x1},0 l 0,{e.y2} l -{e.x1},0 Z ' +
                        'M {e.x2},{e.y3} l {e.x0},0 ' +
                        'M {e.x2},{e.y4} l {e.x0},0 ' +
                        'M {e.x2},{e.y5} l {e.x0},0 ' +
                        'M {e.x2},{e.y6} l {e.x0},0 ' +
                        'M {e.x2},{e.y7} l {e.x0},0 ' +
                        'M {e.x2},{e.y8} l {e.x0},0 ',
                    height: 36,
                    width: 36,
                    heightElements: [8.5, 14.5, 18, 11.5, 14.5, 17.5, 20.5, 23.5, 26.5],
                    widthElements: [10.5, 14.5, 12.5]
                },
                'EVENT_LINK': {
                    d: 'm {mx},{my} 0,{e.y0} -{e.x1},0 0,{e.y1} {e.x1},0 0,{e.y0} {e.x0},-{e.y2} -{e.x0},-{e.y2} z',
                    height: 36,
                    width: 36,
                    heightElements: [4.4375, 6.75, 7.8125],
                    widthElements: [9.84375, 13.5]
                },
                'EVENT_ERROR': {
                    d: 'm {mx},{my} {e.x0},-{e.y0} {e.x1},-{e.y1} {e.x2},{e.y2} {e.x3},-{e.y3} -{e.x4},{e.y4} -{e.x5},-{e.y5} z',
                    height: 36,
                    width: 36,
                    heightElements: [0.023, 8.737, 8.151, 16.564, 10.591, 8.714],
                    widthElements: [0.085, 6.672, 6.97, 4.273, 5.337, 6.636]
                },
                'EVENT_CANCEL_45': {
                    d: 'm {mx},{my} -{e.x1},0 0,{e.x0} {e.x1},0 0,{e.y1} {e.x0},0 ' +
                        '0,-{e.y1} {e.x1},0 0,-{e.y0} -{e.x1},0 0,-{e.y1} -{e.x0},0 z',
                    height: 36,
                    width: 36,
                    heightElements: [4.75, 8.5],
                    widthElements: [4.75, 8.5]
                },
                'EVENT_COMPENSATION': {
                    d: 'm {mx},{my} {e.x0},-{e.y0} 0,{e.y1} z m {e.x1},-{e.y2} {e.x2},-{e.y3} 0,{e.y1} -{e.x2},-{e.y3} z',
                    height: 36,
                    width: 36,
                    heightElements: [6.5, 13, 0.4, 6.1],
                    widthElements: [9, 9.3, 8.7]
                },
                'EVENT_TIMER_WH': {
                    d: 'M {mx},{my} l {e.x0},-{e.y0} m -{e.x0},{e.y0} l {e.x1},{e.y1} ',
                    height: 36,
                    width: 36,
                    heightElements: [10, 2],
                    widthElements: [3, 7]
                },
                'EVENT_TIMER_LINE': {
                    d: 'M {mx},{my} ' +
                        'm {e.x0},{e.y0} l -{e.x1},{e.y1} ',
                    height: 36,
                    width: 36,
                    heightElements: [10, 3],
                    widthElements: [0, 0]
                },
                'EVENT_MULTIPLE': {
                    d: 'm {mx},{my} {e.x1},-{e.y0} {e.x1},{e.y0} -{e.x0},{e.y1} -{e.x2},0 z',
                    height: 36,
                    width: 36,
                    heightElements: [6.28099, 12.56199],
                    widthElements: [3.1405, 9.42149, 12.56198]
                },
                'EVENT_PARALLEL_MULTIPLE': {
                    d: 'm {mx},{my} {e.x0},0 0,{e.y1} {e.x1},0 0,{e.y0} -{e.x1},0 0,{e.y1} ' +
                        '-{e.x0},0 0,-{e.y1} -{e.x1},0 0,-{e.y0} {e.x1},0 z',
                    height: 36,
                    width: 36,
                    heightElements: [2.56228, 7.68683],
                    widthElements: [2.56228, 7.68683]
                },
                'GATEWAY_EXCLUSIVE': {
                    d: 'm {mx},{my} {e.x0},{e.y0} {e.x1},{e.y0} {e.x2},0 {e.x4},{e.y2} ' +
                        '{e.x4},{e.y1} {e.x2},0 {e.x1},{e.y3} {e.x0},{e.y3} ' +
                        '{e.x3},0 {e.x5},{e.y1} {e.x5},{e.y2} {e.x3},0 z',
                    height: 17.5,
                    width: 17.5,
                    heightElements: [8.5, 6.5312, -6.5312, -8.5],
                    widthElements: [6.5, -6.5, 3, -3, 5, -5]
                },
                'GATEWAY_PARALLEL': {
                    d: 'm {mx},{my} 0,{e.y1} -{e.x1},0 0,{e.y0} {e.x1},0 0,{e.y1} {e.x0},0 ' +
                        '0,-{e.y1} {e.x1},0 0,-{e.y0} -{e.x1},0 0,-{e.y1} -{e.x0},0 z',
                    height: 30,
                    width: 30,
                    heightElements: [5, 12.5],
                    widthElements: [5, 12.5]
                },
                'GATEWAY_EVENT_BASED': {
                    d: 'm {mx},{my} {e.x0},{e.y0} {e.x0},{e.y1} {e.x1},{e.y2} {e.x2},0 z',
                    height: 11,
                    width: 11,
                    heightElements: [-6, 6, 12, -12],
                    widthElements: [9, -3, -12]
                },
                'GATEWAY_COMPLEX': {
                    d: 'm {mx},{my} 0,{e.y0} -{e.x0},-{e.y1} -{e.x1},{e.y2} {e.x0},{e.y1} -{e.x2},0 0,{e.y3} ' +
                        '{e.x2},0  -{e.x0},{e.y1} l {e.x1},{e.y2} {e.x0},-{e.y1} 0,{e.y0} {e.x3},0 0,-{e.y0} {e.x0},{e.y1} ' +
                        '{e.x1},-{e.y2} -{e.x0},-{e.y1} {e.x2},0 0,-{e.y3} -{e.x2},0 {e.x0},-{e.y1} -{e.x1},-{e.y2} ' +
                        '-{e.x0},{e.y1} 0,-{e.y0} -{e.x3},0 z',
                    height: 17.125,
                    width: 17.125,
                    heightElements: [4.875, 3.4375, 2.125, 3],
                    widthElements: [3.4375, 2.125, 4.875, 3]
                },
                'DATA_OBJECT_PATH': {
                    d: 'm 0,0 {e.x1},0 {e.x0},{e.y0} 0,{e.y1} -{e.x2},0 0,-{e.y2} {e.x1},0 0,{e.y0} {e.x0},0',
                    height: 61,
                    width: 51,
                    heightElements: [10, 50, 60],
                    widthElements: [10, 40, 50, 60]
                },
                'DATA_OBJECT_COLLECTION_PATH': {
                    d: 'm {mx}, {my} ' +
                        'm  0 15  l 0 -15 ' +
                        'm  4 15  l 0 -15 ' +
                        'm  4 15  l 0 -15 ',
                    height: 61,
                    width: 51,
                    heightElements: [12],
                    widthElements: [1, 6, 12, 15]
                },
                'DATA_ARROW': {
                    d: 'm 5,9 9,0 0,-3 5,5 -5,5 0,-3 -9,0 z',
                    height: 61,
                    width: 51,
                    heightElements: [],
                    widthElements: []
                },
                'DATA_STORE': {
                    d: 'm  {mx},{my} ' +
                        'l  0,{e.y2} ' +
                        'c  {e.x0},{e.y1} {e.x1},{e.y1}  {e.x2},0 ' +
                        'l  0,-{e.y2} ' +
                        'c -{e.x0},-{e.y1} -{e.x1},-{e.y1} -{e.x2},0' +
                        'c  {e.x0},{e.y1} {e.x1},{e.y1}  {e.x2},0 ' +
                        'm  -{e.x2},{e.y0}' +
                        'c  {e.x0},{e.y1} {e.x1},{e.y1} {e.x2},0' +
                        'm  -{e.x2},{e.y0}' +
                        'c  {e.x0},{e.y1} {e.x1},{e.y1}  {e.x2},0',
                    height: 61,
                    width: 61,
                    heightElements: [7, 10, 45],
                    widthElements: [2, 58, 60]
                },
                'TEXT_ANNOTATION': {
                    d: 'm {mx}, {my} m 10,0 l -10,0 l 0,{e.y0} l 10,0',
                    height: 30,
                    width: 10,
                    heightElements: [30],
                    widthElements: [10]
                },
                'MARKER_SUB_PROCESS': {
                    d: 'm{mx},{my} m 7,2 l 0,10 m -5,-5 l 10,0',
                    height: 10,
                    width: 10,
                    heightElements: [],
                    widthElements: []
                },
                'MARKER_PARALLEL': {
                    d: 'm{mx},{my} m 3,2 l 0,10 m 3,-10 l 0,10 m 3,-10 l 0,10',
                    height: 10,
                    width: 10,
                    heightElements: [],
                    widthElements: []
                },
                'MARKER_SEQUENTIAL': {
                    d: 'm{mx},{my} m 0,3 l 10,0 m -10,3 l 10,0 m -10,3 l 10,0',
                    height: 10,
                    width: 10,
                    heightElements: [],
                    widthElements: []
                },
                'MARKER_COMPENSATION': {
                    d: 'm {mx},{my} 7,-5 0,10 z m 7.1,-0.3 6.9,-4.7 0,10 -6.9,-4.7 z',
                    height: 10,
                    width: 21,
                    heightElements: [],
                    widthElements: []
                },
                'MARKER_LOOP': {
                    d: 'm {mx},{my} c 3.526979,0 6.386161,-2.829858 6.386161,-6.320661 0,-3.490806 -2.859182,-6.320661 ' +
                        '-6.386161,-6.320661 -3.526978,0 -6.38616,2.829855 -6.38616,6.320661 0,1.745402 ' +
                        '0.714797,3.325567 1.870463,4.469381 0.577834,0.571908 1.265885,1.034728 2.029916,1.35457 ' +
                        'l -0.718163,-3.909793 m 0.718163,3.909793 -3.885211,0.802902',
                    height: 13.9,
                    width: 13.7,
                    heightElements: [],
                    widthElements: []
                },
                'MARKER_ADHOC': {
                    d: 'm {mx},{my} m 0.84461,2.64411 c 1.05533,-1.23780996 2.64337,-2.07882 4.29653,-1.97997996 2.05163,0.0805 ' +
                        '3.85579,1.15803 5.76082,1.79107 1.06385,0.34139996 2.24454,0.1438 3.18759,-0.43767 0.61743,-0.33642 ' +
                        '1.2775,-0.64078 1.7542,-1.17511 0,0.56023 0,1.12046 0,1.6807 -0.98706,0.96237996 -2.29792,1.62393996 ' +
                        '-3.6918,1.66181996 -1.24459,0.0927 -2.46671,-0.2491 -3.59505,-0.74812 -1.35789,-0.55965 ' +
                        '-2.75133,-1.33436996 -4.27027,-1.18121996 -1.37741,0.14601 -2.41842,1.13685996 -3.44288,1.96782996 z',
                    height: 4,
                    width: 15,
                    heightElements: [],
                    widthElements: []
                },
                'TASK_TYPE_SEND': {
                    d: 'm {mx},{my} l 0,{e.y1} l {e.x1},0 l 0,-{e.y1} z l {e.x0},{e.y0} l {e.x0},-{e.y0}',
                    height: 14,
                    width: 21,
                    heightElements: [6, 14],
                    widthElements: [10.5, 21]
                },
                'TASK_TYPE_SCRIPT': {
                    d: 'm {mx},{my} c 9.966553,-6.27276 -8.000926,-7.91932 2.968968,-14.938 l -8.802728,0 ' +
                        'c -10.969894,7.01868 6.997585,8.66524 -2.968967,14.938 z ' +
                        'm -7,-12 l 5,0 ' +
                        'm -4.5,3 l 4.5,0 ' +
                        'm -3,3 l 5,0' +
                        'm -4,3 l 5,0',
                    height: 15,
                    width: 12.6,
                    heightElements: [6, 14],
                    widthElements: [10.5, 21]
                },
                'TASK_TYPE_USER_1': {
                    d: 'm {mx},{my} c 0.909,-0.845 1.594,-2.049 1.594,-3.385 0,-2.554 -1.805,-4.62199999 ' +
                        '-4.357,-4.62199999 -2.55199998,0 -4.28799998,2.06799999 -4.28799998,4.62199999 0,1.348 ' +
                        '0.974,2.562 1.89599998,3.405 -0.52899998,0.187 -5.669,2.097 -5.794,4.7560005 v 6.718 ' +
                        'h 17 v -6.718 c 0,-2.2980005 -5.5279996,-4.5950005 -6.0509996,-4.7760005 z' +
                        'm -8,6 l 0,5.5 m 11,0 l 0,-5'
                },
                'TASK_TYPE_USER_2': {
                    d: 'm {mx},{my} m 2.162,1.009 c 0,2.4470005 -2.158,4.4310005 -4.821,4.4310005 ' +
                        '-2.66499998,0 -4.822,-1.981 -4.822,-4.4310005 '
                },
                'TASK_TYPE_USER_3': {
                    d: 'm {mx},{my} m -6.9,-3.80 c 0,0 2.25099998,-2.358 4.27399998,-1.177 2.024,1.181 4.221,1.537 ' +
                        '4.124,0.965 -0.098,-0.57 -0.117,-3.79099999 -4.191,-4.13599999 -3.57499998,0.001 ' +
                        '-4.20799998,3.36699999 -4.20699998,4.34799999 z'
                },
                'TASK_TYPE_MANUAL': {
                    d: 'm {mx},{my} c 0.234,-0.01 5.604,0.008 8.029,0.004 0.808,0 1.271,-0.172 1.417,-0.752 0.227,-0.898 ' +
                        '-0.334,-1.314 -1.338,-1.316 -2.467,-0.01 -7.886,-0.004 -8.108,-0.004 -0.014,-0.079 0.016,-0.533 0,-0.61 ' +
                        '0.195,-0.042 8.507,0.006 9.616,0.002 0.877,-0.007 1.35,-0.438 1.353,-1.208 0.003,-0.768 -0.479,-1.09 ' +
                        '-1.35,-1.091 -2.968,-0.002 -9.619,-0.013 -9.619,-0.013 v -0.591 c 0,0 5.052,-0.016 7.225,-0.016 ' +
                        '0.888,-0.002 1.354,-0.416 1.351,-1.193 -0.006,-0.761 -0.492,-1.196 -1.361,-1.196 -3.473,-0.005 ' +
                        '-10.86,-0.003 -11.0829995,-0.003 -0.022,-0.047 -0.045,-0.094 -0.069,-0.139 0.3939995,-0.319 ' +
                        '2.0409995,-1.626 2.4149995,-2.017 0.469,-0.4870005 0.519,-1.1650005 0.162,-1.6040005 -0.414,-0.511 ' +
                        '-0.973,-0.5 -1.48,-0.236 -1.4609995,0.764 -6.5999995,3.6430005 -7.7329995,4.2710005 -0.9,0.499 ' +
                        '-1.516,1.253 -1.882,2.19 -0.37000002,0.95 -0.17,2.01 -0.166,2.979 0.004,0.718 -0.27300002,1.345 ' +
                        '-0.055,2.063 0.629,2.087 2.425,3.312 4.859,3.318 4.6179995,0.014 9.2379995,-0.139 13.8569995,-0.158 ' +
                        '0.755,-0.004 1.171,-0.301 1.182,-1.033 0.012,-0.754 -0.423,-0.969 -1.183,-0.973 -1.778,-0.01 ' +
                        '-5.824,-0.004 -6.04,-0.004 10e-4,-0.084 0.003,-0.586 10e-4,-0.67 z'
                },
                'TASK_TYPE_INSTANTIATING_SEND': {
                    d: 'm {mx},{my} l 0,8.4 l 12.6,0 l 0,-8.4 z l 6.3,3.6 l 6.3,-3.6'
                },
                'TASK_TYPE_SERVICE': {
                    d: 'm {mx},{my} v -1.71335 c 0.352326,-0.0705 0.703932,-0.17838 1.047628,-0.32133 ' +
                        '0.344416,-0.14465 0.665822,-0.32133 0.966377,-0.52145 l 1.19431,1.18005 1.567487,-1.57688 ' +
                        '-1.195028,-1.18014 c 0.403376,-0.61394 0.683079,-1.29908 0.825447,-2.01824 l 1.622133,-0.01 ' +
                        'v -2.2196 l -1.636514,0.01 c -0.07333,-0.35153 -0.178319,-0.70024 -0.323564,-1.04372 ' +
                        '-0.145244,-0.34406 -0.321407,-0.6644 -0.522735,-0.96217 l 1.131035,-1.13631 -1.583305,-1.56293 ' +
                        '-1.129598,1.13589 c -0.614052,-0.40108 -1.302883,-0.68093 -2.022633,-0.82247 l 0.0093,-1.61852 ' +
                        'h -2.241173 l 0.0042,1.63124 c -0.353763,0.0736 -0.705369,0.17977 -1.049785,0.32371 -0.344415,0.14437 ' +
                        '-0.665102,0.32092 -0.9635006,0.52046 l -1.1698628,-1.15823 -1.5667691,1.5792 1.1684265,1.15669 ' +
                        'c -0.4026573,0.61283 -0.68308,1.29797 -0.8247287,2.01713 l -1.6588041,0.003 v 2.22174 ' +
                        'l 1.6724648,-0.006 c 0.073327,0.35077 0.1797598,0.70243 0.3242851,1.04472 0.1452428,0.34448 ' +
                        '0.3214064,0.6644 0.5227339,0.96066 l -1.1993431,1.19723 1.5840256,1.56011 1.1964668,-1.19348 ' +
                        'c 0.6140517,0.40346 1.3028827,0.68232 2.0233517,0.82331 l 7.19e-4,1.69892 h 2.226848 z ' +
                        'm 0.221462,-3.9957 c -1.788948,0.7502 -3.8576,-0.0928 -4.6097055,-1.87438 -0.7521065,-1.78321 ' +
                        '0.090598,-3.84627 1.8802645,-4.59604 1.78823,-0.74936 3.856881,0.0929 4.608987,1.87437 ' +
                        '0.752106,1.78165 -0.0906,3.84612 -1.879546,4.59605 z'
                },
                'TASK_TYPE_SERVICE_FILL': {
                    d: 'm {mx},{my} c -1.788948,0.7502 -3.8576,-0.0928 -4.6097055,-1.87438 -0.7521065,-1.78321 ' +
                        '0.090598,-3.84627 1.8802645,-4.59604 1.78823,-0.74936 3.856881,0.0929 4.608987,1.87437 ' +
                        '0.752106,1.78165 -0.0906,3.84612 -1.879546,4.59605 z'
                },
                'TASK_TYPE_BUSINESS_RULE_HEADER': {
                    d: 'm {mx},{my} 0,4 20,0 0,-4 z'
                },
                'TASK_TYPE_BUSINESS_RULE_MAIN': {
                    d: 'm {mx},{my} 0,12 20,0 0,-12 z' +
                        'm 0,8 l 20,0 ' +
                        'm -13,-4 l 0,8'
                },
                'MESSAGE_FLOW_MARKER': {
                    d: 'm {mx},{my} m -10.5 ,-7 l 0,14 l 21,0 l 0,-14 z l 10.5,6 l 10.5,-6'
                }
            };

            this.getRawPath = function getRawPath(pathId) {
                return this.pathMap[pathId].d;
            };

            /**
             * Scales the path to the given height and width.
             * <h1>Use case</h1>
             * <p>Use case is to scale the content of elements (event, gateways) based
             * on the element bounding box's size.
             * </p>
             * <h1>Why not transform</h1>
             * <p>Scaling a path with transform() will also scale the stroke and IE does not support
             * the option 'non-scaling-stroke' to prevent this.
             * Also there are use cases where only some parts of a path should be
             * scaled.</p>
             *
             * @param {String} pathId The ID of the path.
             * @param {Object} param <p>
             *   Example param object scales the path to 60% size of the container (data.width, data.height).
             *   <pre>
             *   {
             *     xScaleFactor: 0.6,
             *     yScaleFactor:0.6,
             *     containerWidth: data.width,
             *     containerHeight: data.height,
             *     position: {
             *       mx: 0.46,
             *       my: 0.2,
             *     }
             *   }
             *   </pre>
             *   <ul>
             *    <li>targetpathwidth = xScaleFactor * containerWidth</li>
             *    <li>targetpathheight = yScaleFactor * containerHeight</li>
             *    <li>Position is used to set the starting coordinate of the path. M is computed:
              *    <ul>
              *      <li>position.x * containerWidth</li>
              *      <li>position.y * containerHeight</li>
              *    </ul>
              *    Center of the container <pre> position: {
             *       mx: 0.5,
             *       my: 0.5,
             *     }</pre>
             *     Upper left corner of the container
             *     <pre> position: {
             *       mx: 0.0,
             *       my: 0.0,
             *     }</pre>
             *    </li>
             *   </ul>
             * </p>
             *
             */
            this.getScaledPath = function getScaledPath(pathId, param) {
                var rawPath = this.pathMap[pathId];

                // positioning
                // compute the start point of the path
                var mx, my;

                if (param.abspos) {
                    mx = param.abspos.x;
                    my = param.abspos.y;
                } else {
                    mx = param.containerWidth * param.position.mx;
                    my = param.containerHeight * param.position.my;
                }

                var coordinates = {}; //map for the scaled coordinates
                if (param.position) {

                    // path
                    var heightRatio = (param.containerHeight / rawPath.height) * param.yScaleFactor;
                    var widthRatio = (param.containerWidth / rawPath.width) * param.xScaleFactor;


                    //Apply height ratio
                    for (var heightIndex = 0; heightIndex < rawPath.heightElements.length; heightIndex++) {
                        coordinates['y' + heightIndex] = rawPath.heightElements[heightIndex] * heightRatio;
                    }

                    //Apply width ratio
                    for (var widthIndex = 0; widthIndex < rawPath.widthElements.length; widthIndex++) {
                        coordinates['x' + widthIndex] = rawPath.widthElements[widthIndex] * widthRatio;
                    }
                }

                //Apply value to raw path
                var path = format(
                    rawPath.d, {
                    mx: mx,
                    my: my,
                    e: coordinates
                }
                );
                return path;
            };
        }

        module.exports = PathMap;

        ////////// helpers //////////

        // copied from https://github.com/adobe-webplatform/Snap.svg/blob/master/src/svg.js
        var tokenRegex = /\{([^\}]+)\}/g,
            objNotationRegex = /(?:(?:^|\.)(.+?)(?=\[|\.|$|\()|\[('|")(.+?)\2\])(\(\))?/g; // matches .xxxxx or ["xxxxx"] to run over object properties

        function replacer(all, key, obj) {
            var res = obj;
            key.replace(objNotationRegex, function (all, name, quote, quotedName, isFunc) {
                name = name || quotedName;
                if (res) {
                    if (name in res) {
                        res = res[name];
                    }
                    typeof res == 'function' && isFunc && (res = res());
                }
            });
            res = (res == null || res == obj ? all : res) + '';

            return res;
        }

        function format(str, obj) {
            return String(str).replace(tokenRegex, function (all, key) {
                return replacer(all, key, obj);
            });
        }

    }, {}], 8: [function (require, module, exports) {
        module.exports = {
            __init__: ['bpmnRenderer'],
            bpmnRenderer: ['type', require('./BpmnRenderer')],
            pathMap: ['type', require('./PathMap')]
        };

    }, { "./BpmnRenderer": 6, "./PathMap": 7 }], 9: [function (require, module, exports) {
        var AutoResize = require('diagram-js/lib/features/auto-resize/AutoResize');

        var inherits = require('inherits');

        var is = require('../../util/ModelUtil').is;

        /**
         * Sub class of the AutoResize module which implements a BPMN
         * specific resize function.
         */
        function BpmnAutoResize(eventBus, elementRegistry, modeling, rules) {
            AutoResize.call(this, eventBus, elementRegistry, modeling, rules);
        }

        BpmnAutoResize.$inject = ['eventBus', 'elementRegistry', 'modeling', 'rules'];

        inherits(BpmnAutoResize, AutoResize);

        module.exports = BpmnAutoResize;


        /**
         * Resize shapes and lanes
         *
         * @param  {djs.model.Shape} target
         * @param  {Object} newBounds
         */
        BpmnAutoResize.prototype.resize = function (target, newBounds) {

            if (is(target, 'bpmn:Participant')) {
                this._modeling.resizeLane(target, newBounds);
            } else {
                this._modeling.resizeShape(target, newBounds);
            }
        };
    }, { "../../util/ModelUtil": 95, "diagram-js/lib/features/auto-resize/AutoResize": 136, "inherits": 289 }], 10: [function (require, module, exports) {
        'use strict';

        var is = require('../../util/ModelUtil').is;

        var inherits = require('inherits');

        var forEach = require('lodash/collection/forEach');

        var AutoResizeProvider = require('diagram-js/lib/features/auto-resize/AutoResizeProvider');

        /**
         * This module is a provider for automatically resizing parent BPMN elements
         */
        function BpmnAutoResizeProvider(eventBus, modeling) {
            AutoResizeProvider.call(this, eventBus);

            this._modeling = modeling;
        }

        inherits(BpmnAutoResizeProvider, AutoResizeProvider);

        BpmnAutoResizeProvider.$inject = ['eventBus', 'modeling'];

        module.exports = BpmnAutoResizeProvider;


        /**
         * Check if the given target can be expanded
         *
         * @param  {djs.model.Shape} target
         *
         * @return {boolean}
         */
        BpmnAutoResizeProvider.prototype.canResize = function (elements, target) {

            if (!is(target, 'bpmn:Participant') && !is(target, 'bpmn:Lane') && !(is(target, 'bpmn:SubProcess'))) {
                return false;
            }

            var canResize = true;

            forEach(elements, function (element) {

                if (is(element, 'bpmn:Lane') || element.labelTarget) {
                    canResize = false;
                    return;
                }
            });

            return canResize;
        };

    }, { "../../util/ModelUtil": 95, "diagram-js/lib/features/auto-resize/AutoResizeProvider": 137, "inherits": 289, "lodash/collection/forEach": 304 }], 11: [function (require, module, exports) {
        module.exports = {
            __init__: ['bpmnAutoResize', 'bpmnAutoResizeProvider'],
            bpmnAutoResize: ['type', require('./BpmnAutoResize')],
            bpmnAutoResizeProvider: ['type', require('./BpmnAutoResizeProvider')]
        };

    }, { "./BpmnAutoResize": 9, "./BpmnAutoResizeProvider": 10 }], 12: [function (require, module, exports) {
        'use strict';


        var assign = require('lodash/object/assign'),
            forEach = require('lodash/collection/forEach'),
            isArray = require('lodash/lang/isArray'),
            is = require('../../util/ModelUtil').is,
            isExpanded = require('../../util/DiUtil').isExpanded,
            isAny = require('../modeling/util/ModelingUtil').isAny,
            getChildLanes = require('../modeling/util/LaneUtil').getChildLanes,
            isEventSubProcess = require('../../util/DiUtil').isEventSubProcess,
            hasPrimaryModifier = require('diagram-js/lib/util/Mouse').hasPrimaryModifier;

        /**
         * A provider for BPMN 2.0 elements context pad
         */
        function ContextPadProvider(eventBus, contextPad, modeling, elementFactory,
            connect, create, popupMenu,
            canvas, rules, translate) {

            contextPad.registerProvider(this);

            this._contextPad = contextPad;

            this._modeling = modeling;

            this._elementFactory = elementFactory;
            this._connect = connect;
            this._create = create;
            this._popupMenu = popupMenu;
            this._canvas = canvas;
            this._rules = rules;
            this._translate = translate;


            eventBus.on('create.end', 250, function (event) {
                var shape = event.context.shape;

                if (!hasPrimaryModifier(event)) {
                    return;
                }

                var entries = contextPad.getEntries(shape);

                if (entries.replace) {
                    entries.replace.action.click(event, shape);
                }
            });
        }

        ContextPadProvider.$inject = [
            'eventBus',
            'contextPad',
            'modeling',
            'elementFactory',
            'connect',
            'create',
            'popupMenu',
            'canvas',
            'rules',
            'translate'
        ];

        module.exports = ContextPadProvider;


        ContextPadProvider.prototype.getContextPadEntries = function (element) {

            var contextPad = this._contextPad,
                modeling = this._modeling,

                elementFactory = this._elementFactory,
                connect = this._connect,
                create = this._create,
                popupMenu = this._popupMenu,
                canvas = this._canvas,
                rules = this._rules,

                translate = this._translate;

            var actions = {};

            if (element.type === 'label') {
                return actions;
            }

            var businessObject = element.businessObject;

            function startConnect(event, element, autoActivate) {
                connect.start(event, element, autoActivate);
            }

            function removeElement(e) {
                modeling.removeElements([element]);
            }

            function getReplaceMenuPosition(element) {

                var Y_OFFSET = 5;

                var diagramContainer = canvas.getContainer(),
                    pad = contextPad.getPad(element).html;

                var diagramRect = diagramContainer.getBoundingClientRect(),
                    padRect = pad.getBoundingClientRect();

                var top = padRect.top - diagramRect.top;
                var left = padRect.left - diagramRect.left;

                var pos = {
                    x: left,
                    y: top + padRect.height + Y_OFFSET
                };

                return pos;
            }


            /**
             * Create an append action
             *
             * @param {String} type
             * @param {String} className
             * @param {String} [title]
             * @param {Object} [options]
             *
             * @return {Object} descriptor
             */
            function appendAction(type, className, title, options) {

                if (typeof title !== 'string') {
                    options = title;
                    title = translate('Append {type}', { type: type.replace(/^bpmn\:/, '') });
                }

                function appendListener(event, element) {

                    var shape = elementFactory.createShape(assign({ type: type }, options));
                    create.start(event, shape, element);
                }

                return {
                    group: 'model',
                    className: className,
                    title: title,
                    action: {
                        dragstart: appendListener,
                        click: appendListener
                    }
                };
            }

            function splitLaneHandler(count) {

                return function (event, element) {
                    // actual split
                    modeling.splitLane(element, count);

                    // refresh context pad after split to
                    // get rid of split icons
                    contextPad.open(element, true);
                };
            }


            if (isAny(businessObject, ['bpmn:Lane', 'bpmn:Participant']) && isExpanded(businessObject)) {

                var childLanes = getChildLanes(element);

                assign(actions, {
                    'lane-insert-above': {
                        group: 'lane-insert-above',
                        className: 'bpmn-icon-lane-insert-above',
                        title: translate('Add Lane above'),
                        action: {
                            click: function (event, element) {
                                modeling.addLane(element, 'top');
                            }
                        }
                    }
                });

                if (childLanes.length < 2) {

                    if (element.height >= 120) {
                        assign(actions, {
                            'lane-divide-two': {
                                group: 'lane-divide',
                                className: 'bpmn-icon-lane-divide-two',
                                title: translate('Divide into two Lanes'),
                                action: {
                                    click: splitLaneHandler(2)
                                }
                            }
                        });
                    }

                    if (element.height >= 180) {
                        assign(actions, {
                            'lane-divide-three': {
                                group: 'lane-divide',
                                className: 'bpmn-icon-lane-divide-three',
                                title: translate('Divide into three Lanes'),
                                action: {
                                    click: splitLaneHandler(3)
                                }
                            }
                        });
                    }
                }

                assign(actions, {
                    'lane-insert-below': {
                        group: 'lane-insert-below',
                        className: 'bpmn-icon-lane-insert-below',
                        title: translate('Add Lane below'),
                        action: {
                            click: function (event, element) {
                                modeling.addLane(element, 'bottom');
                            }
                        }
                    }
                });

            }

            if (is(businessObject, 'bpmn:FlowNode')) {

                if (is(businessObject, 'bpmn:EventBasedGateway')) {

                    assign(actions, {
                        'append.receive-task': appendAction('bpmn:ReceiveTask', 'bpmn-icon-receive-task'),
                        'append.message-intermediate-event': appendAction('bpmn:IntermediateCatchEvent',
                            'bpmn-icon-intermediate-event-catch-message',
                            { eventDefinitionType: 'bpmn:MessageEventDefinition' }),
                        'append.timer-intermediate-event': appendAction('bpmn:IntermediateCatchEvent',
                            'bpmn-icon-intermediate-event-catch-timer',
                            { eventDefinitionType: 'bpmn:TimerEventDefinition' }),
                        'append.condtion-intermediate-event': appendAction('bpmn:IntermediateCatchEvent',
                            'bpmn-icon-intermediate-event-catch-condition',
                            { eventDefinitionType: 'bpmn:ConditionalEventDefinition' }),
                        'append.signal-intermediate-event': appendAction('bpmn:IntermediateCatchEvent',
                            'bpmn-icon-intermediate-event-catch-signal',
                            { eventDefinitionType: 'bpmn:SignalEventDefinition' })
                    });
                } else

                    if (isEventType(businessObject, 'bpmn:BoundaryEvent', 'bpmn:CompensateEventDefinition')) {

                        assign(actions, {
                            'append.compensation-activity':
                                appendAction('bpmn:Task', 'bpmn-icon-task', translate('Append compensation activity'), {
                                    isForCompensation: true
                                })
                        });
                    } else

                        if (!is(businessObject, 'bpmn:EndEvent') &&
                            !businessObject.isForCompensation &&
                            !isEventType(businessObject, 'bpmn:IntermediateThrowEvent', 'bpmn:LinkEventDefinition') &&
                            !isEventSubProcess(businessObject)) {

                            assign(actions, {
                                'append.end-event': appendAction('bpmn:EndEvent', 'bpmn-icon-end-event-none'),
                                'append.gateway': appendAction('bpmn:ExclusiveGateway', 'bpmn-icon-gateway-xor'),
                                'append.append-task': appendAction('bpmn:Task', 'bpmn-icon-task'),
                                'append.intermediate-event': appendAction('bpmn:IntermediateThrowEvent',
                                    'bpmn-icon-intermediate-event-none')
                            });
                        }
            }

            var replaceMenu;

            if (popupMenu._providers['bpmn-replace']) {
                replaceMenu = popupMenu.create('bpmn-replace', element);
            }

            if (replaceMenu && !replaceMenu.isEmpty()) {

                // Replace menu entry
                assign(actions, {
                    'replace': {
                        group: 'edit',
                        className: 'bpmn-icon-screw-wrench',
                        title: translate('Change type'),
                        action: {
                            click: function (event, element) {
                                replaceMenu.open(assign(getReplaceMenuPosition(element), {
                                    cursor: { x: event.x, y: event.y }
                                }), element);
                            }
                        }
                    }
                });
            }

            if (isAny(businessObject, [
                'bpmn:FlowNode',
                'bpmn:InteractionNode',
                'bpmn:DataObjectReference',
                'bpmn:DataStoreReference'
            ])) {

                assign(actions, {
                    'append.text-annotation': appendAction('bpmn:TextAnnotation', 'bpmn-icon-text-annotation'),

                    'connect': {
                        group: 'connect',
                        className: 'bpmn-icon-connection-multi',
                        title: translate('Connect using ' +
                            (businessObject.isForCompensation ? '' : 'Sequence/MessageFlow or ') +
                            'Association'),
                        action: {
                            click: startConnect,
                            dragstart: startConnect
                        }
                    }
                });
            }

            if (isAny(businessObject, ['bpmn:DataObjectReference', 'bpmn:DataStoreReference'])) {
                assign(actions, {
                    'connect': {
                        group: 'connect',
                        className: 'bpmn-icon-connection-multi',
                        title: translate('Connect using DataInputAssociation'),
                        action: {
                            click: startConnect,
                            dragstart: startConnect
                        }
                    }
                });
            }

            // delete element entry, only show if allowed by rules
            var deleteAllowed = rules.allowed('elements.delete', { elements: [element] });

            if (isArray(deleteAllowed)) {
                // was the element returned as a deletion candidate?
                deleteAllowed = deleteAllowed[0] === element;
            }

            if (deleteAllowed) {
                assign(actions, {
                    'delete': {
                        group: 'edit',
                        className: 'bpmn-icon-trash',
                        title: translate('Remove'),
                        action: {
                            click: removeElement,
                            dragstart: removeElement
                        }
                    }
                });
            }

            return actions;
        };

        function isEventType(eventBo, type, definition) {

            var isType = eventBo.$instanceOf(type);
            var isDefinition = false;

            var definitions = eventBo.eventDefinitions || [];
            forEach(definitions, function (def) {
                if (def.$type === definition) {
                    isDefinition = true;
                }
            });

            return isType && isDefinition;
        }

    }, { "../../util/DiUtil": 93, "../../util/ModelUtil": 95, "../modeling/util/LaneUtil": 67, "../modeling/util/ModelingUtil": 68, "diagram-js/lib/util/Mouse": 274, "lodash/collection/forEach": 304, "lodash/lang/isArray": 424, "lodash/object/assign": 433 }], 13: [function (require, module, exports) {
        module.exports = {
            __depends__: [
                require('diagram-js-direct-editing'),
                require('diagram-js/lib/features/context-pad'),
                require('diagram-js/lib/features/selection'),
                require('diagram-js/lib/features/connect'),
                require('diagram-js/lib/features/create'),
                require('../popup-menu')
            ],
            __init__: ['contextPadProvider'],
            contextPadProvider: ['type', require('./ContextPadProvider')]
        };
    }, { "../popup-menu": 74, "./ContextPadProvider": 12, "diagram-js-direct-editing": 114, "diagram-js/lib/features/connect": 151, "diagram-js/lib/features/context-pad": 153, "diagram-js/lib/features/create": 157, "diagram-js/lib/features/selection": 233 }], 14: [function (require, module, exports) {
        'use strict';

        var ModelUtil = require('../../util/ModelUtil'),
            getBusinessObject = ModelUtil.getBusinessObject,
            is = ModelUtil.is;

        var ModelCloneHelper = require('../../util/model/ModelCloneHelper');

        var ModelCloneUtils = require('../../util/model/ModelCloneUtils'),
            getProperties = ModelCloneUtils.getProperties;

        var IGNORED_PROPERTIES = ModelCloneUtils.IGNORED_PROPERTIES;

        var filter = require('lodash/collection/filter'),
            forEach = require('lodash/collection/forEach');

        function setProperties(descriptor, data, properties) {
            forEach(properties, function (property) {
                if (data[property] !== undefined) {
                    descriptor[property] = data[property];
                }
            });
        }

        function removeProperties(element, properties) {
            forEach(properties, function (prop) {
                if (element[prop]) {
                    delete element[prop];
                }
            });
        }

        function BpmnCopyPaste(
            bpmnFactory, eventBus, copyPaste,
            clipboard, canvas, bpmnRules) {

            var helper = new ModelCloneHelper(eventBus);

            copyPaste.registerDescriptor(function (element, descriptor) {
                var businessObject = getBusinessObject(element),
                    newBusinessObject = bpmnFactory.create(businessObject.$type);

                var properties = getProperties(businessObject.$descriptor),
                    colors = {};

                properties = filter(properties, function (property) {
                    return IGNORED_PROPERTIES.indexOf(property.replace(/bpmn:/, '')) === -1;
                });

                descriptor.businessObject = helper.clone(businessObject, newBusinessObject, properties);

                descriptor.type = element.type;

                setProperties(descriptor, businessObject.di, ['isExpanded']);

                setProperties(colors, businessObject.di, ['fill', 'stroke']);

                descriptor.colors = colors;

                if (element.type === 'label') {
                    return descriptor;
                }

                setProperties(descriptor, businessObject, [
                    'type',
                    'processRef',
                    'triggeredByEvent'
                ]);

                if (businessObject.default) {
                    descriptor.default = businessObject.default.id;
                }

                return descriptor;
            });

            eventBus.on('element.paste', function (context) {
                var descriptor = context.descriptor,
                    createdElements = context.createdElements,
                    parent = descriptor.parent,
                    rootElement = canvas.getRootElement(),
                    businessObject,
                    source,
                    target,
                    canConnect;

                if (descriptor.type === 'label') {
                    return;
                }

                if (is(parent, 'bpmn:Process')) {
                    descriptor.parent = is(rootElement, 'bpmn:Collaboration') ? rootElement : parent;
                }

                if (descriptor.type === 'bpmn:DataOutputAssociation' ||
                    descriptor.type === 'bpmn:DataInputAssociation' ||
                    descriptor.type === 'bpmn:MessageFlow') {
                    descriptor.parent = rootElement;
                }

                if (is(parent, 'bpmn:Lane')) {
                    descriptor.parent = parent.parent;
                }

                // make sure that the correct type of connection is created
                if (descriptor.waypoints) {
                    source = createdElements[descriptor.source];
                    target = createdElements[descriptor.target];

                    if (source && target) {
                        source = source.element;
                        target = target.element;
                    }

                    canConnect = bpmnRules.canConnect(source, target);

                    if (canConnect) {
                        descriptor.type = canConnect.type;
                    }
                }

                businessObject = descriptor.businessObject;

                // remove the id or else we cannot paste multiple times
                delete businessObject.id;

                // assign an ID
                bpmnFactory._ensureId(businessObject);

                if (descriptor.type === 'bpmn:Participant' && descriptor.processRef) {
                    descriptor.processRef = businessObject.processRef = bpmnFactory.create('bpmn:Process');
                }

                setProperties(businessObject, descriptor, [
                    'isExpanded',
                    'triggeredByEvent'
                ]);

                removeProperties(descriptor, [
                    'triggeredByEvent'
                ]);
            });


            eventBus.on('commandStack.elements.paste.postExecuted', function () {
                // temporarily disable multi paste until #686
                // is addressed
                clipboard.clear();
            });

        }


        BpmnCopyPaste.$inject = [
            'bpmnFactory',
            'eventBus',
            'copyPaste',
            'clipboard',
            'canvas',
            'bpmnRules'
        ];

        module.exports = BpmnCopyPaste;

    }, { "../../util/ModelUtil": 95, "../../util/model/ModelCloneHelper": 97, "../../util/model/ModelCloneUtils": 98, "lodash/collection/filter": 302, "lodash/collection/forEach": 304 }], 15: [function (require, module, exports) {
        module.exports = {
            __depends__: [
                require('diagram-js/lib/features/copy-paste')
            ],
            __init__: ['bpmnCopyPaste'],
            bpmnCopyPaste: ['type', require('./BpmnCopyPaste')]
        };

    }, { "./BpmnCopyPaste": 14, "diagram-js/lib/features/copy-paste": 155 }], 16: [function (require, module, exports) {
        'use strict';

        var filter = require('lodash/collection/filter');

        var isAny = require('../modeling/util/ModelingUtil').isAny;

        /**
         * Registers element exclude filters for elements that currently do 
         * not support distribution.
         */
        function BpmnDistributeElements(distributeElements) {

            distributeElements.registerFilter(function (elements) {
                return filter(elements, function (element) {
                    var cannotDistribute = isAny(element, [
                        'bpmn:Association',
                        'bpmn:BoundaryEvent',
                        'bpmn:DataInputAssociation',
                        'bpmn:DataOutputAssociation',
                        'bpmn:Lane',
                        'bpmn:MessageFlow',
                        'bpmn:Participant',
                        'bpmn:SequenceFlow',
                        'bpmn:TextAnnotation'
                    ]);

                    return !(element.labelTarget || cannotDistribute);
                });
            });
        }

        BpmnDistributeElements.$inject = ['distributeElements'];

        module.exports = BpmnDistributeElements;

    }, { "../modeling/util/ModelingUtil": 68, "lodash/collection/filter": 302 }], 17: [function (require, module, exports) {
        module.exports = {
            __depends__: [
                require('diagram-js/lib/features/distribute-elements')
            ],
            __init__: ['bpmnDistributeElements'],
            bpmnDistributeElements: ['type', require('./BpmnDistributeElements')]
        };

    }, { "./BpmnDistributeElements": 16, "diagram-js/lib/features/distribute-elements": 159 }], 18: [function (require, module, exports) {
        'use strict';

        var inherits = require('inherits');

        var EditorActions = require('diagram-js/lib/features/editor-actions/EditorActions');

        var filter = require('lodash/collection/filter');

        var is = require('../../util/ModelUtil').is;

        var getBBox = require('diagram-js/lib/util/Elements').getBBox;

        function BpmnEditorActions(
            injector,
            canvas, elementRegistry, selection,
            spaceTool,
            lassoTool,
            handTool,
            globalConnect,
            distributeElements,
            alignElements,
            directEditing,
            searchPad,
            modeling) {

            injector.invoke(EditorActions, this);

            this.register({
                selectElements: function () {
                    // select all elements except for the invisible
                    // root element
                    var rootElement = canvas.getRootElement();

                    var elements = elementRegistry.filter(function (element) {
                        return element !== rootElement;
                    });

                    selection.select(elements);

                    return elements;
                },
                spaceTool: function () {
                    spaceTool.toggle();
                },
                lassoTool: function () {
                    lassoTool.toggle();
                },
                handTool: function () {
                    handTool.toggle();
                },
                globalConnectTool: function () {
                    globalConnect.toggle();
                },
                distributeElements: function (opts) {
                    var currentSelection = selection.get(),
                        type = opts.type;

                    if (currentSelection.length) {
                        distributeElements.trigger(currentSelection, type);
                    }
                },
                alignElements: function (opts) {
                    var currentSelection = selection.get(),
                        aligneableElements = [],
                        type = opts.type;

                    if (currentSelection.length) {
                        aligneableElements = filter(currentSelection, function (element) {
                            return !is(element, 'bpmn:Lane');
                        });

                        alignElements.trigger(aligneableElements, type);
                    }
                },
                setColor: function (opts) {
                    var currentSelection = selection.get();

                    if (currentSelection.length) {
                        modeling.setColor(currentSelection, opts);
                    }
                },
                directEditing: function () {
                    var currentSelection = selection.get();

                    if (currentSelection.length) {
                        directEditing.activate(currentSelection[0]);
                    }
                },
                find: function () {
                    searchPad.toggle();
                },
                moveToOrigin: function () {
                    var rootElement = canvas.getRootElement(),
                        boundingBox,
                        elements;

                    if (is(rootElement, 'bpmn:Collaboration')) {
                        elements = elementRegistry.filter(function (element) {
                            return is(element.parent, 'bpmn:Collaboration');
                        });
                    } else {
                        elements = elementRegistry.filter(function (element) {
                            return element !== rootElement && !is(element.parent, 'bpmn:SubProcess');
                        });
                    }

                    boundingBox = getBBox(elements);

                    modeling.moveElements(elements, { x: -boundingBox.x, y: -boundingBox.y }, rootElement);
                }
            });
        }

        inherits(BpmnEditorActions, EditorActions);

        BpmnEditorActions.$inject = [
            'injector',
            'canvas', 'elementRegistry', 'selection',
            'spaceTool',
            'lassoTool',
            'handTool',
            'globalConnect',
            'distributeElements',
            'alignElements',
            'directEditing',
            'searchPad',
            'modeling'
        ];

        module.exports = BpmnEditorActions;

    }, { "../../util/ModelUtil": 95, "diagram-js/lib/features/editor-actions/EditorActions": 163, "diagram-js/lib/util/Elements": 266, "inherits": 289, "lodash/collection/filter": 302 }], 19: [function (require, module, exports) {
        module.exports = {
            __depends__: [
                require('diagram-js/lib/features/align-elements'),
                require('diagram-js/lib/features/editor-actions'),
                require('diagram-js/lib/features/hand-tool'),
                require('diagram-js/lib/features/lasso-tool'),
                require('diagram-js/lib/features/space-tool'),
                require('../global-connect'),
                require('../copy-paste'),
                require('../distribute-elements'),
                require('../search'),
                require('../modeling')
            ],
            editorActions: ['type', require('./BpmnEditorActions')]
        };

    }, { "../copy-paste": 15, "../distribute-elements": 17, "../global-connect": 21, "../modeling": 66, "../search": 84, "./BpmnEditorActions": 18, "diagram-js/lib/features/align-elements": 133, "diagram-js/lib/features/editor-actions": 164, "diagram-js/lib/features/hand-tool": 168, "diagram-js/lib/features/lasso-tool": 176, "diagram-js/lib/features/space-tool": 240 }], 20: [function (require, module, exports) {
        'use strict';

        var isAny = require('../modeling/util/ModelingUtil').isAny;

        /**
         * Extention of GlobalConnect tool that implements BPMN specific rules about
         * connection start elements.
         */
        function BpmnGlobalConnect(globalConnect) {
            globalConnect.registerProvider(this);
        }

        BpmnGlobalConnect.$inject = ['globalConnect'];

        module.exports = BpmnGlobalConnect;


        /**
         * Checks if given element can be used for starting connection.
         *
         * @param  {Element} source
         * @return {Boolean}
         */
        BpmnGlobalConnect.prototype.canStartConnect = function (source) {

            if (nonExistantOrLabel(source)) {
                return null;
            }

            var businessObject = source.businessObject;

            return isAny(businessObject, [
                'bpmn:FlowNode',
                'bpmn:InteractionNode',
                'bpmn:DataObjectReference',
                'bpmn:DataStoreReference'
            ]);
        };


        function nonExistantOrLabel(element) {
            return !element || isLabel(element);
        }

        function isLabel(element) {
            return element.labelTarget;
        }



    }, { "../modeling/util/ModelingUtil": 68 }], 21: [function (require, module, exports) {
        module.exports = {
            __depends__: [
                require('diagram-js/lib/features/global-connect')
            ],
            __init__: ['bpmnGlobalConnect'],
            bpmnGlobalConnect: ['type', require('./BpmnGlobalConnect')]
        };

    }, { "./BpmnGlobalConnect": 20, "diagram-js/lib/features/global-connect": 166 }], 22: [function (require, module, exports) {
        'use strict';

        /**
         * BPMN 2.0 specific key bindings.
         *
         * @param {Keyboard} keyboard
         * @param {EditorActions} editorActions
         */
        function BpmnKeyBindings(keyboard, editorActions) {

            keyboard.addListener(function (key, modifiers) {

                // ctrl + a -> select all elements
                if (key === 65 && keyboard.isCmd(modifiers)) {
                    editorActions.trigger('selectElements');

                    return true;
                }

                // ctrl + f -> search labels
                if (key === 70 && keyboard.isCmd(modifiers)) {
                    editorActions.trigger('find');

                    return true;
                }

                if (keyboard.hasModifier(modifiers)) {
                    return;
                }

                // s -> activate space tool
                if (key === 83) {
                    editorActions.trigger('spaceTool');

                    return true;
                }

                // l -> activate lasso tool
                if (key === 76) {
                    editorActions.trigger('lassoTool');

                    return true;
                }

                // h -> activate hand tool
                if (key === 72) {
                    editorActions.trigger('handTool');

                    return true;
                }

                // c -> activate global connect tool
                if (key === 67) {
                    editorActions.trigger('globalConnectTool');

                    return true;
                }

                // e -> activate direct editing
                if (key === 69) {
                    editorActions.trigger('directEditing');

                    return true;
                }
            });
        }

        BpmnKeyBindings.$inject = [
            'keyboard',
            'editorActions'
        ];

        module.exports = BpmnKeyBindings;
    }, {}], 23: [function (require, module, exports) {
        module.exports = {
            __depends__: [
                require('diagram-js/lib/features/keyboard')
            ],
            __init__: ['bpmnKeyBindings'],
            bpmnKeyBindings: ['type', require('./BpmnKeyBindings')]
        };

    }, { "./BpmnKeyBindings": 22, "diagram-js/lib/features/keyboard": 172 }], 24: [function (require, module, exports) {
        'use strict';

        var UpdateLabelHandler = require('./cmd/UpdateLabelHandler');

        var LabelUtil = require('./LabelUtil');

        var is = require('../../util/ModelUtil').is,
            isExpanded = require('../../util/DiUtil').isExpanded;

        var LINE_HEIGHT = 14,
            PADDING = 6;

        function LabelEditingProvider(eventBus, canvas, directEditing, commandStack) {

            this._canvas = canvas;
            this._commandStack = commandStack;

            directEditing.registerProvider(this);

            commandStack.registerHandler('element.updateLabel', UpdateLabelHandler);

            // listen to dblclick on non-root elements
            eventBus.on('element.dblclick', function (event) {
                directEditing.activate(event.element);
            });

            // complete on followup canvas operation
            eventBus.on(['element.mousedown', 'drag.init', 'canvas.viewbox.changed'], function (event) {
                directEditing.complete();
            });

            // cancel on command stack changes
            eventBus.on(['commandStack.changed'], function () {
                directEditing.cancel();
            });


            if ('ontouchstart' in document.documentElement) {
                // we deactivate automatic label editing on mobile devices
                // as it breaks the user interaction workflow

                // TODO(nre): we should temporarily focus the edited element here
                // and release the focused viewport after the direct edit operation is finished
            } else {
                eventBus.on('create.end', 500, function (e) {

                    var element = e.shape,
                        canExecute = e.context.canExecute;

                    if (!canExecute) {
                        return;
                    }

                    if (is(element, 'bpmn:Task') || is(element, 'bpmn:TextAnnotation') ||
                        (is(element, 'bpmn:SubProcess') && !isExpanded(element))) {

                        directEditing.activate(element);
                    }
                });
            }
        }

        LabelEditingProvider.$inject = ['eventBus', 'canvas', 'directEditing', 'commandStack'];

        module.exports = LabelEditingProvider;


        /**
         * Activate direct editing for activities and text annotations.
         *
         * @param  {djs.model.Base} element
         *
         * @return {Object} an object with properties bounds (position and size) and text
         */
        LabelEditingProvider.prototype.activate = function (element) {

            var text = LabelUtil.getLabel(element);

            if (text === undefined) {
                return;
            }

            var properties = this.getEditingBBox(element);

            properties.text = text;

            return properties;
        };


        /**
         * Get the editing bounding box based on the element's size and position
         *
         * @param  {djs.model.Base} element
         *
         * @return {Object} an object containing information about position and size (fixed or minimum and/or maximum)
         */
        LabelEditingProvider.prototype.getEditingBBox = function (element) {
            var canvas = this._canvas;

            var target = element.label || element;

            var bbox = canvas.getAbsoluteBBox(target);

            var mid = {
                x: bbox.x + bbox.width / 2,
                y: bbox.y + bbox.height / 2
            };

            // default position
            var bounds = { x: bbox.x, y: bbox.y };

            var style = {},
                zoom;

            // adjust for expanded pools AND lanes
            if ((is(element, 'bpmn:Participant') && isExpanded(element)) || is(element, 'bpmn:Lane')) {

                bounds.width = 150;
                bounds.minHeight = LINE_HEIGHT + PADDING;
                bounds.maxHeight = LINE_HEIGHT * 2 + PADDING;
                bounds.x = bbox.x - bounds.width / 2;
                bounds.y = mid.y - bounds.minHeight / 2;
            }


            // internal labels for tasks and collapsed call activities, sub processes and participants
            if (
                is(element, 'bpmn:Task') ||
                (is(element, 'bpmn:CallActivity') && !isExpanded(element)) ||
                (is(element, 'bpmn:SubProcess') && !isExpanded(element)) ||
                (is(element, 'bpmn:Participant') && !isExpanded(element))
            ) {

                zoom = canvas.zoom();

                // fixed size for internal labels:
                // on high zoom levels: text box size === bbox size
                // on low zoom levels: text box size === bbox size at 100% zoom
                // This ensures minimum bounds at low zoom levels
                if (zoom > 1) {
                    bounds.width = bbox.width;
                    bounds.height = bbox.height;
                } else {
                    bounds.width = bbox.width / zoom;
                    bounds.height = bbox.height / zoom;
                }

                // centering overlapping text box size at low zoom levels
                if (zoom < 1) {
                    bounds.x = bbox.x - (bounds.width / 2 - bbox.width / 2);
                    bounds.y = bbox.y - (bounds.height / 2 - bbox.height / 2);
                }

            }


            // internal labels for expanded sub processes
            if (is(element, 'bpmn:SubProcess') && isExpanded(element)) {

                bounds.width = element.width;
                bounds.maxHeight = 3 * LINE_HEIGHT + PADDING; // maximum 3 lines
                bounds.x = mid.x - element.width / 2;
            }


            // external labels for events, data elements, gateways and connections
            if (target.labelTarget) {

                bounds.width = 150;
                bounds.minHeight = LINE_HEIGHT + PADDING; // 1 line
                bounds.x = mid.x - bounds.width / 2;
            }


            // text annotations
            if (is(element, 'bpmn:TextAnnotation')) {
                bounds.minWidth = 100;
                bounds.height = element.height;

                style.textAlign = 'left';
            }

            return { bounds: bounds, style: style };
        };


        LabelEditingProvider.prototype.update = function (element, newLabel) {
            this._commandStack.execute('element.updateLabel', {
                element: element,
                newLabel: newLabel
            });
        };

    }, { "../../util/DiUtil": 93, "../../util/ModelUtil": 95, "./LabelUtil": 25, "./cmd/UpdateLabelHandler": 26 }], 25: [function (require, module, exports) {
        'use strict';

        var is = require('../../util/ModelUtil').is;

        function getLabelAttr(semantic) {
            if (is(semantic, 'bpmn:FlowElement') ||
                is(semantic, 'bpmn:Participant') ||
                is(semantic, 'bpmn:Lane') ||
                is(semantic, 'bpmn:SequenceFlow') ||
                is(semantic, 'bpmn:MessageFlow')) {

                return 'name';
            }

            if (is(semantic, 'bpmn:TextAnnotation')) {
                return 'text';
            }
        }

        module.exports.getLabel = function (element) {
            var semantic = element.businessObject,
                attr = getLabelAttr(semantic);

            if (attr) {
                return semantic[attr] || '';
            }
        };


        module.exports.setLabel = function (element, text, isExternal) {
            var semantic = element.businessObject,
                attr = getLabelAttr(semantic);

            if (attr) {
                semantic[attr] = text;
            }

            // show external label if not empty
            if (isExternal) {
                element.hidden = !text;
            }

            return element;
        };
    }, { "../../util/ModelUtil": 95 }], 26: [function (require, module, exports) {
        'use strict';

        var LabelUtil = require('../LabelUtil');

        var TextUtil = require('diagram-js/lib/util/Text');

        var hasExternalLabel = require('../../../util/LabelUtil').hasExternalLabel;

        var getBusinessObject = require('../../../util/ModelUtil').getBusinessObject;

        var NULL_DIMENSIONS = {
            width: 0,
            height: 0
        };


        /**
         * A handler that updates the text of a BPMN element.
         */
        function UpdateLabelHandler(modeling) {

            var textUtil = new TextUtil();

            /**
             * Set the label and return the changed elements.
             *
             * Element parameter can be label itself or connection (i.e. sequence flow).
             *
             * @param {djs.model.Base} element
             * @param {String} text
             */
            function setText(element, text) {

                // external label if present
                var label = element.label || element;

                var labelTarget = element.labelTarget || element;

                LabelUtil.setLabel(label, text, labelTarget !== label);

                return [label, labelTarget];
            }

            function execute(ctx) {
                ctx.oldLabel = LabelUtil.getLabel(ctx.element);
                return setText(ctx.element, ctx.newLabel);
            }

            function revert(ctx) {
                return setText(ctx.element, ctx.oldLabel);
            }

            function postExecute(ctx) {
                var element = ctx.element,
                    label = element.label || element;

                // ignore internal labels
                if (!hasExternalLabel(element)) {
                    return;
                }

                var text = getBusinessObject(label).name;

                if (!text) {
                    return;
                }

                // get layouted text bounds and resize external
                // external label accordingly
                var newBounds = getLayoutedBounds(label, text, textUtil);

                modeling.resizeShape(label, newBounds, NULL_DIMENSIONS);
            }

            // API

            this.execute = execute;
            this.revert = revert;
            this.postExecute = postExecute;
        }

        UpdateLabelHandler.$inject = ['modeling'];

        module.exports = UpdateLabelHandler;


        // TODO(nikku): repeating code (search for <getLayoutedBounds>)

        var EXTERNAL_LABEL_STYLE = {
            fontFamily: 'Arial, sans-serif',
            fontSize: '11px'
        };

        function getLayoutedBounds(bounds, text, textUtil) {

            var layoutedLabelDimensions = textUtil.getDimensions(text, {
                box: {
                    width: 90,
                    height: 30,
                    x: bounds.width / 2 + bounds.x,
                    y: bounds.height / 2 + bounds.y
                },
                style: EXTERNAL_LABEL_STYLE
            });

            // resize label shape to fit label text
            return {
                x: Math.round(bounds.x + bounds.width / 2 - layoutedLabelDimensions.width / 2),
                y: Math.round(bounds.y),
                width: Math.ceil(layoutedLabelDimensions.width),
                height: Math.ceil(layoutedLabelDimensions.height)
            };
        }
    }, { "../../../util/LabelUtil": 94, "../../../util/ModelUtil": 95, "../LabelUtil": 25, "diagram-js/lib/util/Text": 280 }], 27: [function (require, module, exports) {
        module.exports = {
            __depends__: [
                require('diagram-js/lib/command'),
                require('diagram-js/lib/features/change-support'),
                require('diagram-js-direct-editing')
            ],
            __init__: ['labelEditingProvider'],
            labelEditingProvider: ['type', require('./LabelEditingProvider')]
        };
    }, { "./LabelEditingProvider": 24, "diagram-js-direct-editing": 114, "diagram-js/lib/command": 121, "diagram-js/lib/features/change-support": 147 }], 28: [function (require, module, exports) {
        'use strict';

        var map = require('lodash/collection/map'),
            assign = require('lodash/object/assign'),
            pick = require('lodash/object/pick');


        function BpmnFactory(moddle) {
            this._model = moddle;
        }

        BpmnFactory.$inject = ['moddle'];


        BpmnFactory.prototype._needsId = function (element) {
            return element.$instanceOf('bpmn:RootElement') ||
                element.$instanceOf('bpmn:FlowElement') ||
                element.$instanceOf('bpmn:MessageFlow') ||
                element.$instanceOf('bpmn:DataAssociation') ||
                element.$instanceOf('bpmn:Artifact') ||
                element.$instanceOf('bpmn:Participant') ||
                element.$instanceOf('bpmn:Lane') ||
                element.$instanceOf('bpmn:Process') ||
                element.$instanceOf('bpmn:Collaboration') ||
                element.$instanceOf('bpmndi:BPMNShape') ||
                element.$instanceOf('bpmndi:BPMNEdge') ||
                element.$instanceOf('bpmndi:BPMNDiagram') ||
                element.$instanceOf('bpmndi:BPMNPlane') ||
                element.$instanceOf('bpmn:Property');
        };

        BpmnFactory.prototype._ensureId = function (element) {

            // generate semantic ids for elements
            // bpmn:SequenceFlow -> SequenceFlow_ID
            var prefix = (element.$type || '').replace(/^[^:]*:/g, '') + '_';

            if (!element.id && this._needsId(element)) {
                element.id = this._model.ids.nextPrefixed(prefix, element);
            }
        };


        BpmnFactory.prototype.create = function (type, attrs) {
            var element = this._model.create(type, attrs || {});

            this._ensureId(element);

            return element;
        };


        BpmnFactory.prototype.createDiLabel = function () {
            return this.create('bpmndi:BPMNLabel', {
                bounds: this.createDiBounds()
            });
        };


        BpmnFactory.prototype.createDiShape = function (semantic, bounds, attrs) {

            return this.create('bpmndi:BPMNShape', assign({
                bpmnElement: semantic,
                bounds: this.createDiBounds(bounds)
            }, attrs));
        };


        BpmnFactory.prototype.createDiBounds = function (bounds) {
            return this.create('dc:Bounds', bounds);
        };


        BpmnFactory.prototype.createDiWaypoints = function (waypoints) {
            return map(waypoints, function (pos) {
                return this.createDiWaypoint(pos);
            }, this);
        };

        BpmnFactory.prototype.createDiWaypoint = function (point) {
            return this.create('dc:Point', pick(point, ['x', 'y']));
        };


        BpmnFactory.prototype.createDiEdge = function (semantic, waypoints, attrs) {
            return this.create('bpmndi:BPMNEdge', assign({
                bpmnElement: semantic
            }, attrs));
        };

        BpmnFactory.prototype.createDiPlane = function (semantic) {
            return this.create('bpmndi:BPMNPlane', {
                bpmnElement: semantic
            });
        };

        module.exports = BpmnFactory;

    }, { "lodash/collection/map": 306, "lodash/object/assign": 433, "lodash/object/pick": 440 }], 29: [function (require, module, exports) {
        'use strict';

        var inherits = require('inherits');

        var assign = require('lodash/object/assign');

        var BaseLayouter = require('diagram-js/lib/layout/BaseLayouter'),
            ManhattanLayout = require('diagram-js/lib/layout/ManhattanLayout');

        var LayoutUtil = require('diagram-js/lib/layout/LayoutUtil');

        var isExpanded = require('../../util/DiUtil').isExpanded;

        var getMid = LayoutUtil.getMid,
            getOrientation = LayoutUtil.getOrientation;

        var is = require('../../util/ModelUtil').is;


        function BpmnLayouter() { }

        inherits(BpmnLayouter, BaseLayouter);

        module.exports = BpmnLayouter;


        BpmnLayouter.prototype.layoutConnection = function (connection, hints) {

            hints = hints || {};

            var source = connection.source,
                target = connection.target,
                waypoints = connection.waypoints,
                start = hints.connectionStart,
                end = hints.connectionEnd;

            var manhattanOptions,
                updatedWaypoints;

            if (!start) {
                start = getConnectionDocking(waypoints && waypoints[0], source);
            }

            if (!end) {
                end = getConnectionDocking(waypoints && waypoints[waypoints.length - 1], target);
            }

            // TODO(nikku): support vertical modeling
            // and invert preferredLayouts accordingly

            if (is(connection, 'bpmn:Association') ||
                is(connection, 'bpmn:DataAssociation')) {

                if (waypoints && !isCompensationAssociation(connection)) {
                    return [].concat([start], waypoints.slice(1, -1), [end]);
                }
            }

            // manhattan layout sequence / message flows
            if (is(connection, 'bpmn:MessageFlow')) {
                manhattanOptions = {
                    preferredLayouts: ['v:v']
                };

                if (is(target, 'bpmn:Participant')) {
                    manhattanOptions = {
                        preferredLayouts: ['straight', 'v:v']
                    };
                }

                if (isExpandedSubProcess(target)) {
                    manhattanOptions = {
                        preferredLayouts: ['straight', 'v:v']
                    };
                }

                if (isExpandedSubProcess(source) && is(target, 'bpmn:FlowNode')) {
                    manhattanOptions = {
                        preferredLayouts: ['straight', 'v:v'],
                        preserveDocking: isExpandedSubProcess(target) ? 'source' : 'target'
                    };
                }

                if (is(source, 'bpmn:Participant') && is(target, 'bpmn:FlowNode')) {
                    manhattanOptions = {
                        preferredLayouts: ['straight', 'v:v'],
                        preserveDocking: 'target'
                    };
                }

                if (is(target, 'bpmn:Event')) {
                    manhattanOptions = {
                        preferredLayouts: ['v:v']
                    };
                }
            } else


                // layout all connection between flow elements h:h,
                //
                // except for
                //
                // (1) outgoing of BoundaryEvents -> layout h:v or v:h based on attach orientation
                // (2) incoming / outgoing of Gateway -> v:h (outgoing), h:v (incoming)
                //
                if (is(connection, 'bpmn:SequenceFlow') ||
                    isCompensationAssociation(connection)) {

                    // make sure boundary event connections do
                    // not look ugly =:>
                    if (is(source, 'bpmn:BoundaryEvent')) {

                        var orientation = getAttachOrientation(source);

                        if (/left|right/.test(orientation)) {
                            manhattanOptions = {
                                preferredLayouts: ['h:v']
                            };
                        } else

                            if (/top|bottom/.test(orientation)) {
                                manhattanOptions = {
                                    preferredLayouts: ['v:h']
                                };
                            }
                    } else

                        if (is(source, 'bpmn:Gateway')) {

                            manhattanOptions = {
                                preferredLayouts: ['v:h']
                            };
                        } else

                            if (is(target, 'bpmn:Gateway')) {

                                manhattanOptions = {
                                    preferredLayouts: ['h:v']
                                };
                            }

                            // apply horizontal love <3
                            else {
                                manhattanOptions = {
                                    preferredLayouts: ['h:h']
                                };
                            }
                }

            if (manhattanOptions) {

                manhattanOptions = assign(manhattanOptions, hints);

                updatedWaypoints =
                    ManhattanLayout.repairConnection(
                        source, target,
                        start, end,
                        waypoints,
                        manhattanOptions);
            }

            return updatedWaypoints || [start, end];
        };


        function getAttachOrientation(attachedElement) {

            var hostElement = attachedElement.host,
                padding = -10;

            return getOrientation(getMid(attachedElement), hostElement, padding);
        }


        function getConnectionDocking(point, shape) {
            return point ? (point.original || point) : getMid(shape);
        }

        function isCompensationAssociation(connection) {

            var source = connection.source,
                target = connection.target;

            return is(target, 'bpmn:Activity') &&
                is(source, 'bpmn:BoundaryEvent') &&
                target.businessObject.isForCompensation;
        }


        function isExpandedSubProcess(element) {
            return is(element, 'bpmn:SubProcess') && isExpanded(element);
        }
    }, { "../../util/DiUtil": 93, "../../util/ModelUtil": 95, "diagram-js/lib/layout/BaseLayouter": 250, "diagram-js/lib/layout/LayoutUtil": 252, "diagram-js/lib/layout/ManhattanLayout": 253, "inherits": 289, "lodash/object/assign": 433 }], 30: [function (require, module, exports) {
        'use strict';

        var assign = require('lodash/object/assign'),
            forEach = require('lodash/collection/forEach'),
            inherits = require('inherits');

        var Collections = require('diagram-js/lib/util/Collections'),
            Model = require('diagram-js/lib/model');

        var getBusinessObject = require('../../util/ModelUtil').getBusinessObject,
            is = require('../../util/ModelUtil').is;

        var CommandInterceptor = require('diagram-js/lib/command/CommandInterceptor');

        /**
         * A handler responsible for updating the underlying BPMN 2.0 XML + DI
         * once changes on the diagram happen
         */
        function BpmnUpdater(eventBus, bpmnFactory, connectionDocking, translate) {

            CommandInterceptor.call(this, eventBus);

            this._bpmnFactory = bpmnFactory;
            this._translate = translate;

            var self = this;



            ////// connection cropping /////////////////////////

            // crop connection ends during create/update
            function cropConnection(e) {
                var context = e.context,
                    connection;

                if (!context.cropped) {
                    connection = context.connection;
                    connection.waypoints = connectionDocking.getCroppedWaypoints(connection);
                    context.cropped = true;
                }
            }

            this.executed([
                'connection.layout',
                'connection.create',
                'connection.reconnectEnd',
                'connection.reconnectStart'
            ], cropConnection);

            this.reverted(['connection.layout'], function (e) {
                delete e.context.cropped;
            });



            ////// BPMN + DI update /////////////////////////


            // update parent
            function updateParent(e) {
                var context = e.context;

                self.updateParent(context.shape || context.connection, context.oldParent);
            }

            function reverseUpdateParent(e) {
                var context = e.context;

                var element = context.shape || context.connection,
                    // oldParent is the (old) new parent, because we are undoing
                    oldParent = context.parent || context.newParent;

                self.updateParent(element, oldParent);
            }

            this.executed([
                'shape.move',
                'shape.create',
                'shape.delete',
                'connection.create',
                'connection.move',
                'connection.delete'
            ], ifBpmn(updateParent));

            this.reverted([
                'shape.move',
                'shape.create',
                'shape.delete',
                'connection.create',
                'connection.move',
                'connection.delete'
            ], ifBpmn(reverseUpdateParent));

            /*
             * ## Updating Parent
             *
             * When morphing a Process into a Collaboration or vice-versa,
             * make sure that both the *semantic* and *di* parent of each element
             * is updated.
             *
             */
            function updateRoot(event) {
                var context = event.context,
                    oldRoot = context.oldRoot,
                    children = oldRoot.children;

                forEach(children, function (child) {
                    if (is(child, 'bpmn:BaseElement')) {
                        self.updateParent(child);
                    }
                });
            }

            this.executed(['canvas.updateRoot'], updateRoot);
            this.reverted(['canvas.updateRoot'], updateRoot);


            // update bounds
            function updateBounds(e) {
                var shape = e.context.shape;

                if (!is(shape, 'bpmn:BaseElement')) {
                    return;
                }

                self.updateBounds(shape);
            }

            this.executed(['shape.move', 'shape.create', 'shape.resize'], ifBpmn(function (event) {

                // exclude labels because they're handled separately during shape.changed
                if (event.context.shape.type === 'label') {
                    return;
                }

                updateBounds(event);
            }));

            this.reverted(['shape.move', 'shape.create', 'shape.resize'], ifBpmn(function (event) {

                // exclude labels because they're handled separately during shape.changed
                if (event.context.shape.type === 'label') {
                    return;
                }

                updateBounds(event);
            }));

            // Handle labels separately. This is necessary, because the label bounds have to be updated
            // every time its shape changes, not only on move, create and resize.
            eventBus.on('shape.changed', function (event) {
                if (event.element.type === 'label') {
                    updateBounds({ context: { shape: event.element } });
                }
            });

            // attach / detach connection
            function updateConnection(e) {
                self.updateConnection(e.context);
            }

            this.executed([
                'connection.create',
                'connection.move',
                'connection.delete',
                'connection.reconnectEnd',
                'connection.reconnectStart'
            ], ifBpmn(updateConnection));

            this.reverted([
                'connection.create',
                'connection.move',
                'connection.delete',
                'connection.reconnectEnd',
                'connection.reconnectStart'
            ], ifBpmn(updateConnection));


            // update waypoints
            function updateConnectionWaypoints(e) {
                self.updateConnectionWaypoints(e.context.connection);
            }

            this.executed([
                'connection.layout',
                'connection.move',
                'connection.updateWaypoints',
                'connection.reconnectEnd',
                'connection.reconnectStart'
            ], ifBpmn(updateConnectionWaypoints));

            this.reverted([
                'connection.layout',
                'connection.move',
                'connection.updateWaypoints',
                'connection.reconnectEnd',
                'connection.reconnectStart'
            ], ifBpmn(updateConnectionWaypoints));


            // update Default & Conditional flows
            this.executed([
                'connection.reconnectEnd',
                'connection.reconnectStart'
            ], ifBpmn(function (e) {
                var context = e.context,
                    connection = context.connection,
                    businessObject = getBusinessObject(connection),
                    oldSource = getBusinessObject(context.oldSource),
                    oldTarget = getBusinessObject(context.oldTarget),
                    newSource = getBusinessObject(connection.source),
                    newTarget = getBusinessObject(connection.target);

                if (oldSource === newSource || oldTarget === newTarget) {
                    return;
                }

                // on reconnectStart -> default flow
                if (oldSource && oldSource.default === businessObject) {
                    context.default = oldSource.default;
                    oldSource.default = undefined;
                }

                // on reconnectEnd -> default flow
                if ((businessObject.sourceRef && businessObject.sourceRef.default) &&
                    !(is(newTarget, 'bpmn:Activity') ||
                        is(newTarget, 'bpmn:EndEvent') ||
                        is(newTarget, 'bpmn:Gateway') ||
                        is(newTarget, 'bpmn:IntermediateThrowEvent'))) {
                    context.default = businessObject.sourceRef.default;
                    businessObject.sourceRef.default = undefined;
                }

                // on reconnectStart -> conditional flow
                if (oldSource && (businessObject.conditionExpression) &&
                    !(is(newSource, 'bpmn:Activity') ||
                        is(newSource, 'bpmn:Gateway'))) {
                    context.conditionExpression = businessObject.conditionExpression;
                    businessObject.conditionExpression = undefined;
                }

                // on reconnectEnd -> conditional flow
                if (oldTarget && (businessObject.conditionExpression) &&
                    !(is(newTarget, 'bpmn:Activity') ||
                        is(newTarget, 'bpmn:EndEvent') ||
                        is(newTarget, 'bpmn:Gateway') ||
                        is(newTarget, 'bpmn:IntermediateThrowEvent'))) {
                    context.conditionExpression = businessObject.conditionExpression;
                    businessObject.conditionExpression = undefined;
                }
            }));

            this.reverted([
                'connection.reconnectEnd',
                'connection.reconnectStart'
            ], ifBpmn(function (e) {
                var context = e.context,
                    connection = context.connection,
                    businessObject = getBusinessObject(connection),
                    newSource = getBusinessObject(connection.source);

                // default flow
                if (context.default) {
                    if (is(newSource, 'bpmn:ExclusiveGateway') || is(newSource, 'bpmn:InclusiveGateway') ||
                        is(newSource, 'bpmn:Activity')) {
                        newSource.default = context.default;
                    }
                }

                // conditional flow
                if (context.conditionExpression && is(newSource, 'bpmn:Activity')) {
                    businessObject.conditionExpression = context.conditionExpression;
                }
            }));

            // update attachments
            function updateAttachment(e) {
                self.updateAttachment(e.context);
            }

            this.executed(['element.updateAttachment'], ifBpmn(updateAttachment));
            this.reverted(['element.updateAttachment'], ifBpmn(updateAttachment));
        }

        inherits(BpmnUpdater, CommandInterceptor);

        module.exports = BpmnUpdater;

        BpmnUpdater.$inject = ['eventBus', 'bpmnFactory', 'connectionDocking', 'translate'];


        /////// implementation //////////////////////////////////

        BpmnUpdater.prototype.updateAttachment = function (context) {

            var shape = context.shape,
                businessObject = shape.businessObject,
                host = shape.host;

            businessObject.attachedToRef = host && host.businessObject;
        };

        BpmnUpdater.prototype.updateParent = function (element, oldParent) {
            // do not update BPMN 2.0 label parent
            if (element instanceof Model.Label) {
                return;
            }

            var parentShape = element.parent;

            var businessObject = element.businessObject,
                parentBusinessObject = parentShape && parentShape.businessObject,
                parentDi = parentBusinessObject && parentBusinessObject.di;

            if (is(element, 'bpmn:FlowNode')) {
                this.updateFlowNodeRefs(businessObject, parentBusinessObject, oldParent && oldParent.businessObject);
            }

            if (is(element, 'bpmn:DataOutputAssociation')) {
                if (element.source) {
                    parentBusinessObject = element.source.businessObject;
                } else {
                    parentBusinessObject = null;
                }
            }

            if (is(element, 'bpmn:DataInputAssociation')) {
                if (element.target) {
                    parentBusinessObject = element.target.businessObject;
                } else {
                    parentBusinessObject = null;
                }
            }

            this.updateSemanticParent(businessObject, parentBusinessObject);

            if (is(element, 'bpmn:DataObjectReference') && businessObject.dataObjectRef) {
                this.updateSemanticParent(businessObject.dataObjectRef, parentBusinessObject);
            }

            this.updateDiParent(businessObject.di, parentDi);
        };


        BpmnUpdater.prototype.updateBounds = function (shape) {

            var di = shape.businessObject.di;

            var bounds = (shape instanceof Model.Label) ? this._getLabel(di).bounds : di.bounds;

            assign(bounds, {
                x: shape.x,
                y: shape.y,
                width: shape.width,
                height: shape.height
            });
        };

        BpmnUpdater.prototype.updateFlowNodeRefs = function (businessObject, newContainment, oldContainment) {

            if (oldContainment === newContainment) {
                return;
            }

            var oldRefs, newRefs;

            if (is(oldContainment, 'bpmn:Lane')) {
                oldRefs = oldContainment.get('flowNodeRef');
                Collections.remove(oldRefs, businessObject);
            }

            if (is(newContainment, 'bpmn:Lane')) {
                newRefs = newContainment.get('flowNodeRef');
                Collections.add(newRefs, businessObject);
            }
        };


        // update existing sourceElement and targetElement di information
        BpmnUpdater.prototype.updateDiConnection = function (di, newSource, newTarget) {

            if (di.sourceElement && di.sourceElement.bpmnElement !== newSource) {
                di.sourceElement = newSource && newSource.di;
            }

            if (di.targetElement && di.targetElement.bpmnElement !== newTarget) {
                di.targetElement = newTarget && newTarget.di;
            }

        };


        BpmnUpdater.prototype.updateDiParent = function (di, parentDi) {

            if (parentDi && !is(parentDi, 'bpmndi:BPMNPlane')) {
                parentDi = parentDi.$parent;
            }

            if (di.$parent === parentDi) {
                return;
            }

            var planeElements = (parentDi || di.$parent).get('planeElement');

            if (parentDi) {
                planeElements.push(di);
                di.$parent = parentDi;
            } else {
                Collections.remove(planeElements, di);
                di.$parent = null;
            }
        };

        function getDefinitions(element) {
            while (element && !is(element, 'bpmn:Definitions')) {
                element = element.$parent;
            }

            return element;
        }

        BpmnUpdater.prototype.getLaneSet = function (container) {

            var laneSet, laneSets;

            // bpmn:Lane
            if (is(container, 'bpmn:Lane')) {
                laneSet = container.childLaneSet;

                if (!laneSet) {
                    laneSet = this._bpmnFactory.create('bpmn:LaneSet');
                    container.childLaneSet = laneSet;
                    laneSet.$parent = container;
                }

                return laneSet;
            }

            // bpmn:Participant
            if (is(container, 'bpmn:Participant')) {
                container = container.processRef;
            }

            // bpmn:FlowElementsContainer
            laneSets = container.get('laneSets');
            laneSet = laneSets[0];

            if (!laneSet) {
                laneSet = this._bpmnFactory.create('bpmn:LaneSet');
                laneSet.$parent = container;
                laneSets.push(laneSet);
            }

            return laneSet;
        };

        BpmnUpdater.prototype.updateSemanticParent = function (businessObject, newParent, visualParent) {

            var containment,
                translate = this._translate;

            if (businessObject.$parent === newParent) {
                return;
            }

            if (is(businessObject, 'bpmn:Lane')) {

                if (newParent) {
                    newParent = this.getLaneSet(newParent);
                }

                containment = 'lanes';
            } else

                if (is(businessObject, 'bpmn:FlowElement')) {

                    if (newParent) {

                        if (is(newParent, 'bpmn:Participant')) {
                            newParent = newParent.processRef;
                        } else

                            if (is(newParent, 'bpmn:Lane')) {
                                do {
                                    // unwrap Lane -> LaneSet -> (Lane | FlowElementsContainer)
                                    newParent = newParent.$parent.$parent;
                                } while (is(newParent, 'bpmn:Lane'));

                            }
                    }

                    containment = 'flowElements';

                } else

                    if (is(businessObject, 'bpmn:Artifact')) {

                        while (newParent &&
                            !is(newParent, 'bpmn:Process') &&
                            !is(newParent, 'bpmn:SubProcess') &&
                            !is(newParent, 'bpmn:Collaboration')) {

                            if (is(newParent, 'bpmn:Participant')) {
                                newParent = newParent.processRef;
                                break;
                            } else {
                                newParent = newParent.$parent;
                            }
                        }

                        containment = 'artifacts';
                    } else

                        if (is(businessObject, 'bpmn:MessageFlow')) {
                            containment = 'messageFlows';

                        } else

                            if (is(businessObject, 'bpmn:Participant')) {
                                containment = 'participants';

                                // make sure the participants process is properly attached / detached
                                // from the XML document

                                var process = businessObject.processRef,
                                    definitions;

                                if (process) {
                                    definitions = getDefinitions(businessObject.$parent || newParent);

                                    if (businessObject.$parent) {
                                        Collections.remove(definitions.get('rootElements'), process);
                                        process.$parent = null;
                                    }

                                    if (newParent) {
                                        Collections.add(definitions.get('rootElements'), process);
                                        process.$parent = definitions;
                                    }
                                }
                            } else

                                if (is(businessObject, 'bpmn:DataOutputAssociation')) {
                                    containment = 'dataOutputAssociations';
                                } else

                                    if (is(businessObject, 'bpmn:DataInputAssociation')) {
                                        containment = 'dataInputAssociations';
                                    }

            if (!containment) {
                throw new Error(translate(
                    'no parent for {element} in {parent}',
                    {
                        element: businessObject.id,
                        parent: newParent.id
                    }
                ));
            }

            var children;

            if (businessObject.$parent) {
                // remove from old parent
                children = businessObject.$parent.get(containment);
                Collections.remove(children, businessObject);
            }

            if (!newParent) {
                businessObject.$parent = null;
            } else {
                // add to new parent
                children = newParent.get(containment);
                children.push(businessObject);
                businessObject.$parent = newParent;
            }

            if (visualParent) {
                var diChildren = visualParent.get(containment);

                Collections.remove(children, businessObject);

                if (newParent) {

                    if (!diChildren) {
                        diChildren = [];
                        newParent.set(containment, diChildren);
                    }

                    diChildren.push(businessObject);
                }
            }
        };


        BpmnUpdater.prototype.updateConnectionWaypoints = function (connection) {
            connection.businessObject.di.set('waypoint', this._bpmnFactory.createDiWaypoints(connection.waypoints));
        };


        BpmnUpdater.prototype.updateConnection = function (context) {

            var connection = context.connection,
                businessObject = getBusinessObject(connection),
                newSource = getBusinessObject(connection.source),
                newTarget = getBusinessObject(connection.target),
                visualParent;

            if (!is(businessObject, 'bpmn:DataAssociation')) {

                var inverseSet = is(businessObject, 'bpmn:SequenceFlow');

                if (businessObject.sourceRef !== newSource) {
                    if (inverseSet) {
                        Collections.remove(businessObject.sourceRef && businessObject.sourceRef.get('outgoing'), businessObject);

                        if (newSource && newSource.get('outgoing')) {
                            newSource.get('outgoing').push(businessObject);
                        }
                    }

                    businessObject.sourceRef = newSource;
                }

                if (businessObject.targetRef !== newTarget) {
                    if (inverseSet) {
                        Collections.remove(businessObject.targetRef && businessObject.targetRef.get('incoming'), businessObject);

                        if (newTarget && newTarget.get('incoming')) {
                            newTarget.get('incoming').push(businessObject);
                        }
                    }

                    businessObject.targetRef = newTarget;
                }
            } else

                if (is(businessObject, 'bpmn:DataInputAssociation')) {
                    // handle obnoxious isMany sourceRef
                    businessObject.get('sourceRef')[0] = newSource;

                    visualParent = context.parent || context.newParent || newTarget;

                    this.updateSemanticParent(businessObject, newTarget, parent.businessObject);
                } else

                    if (is(businessObject, 'bpmn:DataOutputAssociation')) {
                        visualParent = context.parent || context.newParent || newSource;

                        this.updateSemanticParent(businessObject, newSource, visualParent);

                        // targetRef = new target
                        businessObject.targetRef = newTarget;
                    }

            this.updateConnectionWaypoints(connection);

            this.updateDiConnection(businessObject.di, newSource, newTarget);
        };


        /////// helpers /////////////////////////////////////////

        BpmnUpdater.prototype._getLabel = function (di) {
            if (!di.label) {
                di.label = this._bpmnFactory.createDiLabel();
            }

            return di.label;
        };


        /**
         * Make sure the event listener is only called
         * if the touched element is a BPMN element.
         *
         * @param  {Function} fn
         * @return {Function} guarded function
         */
        function ifBpmn(fn) {

            return function (event) {

                var context = event.context,
                    element = context.shape || context.connection;

                if (is(element, 'bpmn:BaseElement')) {
                    fn(event);
                }
            };
        }

    }, { "../../util/ModelUtil": 95, "diagram-js/lib/command/CommandInterceptor": 119, "diagram-js/lib/model": 254, "diagram-js/lib/util/Collections": 263, "inherits": 289, "lodash/collection/forEach": 304, "lodash/object/assign": 433 }], 31: [function (require, module, exports) {
        'use strict';

        var assign = require('lodash/object/assign'),
            forEach = require('lodash/collection/forEach'),
            inherits = require('inherits');

        var is = require('../../util/ModelUtil').is;

        var isExpanded = require('../../util/DiUtil').isExpanded;

        var BaseElementFactory = require('diagram-js/lib/core/ElementFactory'),
            LabelUtil = require('../../util/LabelUtil');

        /**
         * A bpmn-aware factory for diagram-js shapes
         */
        function ElementFactory(bpmnFactory, moddle, translate) {
            BaseElementFactory.call(this);

            this._bpmnFactory = bpmnFactory;
            this._moddle = moddle;
            this._translate = translate;
        }

        inherits(ElementFactory, BaseElementFactory);


        ElementFactory.$inject = ['bpmnFactory', 'moddle', 'translate'];

        module.exports = ElementFactory;

        ElementFactory.prototype.baseCreate = BaseElementFactory.prototype.create;

        ElementFactory.prototype.create = function (elementType, attrs) {
            // no special magic for labels,
            // we assume their businessObjects have already been created
            // and wired via attrs
            if (elementType === 'label') {
                return this.baseCreate(elementType, assign({ type: 'label' }, LabelUtil.DEFAULT_LABEL_SIZE, attrs));
            }

            return this.createBpmnElement(elementType, attrs);
        };

        ElementFactory.prototype.createBpmnElement = function (elementType, attrs) {
            var size,
                translate = this._translate;

            attrs = attrs || {};

            var businessObject = attrs.businessObject;

            if (!businessObject) {
                if (!attrs.type) {
                    throw new Error(translate('no shape type specified'));
                }

                businessObject = this._bpmnFactory.create(attrs.type);
            }

            if (!businessObject.di) {
                if (elementType === 'root') {
                    businessObject.di = this._bpmnFactory.createDiPlane(businessObject, [], {
                        id: businessObject.id + '_di'
                    });
                } else
                    if (elementType === 'connection') {
                        businessObject.di = this._bpmnFactory.createDiEdge(businessObject, [], {
                            id: businessObject.id + '_di'
                        });
                    } else {
                        businessObject.di = this._bpmnFactory.createDiShape(businessObject, {}, {
                            id: businessObject.id + '_di'
                        });
                    }
            }

            if (attrs.colors) {
                assign(businessObject.di, attrs.colors);

                delete attrs.colors;
            }

            applyAttributes(businessObject, attrs, [
                'processRef',
                'isInterrupting',
                'associationDirection',
                'isForCompensation'
            ]);

            if (attrs.isExpanded) {
                applyAttribute(businessObject.di, attrs, 'isExpanded');
            }

            if (is(businessObject, 'bpmn:ExclusiveGateway')) {
                businessObject.di.isMarkerVisible = true;
            }

            var eventDefinitions,
                newEventDefinition;

            if (attrs.eventDefinitionType) {
                eventDefinitions = businessObject.get('eventDefinitions') || [];
                newEventDefinition = this._moddle.create(attrs.eventDefinitionType);

                eventDefinitions.push(newEventDefinition);

                newEventDefinition.$parent = businessObject;
                businessObject.eventDefinitions = eventDefinitions;

                delete attrs.eventDefinitionType;
            }

            size = this._getDefaultSize(businessObject);

            attrs = assign({
                businessObject: businessObject,
                id: businessObject.id
            }, size, attrs);

            return this.baseCreate(elementType, attrs);
        };


        ElementFactory.prototype._getDefaultSize = function (semantic) {

            if (is(semantic, 'bpmn:SubProcess')) {

                if (isExpanded(semantic)) {
                    return { width: 350, height: 200 };
                } else {
                    return { width: 100, height: 80 };
                }
            }

            if (is(semantic, 'bpmn:Task')) {
                return { width: 100, height: 80 };
            }

            if (is(semantic, 'bpmn:Gateway')) {
                return { width: 50, height: 50 };
            }

            if (is(semantic, 'bpmn:Event')) {
                return { width: 36, height: 36 };
            }

            if (is(semantic, 'bpmn:Participant')) {
                if (!isExpanded(semantic)) {
                    return { width: 400, height: 100 };
                } else {
                    return { width: 600, height: 250 };
                }
            }

            if (is(semantic, 'bpmn:Lane')) {
                return { width: 400, height: 100 };
            }

            if (is(semantic, 'bpmn:DataObjectReference')) {
                return { width: 36, height: 50 };
            }

            if (is(semantic, 'bpmn:DataStoreReference')) {
                return { width: 50, height: 50 };
            }

            if (is(semantic, 'bpmn:TextAnnotation')) {
                return { width: 100, height: 30 };
            }

            return { width: 100, height: 80 };
        };


        ElementFactory.prototype.createParticipantShape = function (collapsed) {

            var attrs = { type: 'bpmn:Participant' };

            if (!collapsed) {
                attrs.processRef = this._bpmnFactory.create('bpmn:Process');
            }

            return this.createShape(attrs);
        };


        //////////// helpers ////////////////////////////////////

        /**
         * Apply attributes from a map to the given element,
         * remove attribute from the map on application.
         *
         * @param {Base} element
         * @param {Object} attrs (in/out map of attributes)
         * @param {Array<String>} attributeNames name of attributes to apply
         */
        function applyAttributes(element, attrs, attributeNames) {

            forEach(attributeNames, function (property) {
                if (attrs[property] !== undefined) {
                    applyAttribute(element, attrs, property);
                }
            });
        }

        /**
         * Apply named property to element and drain it from the attrs
         * collection.
         *
         * @param {Base} element
         * @param {Object} attrs (in/out map of attributes)
         * @param {String} attributeName to apply
         */
        function applyAttribute(element, attrs, attributeName) {
            element[attributeName] = attrs[attributeName];

            delete attrs[attributeName];
        }
    }, { "../../util/DiUtil": 93, "../../util/LabelUtil": 94, "../../util/ModelUtil": 95, "diagram-js/lib/core/ElementFactory": 123, "inherits": 289, "lodash/collection/forEach": 304, "lodash/object/assign": 433 }], 32: [function (require, module, exports) {
        'use strict';

        var inherits = require('inherits');

        var BaseModeling = require('diagram-js/lib/features/modeling/Modeling');

        var UpdatePropertiesHandler = require('./cmd/UpdatePropertiesHandler'),
            UpdateCanvasRootHandler = require('./cmd/UpdateCanvasRootHandler'),
            AddLaneHandler = require('./cmd/AddLaneHandler'),
            SplitLaneHandler = require('./cmd/SplitLaneHandler'),
            ResizeLaneHandler = require('./cmd/ResizeLaneHandler'),
            UpdateFlowNodeRefsHandler = require('./cmd/UpdateFlowNodeRefsHandler'),
            IdClaimHandler = require('./cmd/IdClaimHandler'),
            SetColorHandler = require('./cmd/SetColorHandler');


        /**
         * BPMN 2.0 modeling features activator
         *
         * @param {EventBus} eventBus
         * @param {ElementFactory} elementFactory
         * @param {CommandStack} commandStack
         * @param {BpmnRules} bpmnRules
         */
        function Modeling(eventBus, elementFactory, commandStack, bpmnRules) {
            BaseModeling.call(this, eventBus, elementFactory, commandStack);

            this._bpmnRules = bpmnRules;
        }

        inherits(Modeling, BaseModeling);

        Modeling.$inject = ['eventBus', 'elementFactory', 'commandStack', 'bpmnRules'];

        module.exports = Modeling;


        Modeling.prototype.getHandlers = function () {
            var handlers = BaseModeling.prototype.getHandlers.call(this);

            handlers['element.updateProperties'] = UpdatePropertiesHandler;
            handlers['canvas.updateRoot'] = UpdateCanvasRootHandler;
            handlers['lane.add'] = AddLaneHandler;
            handlers['lane.resize'] = ResizeLaneHandler;
            handlers['lane.split'] = SplitLaneHandler;
            handlers['lane.updateRefs'] = UpdateFlowNodeRefsHandler;
            handlers['id.updateClaim'] = IdClaimHandler;
            handlers['element.setColor'] = SetColorHandler;

            return handlers;
        };


        Modeling.prototype.updateLabel = function (element, newLabel) {
            this._commandStack.execute('element.updateLabel', {
                element: element,
                newLabel: newLabel
            });
        };


        Modeling.prototype.connect = function (source, target, attrs, hints) {

            var bpmnRules = this._bpmnRules;

            if (!attrs) {
                attrs = bpmnRules.canConnect(source, target);
            }

            if (!attrs) {
                return;
            }

            return this.createConnection(source, target, attrs, source.parent, hints);
        };


        Modeling.prototype.updateProperties = function (element, properties) {
            this._commandStack.execute('element.updateProperties', {
                element: element,
                properties: properties
            });
        };

        Modeling.prototype.resizeLane = function (laneShape, newBounds, balanced) {
            this._commandStack.execute('lane.resize', {
                shape: laneShape,
                newBounds: newBounds,
                balanced: balanced
            });
        };

        Modeling.prototype.addLane = function (targetLaneShape, location) {
            var context = {
                shape: targetLaneShape,
                location: location
            };

            this._commandStack.execute('lane.add', context);

            return context.newLane;
        };

        Modeling.prototype.splitLane = function (targetLane, count) {
            this._commandStack.execute('lane.split', {
                shape: targetLane,
                count: count
            });
        };

        /**
         * Transform the current diagram into a collaboration.
         *
         * @return {djs.model.Root} the new root element
         */
        Modeling.prototype.makeCollaboration = function () {

            var collaborationElement = this._create('root', {
                type: 'bpmn:Collaboration'
            });

            var context = {
                newRoot: collaborationElement
            };

            this._commandStack.execute('canvas.updateRoot', context);

            return collaborationElement;
        };

        Modeling.prototype.updateLaneRefs = function (flowNodeShapes, laneShapes) {

            this._commandStack.execute('lane.updateRefs', {
                flowNodeShapes: flowNodeShapes,
                laneShapes: laneShapes
            });
        };

        /**
         * Transform the current diagram into a process.
         *
         * @return {djs.model.Root} the new root element
         */
        Modeling.prototype.makeProcess = function () {

            var processElement = this._create('root', {
                type: 'bpmn:Process'
            });

            var context = {
                newRoot: processElement
            };

            this._commandStack.execute('canvas.updateRoot', context);
        };


        Modeling.prototype.claimId = function (id, moddleElement) {
            this._commandStack.execute('id.updateClaim', {
                id: id,
                element: moddleElement,
                claiming: true
            });
        };


        Modeling.prototype.unclaimId = function (id, moddleElement) {
            this._commandStack.execute('id.updateClaim', {
                id: id,
                element: moddleElement
            });
        };

        Modeling.prototype.setColor = function (elements, colors) {
            if (!elements.length) {
                elements = [elements];
            }

            this._commandStack.execute('element.setColor', {
                elements: elements,
                colors: colors
            });
        };

    }, { "./cmd/AddLaneHandler": 58, "./cmd/IdClaimHandler": 59, "./cmd/ResizeLaneHandler": 60, "./cmd/SetColorHandler": 61, "./cmd/SplitLaneHandler": 62, "./cmd/UpdateCanvasRootHandler": 63, "./cmd/UpdateFlowNodeRefsHandler": 64, "./cmd/UpdatePropertiesHandler": 65, "diagram-js/lib/features/modeling/Modeling": 177, "inherits": 289 }], 33: [function (require, module, exports) {
        'use strict';

        var inherits = require('inherits');

        var is = require('../../../util/ModelUtil').is;

        var CommandInterceptor = require('diagram-js/lib/command/CommandInterceptor');


        function AppendBehavior(eventBus, elementFactory, bpmnRules) {

            CommandInterceptor.call(this, eventBus);

            // assign correct shape position unless already set

            this.preExecute('shape.append', function (context) {

                var source = context.source,
                    shape = context.shape;

                if (!context.position) {

                    if (is(shape, 'bpmn:TextAnnotation')) {
                        context.position = {
                            x: source.x + source.width / 2 + 75,
                            y: source.y - (50) - shape.height / 2
                        };
                    } else {
                        context.position = {
                            x: source.x + source.width + 80 + shape.width / 2,
                            y: source.y + source.height / 2
                        };
                    }
                }
            }, true);
        }


        AppendBehavior.$inject = ['eventBus', 'elementFactory', 'bpmnRules'];

        inherits(AppendBehavior, CommandInterceptor);

        module.exports = AppendBehavior;
    }, { "../../../util/ModelUtil": 95, "diagram-js/lib/command/CommandInterceptor": 119, "inherits": 289 }], 34: [function (require, module, exports) {
        'use strict';

        var inherits = require('inherits');

        var forEach = require('lodash/collection/forEach');

        var is = require('../../../util/ModelUtil').is;

        var CommandInterceptor = require('diagram-js/lib/command/CommandInterceptor');


        function CopyPasteBehavior(eventBus, modeling, canvas) {

            CommandInterceptor.call(this, eventBus);

            this.preExecute('elements.paste', 1500, function (context) {
                var topParent = context.topParent;

                // always grab the latest root
                if (!topParent.parent) {
                    context.topParent = canvas.getRootElement();
                }

                if (is(topParent, 'bpmn:Lane')) {
                    do {
                        // unwrap Lane -> LaneSet -> (Lane | FlowElementsContainer)
                        topParent = context.topParent = topParent.parent;

                    } while (is(topParent, 'bpmn:Lane') || !is(topParent, 'bpmn:Participant'));
                }
            }, true);

            this.postExecute('elements.paste', function (context) {

                var tree = context.tree,
                    createdElements = tree.createdElements;

                forEach(createdElements, function (data) {
                    var element = data.element,
                        businessObject = element.businessObject,
                        descriptor = data.descriptor,
                        defaultFlow;

                    if ((is(businessObject, 'bpmn:ExclusiveGateway') || is(businessObject, 'bpmn:InclusiveGateway') ||
                        is(businessObject, 'bpmn:Activity')) && descriptor.default) {

                        defaultFlow = createdElements[descriptor.default];

                        // if the default flow wasn't created, means that it wasn't copied
                        if (defaultFlow) {
                            defaultFlow = defaultFlow.element;
                        } else {
                            defaultFlow = undefined;
                        }

                        delete element.default;

                        modeling.updateProperties(element, { default: defaultFlow });
                    }
                });
            }, true);
        }


        CopyPasteBehavior.$inject = ['eventBus', 'modeling', 'canvas'];

        inherits(CopyPasteBehavior, CommandInterceptor);

        module.exports = CopyPasteBehavior;

    }, { "../../../util/ModelUtil": 95, "diagram-js/lib/command/CommandInterceptor": 119, "inherits": 289, "lodash/collection/forEach": 304 }], 35: [function (require, module, exports) {
        'use strict';

        var inherits = require('inherits');

        var CommandInterceptor = require('diagram-js/lib/command/CommandInterceptor');

        var is = require('../../../util/ModelUtil').is;


        /**
         * BPMN specific create boundary event behavior
         */
        function CreateBoundaryEventBehavior(eventBus, modeling, elementFactory, bpmnFactory) {

            CommandInterceptor.call(this, eventBus);

            /**
             * replace intermediate event with boundary event when
             * attaching it to a shape
             */

            this.preExecute('shape.create', function (context) {
                var shape = context.shape,
                    host = context.host,
                    businessObject,
                    boundaryEvent;

                var attrs = {
                    cancelActivity: true
                };

                if (host && is(shape, 'bpmn:IntermediateThrowEvent')) {
                    attrs.attachedToRef = host.businessObject;

                    businessObject = bpmnFactory.create('bpmn:BoundaryEvent', attrs);

                    boundaryEvent = {
                        type: 'bpmn:BoundaryEvent',
                        businessObject: businessObject
                    };

                    context.shape = elementFactory.createShape(boundaryEvent);
                }
            }, true);
        }

        CreateBoundaryEventBehavior.$inject = ['eventBus', 'modeling', 'elementFactory', 'bpmnFactory'];

        inherits(CreateBoundaryEventBehavior, CommandInterceptor);

        module.exports = CreateBoundaryEventBehavior;

    }, { "../../../util/ModelUtil": 95, "diagram-js/lib/command/CommandInterceptor": 119, "inherits": 289 }], 36: [function (require, module, exports) {
        'use strict';

        var inherits = require('inherits');

        var CommandInterceptor = require('diagram-js/lib/command/CommandInterceptor');

        var is = require('../../../util/ModelUtil').is;

        /**
         * BPMN specific create data object behavior
         */
        function CreateDataObjectBehavior(eventBus, bpmnFactory, moddle) {

            CommandInterceptor.call(this, eventBus);

            this.preExecute('shape.create', function (event) {

                var context = event.context,
                    shape = context.shape;

                if (is(shape, 'bpmn:DataObjectReference') && shape.type !== 'label') {

                    // create a DataObject every time a DataObjectReference is created
                    var dataObject = bpmnFactory.create('bpmn:DataObject');

                    // set the reference to the DataObject
                    shape.businessObject.dataObjectRef = dataObject;
                }
            });

        }

        CreateDataObjectBehavior.$inject = ['eventBus', 'bpmnFactory', 'moddle'];

        inherits(CreateDataObjectBehavior, CommandInterceptor);

        module.exports = CreateDataObjectBehavior;

    }, { "../../../util/ModelUtil": 95, "diagram-js/lib/command/CommandInterceptor": 119, "inherits": 289 }], 37: [function (require, module, exports) {
        'use strict';

        var inherits = require('inherits');

        var CommandInterceptor = require('diagram-js/lib/command/CommandInterceptor');

        var is = require('../../../util/ModelUtil').is;

        /**
         * BPMN specific create participant behavior
         */
        function CreateParticipantBehavior(eventBus, modeling, elementFactory, bpmnFactory, canvas) {

            CommandInterceptor.call(this, eventBus);

            /**
             * morph process into collaboration before adding
             * participant onto collaboration
             */

            this.preExecute('shape.create', function (context) {

                var parent = context.parent,
                    shape = context.shape,
                    position = context.position;

                var rootElement = canvas.getRootElement();

                if (is(parent, 'bpmn:Process') && is(shape, 'bpmn:Participant') && !is(rootElement, 'bpmn:Collaboration')) {

                    // this is going to detach the process root
                    // and set the returned collaboration element
                    // as the new root element
                    var collaborationElement = modeling.makeCollaboration();

                    // monkey patch the create context
                    // so that the participant is being dropped
                    // onto the new collaboration root instead
                    context.position = position;
                    context.parent = collaborationElement;

                    context.processRoot = parent;
                }
            }, true);


            this.execute('shape.create', function (context) {

                var processRoot = context.processRoot,
                    shape = context.shape;

                if (processRoot) {
                    context.oldProcessRef = shape.businessObject.processRef;

                    // assign the participant processRef
                    shape.businessObject.processRef = processRoot.businessObject;
                }
            }, true);


            this.revert('shape.create', function (context) {
                var processRoot = context.processRoot,
                    shape = context.shape;

                if (processRoot) {
                    // assign the participant processRef
                    shape.businessObject.processRef = context.oldProcessRef;
                }
            }, true);


            this.postExecute('shape.create', function (context) {

                var processRoot = context.processRoot,
                    shape = context.shape;

                if (processRoot) {
                    // process root is already detached at this point
                    var processChildren = processRoot.children.slice();
                    modeling.moveElements(processChildren, { x: 0, y: 0 }, shape);
                }

            }, true);

        }

        CreateParticipantBehavior.$inject = ['eventBus', 'modeling', 'elementFactory', 'bpmnFactory', 'canvas'];

        inherits(CreateParticipantBehavior, CommandInterceptor);

        module.exports = CreateParticipantBehavior;

    }, { "../../../util/ModelUtil": 95, "diagram-js/lib/command/CommandInterceptor": 119, "inherits": 289 }], 38: [function (require, module, exports) {
        'use strict';

        var inherits = require('inherits');

        var CommandInterceptor = require('diagram-js/lib/command/CommandInterceptor');

        var Collections = require('diagram-js/lib/util/Collections');

        var find = require('lodash/collection/find');

        var is = require('../../../util/ModelUtil').is;

        var TARGET_REF_PLACEHOLDER_NAME = '__targetRef_placeholder';


        /**
         * This behavior makes sure we always set a fake
         * DataInputAssociation#targetRef as demanded by the BPMN 2.0
         * XSD schema.
         *
         * The reference is set to a bpmn:Property{ name: '__targetRef_placeholder' }
         * which is created on the fly and cleaned up afterwards if not needed
         * anymore.
         *
         * @param {EventBus} eventBus
         * @param {BpmnFactory} bpmnFactory
         */
        function DataInputAssociationBehavior(eventBus, bpmnFactory) {

            CommandInterceptor.call(this, eventBus);


            this.executed([
                'connection.create',
                'connection.delete',
                'connection.move',
                'connection.reconnectEnd'
            ], ifDataInputAssociation(fixTargetRef));

            this.reverted([
                'connection.create',
                'connection.delete',
                'connection.move',
                'connection.reconnectEnd'
            ], ifDataInputAssociation(fixTargetRef));


            function usesTargetRef(element, targetRef, removedConnection) {

                var inputAssociations = element.get('dataInputAssociations');

                return find(inputAssociations, function (association) {
                    return association !== removedConnection &&
                        association.targetRef === targetRef;
                });
            }

            function getTargetRef(element, create) {

                var properties = element.get('properties');

                var targetRefProp = find(properties, function (p) {
                    return p.name === TARGET_REF_PLACEHOLDER_NAME;
                });

                if (!targetRefProp && create) {
                    targetRefProp = bpmnFactory.create('bpmn:Property', {
                        name: TARGET_REF_PLACEHOLDER_NAME
                    });

                    Collections.add(properties, targetRefProp);
                }

                return targetRefProp;
            }

            function cleanupTargetRef(element, connection) {

                var targetRefProp = getTargetRef(element);

                if (!targetRefProp) {
                    return;
                }

                if (!usesTargetRef(element, targetRefProp, connection)) {
                    Collections.remove(element.get('properties'), targetRefProp);
                }
            }

            /**
             * Make sure targetRef is set to a valid property or
             * `null` if the connection is detached.
             *
             * @param {Event} event
             */
            function fixTargetRef(event) {

                var context = event.context,
                    connection = context.connection,
                    connectionBo = connection.businessObject,
                    target = connection.target,
                    targetBo = target && target.businessObject,
                    newTarget = context.newTarget,
                    newTargetBo = newTarget && newTarget.businessObject,
                    oldTarget = context.oldTarget || context.target,
                    oldTargetBo = oldTarget && oldTarget.businessObject;

                var dataAssociation = connection.businessObject,
                    targetRefProp;

                if (oldTargetBo && oldTargetBo !== targetBo) {
                    cleanupTargetRef(oldTargetBo, connectionBo);
                }

                if (newTargetBo && newTargetBo !== targetBo) {
                    cleanupTargetRef(newTargetBo, connectionBo);
                }

                if (targetBo) {
                    targetRefProp = getTargetRef(targetBo, true);
                    dataAssociation.targetRef = targetRefProp;
                } else {
                    dataAssociation.targetRef = null;
                }
            }
        }

        DataInputAssociationBehavior.$inject = ['eventBus', 'bpmnFactory'];

        inherits(DataInputAssociationBehavior, CommandInterceptor);

        module.exports = DataInputAssociationBehavior;


        /**
         * Only call the given function when the event
         * touches a bpmn:DataInputAssociation.
         *
         * @param {Function} fn
         * @return {Function}
         */
        function ifDataInputAssociation(fn) {

            return function (event) {
                var context = event.context,
                    connection = context.connection;

                if (is(connection, 'bpmn:DataInputAssociation')) {
                    return fn(event);
                }
            };
        }
    }, { "../../../util/ModelUtil": 95, "diagram-js/lib/command/CommandInterceptor": 119, "diagram-js/lib/util/Collections": 263, "inherits": 289, "lodash/collection/find": 303 }], 39: [function (require, module, exports) {
        'use strict';

        var inherits = require('inherits');

        var CommandInterceptor = require('diagram-js/lib/command/CommandInterceptor');

        var is = require('../../../util/ModelUtil').is;

        var getChildLanes = require('../util/LaneUtil').getChildLanes;

        var eachElement = require('diagram-js/lib/util/Elements').eachElement;


        var LOW_PRIORITY = 500;


        /**
         * BPMN specific delete lane behavior
         */
        function DeleteLaneBehavior(eventBus, modeling, spaceTool) {

            CommandInterceptor.call(this, eventBus);


            function compensateLaneDelete(shape, oldParent) {

                var siblings = getChildLanes(oldParent);

                var topAffected = [];
                var bottomAffected = [];

                eachElement(siblings, function (element) {

                    if (element.y > shape.y) {
                        bottomAffected.push(element);
                    } else {
                        topAffected.push(element);
                    }

                    return element.children;
                });

                if (!siblings.length) {
                    return;
                }

                var offset;

                if (bottomAffected.length && topAffected.length) {
                    offset = shape.height / 2;
                } else {
                    offset = shape.height;
                }

                var topAdjustments,
                    bottomAdjustments;

                if (topAffected.length) {
                    topAdjustments = spaceTool.calculateAdjustments(
                        topAffected, 'y', offset, shape.y - 10);

                    spaceTool.makeSpace(
                        topAdjustments.movingShapes,
                        topAdjustments.resizingShapes,
                        { x: 0, y: offset }, 's');
                }

                if (bottomAffected.length) {
                    bottomAdjustments = spaceTool.calculateAdjustments(
                        bottomAffected, 'y', -offset, shape.y + shape.height + 10);

                    spaceTool.makeSpace(
                        bottomAdjustments.movingShapes,
                        bottomAdjustments.resizingShapes,
                        { x: 0, y: -offset }, 'n');
                }
            }


            /**
             * Adjust sizes of other lanes after lane deletion
             */
            this.postExecuted('shape.delete', LOW_PRIORITY, function (event) {

                var context = event.context,
                    hints = context.hints,
                    shape = context.shape,
                    oldParent = context.oldParent;

                // only compensate lane deletes
                if (!is(shape, 'bpmn:Lane')) {
                    return;
                }

                // compensate root deletes only
                if (hints && hints.nested) {
                    return;
                }

                compensateLaneDelete(shape, oldParent);
            });
        }

        DeleteLaneBehavior.$inject = ['eventBus', 'modeling', 'spaceTool'];

        inherits(DeleteLaneBehavior, CommandInterceptor);

        module.exports = DeleteLaneBehavior;
    }, { "../../../util/ModelUtil": 95, "../util/LaneUtil": 67, "diagram-js/lib/command/CommandInterceptor": 119, "diagram-js/lib/util/Elements": 266, "inherits": 289 }], 40: [function (require, module, exports) {
        'use strict';

        var inherits = require('inherits');

        var assign = require('lodash/object/assign');

        var CommandInterceptor = require('diagram-js/lib/command/CommandInterceptor');

        var getApproxIntersection = require('diagram-js/lib/util/LineIntersection').getApproxIntersection;

        function copy(obj) {
            return assign({}, obj);
        }

        function getMid(bounds) {

            return {
                x: Math.round(bounds.x + bounds.width / 2),
                y: Math.round(bounds.y + bounds.height / 2)
            };
        }

        function DropOnFlow(eventBus, bpmnRules, modeling) {

            CommandInterceptor.call(this, eventBus);

            /**
             * Reconnect start / end of a connection after
             * dropping an element on a flow.
             */

            function insertShape(shape, targetFlow, position) {
                var waypoints = targetFlow.waypoints,
                    waypointsBefore, waypointsAfter, dockingPoint, source, target, reconnected;

                var intersection = getApproxIntersection(waypoints, position);

                if (intersection) {
                    waypointsBefore = waypoints.slice(0, intersection.index);
                    waypointsAfter = waypoints.slice(intersection.index + (intersection.bendpoint ? 1 : 0));

                    dockingPoint = intersection.bendpoint ? waypoints[intersection.index] : position;

                    waypointsBefore.push(copy(dockingPoint));
                    waypointsAfter.unshift(copy(dockingPoint));
                }

                source = targetFlow.source;
                target = targetFlow.target;

                if (bpmnRules.canConnect(source, shape, targetFlow)) {
                    // reconnect source -> inserted shape
                    modeling.reconnectEnd(targetFlow, shape, waypointsBefore || position);

                    reconnected = true;
                }

                if (bpmnRules.canConnect(shape, target, targetFlow)) {

                    if (!reconnected) {
                        // reconnect inserted shape -> end
                        modeling.reconnectStart(targetFlow, shape, waypointsAfter || position);
                    } else {
                        modeling.connect(shape, target, { type: targetFlow.type, waypoints: waypointsAfter });
                    }
                }
            }

            this.preExecute('elements.move', function (context) {

                var parent = context.newParent,
                    shapes = context.shapes,
                    shape,
                    shapeMid,
                    delta = context.delta;

                if (bpmnRules.canInsert(shapes, parent)) {

                    shape = shapes[0];
                    shapeMid = getMid(shape);

                    context.targetFlow = parent;
                    context.newParent = parent.parent;
                    context.position = {
                        x: shapeMid.x + delta.x,
                        y: shapeMid.y + delta.y
                    };
                }
            }, true);

            this.postExecuted('elements.move', function (context) {

                var shapes = context.shapes,
                    targetFlow = context.targetFlow,
                    position = context.position;

                if (targetFlow) {
                    insertShape(shapes[0], targetFlow, position);
                }

            }, true);

            this.preExecute('shape.create', function (context) {

                var parent = context.parent,
                    shape = context.shape;

                if (bpmnRules.canInsert(shape, parent)) {
                    context.targetFlow = parent;
                    context.parent = parent.parent;
                }
            }, true);


            this.postExecute('shape.create', function (context) {

                var shape = context.shape,
                    targetFlow = context.targetFlow,
                    position = context.position;

                if (targetFlow) {
                    insertShape(shape, targetFlow, position);
                }
            }, true);
        }

        inherits(DropOnFlow, CommandInterceptor);

        DropOnFlow.$inject = ['eventBus', 'bpmnRules', 'modeling'];

        module.exports = DropOnFlow;

    }, { "diagram-js/lib/command/CommandInterceptor": 119, "diagram-js/lib/util/LineIntersection": 272, "inherits": 289, "lodash/object/assign": 433 }], 41: [function (require, module, exports) {
        'use strict';

        var getMid = require('diagram-js/lib/layout/LayoutUtil').getMid;

        var lineIntersect = require('./util/LineIntersect');


        /**
         * Fix broken dockings after DI imports.
         *
         * @param {EventBus} eventBus
         */
        function ImportDockingFix(eventBus) {

            function adjustDocking(startPoint, nextPoint, elementMid) {

                var elementTop = {
                    x: elementMid.x,
                    y: elementMid.y - 50
                };

                var elementLeft = {
                    x: elementMid.x - 50,
                    y: elementMid.y
                };

                var verticalIntersect = lineIntersect(startPoint, nextPoint, elementMid, elementTop),
                    horizontalIntersect = lineIntersect(startPoint, nextPoint, elementMid, elementLeft);

                // original is horizontal or vertical center cross intersection
                var centerIntersect;

                if (verticalIntersect && horizontalIntersect) {
                    if (getDistance(verticalIntersect, elementMid) > getDistance(horizontalIntersect, elementMid)) {
                        centerIntersect = horizontalIntersect;
                    } else {
                        centerIntersect = verticalIntersect;
                    }
                } else {
                    centerIntersect = verticalIntersect || horizontalIntersect;
                }

                startPoint.original = centerIntersect;
            }

            function fixDockings(connection) {
                var waypoints = connection.waypoints;

                adjustDocking(
                    waypoints[0],
                    waypoints[1],
                    getMid(connection.source)
                );

                adjustDocking(
                    waypoints[waypoints.length - 1],
                    waypoints[waypoints.length - 2],
                    getMid(connection.target)
                );
            }

            eventBus.on('bpmnElement.added', function (e) {

                var element = e.element;

                if (element.waypoints) {
                    fixDockings(element);
                }
            });
        }

        ImportDockingFix.$inject = ['eventBus'];

        module.exports = ImportDockingFix;


        /////// helpers //////////////////////////////////

        function getDistance(p1, p2) {
            return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
        }
    }, { "./util/LineIntersect": 57, "diagram-js/lib/layout/LayoutUtil": 252 }], 42: [function (require, module, exports) {
        'use strict';

        var assign = require('lodash/object/assign'),
            inherits = require('inherits');

        var LabelUtil = require('../../../util/LabelUtil'),
            LabelLayoutUtil = require('./util/LabelLayoutUtil'),
            ModelUtil = require('../../../util/ModelUtil'),
            is = ModelUtil.is,
            getBusinessObject = ModelUtil.getBusinessObject;

        var hasExternalLabel = LabelUtil.hasExternalLabel,
            getExternalLabelMid = LabelUtil.getExternalLabelMid,
            getLabelAdjustment = LabelLayoutUtil.getLabelAdjustment;

        var CommandInterceptor = require('diagram-js/lib/command/CommandInterceptor');

        var TextUtil = require('diagram-js/lib/util/Text');

        var DEFAULT_LABEL_DIMENSIONS = {
            width: 90,
            height: 20
        };


        /**
         * A component that makes sure that external labels are added
         * together with respective elements and properly updated (DI wise)
         * during move.
         *
         * @param {EventBus} eventBus
         * @param {Modeling} modeling
         * @param {BpmnFactory} bpmnFactory
         */
        function LabelSupport(eventBus, modeling, bpmnFactory) {

            CommandInterceptor.call(this, eventBus);

            var textUtil = new TextUtil();


            ///// create external labels on shape creation

            this.postExecute(['shape.create', 'connection.create'], function (e) {
                var context = e.context;

                var element = context.shape || context.connection,
                    businessObject = element.businessObject;

                if (!hasExternalLabel(businessObject)) {
                    return;
                }

                var labelCenter = getExternalLabelMid(element);

                // we don't care about x and y
                var labelDimensions = getLayoutedBounds(
                    DEFAULT_LABEL_DIMENSIONS,
                    businessObject.name || '',
                    textUtil
                );

                modeling.createLabel(element, labelCenter, {
                    id: businessObject.id + '_label',
                    hidden: !businessObject.name,
                    businessObject: businessObject,
                    width: labelDimensions.width,
                    height: labelDimensions.height
                });
            });


            ///// update di information on label creation

            this.executed(['label.create'], function (event) {

                var element = event.context.shape,
                    businessObject,
                    di;

                // we want to trigger on real labels only
                if (!element.labelTarget) {
                    return;
                }

                // we want to trigger on BPMN elements only
                if (!is(element.labelTarget || element, 'bpmn:BaseElement')) {
                    return;
                }

                businessObject = element.businessObject,
                    di = businessObject.di;


                if (!di.label) {
                    di.label = bpmnFactory.create('bpmndi:BPMNLabel', {
                        bounds: bpmnFactory.create('dc:Bounds')
                    });
                }

                assign(di.label.bounds, {
                    x: element.x,
                    y: element.y,
                    width: element.width,
                    height: element.height
                });
            });


            ///// update label position on connection change

            function getHiddenLabelAdjustment(event) {

                var context = event.context,
                    connection = context.connection,
                    label = connection.label;

                var labelPosition = getExternalLabelMid(connection);

                return {
                    x: labelPosition.x - label.x - label.width / 2,
                    y: labelPosition.y - label.y - label.height / 2
                };
            }

            function getVisibleLabelAdjustment(event) {

                var command = event.command,
                    context = event.context,
                    connection = context.connection,
                    label = connection.label,
                    hints = assign({}, context.hints),
                    newWaypoints = context.newWaypoints || connection.waypoints,
                    oldWaypoints = context.oldWaypoints;


                if (typeof hints.startChanged === 'undefined') {
                    hints.startChanged = (command === 'connection.reconnectStart');
                }

                if (typeof hints.endChanged === 'undefined') {
                    hints.endChanged = (command === 'connection.reconnectEnd');
                }

                return getLabelAdjustment(label, newWaypoints, oldWaypoints, hints);
            }

            this.postExecute([
                'connection.layout',
                'connection.reconnectEnd',
                'connection.reconnectStart',
                'connection.updateWaypoints'
            ], function (event) {

                var label = event.context.connection.label,
                    labelAdjustment;

                if (!label) {
                    return;
                }

                if (label.hidden) {
                    labelAdjustment = getHiddenLabelAdjustment(event);
                } else {
                    labelAdjustment = getVisibleLabelAdjustment(event);
                }

                modeling.moveShape(label, labelAdjustment);
            });


            ////// keep label position on shape replace

            this.postExecute(['shape.replace'], function (event) {
                var context = event.context,
                    newShape = context.newShape,
                    oldShape = context.oldShape;

                var businessObject = getBusinessObject(newShape);

                if (businessObject && hasExternalLabel(businessObject)) {
                    newShape.label.x = oldShape.label.x;
                    newShape.label.y = oldShape.label.y;
                }
            });

        }

        inherits(LabelSupport, CommandInterceptor);

        LabelSupport.$inject = ['eventBus', 'modeling', 'bpmnFactory'];

        module.exports = LabelSupport;


        // TODO(nikku): repeating code (search for <getLayoutedBounds>)

        var EXTERNAL_LABEL_STYLE = {
            fontFamily: 'Arial, sans-serif',
            fontSize: '11px'
        };

        function getLayoutedBounds(bounds, text, textUtil) {

            var layoutedLabelDimensions = textUtil.getDimensions(text, {
                box: {
                    width: 90,
                    height: 30,
                    x: bounds.width / 2 + bounds.x,
                    y: bounds.height / 2 + bounds.y
                },
                style: EXTERNAL_LABEL_STYLE
            });

            // resize label shape to fit label text
            return {
                x: Math.round(bounds.x + bounds.width / 2 - layoutedLabelDimensions.width / 2),
                y: Math.round(bounds.y),
                width: Math.ceil(layoutedLabelDimensions.width),
                height: Math.ceil(layoutedLabelDimensions.height)
            };
        }

    }, { "../../../util/LabelUtil": 94, "../../../util/ModelUtil": 95, "./util/LabelLayoutUtil": 55, "diagram-js/lib/command/CommandInterceptor": 119, "diagram-js/lib/util/Text": 280, "inherits": 289, "lodash/object/assign": 433 }], 43: [function (require, module, exports) {
        'use strict';

        var is = require('../../../util/ModelUtil').is;

        var COLLAB_ERR_MSG = 'flow elements must be children of pools/participants',
            PROCESS_ERR_MSG = 'participants cannot be pasted onto a non-empty process diagram';

        function ModelingFeedback(eventBus, tooltips, translate) {

            function showError(position, message, timeout) {
                tooltips.add({
                    position: {
                        x: position.x + 5,
                        y: position.y + 5
                    },
                    type: 'error',
                    timeout: timeout || 2000,
                    html: '<div>' + message + '</div>'
                });
            }

            eventBus.on(['shape.move.rejected', 'create.rejected'], function (event) {
                var context = event.context,
                    shape = context.shape,
                    target = context.target;

                if (is(target, 'bpmn:Collaboration') && is(shape, 'bpmn:FlowNode')) {
                    showError(event, translate(COLLAB_ERR_MSG));
                }
            });

            eventBus.on(['elements.paste.rejected'], function (event) {
                var context = event.context,
                    position = context.position,
                    target = context.target;

                if (is(target, 'bpmn:Collaboration')) {
                    showError(position, translate(COLLAB_ERR_MSG));
                }

                if (is(target, 'bpmn:Process')) {
                    showError(position, translate(PROCESS_ERR_MSG), 3000);
                }
            });
        }


        ModelingFeedback.$inject = ['eventBus', 'tooltips', 'translate'];

        module.exports = ModelingFeedback;

    }, { "../../../util/ModelUtil": 95 }], 44: [function (require, module, exports) {
        'use strict';

        var inherits = require('inherits');

        var CommandInterceptor = require('diagram-js/lib/command/CommandInterceptor');

        var lineIntersect = require('./util/LineIntersect');


        function RemoveElementBehavior(eventBus, bpmnRules, modeling) {

            CommandInterceptor.call(this, eventBus);

            /**
             * Combine sequence flows when deleting an element
             * if there is one incoming and one outgoing
             * sequence flow
             */
            this.preExecute('shape.delete', function (e) {

                var shape = e.context.shape;

                if (shape.incoming.length == 1 && shape.outgoing.length == 1) {

                    var inConnection = shape.incoming[0],
                        outConnection = shape.outgoing[0];


                    if (bpmnRules.canConnect(inConnection.source, outConnection.target, inConnection)) {

                        // compute new, combined waypoints
                        var newWaypoints = getNewWaypoints(inConnection.waypoints, outConnection.waypoints);

                        modeling.reconnectEnd(inConnection, outConnection.target, newWaypoints);
                    }
                }
            });

        }

        inherits(RemoveElementBehavior, CommandInterceptor);

        RemoveElementBehavior.$inject = ['eventBus', 'bpmnRules', 'modeling'];

        module.exports = RemoveElementBehavior;


        ///////// helpers //////////////////////////////

        function getDocking(point) {
            return point.original || point;
        }


        function getNewWaypoints(inWaypoints, outWaypoints) {

            var intersection = lineIntersect(
                getDocking(inWaypoints[inWaypoints.length - 2]),
                getDocking(inWaypoints[inWaypoints.length - 1]),
                getDocking(outWaypoints[1]),
                getDocking(outWaypoints[0]));

            if (intersection) {
                return [].concat(
                    inWaypoints.slice(0, inWaypoints.length - 1),
                    [intersection],
                    outWaypoints.slice(1));
            } else {
                return [
                    getDocking(inWaypoints[0]),
                    getDocking(outWaypoints[outWaypoints.length - 1])
                ];
            }
        }
    }, { "./util/LineIntersect": 57, "diagram-js/lib/command/CommandInterceptor": 119, "inherits": 289 }], 45: [function (require, module, exports) {
        'use strict';

        var inherits = require('inherits');

        var CommandInterceptor = require('diagram-js/lib/command/CommandInterceptor');

        var is = require('../../../util/ModelUtil').is;


        /**
         * BPMN specific remove behavior
         */
        function RemoveParticipantBehavior(eventBus, modeling) {

            CommandInterceptor.call(this, eventBus);


            /**
             * morph collaboration diagram into process diagram
             * after the last participant has been removed
             */

            this.preExecute('shape.delete', function (context) {

                var shape = context.shape,
                    parent = shape.parent;

                // activate the behavior if the shape to be removed
                // is a participant
                if (is(shape, 'bpmn:Participant')) {
                    context.collaborationRoot = parent;
                }
            }, true);

            this.postExecute('shape.delete', function (context) {

                var collaborationRoot = context.collaborationRoot;

                if (collaborationRoot && !collaborationRoot.businessObject.participants.length) {
                    // replace empty collaboration with process diagram
                    modeling.makeProcess();
                }
            }, true);

        }

        RemoveParticipantBehavior.$inject = ['eventBus', 'modeling'];

        inherits(RemoveParticipantBehavior, CommandInterceptor);

        module.exports = RemoveParticipantBehavior;
    }, { "../../../util/ModelUtil": 95, "diagram-js/lib/command/CommandInterceptor": 119, "inherits": 289 }], 46: [function (require, module, exports) {
        'use strict';

        var forEach = require('lodash/collection/forEach'),
            find = require('lodash/collection/find'),
            inherits = require('inherits');

        var CommandInterceptor = require('diagram-js/lib/command/CommandInterceptor');

        var is = require('../../../util/ModelUtil').is;

        function ReplaceConnectionBehavior(eventBus, modeling, bpmnRules) {

            CommandInterceptor.call(this, eventBus);

            function fixConnection(connection) {

                var source = connection.source,
                    target = connection.target,
                    parent = connection.parent;

                // do not do anything if connection
                // is already deleted (may happen due to other
                // behaviors plugged-in before)
                if (!parent) {
                    return;
                }

                var replacementType,
                    remove;

                /**
                 * Check if incoming or outgoing connections
                 * can stay or could be substituted with an
                 * appropriate replacement.
                 *
                 * This holds true for SequenceFlow <> MessageFlow.
                 */

                if (is(connection, 'bpmn:SequenceFlow')) {
                    if (!bpmnRules.canConnectSequenceFlow(source, target)) {
                        remove = true;
                    }

                    if (bpmnRules.canConnectMessageFlow(source, target)) {
                        replacementType = 'bpmn:MessageFlow';
                    }
                }

                // transform message flows into sequence flows, if possible

                if (is(connection, 'bpmn:MessageFlow')) {

                    if (!bpmnRules.canConnectMessageFlow(source, target)) {
                        remove = true;
                    }

                    if (bpmnRules.canConnectSequenceFlow(source, target)) {
                        replacementType = 'bpmn:SequenceFlow';
                    }
                }

                if (is(connection, 'bpmn:Association') && !bpmnRules.canConnectAssociation(source, target)) {
                    remove = true;
                }


                // remove invalid connection,
                // unless it has been removed already
                if (remove) {
                    modeling.removeConnection(connection);
                }

                // replace SequenceFlow <> MessageFlow

                if (replacementType) {
                    modeling.connect(source, target, {
                        type: replacementType,
                        waypoints: connection.waypoints.slice()
                    });
                }
            }

            this.postExecuted('elements.move', function (context) {

                var closure = context.closure,
                    allConnections = closure.allConnections;

                forEach(allConnections, fixConnection);
            }, true);

            this.postExecuted([
                'connection.reconnectStart',
                'connection.reconnectEnd'
            ], function (event) {

                var connection = event.context.connection;

                fixConnection(connection);
            });

            this.postExecuted('element.updateProperties', function (event) {
                var context = event.context,
                    properties = context.properties,
                    element = context.element,
                    businessObject = element.businessObject,
                    connection;

                // remove condition expression when morphing to default flow
                if (properties.default) {
                    connection = find(element.outgoing, { id: element.businessObject.default.id });

                    if (connection) {
                        modeling.updateProperties(connection, { conditionExpression: undefined });
                    }
                }

                // remove default property from source when morphing to conditional flow
                if (properties.conditionExpression && businessObject.sourceRef.default === businessObject) {
                    modeling.updateProperties(element.source, { default: undefined });
                }
            });
        }

        inherits(ReplaceConnectionBehavior, CommandInterceptor);

        ReplaceConnectionBehavior.$inject = ['eventBus', 'modeling', 'bpmnRules'];

        module.exports = ReplaceConnectionBehavior;

    }, { "../../../util/ModelUtil": 95, "diagram-js/lib/command/CommandInterceptor": 119, "inherits": 289, "lodash/collection/find": 303, "lodash/collection/forEach": 304 }], 47: [function (require, module, exports) {
        'use strict';

        var inherits = require('inherits');

        var CommandInterceptor = require('diagram-js/lib/command/CommandInterceptor');

        var forEach = require('lodash/collection/forEach');

        var isEventSubProcess = require('../../../util/DiUtil').isEventSubProcess;
        var is = require('../../../util/ModelUtil').is;

        /**
         * Defines the behaviour of what happens to the elements inside a container
         * that morphs into another BPMN element
         */
        function ReplaceElementBehaviour(eventBus, bpmnReplace, bpmnRules, elementRegistry, selection, modeling) {
            CommandInterceptor.call(this, eventBus);

            this._bpmnReplace = bpmnReplace;
            this._elementRegistry = elementRegistry;
            this._selection = selection;
            this._modeling = modeling;

            this.postExecuted(['elements.move'], 500, function (event) {

                var context = event.context,
                    target = context.newParent,
                    newHost = context.newHost,
                    elements = [];

                forEach(context.closure.topLevel, function (topLevelElements) {
                    if (isEventSubProcess(topLevelElements)) {
                        elements = elements.concat(topLevelElements.children);
                    } else {
                        elements = elements.concat(topLevelElements);
                    }
                });

                // Change target to host when the moving element is a `bpmn:BoundaryEvent`
                if (elements.length === 1 && newHost) {
                    target = newHost;
                }

                var canReplace = bpmnRules.canReplace(elements, target);

                if (canReplace) {
                    this.replaceElements(elements, canReplace.replacements, newHost);
                }
            }, this);

            // update attachments if the host is replaced
            this.postExecute(['shape.replace'], 1500, function (e) {

                var context = e.context,
                    oldShape = context.oldShape,
                    newShape = context.newShape,
                    attachers = oldShape.attachers,
                    canReplace;

                if (attachers && attachers.length) {
                    canReplace = bpmnRules.canReplace(attachers, newShape);

                    this.replaceElements(attachers, canReplace.replacements);
                }

            }, this);

            this.postExecuted(['shape.replace'], 1500, function (e) {
                var context = e.context,
                    oldShape = context.oldShape,
                    newShape = context.newShape;

                modeling.unclaimId(oldShape.businessObject.id, oldShape.businessObject);
                modeling.updateProperties(newShape, { id: oldShape.id });
            });
        }

        inherits(ReplaceElementBehaviour, CommandInterceptor);


        ReplaceElementBehaviour.prototype.replaceElements = function (elements, newElements, newHost) {
            var elementRegistry = this._elementRegistry,
                bpmnReplace = this._bpmnReplace,
                selection = this._selection,
                modeling = this._modeling;

            forEach(newElements, function (replacement) {

                var newElement = {
                    type: replacement.newElementType
                };

                var oldElement = elementRegistry.get(replacement.oldElementId);

                if (newHost && is(oldElement, 'bpmn:BoundaryEvent')) {
                    modeling.updateAttachment(oldElement, null);
                }

                var idx = elements.indexOf(oldElement);

                elements[idx] = bpmnReplace.replaceElement(oldElement, newElement, { select: false });

                if (newHost && is(elements[idx], 'bpmn:BoundaryEvent')) {
                    modeling.updateAttachment(elements[idx], newHost);
                }
            });

            if (newElements) {
                selection.select(elements);
            }
        };

        ReplaceElementBehaviour.$inject = [
            'eventBus', 'bpmnReplace', 'bpmnRules',
            'elementRegistry', 'selection', 'modeling'
        ];

        module.exports = ReplaceElementBehaviour;

    }, { "../../../util/DiUtil": 93, "../../../util/ModelUtil": 95, "diagram-js/lib/command/CommandInterceptor": 119, "inherits": 289, "lodash/collection/forEach": 304 }], 48: [function (require, module, exports) {
        'use strict';

        var is = require('../../../util/ModelUtil').is;

        var roundBounds = require('diagram-js/lib/layout/LayoutUtil').roundBounds;

        var hasPrimaryModifier = require('diagram-js/lib/util/Mouse').hasPrimaryModifier;

        var SLIGHTLY_HIGHER_PRIORITY = 1001;


        /**
         * Invoke {@link Modeling#resizeLane} instead of
         * {@link Modeling#resizeShape} when resizing a Lane
         * or Participant shape.
         */
        function ResizeLaneBehavior(eventBus, modeling) {

            eventBus.on('resize.start', SLIGHTLY_HIGHER_PRIORITY + 500, function (event) {
                var context = event.context,
                    shape = context.shape;

                if (is(shape, 'bpmn:Lane') || is(shape, 'bpmn:Participant')) {

                    // should we resize the opposite lane(s) in
                    // order to compensate for the resize operation?
                    context.balanced = !hasPrimaryModifier(event);
                }
            });

            /**
             * Intercept resize end and call resize lane function instead.
             */
            eventBus.on('resize.end', SLIGHTLY_HIGHER_PRIORITY, function (event) {
                var context = event.context,
                    shape = context.shape,
                    canExecute = context.canExecute,
                    newBounds = context.newBounds;

                if (is(shape, 'bpmn:Lane') || is(shape, 'bpmn:Participant')) {

                    if (canExecute) {
                        // ensure we have actual pixel values for new bounds
                        // (important when zoom level was > 1 during move)
                        newBounds = roundBounds(newBounds);

                        // perform the actual resize
                        modeling.resizeLane(shape, newBounds, context.balanced);
                    }

                    // stop propagation
                    return false;
                }
            });
        }

        ResizeLaneBehavior.$inject = ['eventBus', 'modeling'];

        module.exports = ResizeLaneBehavior;

    }, { "../../../util/ModelUtil": 95, "diagram-js/lib/layout/LayoutUtil": 252, "diagram-js/lib/util/Mouse": 274 }], 49: [function (require, module, exports) {
        'use strict';

        var inherits = require('inherits');

        var CommandInterceptor = require('diagram-js/lib/command/CommandInterceptor'),
            getBusinessObject = require('../../../util/ModelUtil').getBusinessObject,
            is = require('../../../util/ModelUtil').is,
            computeChildrenBBox = require('diagram-js/lib/features/resize/ResizeUtil').computeChildrenBBox;


        var LOW_PRIORITY = 500;


        function ToggleElementCollapseBehaviour(eventBus, elementFactory, modeling, resize) {
            CommandInterceptor.call(this, eventBus);


            function hideEmptyLables(children) {
                if (children.length) {
                    children.forEach(function (child) {
                        if (child.type === 'label' && !child.businessObject.name) {
                            child.hidden = true;
                        }
                    });
                }
            }

            function expandedBounds(shape, defaultSize) {
                var children = shape.children,
                    newBounds = defaultSize,
                    visibleElements,
                    visibleBBox;

                visibleElements = filterVisible(children).concat([shape]);

                visibleBBox = computeChildrenBBox(visibleElements);

                if (visibleBBox) {
                    // center to visibleBBox with max(defaultSize, childrenBounds)
                    newBounds.width = Math.max(visibleBBox.width, newBounds.width);
                    newBounds.height = Math.max(visibleBBox.height, newBounds.height);

                    newBounds.x = visibleBBox.x + (visibleBBox.width - newBounds.width) / 2;
                    newBounds.y = visibleBBox.y + (visibleBBox.height - newBounds.height) / 2;
                } else {
                    // center to collapsed shape with defaultSize
                    newBounds.x = shape.x + (shape.width - newBounds.width) / 2;
                    newBounds.y = shape.y + (shape.height - newBounds.height) / 2;
                }

                return newBounds;
            }

            function collapsedBounds(shape, defaultSize) {

                return {
                    x: shape.x + (shape.width - defaultSize.width) / 2,
                    y: shape.y + (shape.height - defaultSize.height) / 2,
                    width: defaultSize.width,
                    height: defaultSize.height
                };
            }

            this.executed(['shape.toggleCollapse'], LOW_PRIORITY, function (e) {

                var context = e.context,
                    shape = context.shape;

                if (!is(shape, 'bpmn:SubProcess')) {
                    return;
                }

                if (!shape.collapsed) {
                    // all children got made visible through djs, hide empty labels
                    hideEmptyLables(shape.children);

                    // remove collapsed marker
                    getBusinessObject(shape).di.isExpanded = true;
                } else {
                    // place collapsed marker
                    getBusinessObject(shape).di.isExpanded = false;
                }
            });

            this.reverted(['shape.toggleCollapse'], LOW_PRIORITY, function (e) {

                var context = e.context;
                var shape = context.shape;


                // revert removing/placing collapsed marker
                if (!shape.collapsed) {
                    getBusinessObject(shape).di.isExpanded = true;

                } else {
                    getBusinessObject(shape).di.isExpanded = false;
                }
            });

            this.postExecuted(['shape.toggleCollapse'], LOW_PRIORITY, function (e) {
                var shape = e.context.shape,
                    defaultSize = elementFactory._getDefaultSize(shape),
                    newBounds;

                if (shape.collapsed) {

                    // resize to default size of collapsed shapes
                    newBounds = collapsedBounds(shape, defaultSize);
                } else {

                    // resize to bounds of max(visible children, defaultSize)
                    newBounds = expandedBounds(shape, defaultSize);
                }

                modeling.resizeShape(shape, newBounds);
            });

        }


        inherits(ToggleElementCollapseBehaviour, CommandInterceptor);

        ToggleElementCollapseBehaviour.$inject = [
            'eventBus',
            'elementFactory',
            'modeling'
        ];

        module.exports = ToggleElementCollapseBehaviour;



        /////// helpers ///////////////////////////

        function filterVisible(elements) {
            return elements.filter(function (e) {
                return !e.hidden;
            });
        }
    }, { "../../../util/ModelUtil": 95, "diagram-js/lib/command/CommandInterceptor": 119, "diagram-js/lib/features/resize/ResizeUtil": 223, "inherits": 289 }], 50: [function (require, module, exports) {
        'use strict';

        var forEach = require('lodash/collection/forEach');

        var inherits = require('inherits');

        var CommandInterceptor = require('diagram-js/lib/command/CommandInterceptor');

        function UnclaimIdBehavior(eventBus, modeling) {

            CommandInterceptor.call(this, eventBus);

            this.preExecute('elements.delete', function (event) {
                var context = event.context,
                    elements = context.elements;

                forEach(elements, function (element) {
                    modeling.unclaimId(element.businessObject.id, element.businessObject);
                });

            });
        }

        inherits(UnclaimIdBehavior, CommandInterceptor);

        UnclaimIdBehavior.$inject = ['eventBus', 'modeling'];

        module.exports = UnclaimIdBehavior;
    }, { "diagram-js/lib/command/CommandInterceptor": 119, "inherits": 289, "lodash/collection/forEach": 304 }], 51: [function (require, module, exports) {
        'use strict';

        var inherits = require('inherits');

        var CommandInterceptor = require('diagram-js/lib/command/CommandInterceptor');

        var is = require('../../../util/ModelUtil').is,
            getBusinessObject = require('../../../util/ModelUtil').getBusinessObject;

        /**
         * A behavior that unsets the Default property of
         * sequence flow source on element delete, if the
         * removed element is the Gateway or Task's default flow.
         *
         * @param {EventBus} eventBus
         * @param {Modeling} modeling
         */
        function DeleteSequenceFlowBehavior(eventBus, modeling) {

            CommandInterceptor.call(this, eventBus);


            this.preExecute('connection.delete', function (event) {
                var context = event.context,
                    connection = context.connection,
                    source = connection.source;

                if (isDefaultFlow(connection, source)) {
                    modeling.updateProperties(source, {
                        'default': null
                    });
                }
            });
        }

        inherits(DeleteSequenceFlowBehavior, CommandInterceptor);

        DeleteSequenceFlowBehavior.$inject = ['eventBus', 'modeling'];

        module.exports = DeleteSequenceFlowBehavior;


        /////// helpers ///////////////////////////

        function isDefaultFlow(connection, source) {

            if (!is(connection, 'bpmn:SequenceFlow')) {
                return false;
            }

            var sourceBo = getBusinessObject(source),
                sequenceFlow = getBusinessObject(connection);

            return sourceBo.get('default') === sequenceFlow;
        }
    }, { "../../../util/ModelUtil": 95, "diagram-js/lib/command/CommandInterceptor": 119, "inherits": 289 }], 52: [function (require, module, exports) {
        'use strict';


        var inherits = require('inherits');

        var CommandInterceptor = require('diagram-js/lib/command/CommandInterceptor');

        var is = require('../../../util/ModelUtil').is;

        var LOW_PRIORITY = 500,
            HIGH_PRIORITY = 5000;


        /**
         * BPMN specific delete lane behavior
         */
        function UpdateFlowNodeRefsBehavior(eventBus, modeling, translate) {

            CommandInterceptor.call(this, eventBus);

            /**
             * Ok, this is it:
             *
             * We have to update the Lane#flowNodeRefs _and_
             * FlowNode#lanes with every FlowNode move/resize and
             * Lane move/resize.
             *
             * We want to group that stuff to recompute containments
             * as efficient as possible.
             *
             * Yea!
             */

            // the update context
            var context;


            function initContext() {
                context = context || new UpdateContext();
                context.enter();

                return context;
            }

            function getContext() {
                if (!context) {
                    throw new Error(translate('out of bounds release'));
                }

                return context;
            }

            function releaseContext() {

                if (!context) {
                    throw new Error(translate('out of bounds release'));
                }

                var triggerUpdate = context.leave();

                if (triggerUpdate) {
                    modeling.updateLaneRefs(context.flowNodes, context.lanes);

                    context = null;
                }

                return triggerUpdate;
            }


            var laneRefUpdateEvents = [
                'spaceTool',
                'lane.add',
                'lane.resize',
                'lane.split',
                'elements.move',
                'elements.delete',
                'shape.create',
                'shape.delete',
                'shape.move',
                'shape.resize'
            ];


            // listen to a lot of stuff to group lane updates

            this.preExecute(laneRefUpdateEvents, HIGH_PRIORITY, function (event) {
                initContext();
            });

            this.postExecuted(laneRefUpdateEvents, LOW_PRIORITY, function (event) {
                releaseContext();
            });


            // Mark flow nodes + lanes that need an update

            this.preExecute([
                'shape.create',
                'shape.move',
                'shape.delete',
                'shape.resize'
            ], function (event) {

                var context = event.context,
                    shape = context.shape;

                var updateContext = getContext();

                // no need to update labels
                if (shape.labelTarget) {
                    return;
                }

                if (is(shape, 'bpmn:Lane')) {
                    updateContext.addLane(shape);
                }

                if (is(shape, 'bpmn:FlowNode')) {
                    updateContext.addFlowNode(shape);
                }
            });
        }

        UpdateFlowNodeRefsBehavior.$inject = ['eventBus', 'modeling', 'translate'];

        inherits(UpdateFlowNodeRefsBehavior, CommandInterceptor);

        module.exports = UpdateFlowNodeRefsBehavior;



        function UpdateContext() {

            this.flowNodes = [];
            this.lanes = [];

            this.counter = 0;

            this.addLane = function (lane) {
                this.lanes.push(lane);
            };

            this.addFlowNode = function (flowNode) {
                this.flowNodes.push(flowNode);
            };

            this.enter = function () {
                this.counter++;
            };

            this.leave = function () {
                this.counter--;

                return !this.counter;
            };
        }
    }, { "../../../util/ModelUtil": 95, "diagram-js/lib/command/CommandInterceptor": 119, "inherits": 289 }], 53: [function (require, module, exports) {
        module.exports = {
            __init__: [
                'appendBehavior',
                'copyPasteBehavior',
                'createBoundaryEventBehavior',
                'createDataObjectBehavior',
                'dropOnFlowBehavior',
                'createParticipantBehavior',
                'dataInputAssociationBehavior',
                'deleteLaneBehavior',
                'importDockingFix',
                'labelBehavior',
                'modelingFeedback',
                'removeParticipantBehavior',
                'replaceConnectionBehavior',
                'replaceElementBehaviour',
                'resizeLaneBehavior',
                'unsetDefaultFlowBehavior',
                'updateFlowNodeRefsBehavior',
                'removeElementBehavior',
                'unclaimIdBehavior',
                'toggleElementCollapseBehaviour'
            ],
            appendBehavior: ['type', require('./AppendBehavior')],
            copyPasteBehavior: ['type', require('./CopyPasteBehavior')],
            createBoundaryEventBehavior: ['type', require('./CreateBoundaryEventBehavior')],
            createDataObjectBehavior: ['type', require('./CreateDataObjectBehavior')],
            dropOnFlowBehavior: ['type', require('./DropOnFlowBehavior')],
            createParticipantBehavior: ['type', require('./CreateParticipantBehavior')],
            dataInputAssociationBehavior: ['type', require('./DataInputAssociationBehavior')],
            deleteLaneBehavior: ['type', require('./DeleteLaneBehavior')],
            importDockingFix: ['type', require('./ImportDockingFix')],
            labelBehavior: ['type', require('./LabelBehavior')],
            modelingFeedback: ['type', require('./ModelingFeedback')],
            removeParticipantBehavior: ['type', require('./RemoveParticipantBehavior')],
            replaceConnectionBehavior: ['type', require('./ReplaceConnectionBehavior')],
            replaceElementBehaviour: ['type', require('./ReplaceElementBehaviour')],
            resizeLaneBehavior: ['type', require('./ResizeLaneBehavior')],
            unsetDefaultFlowBehavior: ['type', require('./UnsetDefaultFlowBehavior')],
            updateFlowNodeRefsBehavior: ['type', require('./UpdateFlowNodeRefsBehavior')],
            removeElementBehavior: ['type', require('./RemoveElementBehavior')],
            unclaimIdBehavior: ['type', require('./UnclaimIdBehavior')],
            toggleElementCollapseBehaviour: ['type', require('./ToggleElementCollapseBehaviour')]
        };

    }, { "./AppendBehavior": 33, "./CopyPasteBehavior": 34, "./CreateBoundaryEventBehavior": 35, "./CreateDataObjectBehavior": 36, "./CreateParticipantBehavior": 37, "./DataInputAssociationBehavior": 38, "./DeleteLaneBehavior": 39, "./DropOnFlowBehavior": 40, "./ImportDockingFix": 41, "./LabelBehavior": 42, "./ModelingFeedback": 43, "./RemoveElementBehavior": 44, "./RemoveParticipantBehavior": 45, "./ReplaceConnectionBehavior": 46, "./ReplaceElementBehaviour": 47, "./ResizeLaneBehavior": 48, "./ToggleElementCollapseBehaviour": 49, "./UnclaimIdBehavior": 50, "./UnsetDefaultFlowBehavior": 51, "./UpdateFlowNodeRefsBehavior": 52 }], 54: [function (require, module, exports) {
        'use strict';

        /**
         * Returns the length of a vector
         *
         * @param {Vector}
         * @return {Float}
         */
        function vectorLength(v) {
            return Math.sqrt(Math.pow(v.x, 2) + Math.pow(v.y, 2));
        }

        module.exports.vectorLength = vectorLength;

        /**
         * Calculates the angle between a line a the yAxis
         *
         * @param {Array}
         * @return {Float}
         */
        function getAngle(line) {
            // return value is between 0, 180 and -180, -0
            // @janstuemmel: maybe replace return a/b with b/a
            return Math.atan((line[1].y - line[0].y) / (line[1].x - line[0].x));
        }

        module.exports.getAngle = getAngle;

        /**
         * Rotates a vector by a given angle
         *
         * @param {Vector}
         * @param {Float} Angle in radians
         * @return {Vector}
         */
        function rotateVector(vector, angle) {
            return (!angle) ? vector : {
                x: Math.cos(angle) * vector.x - Math.sin(angle) * vector.y,
                y: Math.sin(angle) * vector.x + Math.cos(angle) * vector.y
            };
        }

        module.exports.rotateVector = rotateVector;

        /**
         * Solves a 2D equation system
         * a + r*b = c, where a,b,c are 2D vectors
         *
         * @param {Vector}
         * @param {Vector}
         * @param {Vector}
         * @return {Float}
         */
        function solveLambaSystem(a, b, c) {

            // the 2d system
            var system = [
                { n: a[0] - c[0], lambda: b[0] },
                { n: a[1] - c[1], lambda: b[1] }
            ];

            // solve
            var n = system[0].n * b[0] + system[1].n * b[1],
                l = system[0].lambda * b[0] + system[1].lambda * b[1];

            return -n / l;
        }

        /**
         * Position of perpendicular foot
         *
         * @param {Point}
         * @param [ {Point}, {Point} ] line defined throug two points
         * @return {Point} the perpendicular foot position
         */
        function perpendicularFoot(point, line) {

            var a = line[0], b = line[1];

            // relative position of b from a
            var bd = { x: b.x - a.x, y: b.y - a.y };

            // solve equation system to the parametrized vectors param real value
            var r = solveLambaSystem([a.x, a.y], [bd.x, bd.y], [point.x, point.y]);

            return { x: a.x + r * bd.x, y: a.y + r * bd.y };

        }

        module.exports.perpendicularFoot = perpendicularFoot;

        /**
         * Calculates the distance between a point and a line
         *
         * @param {Point}
         * @param [ {Point}, {Point} ] line defined throug two points
         * @return {Float} distance
         */
        function getDistancePointLine(point, line) {

            var pfPoint = perpendicularFoot(point, line);

            // distance vector
            var connectionVector = {
                x: pfPoint.x - point.x,
                y: pfPoint.y - point.y
            };

            return vectorLength(connectionVector);
        }

        module.exports.getDistancePointLine = getDistancePointLine;

        /**
         * Calculates the distance between two points
         *
         * @param {Point}
         * @param {Point}
         * @return {Float} distance
         */
        function getDistancePointPoint(point1, point2) {

            return vectorLength({
                x: point1.x - point2.x,
                y: point1.y - point2.y
            });
        }

        module.exports.getDistancePointPoint = getDistancePointPoint;

    }, {}], 55: [function (require, module, exports) {
        'use strict';

        var GeometricUtil = require('./GeometricUtil');

        var getDistancePointPoint = require('./GeometricUtil').getDistancePointPoint;

        var getAttachment = require('./LineAttachmentUtil').getAttachment;


        function findNewLabelLineStartIndex(oldWaypoints, newWaypoints, attachment, hints) {

            var index = attachment.segmentIndex;

            var offset = newWaypoints.length - oldWaypoints.length;

            // segmentMove happend
            if (hints.segmentMove) {

                var oldSegmentStartIndex = hints.segmentMove.segmentStartIndex,
                    newSegmentStartIndex = hints.segmentMove.newSegmentStartIndex;

                // if label was on moved segment return new segment index
                if (index === oldSegmentStartIndex) {
                    return newSegmentStartIndex;
                }

                // label is after new segment index
                if (index >= newSegmentStartIndex) {
                    return (index + offset < newSegmentStartIndex) ? newSegmentStartIndex : index + offset;
                }

                // if label is before new segment index
                return index;
            }

            // bendpointMove happend
            if (hints.bendpointMove) {

                var insert = hints.bendpointMove.insert,
                    bendpointIndex = hints.bendpointMove.bendpointIndex,
                    newIndex;

                // waypoints length didnt change
                if (offset === 0) {
                    return index;
                }

                // label behind new/removed bendpoint
                if (index >= bendpointIndex) {
                    newIndex = insert ? index + 1 : index - 1;
                }

                // label before new/removed bendpoint
                if (index < bendpointIndex) {

                    newIndex = index;

                    // decide label should take right or left segment
                    if (insert && attachment.type !== 'bendpoint' && bendpointIndex - 1 === index) {

                        var rel = relativePositionMidWaypoint(newWaypoints, bendpointIndex);

                        if (rel < attachment.relativeLocation) {
                            newIndex++;
                        }
                    }
                }

                return newIndex;
            }

            // start/end changed
            if (offset === 0) {
                return index;
            }

            if (hints.connectionStart) {
                return (index === 0) ? 0 : null;
            }

            if (hints.connectionEnd) {
                return (index === oldWaypoints.length - 2) ? newWaypoints.length - 2 : null;
            }

            // if nothing fits, return null
            return null;
        }

        module.exports.findNewLabelLineStartIndex = findNewLabelLineStartIndex;


        /**
         * Calculate the required adjustment (move delta) for the given label
         * after the connection waypoints got updated.
         *
         * @param {djs.model.Label} label
         * @param {Array<Point>} newWaypoints
         * @param {Array<Point>} oldWaypoints
         * @param {Object} hints
         *
         * @return {Point} delta
         */
        function getLabelAdjustment(label, newWaypoints, oldWaypoints, hints) {

            var x = 0,
                y = 0;

            var labelPosition = getLabelMid(label);

            // get closest attachment
            var attachment = getAttachment(labelPosition, oldWaypoints),
                oldLabelLineIndex = attachment.segmentIndex,
                newLabelLineIndex = findNewLabelLineStartIndex(oldWaypoints, newWaypoints, attachment, hints);

            if (newLabelLineIndex === null) {
                return { x: x, y: y };
            }

            // should never happen
            // TODO(@janstuemmel): throw an error here when connectionSegmentMove is refactored
            if (newLabelLineIndex < 0 ||
                newLabelLineIndex > newWaypoints.length - 2) {
                return { x: x, y: y };
            }

            var oldLabelLine = getLine(oldWaypoints, oldLabelLineIndex),
                newLabelLine = getLine(newWaypoints, newLabelLineIndex),
                oldFoot = attachment.position;

            var relativeFootPosition = getRelativeFootPosition(oldLabelLine, oldFoot),
                angleDelta = getAngleDelta(oldLabelLine, newLabelLine);

            // special rule if label on bendpoint
            if (attachment.type === 'bendpoint') {

                var offset = newWaypoints.length - oldWaypoints.length,
                    oldBendpointIndex = attachment.bendpointIndex,
                    oldBendpoint = oldWaypoints[oldBendpointIndex];

                // bendpoint position hasnt changed, return same position
                if (newWaypoints.indexOf(oldBendpoint) !== -1) {
                    return { x: x, y: y };
                }

                // new bendpoint and old bendpoint have same index, then just return the offset
                if (offset === 0) {
                    var newBendpoint = newWaypoints[oldBendpointIndex];

                    return {
                        x: newBendpoint.x - attachment.position.x,
                        y: newBendpoint.y - attachment.position.y
                    };
                }

                // if bendpoints get removed
                if (offset < 0 && oldBendpointIndex !== 0 && oldBendpointIndex < oldWaypoints.length - 1) {
                    relativeFootPosition = relativePositionMidWaypoint(oldWaypoints, oldBendpointIndex);
                }
            }

            var newFoot = {
                x: (newLabelLine[1].x - newLabelLine[0].x) * relativeFootPosition + newLabelLine[0].x,
                y: (newLabelLine[1].y - newLabelLine[0].y) * relativeFootPosition + newLabelLine[0].y
            };

            // the rotated vector to label
            var newLabelVector = GeometricUtil.rotateVector({
                x: labelPosition.x - oldFoot.x,
                y: labelPosition.y - oldFoot.y
            }, angleDelta);

            // the new relative position
            x = newFoot.x + newLabelVector.x - labelPosition.x;
            y = newFoot.y + newLabelVector.y - labelPosition.y;

            return { x: x, y: y };
        }

        module.exports.getLabelAdjustment = getLabelAdjustment;


        //// HELPERS ///////

        function relativePositionMidWaypoint(waypoints, idx) {

            var distanceSegment1 = getDistancePointPoint(waypoints[idx - 1], waypoints[idx]),
                distanceSegment2 = getDistancePointPoint(waypoints[idx], waypoints[idx + 1]);

            var relativePosition = distanceSegment1 / (distanceSegment1 + distanceSegment2);

            return relativePosition;

        }

        function getLabelMid(label) {
            return {
                x: label.x + label.width / 2,
                y: label.y + label.height / 2
            };
        }

        function getAngleDelta(l1, l2) {
            var a1 = GeometricUtil.getAngle(l1),
                a2 = GeometricUtil.getAngle(l2);
            return a2 - a1;
        }

        function getLine(waypoints, idx) {
            return [waypoints[idx], waypoints[idx + 1]];
        }

        function getRelativeFootPosition(line, foot) {

            var length = getDistancePointPoint(line[0], line[1]),
                lengthToFoot = getDistancePointPoint(line[0], foot);

            return length === 0 ? 0 : lengthToFoot / length;
        }

    }, { "./GeometricUtil": 54, "./LineAttachmentUtil": 56 }], 56: [function (require, module, exports) {
        'use strict';

        var sqrt = Math.sqrt,
            min = Math.min,
            max = Math.max,
            abs = Math.abs;

        /**
         * Calculate the square (power to two) of a number.
         *
         * @param {Number} n
         *
         * @return {Number}
         */
        function sq(n) {
            return Math.pow(n, 2);
        }

        /**
         * Get distance between two points.
         *
         * @param {Point} p1
         * @param {Point} p2
         *
         * @return {Number}
         */
        function getDistance(p1, p2) {
            return sqrt(sq(p1.x - p2.x) + sq(p1.y - p2.y));
        }

        /**
         * Return the attachment of the given point on the specified line.
         *
         * The attachment is either a bendpoint (attached to the given point)
         * or segment (attached to a location on a line segment) attachment:
         *
         * ```javascript
         * var pointAttachment = {
         *   type: 'bendpoint',
         *   bendpointIndex: 3,
         *   position: { x: 10, y: 10 } // the attach point on the line
         * };
         *
         * var segmentAttachment = {
         *   type: 'segment',
         *   segmentIndex: 2,
         *   relativeLocation: 0.31, // attach point location between 0 (at start) and 1 (at end)
         *   position: { x: 10, y: 10 } // the attach point on the line
         * };
         * ```
         *
         * @param {Point} point
         * @param {Array<Point>} line
         *
         * @return {Object} attachment
         */
        function getAttachment(point, line) {

            var idx = 0,
                segmentStart,
                segmentEnd,
                segmentStartDistance,
                segmentEndDistance,
                attachmentPosition,
                minDistance,
                intersections,
                attachment,
                attachmentDistance,
                closestAttachmentDistance,
                closestAttachment;

            for (idx = 0; idx < line.length - 1; idx++) {

                segmentStart = line[idx];
                segmentEnd = line[idx + 1];

                if (pointsEqual(segmentStart, segmentEnd)) {
                    intersections = [segmentStart];
                } else {
                    segmentStartDistance = getDistance(point, segmentStart);
                    segmentEndDistance = getDistance(point, segmentEnd);

                    minDistance = min(segmentStartDistance, segmentEndDistance);

                    intersections = getCircleSegmentIntersections(segmentStart, segmentEnd, point, minDistance);
                }

                if (intersections.length < 1) {
                    throw new Error('expected between [1, 2] circle -> line intersections');
                }

                // one intersection -> bendpoint attachment
                if (intersections.length === 1) {
                    attachment = {
                        type: 'bendpoint',
                        position: intersections[0],
                        segmentIndex: idx,
                        bendpointIndex: pointsEqual(segmentStart, intersections[0]) ? idx : idx + 1
                    };
                }

                // two intersections -> segment attachment
                if (intersections.length === 2) {

                    attachmentPosition = mid(intersections[0], intersections[1]);

                    attachment = {
                        type: 'segment',
                        position: attachmentPosition,
                        segmentIndex: idx,
                        relativeLocation: getDistance(segmentStart, attachmentPosition) / getDistance(segmentStart, segmentEnd)
                    };
                }

                attachmentDistance = getDistance(attachment.position, point);

                if (!closestAttachment || closestAttachmentDistance > attachmentDistance) {
                    closestAttachment = attachment;
                    closestAttachmentDistance = attachmentDistance;
                }
            }

            return closestAttachment;
        }

        module.exports.getAttachment = getAttachment;

        /**
         * Gets the intersection between a circle and a line segment.
         *
         * @param {Point} s1 segment start
         * @param {Point} s2 segment end
         * @param {Point} cc circle center
         * @param {Number} cr circle radius
         *
         * @return {Array<Point>} intersections
         */
        function getCircleSegmentIntersections(s1, s2, cc, cr) {

            var baX = s2.x - s1.x;
            var baY = s2.y - s1.y;
            var caX = cc.x - s1.x;
            var caY = cc.y - s1.y;

            var a = baX * baX + baY * baY;
            var bBy2 = baX * caX + baY * caY;
            var c = caX * caX + caY * caY - cr * cr;

            var pBy2 = bBy2 / a;
            var q = c / a;

            var disc = pBy2 * pBy2 - q;

            // check against negative value to work around
            // negative, very close to zero results (-4e-15)
            // being produced in some environments
            if (disc < 0 && disc > -0.000001) {
                disc = 0;
            }

            if (disc < 0) {
                return [];
            }

            // if disc == 0 ... dealt with later
            var tmpSqrt = sqrt(disc);
            var abScalingFactor1 = -pBy2 + tmpSqrt;
            var abScalingFactor2 = -pBy2 - tmpSqrt;

            var i1 = {
                x: s1.x - baX * abScalingFactor1,
                y: s1.y - baY * abScalingFactor1
            };

            if (disc === 0) { // abScalingFactor1 == abScalingFactor2
                return [i1];
            }

            var i2 = {
                x: s1.x - baX * abScalingFactor2,
                y: s1.y - baY * abScalingFactor2
            };

            // return only points on line segment
            return [i1, i2].filter(function (p) {
                return isPointInSegment(p, s1, s2);
            });
        }


        function isPointInSegment(p, segmentStart, segmentEnd) {
            return (
                fenced(p.x, segmentStart.x, segmentEnd.x) &&
                fenced(p.y, segmentStart.y, segmentEnd.y)
            );
        }

        function fenced(n, rangeStart, rangeEnd) {

            // use matching threshold to work around
            // precisison errors in intersection computation

            return (
                n >= min(rangeStart, rangeEnd) - EQUAL_THRESHOLD &&
                n <= max(rangeStart, rangeEnd) + EQUAL_THRESHOLD
            );
        }

        /**
         * Calculate mid of two points.
         *
         * @param {Point} p1
         * @param {Point} p2
         *
         * @return {Point}
         */
        function mid(p1, p2) {

            return {
                x: (p1.x + p2.x) / 2,
                y: (p1.y + p2.y) / 2
            };
        }

        var EQUAL_THRESHOLD = 0.1;

        function pointsEqual(p1, p2) {

            return (
                abs(p1.x - p2.x) <= EQUAL_THRESHOLD &&
                abs(p1.y - p2.y) <= EQUAL_THRESHOLD
            );
        }

    }, {}], 57: [function (require, module, exports) {
        'use strict';

        /**
         * Returns the intersection between two line segments a and b.
         *
         * @param {Point} l1s
         * @param {Point} l1e
         * @param {Point} l2s
         * @param {Point} l2e
         *
         * @return {Point}
         */
        module.exports = function lineIntersect(l1s, l1e, l2s, l2e) {
            // if the lines intersect, the result contains the x and y of the
            // intersection (treating the lines as infinite) and booleans for
            // whether line segment 1 or line segment 2 contain the point
            var denominator, a, b, c, numerator;

            denominator = ((l2e.y - l2s.y) * (l1e.x - l1s.x)) - ((l2e.x - l2s.x) * (l1e.y - l1s.y));

            if (denominator == 0) {
                return null;
            }

            a = l1s.y - l2s.y;
            b = l1s.x - l2s.x;
            numerator = ((l2e.x - l2s.x) * a) - ((l2e.y - l2s.y) * b);

            c = numerator / denominator;

            // if we cast these lines infinitely in
            // both directions, they intersect here
            return {
                x: Math.round(l1s.x + (c * (l1e.x - l1s.x))),
                y: Math.round(l1s.y + (c * (l1e.y - l1s.y)))
            };
        };
    }, {}], 58: [function (require, module, exports) {
        'use strict';

        var filter = require('lodash/collection/filter');

        var Elements = require('diagram-js/lib/util/Elements');

        var getLanesRoot = require('../util/LaneUtil').getLanesRoot,
            getChildLanes = require('../util/LaneUtil').getChildLanes,
            LANE_INDENTATION = require('../util/LaneUtil').LANE_INDENTATION;

        /**
         * A handler that allows us to add a new lane
         * above or below an existing one.
         *
         * @param {Modeling} modeling
         */
        function AddLaneHandler(modeling, spaceTool) {
            this._modeling = modeling;
            this._spaceTool = spaceTool;
        }

        AddLaneHandler.$inject = ['modeling', 'spaceTool'];

        module.exports = AddLaneHandler;


        AddLaneHandler.prototype.preExecute = function (context) {

            var spaceTool = this._spaceTool,
                modeling = this._modeling;

            var shape = context.shape,
                location = context.location;

            var lanesRoot = getLanesRoot(shape);

            var isRoot = lanesRoot === shape,
                laneParent = isRoot ? shape : shape.parent;

            var existingChildLanes = getChildLanes(laneParent);

            // (0) add a lane if we currently got none and are adding to root
            if (!existingChildLanes.length) {
                modeling.createShape({ type: 'bpmn:Lane' }, {
                    x: shape.x + LANE_INDENTATION,
                    y: shape.y,
                    width: shape.width - LANE_INDENTATION,
                    height: shape.height
                }, laneParent);
            }

            // (1) collect affected elements to create necessary space
            var allAffected = [];

            Elements.eachElement(lanesRoot, function (element) {
                allAffected.push(element);

                if (element === shape) {
                    return [];
                }

                return filter(element.children, function (c) {
                    return c !== shape;
                });
            });

            var offset = location === 'top' ? -120 : 120,
                lanePosition = location === 'top' ? shape.y : shape.y + shape.height,
                spacePos = lanePosition + (location === 'top' ? 10 : -10),
                direction = location === 'top' ? 'n' : 's';

            var adjustments = spaceTool.calculateAdjustments(allAffected, 'y', offset, spacePos);

            spaceTool.makeSpace(adjustments.movingShapes, adjustments.resizingShapes, { x: 0, y: offset }, direction);

            // (2) create new lane at open space
            context.newLane = modeling.createShape({ type: 'bpmn:Lane' }, {
                x: shape.x + (isRoot ? LANE_INDENTATION : 0),
                y: lanePosition - (location === 'top' ? 120 : 0),
                width: shape.width - (isRoot ? LANE_INDENTATION : 0),
                height: 120
            }, laneParent);
        };

    }, { "../util/LaneUtil": 67, "diagram-js/lib/util/Elements": 266, "lodash/collection/filter": 302 }], 59: [function (require, module, exports) {
        'use strict';


        function IdClaimHandler(moddle) {
            this._moddle = moddle;
        }

        IdClaimHandler.$inject = ['moddle'];

        module.exports = IdClaimHandler;


        IdClaimHandler.prototype.execute = function (context) {
            var ids = this._moddle.ids,
                id = context.id,
                element = context.element,
                claiming = context.claiming;

            if (claiming) {
                ids.claim(id, element);
            } else {
                ids.unclaim(id);
            }
        };

        /**
         * Command revert implementation.
         */
        IdClaimHandler.prototype.revert = function (context) {
            var ids = this._moddle.ids,
                id = context.id,
                element = context.element,
                claiming = context.claiming;

            if (claiming) {
                ids.unclaim(id);
            } else {
                ids.claim(id, element);
            }
        };


    }, {}], 60: [function (require, module, exports) {
        'use strict';

        var is = require('../../../util/ModelUtil').is;

        var getLanesRoot = require('../util/LaneUtil').getLanesRoot,
            computeLanesResize = require('../util/LaneUtil').computeLanesResize;

        var eachElement = require('diagram-js/lib/util/Elements').eachElement;

        var asTRBL = require('diagram-js/lib/layout/LayoutUtil').asTRBL,
            substractTRBL = require('diagram-js/lib/features/resize/ResizeUtil').substractTRBL;


        /**
         * A handler that resizes a lane.
         *
         * @param {Modeling} modeling
         */
        function ResizeLaneHandler(modeling, spaceTool) {
            this._modeling = modeling;
            this._spaceTool = spaceTool;
        }

        ResizeLaneHandler.$inject = ['modeling', 'spaceTool'];

        module.exports = ResizeLaneHandler;


        ResizeLaneHandler.prototype.preExecute = function (context) {

            var shape = context.shape,
                newBounds = context.newBounds,
                balanced = context.balanced;

            if (balanced !== false) {
                this.resizeBalanced(shape, newBounds);
            } else {
                this.resizeSpace(shape, newBounds);
            }
        };


        /**
         * Resize balanced, adjusting next / previous lane sizes.
         *
         * @param {djs.model.Shape} shape
         * @param {Bounds} newBounds
         */
        ResizeLaneHandler.prototype.resizeBalanced = function (shape, newBounds) {

            var modeling = this._modeling;

            var resizeNeeded = computeLanesResize(shape, newBounds);

            // resize the lane
            modeling.resizeShape(shape, newBounds);

            // resize other lanes as needed
            resizeNeeded.forEach(function (r) {
                modeling.resizeShape(r.shape, r.newBounds);
            });
        };


        /**
         * Resize, making actual space and moving below / above elements.
         *
         * @param {djs.model.Shape} shape
         * @param {Bounds} newBounds
         */
        ResizeLaneHandler.prototype.resizeSpace = function (shape, newBounds) {
            var spaceTool = this._spaceTool;

            var shapeTrbl = asTRBL(shape),
                newTrbl = asTRBL(newBounds);

            var trblDiff = substractTRBL(newTrbl, shapeTrbl);

            var lanesRoot = getLanesRoot(shape);

            var allAffected = [],
                allLanes = [];

            eachElement(lanesRoot, function (element) {
                allAffected.push(element);

                if (is(element, 'bpmn:Lane') || is(element, 'bpmn:Participant')) {
                    allLanes.push(element);
                }

                return element.children;
            });

            var change,
                spacePos,
                direction,
                offset,
                adjustments;

            if (trblDiff.bottom || trblDiff.top) {

                change = trblDiff.bottom || trblDiff.top;
                spacePos = shape.y + (trblDiff.bottom ? shape.height : 0) + (trblDiff.bottom ? -10 : 10);
                direction = trblDiff.bottom ? 's' : 'n';

                offset = trblDiff.top > 0 || trblDiff.bottom < 0 ? -change : change;

                adjustments = spaceTool.calculateAdjustments(allAffected, 'y', offset, spacePos);

                spaceTool.makeSpace(adjustments.movingShapes, adjustments.resizingShapes, { x: 0, y: change }, direction);
            }


            if (trblDiff.left || trblDiff.right) {

                change = trblDiff.right || trblDiff.left;
                spacePos = shape.x + (trblDiff.right ? shape.width : 0) + (trblDiff.right ? -10 : 100);
                direction = trblDiff.right ? 'e' : 'w';

                offset = trblDiff.left > 0 || trblDiff.right < 0 ? -change : change;

                adjustments = spaceTool.calculateAdjustments(allLanes, 'x', offset, spacePos);

                spaceTool.makeSpace(adjustments.movingShapes, adjustments.resizingShapes, { x: change, y: 0 }, direction);
            }
        };
    }, { "../../../util/ModelUtil": 95, "../util/LaneUtil": 67, "diagram-js/lib/features/resize/ResizeUtil": 223, "diagram-js/lib/layout/LayoutUtil": 252, "diagram-js/lib/util/Elements": 266 }], 61: [function (require, module, exports) {
        'use strict';

        var assign = require('lodash/object/assign'),
            forEach = require('lodash/collection/forEach');

        function SetColorHandler(commandStack) {
            this._commandStack = commandStack;
        }

        SetColorHandler.$inject = ['commandStack'];

        module.exports = SetColorHandler;

        SetColorHandler.prototype.postExecute = function (context) {
            var elements = context.elements,
                colors = context.colors || { fill: undefined, stroke: undefined };

            var that = this;

            var di = {};

            if ('fill' in colors) {
                assign(di, { fill: colors.fill });
            }

            if ('stroke' in colors) {
                assign(di, { stroke: colors.stroke });
            }

            forEach(elements, function (element) {
                that._commandStack.execute('element.updateProperties', {
                    element: element,
                    properties: {
                        di: di
                    }
                });
            });

        };

        SetColorHandler.prototype.execute = function (context) { };

        SetColorHandler.prototype.revert = function (context) { };

    }, { "lodash/collection/forEach": 304, "lodash/object/assign": 433 }], 62: [function (require, module, exports) {
        'use strict';

        var getChildLanes = require('../util/LaneUtil').getChildLanes;

        var LANE_INDENTATION = require('../util/LaneUtil').LANE_INDENTATION;

        /**
         * A handler that splits a lane into a number of sub-lanes,
         * creating new sub lanes, if neccessary.
         *
         * @param {Modeling} modeling
         */
        function SplitLaneHandler(modeling, translate) {
            this._modeling = modeling;
            this._translate = translate;
        }

        SplitLaneHandler.$inject = ['modeling', 'translate'];

        module.exports = SplitLaneHandler;


        SplitLaneHandler.prototype.preExecute = function (context) {

            var modeling = this._modeling,
                translate = this._translate;

            var shape = context.shape,
                newLanesCount = context.count;

            var childLanes = getChildLanes(shape),
                existingLanesCount = childLanes.length;

            if (existingLanesCount > newLanesCount) {
                throw new Error(translate('more than {count} child lanes', { count: newLanesCount }));
            }

            var newLanesHeight = Math.round(shape.height / newLanesCount);

            // Iterate from top to bottom in child lane order,
            // resizing existing lanes and creating new ones
            // so that they split the parent proportionally.
            //
            // Due to rounding related errors, the bottom lane
            // needs to take up all the remaining space.
            var laneY,
                laneHeight,
                laneBounds,
                newLaneAttrs,
                idx;

            for (idx = 0; idx < newLanesCount; idx++) {

                laneY = shape.y + idx * newLanesHeight;

                // if bottom lane
                if (idx === newLanesCount - 1) {
                    laneHeight = shape.height - (newLanesHeight * idx);
                } else {
                    laneHeight = newLanesHeight;
                }

                laneBounds = {
                    x: shape.x + LANE_INDENTATION,
                    y: laneY,
                    width: shape.width - LANE_INDENTATION,
                    height: laneHeight
                };

                if (idx < existingLanesCount) {
                    // resize existing lane
                    modeling.resizeShape(childLanes[idx], laneBounds);
                } else {
                    // create a new lane at position
                    newLaneAttrs = {
                        type: 'bpmn:Lane'
                    };

                    modeling.createShape(newLaneAttrs, laneBounds, shape);
                }
            }
        };

    }, { "../util/LaneUtil": 67 }], 63: [function (require, module, exports) {
        'use strict';

        var Collections = require('diagram-js/lib/util/Collections');


        function UpdateCanvasRootHandler(canvas, modeling) {
            this._canvas = canvas;
            this._modeling = modeling;
        }

        UpdateCanvasRootHandler.$inject = ['canvas', 'modeling'];

        module.exports = UpdateCanvasRootHandler;


        UpdateCanvasRootHandler.prototype.execute = function (context) {

            var canvas = this._canvas;

            var newRoot = context.newRoot,
                newRootBusinessObject = newRoot.businessObject,
                oldRoot = canvas.getRootElement(),
                oldRootBusinessObject = oldRoot.businessObject,
                bpmnDefinitions = oldRootBusinessObject.$parent,
                diPlane = oldRootBusinessObject.di;

            // (1) replace process old <> new root
            canvas.setRootElement(newRoot, true);

            // (2) update root elements
            Collections.add(bpmnDefinitions.rootElements, newRootBusinessObject);
            newRootBusinessObject.$parent = bpmnDefinitions;

            Collections.remove(bpmnDefinitions.rootElements, oldRootBusinessObject);
            oldRootBusinessObject.$parent = null;

            // (3) wire di
            oldRootBusinessObject.di = null;

            diPlane.bpmnElement = newRootBusinessObject;
            newRootBusinessObject.di = diPlane;

            context.oldRoot = oldRoot;

            // TODO(nikku): return changed elements?
            // return [ newRoot, oldRoot ];
        };


        UpdateCanvasRootHandler.prototype.revert = function (context) {

            var canvas = this._canvas;

            var newRoot = context.newRoot,
                newRootBusinessObject = newRoot.businessObject,
                oldRoot = context.oldRoot,
                oldRootBusinessObject = oldRoot.businessObject,
                bpmnDefinitions = newRootBusinessObject.$parent,
                diPlane = newRootBusinessObject.di;

            // (1) replace process old <> new root
            canvas.setRootElement(oldRoot, true);

            // (2) update root elements
            Collections.remove(bpmnDefinitions.rootElements, newRootBusinessObject);
            newRootBusinessObject.$parent = null;

            Collections.add(bpmnDefinitions.rootElements, oldRootBusinessObject);
            oldRootBusinessObject.$parent = bpmnDefinitions;

            // (3) wire di
            newRootBusinessObject.di = null;

            diPlane.bpmnElement = oldRootBusinessObject;
            oldRootBusinessObject.di = diPlane;

            // TODO(nikku): return changed elements?
            // return [ newRoot, oldRoot ];
        };
    }, { "diagram-js/lib/util/Collections": 263 }], 64: [function (require, module, exports) {
        'use strict';

        var collectLanes = require('../util/LaneUtil').collectLanes;

        var getLanesRoot = require('../util/LaneUtil').getLanesRoot;

        var is = require('../../../util/ModelUtil').is;

        var Collections = require('diagram-js/lib/util/Collections');

        var asTRBL = require('diagram-js/lib/layout/LayoutUtil').asTRBL;

        var FLOW_NODE_REFS_ATTR = 'flowNodeRef',
            LANES_ATTR = 'lanes';

        /**
         * A handler that updates lane refs on changed elements
         */
        function UpdateFlowNodeRefsHandler(elementRegistry) {
            this._elementRegistry = elementRegistry;
        }

        UpdateFlowNodeRefsHandler.$inject = ['elementRegistry'];

        module.exports = UpdateFlowNodeRefsHandler;


        UpdateFlowNodeRefsHandler.prototype.computeUpdates = function (flowNodeShapes, laneShapes) {

            var handledNodes = {};

            var updates = [];

            var participantCache = {};

            var allFlowNodeShapes = [];

            function isInLaneShape(element, laneShape) {

                var laneTrbl = asTRBL(laneShape);

                var elementMid = {
                    x: element.x + element.width / 2,
                    y: element.y + element.height / 2
                };

                return elementMid.x > laneTrbl.left &&
                    elementMid.x < laneTrbl.right &&
                    elementMid.y > laneTrbl.top &&
                    elementMid.y < laneTrbl.bottom;
            }

            function addFlowNodeShape(flowNodeShape) {
                if (!handledNodes[flowNodeShape.id]) {
                    allFlowNodeShapes.push(flowNodeShape);
                    handledNodes[flowNodeShape.id] = flowNodeShape;
                }
            }

            function getAllLaneShapes(flowNodeShape) {

                var root = getLanesRoot(flowNodeShape);

                if (!participantCache[root.id]) {
                    participantCache[root.id] = collectLanes(root);
                }

                return participantCache[root.id];
            }

            function getNewLanes(flowNodeShape) {
                if (!flowNodeShape.parent) {
                    return [];
                }

                var allLaneShapes = getAllLaneShapes(flowNodeShape);

                return allLaneShapes.filter(function (l) {
                    return isInLaneShape(flowNodeShape, l);
                }).map(function (shape) {
                    return shape.businessObject;
                });
            }

            laneShapes.forEach(function (laneShape) {
                var root = getLanesRoot(laneShape);

                if (!root || handledNodes[root.id]) {
                    return;
                }

                var children = root.children.filter(function (c) {
                    return is(c, 'bpmn:FlowNode');
                });

                children.forEach(addFlowNodeShape);

                handledNodes[root.id] = root;
            });

            flowNodeShapes.forEach(addFlowNodeShape);


            allFlowNodeShapes.forEach(function (flowNodeShape) {

                var flowNode = flowNodeShape.businessObject;

                var lanes = flowNode.get(LANES_ATTR),
                    remove = lanes.slice(),
                    add = getNewLanes(flowNodeShape);

                updates.push({ flowNode: flowNode, remove: remove, add: add });
            });

            laneShapes.forEach(function (laneShape) {

                var lane = laneShape.businessObject;

                // lane got removed XX-)
                if (!laneShape.parent) {
                    lane.get(FLOW_NODE_REFS_ATTR).forEach(function (flowNode) {
                        updates.push({ flowNode: flowNode, remove: [lane], add: [] });
                    });
                }
            });

            return updates;
        };

        UpdateFlowNodeRefsHandler.prototype.execute = function (context) {

            var updates = context.updates;

            if (!updates) {
                updates = context.updates = this.computeUpdates(context.flowNodeShapes, context.laneShapes);
            }


            updates.forEach(function (update) {

                var flowNode = update.flowNode,
                    lanes = flowNode.get(LANES_ATTR);

                // unwire old
                update.remove.forEach(function (oldLane) {
                    Collections.remove(lanes, oldLane);
                    Collections.remove(oldLane.get(FLOW_NODE_REFS_ATTR), flowNode);
                });

                // wire new
                update.add.forEach(function (newLane) {
                    Collections.add(lanes, newLane);
                    Collections.add(newLane.get(FLOW_NODE_REFS_ATTR), flowNode);
                });
            });

            // TODO(nikku): return changed elements
            // return [ ... ];
        };


        UpdateFlowNodeRefsHandler.prototype.revert = function (context) {

            var updates = context.updates;

            updates.forEach(function (update) {

                var flowNode = update.flowNode,
                    lanes = flowNode.get(LANES_ATTR);

                // unwire new
                update.add.forEach(function (newLane) {
                    Collections.remove(lanes, newLane);
                    Collections.remove(newLane.get(FLOW_NODE_REFS_ATTR), flowNode);
                });

                // wire old
                update.remove.forEach(function (oldLane) {
                    Collections.add(lanes, oldLane);
                    Collections.add(oldLane.get(FLOW_NODE_REFS_ATTR), flowNode);
                });
            });

            // TODO(nikku): return changed elements
            // return [ ... ];
        };
    }, { "../../../util/ModelUtil": 95, "../util/LaneUtil": 67, "diagram-js/lib/layout/LayoutUtil": 252, "diagram-js/lib/util/Collections": 263 }], 65: [function (require, module, exports) {
        'use strict';

        var reduce = require('lodash/object/transform'),
            keys = require('lodash/object/keys'),
            forEach = require('lodash/collection/forEach'),
            assign = require('lodash/object/assign');

        var getBusinessObject = require('../../../util/ModelUtil').getBusinessObject;

        var TextUtil = require('diagram-js/lib/util/Text');

        var DEFAULT_FLOW = 'default',
            NAME = 'name',
            ID = 'id',
            DI = 'di';

        var NULL_DIMENSIONS = {
            width: 0,
            height: 0
        };

        /**
         * A handler that implements a BPMN 2.0 property update.
         *
         * This should be used to set simple properties on elements with
         * an underlying BPMN business object.
         *
         * Use respective diagram-js provided handlers if you would
         * like to perform automated modeling.
         */
        function UpdatePropertiesHandler(elementRegistry, moddle, translate, modeling) {
            this._elementRegistry = elementRegistry;
            this._moddle = moddle;
            this._translate = translate;
            this._modeling = modeling;

            this._textUtil = new TextUtil();
        }

        UpdatePropertiesHandler.$inject = ['elementRegistry', 'moddle', 'translate', 'modeling'];

        module.exports = UpdatePropertiesHandler;


        ////// api /////////////////////////////////////////////

        /**
         * Updates a BPMN element with a list of new properties
         *
         * @param {Object} context
         * @param {djs.model.Base} context.element the element to update
         * @param {Object} context.properties a list of properties to set on the element's
         *                                    businessObject (the BPMN model element)
         *
         * @return {Array<djs.model.Base>} the updated element
         */
        UpdatePropertiesHandler.prototype.execute = function (context) {

            var element = context.element,
                changed = [element],
                translate = this._translate;

            if (!element) {
                throw new Error(translate('element required'));
            }

            var elementRegistry = this._elementRegistry,
                ids = this._moddle.ids;

            var businessObject = element.businessObject,
                properties = unwrapBusinessObjects(context.properties),
                oldProperties = context.oldProperties || getProperties(businessObject, properties);

            if (isIdChange(properties, businessObject)) {
                ids.unclaim(businessObject[ID]);

                elementRegistry.updateId(element, properties[ID]);

                ids.claim(properties[ID], businessObject);
            }

            // correctly indicate visual changes on default flow updates
            if (DEFAULT_FLOW in properties) {

                if (properties[DEFAULT_FLOW]) {
                    changed.push(elementRegistry.get(properties[DEFAULT_FLOW].id));
                }

                if (businessObject[DEFAULT_FLOW]) {
                    changed.push(elementRegistry.get(businessObject[DEFAULT_FLOW].id));
                }
            }

            if (NAME in properties && element.label) {
                changed.push(element.label);

                // show the label
                element.label.hidden = !properties[NAME];
            }

            if (DI in properties && businessObject.di) {
                setDiProperties(businessObject.di, properties.di);
            }

            // update properties
            setProperties(businessObject, properties);

            // store old values
            context.oldProperties = oldProperties;
            context.changed = changed;

            // indicate changed on objects affected by the update
            return changed;
        };


        UpdatePropertiesHandler.prototype.postExecute = function (context) {
            var element = context.element,
                label = element.label;

            var text = label && getBusinessObject(label).name;

            if (!text) {
                return;
            }

            // get layouted text bounds and resize external
            // external label accordingly
            var newLabelBounds = getLayoutedBounds(label, text, this._textUtil);

            this._modeling.resizeShape(label, newLabelBounds, NULL_DIMENSIONS);
        };

        /**
         * Reverts the update on a BPMN elements properties.
         *
         * @param  {Object} context
         *
         * @return {djs.model.Base} the updated element
         */
        UpdatePropertiesHandler.prototype.revert = function (context) {

            var element = context.element,
                properties = context.properties,
                oldProperties = context.oldProperties,
                businessObject = element.businessObject,
                elementRegistry = this._elementRegistry,
                ids = this._moddle.ids;

            if (DI in oldProperties && businessObject.di) {
                setDiProperties(businessObject.di, oldProperties.di);
            }

            // update properties
            setProperties(businessObject, oldProperties);

            if (isIdChange(properties, businessObject)) {
                ids.unclaim(properties[ID]);

                elementRegistry.updateId(element, oldProperties[ID]);

                ids.claim(oldProperties[ID], businessObject);
            }

            return context.changed;
        };


        function isIdChange(properties, businessObject) {
            return ID in properties && properties[ID] !== businessObject[ID];
        }


        function getProperties(businessObject, properties) {
            var propertyNames = keys(properties);

            return reduce(propertyNames, function (result, key) {

                // handle DI seperately
                if (key !== DI) {
                    result[key] = businessObject.get(key);
                } else {
                    result[key] = getDiProperties(businessObject.di, keys(properties.di));
                }

                return result;
            }, {});
        }


        function getDiProperties(di, propertyNames) {
            return reduce(propertyNames, function (result, key) {
                result[key] = di.get(key);

                return result;
            }, {});
        }


        function setProperties(businessObject, properties) {
            forEach(properties, function (value, key) {
                businessObject.set(key, value);
            });
        }


        function setDiProperties(di, properties) {
            forEach(properties, function (value, key) {
                di.set(key, value);
            });
        }


        var referencePropertyNames = ['default'];

        /**
         * Make sure we unwrap the actual business object
         * behind diagram element that may have been
         * passed as arguments.
         *
         * @param  {Object} properties
         *
         * @return {Object} unwrappedProps
         */
        function unwrapBusinessObjects(properties) {

            var unwrappedProps = assign({}, properties);

            referencePropertyNames.forEach(function (name) {
                if (name in properties) {
                    unwrappedProps[name] = getBusinessObject(unwrappedProps[name]);
                }
            });

            return unwrappedProps;
        }


        // TODO(nikku): repeating code (search for <getLayoutedBounds>)

        var EXTERNAL_LABEL_STYLE = {
            fontFamily: 'Arial, sans-serif',
            fontSize: '11px'
        };

        function getLayoutedBounds(bounds, text, textUtil) {

            var layoutedLabelDimensions = textUtil.getDimensions(text, {
                box: {
                    width: 90,
                    height: 30,
                    x: bounds.width / 2 + bounds.x,
                    y: bounds.height / 2 + bounds.y
                },
                style: EXTERNAL_LABEL_STYLE
            });

            // resize label shape to fit label text
            return {
                x: Math.round(bounds.x + bounds.width / 2 - layoutedLabelDimensions.width / 2),
                y: Math.round(bounds.y),
                width: Math.ceil(layoutedLabelDimensions.width),
                height: Math.ceil(layoutedLabelDimensions.height)
            };
        }
    }, { "../../../util/ModelUtil": 95, "diagram-js/lib/util/Text": 280, "lodash/collection/forEach": 304, "lodash/object/assign": 433, "lodash/object/keys": 435, "lodash/object/transform": 441 }], 66: [function (require, module, exports) {
        module.exports = {
            __init__: ['modeling', 'bpmnUpdater'],
            __depends__: [
                require('./behavior'),
                require('../label-editing'),
                require('../rules'),
                require('../ordering'),
                require('../replace'),
                require('diagram-js/lib/command'),
                require('diagram-js/lib/features/tooltips'),
                require('diagram-js/lib/features/label-support'),
                require('diagram-js/lib/features/attach-support'),
                require('diagram-js/lib/features/selection'),
                require('diagram-js/lib/features/change-support'),
                require('diagram-js/lib/features/space-tool')
            ],
            bpmnFactory: ['type', require('./BpmnFactory')],
            bpmnUpdater: ['type', require('./BpmnUpdater')],
            elementFactory: ['type', require('./ElementFactory')],
            modeling: ['type', require('./Modeling')],
            layouter: ['type', require('./BpmnLayouter')],
            connectionDocking: ['type', require('diagram-js/lib/layout/CroppingConnectionDocking')]
        };

    }, { "../label-editing": 27, "../ordering": 70, "../replace": 80, "../rules": 82, "./BpmnFactory": 28, "./BpmnLayouter": 29, "./BpmnUpdater": 30, "./ElementFactory": 31, "./Modeling": 32, "./behavior": 53, "diagram-js/lib/command": 121, "diagram-js/lib/features/attach-support": 135, "diagram-js/lib/features/change-support": 147, "diagram-js/lib/features/label-support": 174, "diagram-js/lib/features/selection": 233, "diagram-js/lib/features/space-tool": 240, "diagram-js/lib/features/tooltips": 244, "diagram-js/lib/layout/CroppingConnectionDocking": 251 }], 67: [function (require, module, exports) {
        'use strict';

        var is = require('../../../util/ModelUtil').is;

        var getParent = require('./ModelingUtil').getParent;

        var asTRBL = require('diagram-js/lib/layout/LayoutUtil').asTRBL,
            substractTRBL = require('diagram-js/lib/features/resize/ResizeUtil').substractTRBL,
            resizeTRBL = require('diagram-js/lib/features/resize/ResizeUtil').resizeTRBL;

        var abs = Math.abs;


        function getTRBLResize(oldBounds, newBounds) {
            return substractTRBL(asTRBL(newBounds), asTRBL(oldBounds));
        }


        var LANE_PARENTS = [
            'bpmn:Participant',
            'bpmn:Process',
            'bpmn:SubProcess'
        ];

        var LANE_INDENTATION = 30;

        module.exports.LANE_INDENTATION = LANE_INDENTATION;


        /**
         * Collect all lane shapes in the given paren
         *
         * @param  {djs.model.Shape} shape
         * @param  {Array<djs.model.Base>} [collectedShapes]
         *
         * @return {Array<djs.model.Base>}
         */
        function collectLanes(shape, collectedShapes) {

            collectedShapes = collectedShapes || [];

            shape.children.filter(function (s) {
                if (is(s, 'bpmn:Lane')) {
                    collectLanes(s, collectedShapes);

                    collectedShapes.push(s);
                }
            });

            return collectedShapes;
        }

        module.exports.collectLanes = collectLanes;

        /**
         * Return the lane children of the given element.
         *
         * @param {djs.model.Shape} shape
         *
         * @return {Array<djs.model.Shape>}
         */
        function getChildLanes(shape) {
            return shape.children.filter(function (c) {
                return is(c, 'bpmn:Lane');
            });
        }

        module.exports.getChildLanes = getChildLanes;

        /**
         * Return the root element containing the given lane shape
         *
         * @param {djs.model.Shape} shape
         *
         * @return {djs.model.Shape}
         */
        function getLanesRoot(shape) {
            return getParent(shape, LANE_PARENTS) || shape;
        }

        module.exports.getLanesRoot = getLanesRoot;


        /**
         * Compute the required resize operations for lanes
         * adjacent to the given shape, assuming it will be
         * resized to the given new bounds.
         *
         * @param {djs.model.Shape} shape
         * @param {Bounds} newBounds
         *
         * @return {Array<Object>}
         */
        function computeLanesResize(shape, newBounds) {

            var rootElement = getLanesRoot(shape);

            var initialShapes = is(rootElement, 'bpmn:Process') ? [] : [rootElement];

            var allLanes = collectLanes(rootElement, initialShapes),
                shapeTrbl = asTRBL(shape),
                shapeNewTrbl = asTRBL(newBounds),
                trblResize = getTRBLResize(shape, newBounds),
                resizeNeeded = [];

            allLanes.forEach(function (other) {

                if (other === shape) {
                    return;
                }

                var topResize = 0,
                    rightResize = trblResize.right,
                    bottomResize = 0,
                    leftResize = trblResize.left;

                var otherTrbl = asTRBL(other);

                if (trblResize.top) {
                    if (abs(otherTrbl.bottom - shapeTrbl.top) < 10) {
                        bottomResize = shapeNewTrbl.top - otherTrbl.bottom;
                    }

                    if (abs(otherTrbl.top - shapeTrbl.top) < 5) {
                        topResize = shapeNewTrbl.top - otherTrbl.top;
                    }
                }

                if (trblResize.bottom) {
                    if (abs(otherTrbl.top - shapeTrbl.bottom) < 10) {
                        topResize = shapeNewTrbl.bottom - otherTrbl.top;
                    }

                    if (abs(otherTrbl.bottom - shapeTrbl.bottom) < 5) {
                        bottomResize = shapeNewTrbl.bottom - otherTrbl.bottom;
                    }
                }

                if (topResize || rightResize || bottomResize || leftResize) {

                    resizeNeeded.push({
                        shape: other,
                        newBounds: resizeTRBL(other, {
                            top: topResize,
                            right: rightResize,
                            bottom: bottomResize,
                            left: leftResize
                        })
                    });
                }

            });

            return resizeNeeded;
        }

        module.exports.computeLanesResize = computeLanesResize;

    }, { "../../../util/ModelUtil": 95, "./ModelingUtil": 68, "diagram-js/lib/features/resize/ResizeUtil": 223, "diagram-js/lib/layout/LayoutUtil": 252 }], 68: [function (require, module, exports) {
        'use strict';

        var any = require('lodash/collection/any');

        var is = require('../../../util/ModelUtil').is;


        /**
         * Return true if element has any of the given types.
         *
         * @param {djs.model.Base} element
         * @param {Array<String>} types
         *
         * @return {Boolean}
         */
        function isAny(element, types) {
            return any(types, function (t) {
                return is(element, t);
            });
        }

        module.exports.isAny = isAny;


        /**
         * Return the parent of the element with any of the given types.
         *
         * @param {djs.model.Base} element
         * @param {String|Array<String>} anyType
         *
         * @return {djs.model.Base}
         */
        function getParent(element, anyType) {

            if (typeof anyType === 'string') {
                anyType = [anyType];
            }

            while ((element = element.parent)) {
                if (isAny(element, anyType)) {
                    return element;
                }
            }

            return null;
        }

        module.exports.getParent = getParent;

    }, { "../../../util/ModelUtil": 95, "lodash/collection/any": 300 }], 69: [function (require, module, exports) {
        'use strict';

        var inherits = require('inherits');

        var OrderingProvider = require('diagram-js/lib/features/ordering/OrderingProvider');

        var isAny = require('../modeling/util/ModelingUtil').isAny;

        var findIndex = require('lodash/array/findIndex');

        var find = require('lodash/collection/find');


        /**
         * a simple ordering provider that makes sure:
         *
         * (1) elements are ordered by a {level} property
         * (2) elements with {alwaysOnTop} are always added to the root
         */
        function BpmnOrderingProvider(eventBus, translate) {

            OrderingProvider.call(this, eventBus);

            var orders = [
                { type: 'bpmn:SubProcess', order: { level: 6 } },
                {
                    type: 'bpmn:SequenceFlow',
                    order: {
                        level: 5,
                        containers: [
                            'bpmn:Participant',
                            'bpmn:FlowElementsContainer'
                        ]
                    }
                },
                // handle DataAssociation(s) like message flows and render them always on top
                { type: 'bpmn:DataAssociation', order: { level: 9, containers: ['bpmn:Collaboration', 'bpmn:Process'] } },
                { type: 'bpmn:MessageFlow', order: { level: 9, containers: ['bpmn:Collaboration'] } },
                {
                    type: 'bpmn:Association',
                    order: {
                        level: 6,
                        containers: [
                            'bpmn:Participant',
                            'bpmn:FlowElementsContainer',
                            'bpmn:Collaboration'
                        ]
                    }
                },
                { type: 'bpmn:BoundaryEvent', order: { level: 8 } },
                { type: 'bpmn:Participant', order: { level: -2 } },
                { type: 'bpmn:Lane', order: { level: -1 } }
            ];

            function computeOrder(element) {
                if (element.labelTarget) {
                    return { level: 10 };
                }

                var entry = find(orders, function (o) {
                    return isAny(element, [o.type]);
                });

                return entry && entry.order || { level: 1 };
            }

            function getOrder(element) {

                var order = element.order;

                if (!order) {
                    element.order = order = computeOrder(element);
                }

                return order;
            }

            function findActualParent(element, newParent, containers) {

                var actualParent = newParent;

                while (actualParent) {

                    if (isAny(actualParent, containers)) {
                        break;
                    }

                    actualParent = actualParent.parent;
                }

                if (!actualParent) {
                    throw new Error(translate('no parent for {element} in {parent}', {
                        element: element.id,
                        parent: newParent.id
                    }));
                }

                return actualParent;
            }

            this.getOrdering = function (element, newParent) {

                var elementOrder = getOrder(element);


                if (elementOrder.containers) {
                    newParent = findActualParent(element, newParent, elementOrder.containers);
                }


                var currentIndex = newParent.children.indexOf(element);

                var insertIndex = findIndex(newParent.children, function (child) {

                    // do not compare with labels, they are created
                    // in the wrong order (right after elements) during import and
                    // mess up the positioning.
                    if (!element.labelTarget && child.labelTarget) {
                        return false;
                    }

                    return elementOrder.level < getOrder(child).level;
                });


                // if the element is already in the child list at
                // a smaller index, we need to adjust the inser index.
                // this takes into account that the element is being removed
                // before being re-inserted
                if (insertIndex !== -1) {
                    if (currentIndex !== -1 && currentIndex < insertIndex) {
                        insertIndex -= 1;
                    }
                }

                return {
                    index: insertIndex,
                    parent: newParent
                };
            };
        }

        BpmnOrderingProvider.$inject = ['eventBus', 'translate'];

        inherits(BpmnOrderingProvider, OrderingProvider);

        module.exports = BpmnOrderingProvider;

    }, { "../modeling/util/ModelingUtil": 68, "diagram-js/lib/features/ordering/OrderingProvider": 207, "inherits": 289, "lodash/array/findIndex": 291, "lodash/collection/find": 303 }], 70: [function (require, module, exports) {
        module.exports = {
            __init__: ['bpmnOrderingProvider'],
            __depends__: [
                require('diagram-js/lib/i18n/translate')
            ],
            bpmnOrderingProvider: ['type', require('./BpmnOrderingProvider')]
        };
    }, { "./BpmnOrderingProvider": 69, "diagram-js/lib/i18n/translate": 248 }], 71: [function (require, module, exports) {
        'use strict';

        var assign = require('lodash/object/assign');

        /**
         * A palette provider for BPMN 2.0 elements.
         */
        function PaletteProvider(palette, create, elementFactory, spaceTool, lassoTool, handTool, globalConnect, translate) {

            this._palette = palette;
            this._create = create;
            this._elementFactory = elementFactory;
            this._spaceTool = spaceTool;
            this._lassoTool = lassoTool;
            this._handTool = handTool;
            this._globalConnect = globalConnect;
            this._translate = translate;

            palette.registerProvider(this);
        }

        module.exports = PaletteProvider;

        PaletteProvider.$inject = [
            'palette',
            'create',
            'elementFactory',
            'spaceTool',
            'lassoTool',
            'handTool',
            'globalConnect',
            'translate'
        ];


        PaletteProvider.prototype.getPaletteEntries = function (element) {

            var actions = {},
                create = this._create,
                elementFactory = this._elementFactory,
                spaceTool = this._spaceTool,
                lassoTool = this._lassoTool,
                handTool = this._handTool,
                globalConnect = this._globalConnect,
                translate = this._translate;

            function createAction(type, group, className, title, options) {

                function createListener(event) {
                    var shape = elementFactory.createShape(assign({ type: type }, options));

                    if (options) {
                        shape.businessObject.di.isExpanded = options.isExpanded;
                    }

                    create.start(event, shape);
                }

                var shortType = type.replace(/^bpmn\:/, '');

                return {
                    group: group,
                    className: className,
                    title: title || translate('Create {type}', { type: shortType }),
                    action: {
                        dragstart: createListener,
                        click: createListener
                    }
                };
            }

            function createParticipant(event, collapsed) {
                create.start(event, elementFactory.createParticipantShape(collapsed));
            }

            assign(actions, {
                'hand-tool': {
                    group: 'tools',
                    className: 'bpmn-icon-hand-tool',
                    title: translate('Activate the hand tool'),
                    action: {
                        click: function (event) {
                            handTool.activateHand(event);
                        }
                    }
                },
                'lasso-tool': {
                    group: 'tools',
                    className: 'bpmn-icon-lasso-tool',
                    title: translate('Activate the lasso tool'),
                    action: {
                        click: function (event) {
                            lassoTool.activateSelection(event);
                        }
                    }
                },
                'space-tool': {
                    group: 'tools',
                    className: 'bpmn-icon-space-tool',
                    title: translate('Activate the create/remove space tool'),
                    action: {
                        click: function (event) {
                            spaceTool.activateSelection(event);
                        }
                    }
                },
                'global-connect-tool': {
                    group: 'tools',
                    className: 'bpmn-icon-connection-multi',
                    title: translate('Activate the global connect tool'),
                    action: {
                        click: function (event) {
                            globalConnect.toggle(event);
                        }
                    }
                },
                'tool-separator': {
                    group: 'tools',
                    separator: true
                },
                'create.start-event': createAction(
                    'bpmn:StartEvent', 'event', 'bpmn-icon-start-event-none'
                ),
                'create.intermediate-event': createAction('bpmn:IntermediateThrowEvent', 'event',
                    'bpmn-icon-intermediate-event-none', translate('Create IntermediateThrowEvent/BoundaryEvent')
                ),
                'create.end-event': createAction(
                    'bpmn:EndEvent', 'event', 'bpmn-icon-end-event-none'
                ),
                'create.exclusive-gateway': createAction(
                    'bpmn:ExclusiveGateway', 'gateway', 'bpmn-icon-gateway-xor'
                ),
                'create.task': createAction(
                    'bpmn:Task', 'activity', 'bpmn-icon-task'
                ),
                'create.data-object': createAction(
                    'bpmn:DataObjectReference', 'data-object', 'bpmn-icon-data-object'
                ),
                'create.data-store': createAction(
                    'bpmn:DataStoreReference', 'data-store', 'bpmn-icon-data-store'
                ),
                'create.subprocess-expanded': createAction(
                    'bpmn:SubProcess', 'activity', 'bpmn-icon-subprocess-expanded', translate('Create expanded SubProcess'),
                    { isExpanded: true }
                ),
                'create.participant-expanded': {
                    group: 'collaboration',
                    className: 'bpmn-icon-participant',
                    title: translate('Create Pool/Participant'),
                    action: {
                        dragstart: createParticipant,
                        click: createParticipant
                    }
                }
            });

            return actions;
        };

    }, { "lodash/object/assign": 433 }], 72: [function (require, module, exports) {
        module.exports = {
            __depends__: [
                require('diagram-js/lib/features/palette'),
                require('diagram-js/lib/features/create'),
                require('diagram-js/lib/features/space-tool'),
                require('diagram-js/lib/features/lasso-tool'),
                require('diagram-js/lib/features/hand-tool'),
                require('diagram-js/lib/i18n/translate'),
                require('../global-connect')
            ],
            __init__: ['paletteProvider'],
            paletteProvider: ['type', require('./PaletteProvider')]
        };

    }, { "../global-connect": 21, "./PaletteProvider": 71, "diagram-js/lib/features/create": 157, "diagram-js/lib/features/hand-tool": 168, "diagram-js/lib/features/lasso-tool": 176, "diagram-js/lib/features/palette": 213, "diagram-js/lib/features/space-tool": 240, "diagram-js/lib/i18n/translate": 248 }], 73: [function (require, module, exports) {
        'use strict';

        var is = require('../../util/ModelUtil').is,
            isEventSubProcess = require('../../util/DiUtil').isEventSubProcess,
            getBusinessObject = require('../../util/ModelUtil').getBusinessObject,
            isExpanded = require('../../util/DiUtil').isExpanded,
            isDifferentType = require('./util/TypeUtil').isDifferentType;

        var forEach = require('lodash/collection/forEach'),
            filter = require('lodash/collection/filter'),
            reject = require('lodash/collection/reject');

        var replaceOptions = require('../replace/ReplaceOptions');


        /**
         * This module is an element agnostic replace menu provider for the popup menu.
         */
        function ReplaceMenuProvider(popupMenu, modeling, moddle, bpmnReplace, rules, translate) {

            this._popupMenu = popupMenu;
            this._modeling = modeling;
            this._moddle = moddle;
            this._bpmnReplace = bpmnReplace;
            this._rules = rules;
            this._translate = translate;

            this.register();
        }

        ReplaceMenuProvider.$inject = ['popupMenu', 'modeling', 'moddle', 'bpmnReplace', 'rules', 'translate'];


        /**
         * Register replace menu provider in the popup menu
         */
        ReplaceMenuProvider.prototype.register = function () {
            this._popupMenu.registerProvider('bpmn-replace', this);
        };


        /**
         * Get all entries from replaceOptions for the given element and apply filters
         * on them. Get for example only elements, which are different from the current one.
         *
         * @param {djs.model.Base} element
         *
         * @return {Array<Object>} a list of menu entry items
         */
        ReplaceMenuProvider.prototype.getEntries = function (element) {

            var businessObject = element.businessObject;

            var rules = this._rules;

            var entries;

            if (!rules.allowed('shape.replace', { element: element })) {
                return [];
            }

            var differentType = isDifferentType(element);

            // start events outside event sub processes
            if (is(businessObject, 'bpmn:StartEvent') && !isEventSubProcess(businessObject.$parent)) {

                entries = filter(replaceOptions.START_EVENT, differentType);

                return this._createEntries(element, entries);
            }

            // expanded/collapsed pools
            if (is(businessObject, 'bpmn:Participant')) {

                entries = filter(replaceOptions.PARTICIPANT, function (entry) {
                    return isExpanded(businessObject) !== entry.target.isExpanded;
                });

                return this._createEntries(element, entries);
            }

            // start events inside event sub processes
            if (is(businessObject, 'bpmn:StartEvent') && isEventSubProcess(businessObject.$parent)) {

                entries = filter(replaceOptions.EVENT_SUB_PROCESS_START_EVENT, function (entry) {

                    var target = entry.target;

                    var isInterrupting = target.isInterrupting !== false;

                    var isInterruptingEqual = getBusinessObject(element).isInterrupting === isInterrupting;

                    // filters elements which types and event definition are equal but have have different interrupting types
                    return differentType(entry) || !differentType(entry) && !isInterruptingEqual;

                });

                return this._createEntries(element, entries);
            }

            // end events
            if (is(businessObject, 'bpmn:EndEvent')) {

                entries = filter(replaceOptions.END_EVENT, function (entry) {
                    var target = entry.target;

                    // hide cancel end events outside transactions
                    if (target.eventDefinitionType == 'bpmn:CancelEventDefinition' && !is(businessObject.$parent, 'bpmn:Transaction')) {
                        return false;
                    }

                    return differentType(entry);
                });

                return this._createEntries(element, entries);
            }

            // boundary events
            if (is(businessObject, 'bpmn:BoundaryEvent')) {

                entries = filter(replaceOptions.BOUNDARY_EVENT, function (entry) {

                    var target = entry.target;

                    if (target.eventDefinition == 'bpmn:CancelEventDefinition' &&
                        !is(businessObject.attachedToRef, 'bpmn:Transaction')) {
                        return false;
                    }
                    var cancelActivity = target.cancelActivity !== false;

                    var isCancelActivityEqual = businessObject.cancelActivity == cancelActivity;

                    return differentType(entry) || !differentType(entry) && !isCancelActivityEqual;
                });

                return this._createEntries(element, entries);
            }

            // intermediate events
            if (is(businessObject, 'bpmn:IntermediateCatchEvent') ||
                is(businessObject, 'bpmn:IntermediateThrowEvent')) {

                entries = filter(replaceOptions.INTERMEDIATE_EVENT, differentType);

                return this._createEntries(element, entries);
            }

            // gateways
            if (is(businessObject, 'bpmn:Gateway')) {

                entries = filter(replaceOptions.GATEWAY, differentType);

                return this._createEntries(element, entries);
            }

            // transactions
            if (is(businessObject, 'bpmn:Transaction')) {

                entries = filter(replaceOptions.TRANSACTION, differentType);

                return this._createEntries(element, entries);
            }

            // expanded event sub processes
            if (isEventSubProcess(businessObject) && isExpanded(businessObject)) {

                entries = filter(replaceOptions.EVENT_SUB_PROCESS, differentType);

                return this._createEntries(element, entries);
            }

            // expanded sub processes
            if (is(businessObject, 'bpmn:SubProcess') && isExpanded(businessObject)) {

                entries = filter(replaceOptions.SUBPROCESS_EXPANDED, differentType);

                return this._createEntries(element, entries);
            }

            // collapsed ad hoc sub processes
            if (is(businessObject, 'bpmn:AdHocSubProcess') && !isExpanded(businessObject)) {

                entries = filter(replaceOptions.TASK, function (entry) {

                    var target = entry.target;

                    var isTargetSubProcess = target.type === 'bpmn:SubProcess';

                    var isTargetExpanded = target.isExpanded === true;

                    return isDifferentType(element, target) && (!isTargetSubProcess || isTargetExpanded);
                });

                return this._createEntries(element, entries);
            }

            // sequence flows
            if (is(businessObject, 'bpmn:SequenceFlow')) {
                return this._createSequenceFlowEntries(element, replaceOptions.SEQUENCE_FLOW);
            }

            // flow nodes
            if (is(businessObject, 'bpmn:FlowNode')) {
                entries = filter(replaceOptions.TASK, differentType);

                // collapsed SubProcess can not be replaced with itself
                if (is(businessObject, 'bpmn:SubProcess') && !isExpanded(businessObject)) {
                    entries = reject(entries, function (entry) {
                        return entry.label === 'Sub Process (collapsed)';
                    });
                }

                return this._createEntries(element, entries);
            }

            return [];
        };


        /**
         * Get a list of header items for the given element. This includes buttons
         * for multi instance markers and for the ad hoc marker.
         *
         * @param {djs.model.Base} element
         *
         * @return {Array<Object>} a list of menu entry items
         */
        ReplaceMenuProvider.prototype.getHeaderEntries = function (element) {

            var headerEntries = [];

            if (is(element, 'bpmn:Activity') && !isEventSubProcess(element)) {
                headerEntries = headerEntries.concat(this._getLoopEntries(element));
            }

            if (is(element, 'bpmn:SubProcess') &&
                !is(element, 'bpmn:Transaction') &&
                !isEventSubProcess(element)) {
                headerEntries.push(this._getAdHocEntry(element));
            }

            return headerEntries;
        };


        /**
         * Creates an array of menu entry objects for a given element and filters the replaceOptions
         * according to a filter function.
         *
         * @param  {djs.model.Base} element
         * @param  {Object} replaceOptions
         *
         * @return {Array<Object>} a list of menu items
         */
        ReplaceMenuProvider.prototype._createEntries = function (element, replaceOptions) {
            var menuEntries = [];

            var self = this;

            forEach(replaceOptions, function (definition) {
                var entry = self._createMenuEntry(definition, element);

                menuEntries.push(entry);
            });

            return menuEntries;
        };

        /**
         * Creates an array of menu entry objects for a given sequence flow.
         *
         * @param  {djs.model.Base} element
         * @param  {Object} replaceOptions
        
         * @return {Array<Object>} a list of menu items
         */
        ReplaceMenuProvider.prototype._createSequenceFlowEntries = function (element, replaceOptions) {

            var businessObject = getBusinessObject(element);

            var menuEntries = [];

            var modeling = this._modeling,
                moddle = this._moddle;

            var self = this;

            forEach(replaceOptions, function (entry) {

                switch (entry.actionName) {
                    case 'replace-with-default-flow':
                        if (businessObject.sourceRef.default !== businessObject &&
                            (is(businessObject.sourceRef, 'bpmn:ExclusiveGateway') ||
                                is(businessObject.sourceRef, 'bpmn:InclusiveGateway') ||
                                is(businessObject.sourceRef, 'bpmn:ComplexGateway') ||
                                is(businessObject.sourceRef, 'bpmn:Activity'))) {

                            menuEntries.push(self._createMenuEntry(entry, element, function () {
                                modeling.updateProperties(element.source, { default: businessObject });
                            }));
                        }
                        break;
                    case 'replace-with-conditional-flow':
                        if (!businessObject.conditionExpression && is(businessObject.sourceRef, 'bpmn:Activity')) {

                            menuEntries.push(self._createMenuEntry(entry, element, function () {
                                var conditionExpression = moddle.create('bpmn:FormalExpression', { body: '' });

                                modeling.updateProperties(element, { conditionExpression: conditionExpression });
                            }));
                        }
                        break;
                    default:
                        // default flows
                        if (is(businessObject.sourceRef, 'bpmn:Activity') && businessObject.conditionExpression) {
                            return menuEntries.push(self._createMenuEntry(entry, element, function () {
                                modeling.updateProperties(element, { conditionExpression: undefined });
                            }));
                        }
                        // conditional flows
                        if ((is(businessObject.sourceRef, 'bpmn:ExclusiveGateway') ||
                            is(businessObject.sourceRef, 'bpmn:InclusiveGateway') ||
                            is(businessObject.sourceRef, 'bpmn:ComplexGateway') ||
                            is(businessObject.sourceRef, 'bpmn:Activity')) &&
                            businessObject.sourceRef.default === businessObject) {

                            return menuEntries.push(self._createMenuEntry(entry, element, function () {
                                modeling.updateProperties(element.source, { default: undefined });
                            }));
                        }
                }
            });

            return menuEntries;
        };


        /**
         * Creates and returns a single menu entry item.
         *
         * @param  {Object} definition a single replace options definition object
         * @param  {djs.model.Base} element
         * @param  {Function} [action] an action callback function which gets called when
         *                             the menu entry is being triggered.
         *
         * @return {Object} menu entry item
         */
        ReplaceMenuProvider.prototype._createMenuEntry = function (definition, element, action) {
            var translate = this._translate;
            var replaceElement = this._bpmnReplace.replaceElement;

            var replaceAction = function () {
                return replaceElement(element, definition.target);
            };

            action = action || replaceAction;

            var menuEntry = {
                label: translate(definition.label),
                className: definition.className,
                id: definition.actionName,
                action: action
            };

            return menuEntry;
        };

        /**
         * Get a list of menu items containing buttons for multi instance markers
         *
         * @param  {djs.model.Base} element
         *
         * @return {Array<Object>} a list of menu items
         */
        ReplaceMenuProvider.prototype._getLoopEntries = function (element) {

            var self = this;
            var translate = this._translate;

            function toggleLoopEntry(event, entry) {
                var loopCharacteristics;

                if (entry.active) {
                    loopCharacteristics = undefined;
                } else {
                    loopCharacteristics = self._moddle.create(entry.options.loopCharacteristics);

                    if (entry.options.isSequential) {
                        loopCharacteristics.isSequential = entry.options.isSequential;
                    }
                }
                self._modeling.updateProperties(element, { loopCharacteristics: loopCharacteristics });
            }

            var businessObject = getBusinessObject(element),
                loopCharacteristics = businessObject.loopCharacteristics;

            var isSequential,
                isLoop,
                isParallel;

            if (loopCharacteristics) {
                isSequential = loopCharacteristics.isSequential;
                isLoop = loopCharacteristics.isSequential === undefined;
                isParallel = loopCharacteristics.isSequential !== undefined && !loopCharacteristics.isSequential;
            }


            var loopEntries = [
                {
                    id: 'toggle-parallel-mi',
                    className: 'bpmn-icon-parallel-mi-marker',
                    title: translate('Parallel Multi Instance'),
                    active: isParallel,
                    action: toggleLoopEntry,
                    options: {
                        loopCharacteristics: 'bpmn:MultiInstanceLoopCharacteristics',
                        isSequential: false
                    }
                },
                {
                    id: 'toggle-sequential-mi',
                    className: 'bpmn-icon-sequential-mi-marker',
                    title: translate('Sequential Multi Instance'),
                    active: isSequential,
                    action: toggleLoopEntry,
                    options: {
                        loopCharacteristics: 'bpmn:MultiInstanceLoopCharacteristics',
                        isSequential: true
                    }
                },
                {
                    id: 'toggle-loop',
                    className: 'bpmn-icon-loop-marker',
                    title: translate('Loop'),
                    active: isLoop,
                    action: toggleLoopEntry,
                    options: {
                        loopCharacteristics: 'bpmn:StandardLoopCharacteristics'
                    }
                }
            ];
            return loopEntries;
        };


        /**
         * Get the menu items containing a button for the ad hoc marker
         *
         * @param  {djs.model.Base} element
         *
         * @return {Object} a menu item
         */
        ReplaceMenuProvider.prototype._getAdHocEntry = function (element) {
            var translate = this._translate;
            var businessObject = getBusinessObject(element);

            var isAdHoc = is(businessObject, 'bpmn:AdHocSubProcess');

            var replaceElement = this._bpmnReplace.replaceElement;

            var adHocEntry = {
                id: 'toggle-adhoc',
                className: 'bpmn-icon-ad-hoc-marker',
                title: translate('Ad-hoc'),
                active: isAdHoc,
                action: function (event, entry) {
                    if (isAdHoc) {
                        return replaceElement(element, { type: 'bpmn:SubProcess' });
                    } else {
                        return replaceElement(element, { type: 'bpmn:AdHocSubProcess' });
                    }
                }
            };

            return adHocEntry;
        };

        module.exports = ReplaceMenuProvider;

    }, { "../../util/DiUtil": 93, "../../util/ModelUtil": 95, "../replace/ReplaceOptions": 79, "./util/TypeUtil": 75, "lodash/collection/filter": 302, "lodash/collection/forEach": 304, "lodash/collection/reject": 308 }], 74: [function (require, module, exports) {
        module.exports = {
            __depends__: [
                require('diagram-js/lib/features/popup-menu'),
                require('../replace')
            ],
            __init__: ['replaceMenuProvider'],
            replaceMenuProvider: ['type', require('./ReplaceMenuProvider')]
        };
    }, { "../replace": 80, "./ReplaceMenuProvider": 73, "diagram-js/lib/features/popup-menu": 215 }], 75: [function (require, module, exports) {
        'use strict';

        var getBusinessObject = require('../../../util/ModelUtil').getBusinessObject;
        var isExpanded = require('../../../util/DiUtil').isExpanded;

        /**
         * Returns true, if an element is from a different type
         * than a target definition. Takes into account the type,
         * event definition type and triggeredByEvent property.
         *
         * @param {djs.model.Base} element
         *
         * @return {Boolean}
         */
        function isDifferentType(element) {

            return function (entry) {
                var target = entry.target;

                var businessObject = getBusinessObject(element),
                    eventDefinition = businessObject.eventDefinitions && businessObject.eventDefinitions[0];

                var isTypeEqual = businessObject.$type === target.type;

                var isEventDefinitionEqual = (
                    (eventDefinition && eventDefinition.$type) === target.eventDefinitionType
                );

                var isTriggeredByEventEqual = (
                    businessObject.triggeredByEvent === target.triggeredByEvent
                );

                var isExpandedEqual = (
                    target.isExpanded === undefined ||
                    target.isExpanded === isExpanded(businessObject)
                );

                return !isTypeEqual || !isEventDefinitionEqual || !isTriggeredByEventEqual || !isExpandedEqual;
            };
        }

        module.exports.isDifferentType = isDifferentType;
    }, { "../../../util/DiUtil": 93, "../../../util/ModelUtil": 95 }], 76: [function (require, module, exports) {
        'use strict';

        var CommandInterceptor = require('diagram-js/lib/command/CommandInterceptor');

        var inherits = require('inherits');

        var assign = require('lodash/object/assign'),
            forEach = require('lodash/collection/forEach');

        var domQuery = require('min-dom/lib/query');

        var svgAttr = require('tiny-svg/lib/attr');

        var LOW_PRIORITY = 250;

        function BpmnReplacePreview(eventBus, elementRegistry, elementFactory, canvas, previewSupport) {

            CommandInterceptor.call(this, eventBus);

            /**
             * Replace the visuals of all elements in the context which can be replaced
             *
             * @param  {Object} context
             */
            function replaceVisual(context) {

                var replacements = context.canExecute.replacements;

                forEach(replacements, function (replacement) {

                    var id = replacement.oldElementId;

                    var newElement = {
                        type: replacement.newElementType
                    };

                    // if the visual of the element is already replaced
                    if (context.visualReplacements[id]) {
                        return;
                    }

                    var element = elementRegistry.get(id);

                    assign(newElement, { x: element.x, y: element.y });

                    // create a temporary shape
                    var tempShape = elementFactory.createShape(newElement);

                    canvas.addShape(tempShape, element.parent);

                    // select the original SVG element related to the element and hide it
                    var gfx = domQuery('[data-element-id=' + element.id + ']', context.dragGroup);

                    if (gfx) {
                        svgAttr(gfx, { display: 'none' });
                    }

                    // clone the gfx of the temporary shape and add it to the drag group
                    var dragger = previewSupport.addDragger(tempShape, context.dragGroup);

                    context.visualReplacements[id] = dragger;

                    canvas.removeShape(tempShape);
                });
            }

            /**
             * Restore the original visuals of the previously replaced elements
             *
             * @param  {Object} context
             */
            function restoreVisual(context) {

                var visualReplacements = context.visualReplacements;

                forEach(visualReplacements, function (dragger, id) {

                    var originalGfx = domQuery('[data-element-id=' + id + ']', context.dragGroup);

                    if (originalGfx) {
                        svgAttr(originalGfx, { display: 'inline' });
                    }

                    dragger.remove();

                    if (visualReplacements[id]) {
                        delete visualReplacements[id];
                    }
                });
            }

            eventBus.on('shape.move.move', LOW_PRIORITY, function (event) {

                var context = event.context,
                    canExecute = context.canExecute;

                if (!context.visualReplacements) {
                    context.visualReplacements = {};
                }

                if (canExecute.replacements) {
                    replaceVisual(context);
                } else {
                    restoreVisual(context);
                }
            });
        }

        BpmnReplacePreview.$inject = ['eventBus', 'elementRegistry', 'elementFactory', 'canvas', 'previewSupport'];

        inherits(BpmnReplacePreview, CommandInterceptor);

        module.exports = BpmnReplacePreview;

    }, { "diagram-js/lib/command/CommandInterceptor": 119, "inherits": 289, "lodash/collection/forEach": 304, "lodash/object/assign": 433, "min-dom/lib/query": 454, "tiny-svg/lib/attr": 475 }], 77: [function (require, module, exports) {
        module.exports = {
            __depends__: [require('diagram-js/lib/features/preview-support')],
            __init__: ['bpmnReplacePreview'],
            bpmnReplacePreview: ['type', require('./BpmnReplacePreview')]
        };

    }, { "./BpmnReplacePreview": 76, "diagram-js/lib/features/preview-support": 217 }], 78: [function (require, module, exports) {
        'use strict';

        var pick = require('lodash/object/pick'),
            assign = require('lodash/object/assign'),
            intersection = require('lodash/array/intersection'),
            filter = require('lodash/collection/filter'),
            has = require('lodash/object/has');

        var is = require('../../util/ModelUtil').is,
            isExpanded = require('../../util/DiUtil').isExpanded,
            isEventSubProcess = require('../../util/DiUtil').isEventSubProcess,
            ModelCloneUtils = require('../../util/model/ModelCloneUtils'),
            getProperties = ModelCloneUtils.getProperties;

        var IGNORED_PROPERTIES = ModelCloneUtils.IGNORED_PROPERTIES;

        var ModelCloneHelper = require('../../util/model/ModelCloneHelper');

        var CUSTOM_PROPERTIES = [
            'cancelActivity',
            'instantiate',
            'eventGatewayType',
            'triggeredByEvent',
            'isInterrupting'
        ];


        function toggeling(element, target) {

            var oldCollapsed = has(element, 'collapsed') ?
                element.collapsed : !isExpanded(element);

            var targetCollapsed;

            if (has(target, 'collapsed') || has(target, 'isExpanded')) {
                // property is explicitly set so use it
                targetCollapsed = has(target, 'collapsed') ?
                    target.collapsed : !target.isExpanded;
            } else {
                // keep old state
                targetCollapsed = oldCollapsed;
            }

            if (oldCollapsed !== targetCollapsed) {
                element.collapsed = oldCollapsed;
                return true;
            }

            return false;
        }



        /**
         * This module takes care of replacing BPMN elements
         */
        function BpmnReplace(bpmnFactory, replace, selection, modeling, eventBus) {

            var helper = new ModelCloneHelper(eventBus);

            /**
             * Prepares a new business object for the replacement element
             * and triggers the replace operation.
             *
             * @param  {djs.model.Base} element
             * @param  {Object} target
             * @param  {Object} [hints]
             *
             * @return {djs.model.Base} the newly created element
             */
            function replaceElement(element, target, hints) {

                hints = hints || {};

                var type = target.type,
                    oldBusinessObject = element.businessObject;

                if (is(oldBusinessObject, 'bpmn:SubProcess')) {
                    if (type === 'bpmn:SubProcess') {
                        if (toggeling(element, target)) {
                            // expanding or collapsing process
                            modeling.toggleCollapse(element);

                            return element;
                        }
                    }
                }

                var newBusinessObject = bpmnFactory.create(type);

                var newElement = {
                    type: type,
                    businessObject: newBusinessObject
                };

                var elementProps = getProperties(oldBusinessObject.$descriptor),
                    newElementProps = getProperties(newBusinessObject.$descriptor, true),
                    properties = intersection(elementProps, newElementProps);

                // initialize special properties defined in target definition
                assign(newBusinessObject, pick(target, CUSTOM_PROPERTIES));

                properties = filter(properties, function (property) {
                    var propName = property.replace(/bpmn:/, '');

                    // so the applied properties from 'target' don't get lost
                    if (newBusinessObject[property] !== undefined) {
                        return false;
                    }

                    // retain loop characteristics if the target element is not an event sub process
                    if (propName === 'loopCharacteristics') {
                        return !isEventSubProcess(newBusinessObject);
                    }

                    if ((propName === 'processRef' && target.isExpanded === false) ||
                        propName === 'triggeredByEvent' ||
                        propName === 'eventDefinitions') {
                        return false;
                    }

                    return IGNORED_PROPERTIES.indexOf(propName) === -1;
                });

                newBusinessObject = helper.clone(oldBusinessObject, newBusinessObject, properties);

                // initialize custom BPMN extensions
                if (target.eventDefinitionType) {
                    newElement.eventDefinitionType = target.eventDefinitionType;
                }

                if (is(oldBusinessObject, 'bpmn:Activity')) {

                    if (is(oldBusinessObject, 'bpmn:SubProcess')) {
                        // no toggeling, so keep old state
                        newElement.isExpanded = isExpanded(oldBusinessObject);
                    }
                    // else if property is explicitly set, use it
                    else if (has(target, 'isExpanded')) {
                        newElement.isExpanded = target.isExpanded;
                    }

                    // TODO: need also to respect min/max Size
                    // copy size, from an expanded subprocess to an expanded alternative subprocess
                    // except bpmn:Task, because Task is always expanded
                    if ((isExpanded(oldBusinessObject) && !is(oldBusinessObject, 'bpmn:Task')) && newElement.isExpanded) {
                        newElement.width = element.width;
                        newElement.height = element.height;
                    }
                }

                // transform collapsed/expanded pools
                if (is(oldBusinessObject, 'bpmn:Participant')) {

                    // create expanded pool
                    if (target.isExpanded === true) {
                        newBusinessObject.processRef = bpmnFactory.create('bpmn:Process');
                    } else {
                        // remove children when transforming to collapsed pool
                        hints.moveChildren = false;
                    }

                    // apply same size
                    newElement.width = element.width;
                    newElement.height = element.height;
                }

                newBusinessObject.name = oldBusinessObject.name;

                // retain default flow's reference between inclusive <-> exclusive gateways and activities
                if ((is(oldBusinessObject, 'bpmn:ExclusiveGateway') || is(oldBusinessObject, 'bpmn:InclusiveGateway') ||
                    is(oldBusinessObject, 'bpmn:Activity')) &&
                    (is(newBusinessObject, 'bpmn:ExclusiveGateway') || is(newBusinessObject, 'bpmn:InclusiveGateway') ||
                        is(newBusinessObject, 'bpmn:Activity'))) {
                    newBusinessObject.default = oldBusinessObject.default;
                }

                if ('fill' in oldBusinessObject.di || 'stroke' in oldBusinessObject.di) {
                    assign(newElement, { colors: pick(oldBusinessObject.di, ['fill', 'stroke']) });
                }

                newElement = replace.replaceElement(element, newElement, hints);

                if (hints.select !== false) {
                    selection.select(newElement);
                }

                return newElement;
            }

            this.replaceElement = replaceElement;
        }

        BpmnReplace.$inject = ['bpmnFactory', 'replace', 'selection', 'modeling', 'eventBus'];

        module.exports = BpmnReplace;

    }, { "../../util/DiUtil": 93, "../../util/ModelUtil": 95, "../../util/model/ModelCloneHelper": 97, "../../util/model/ModelCloneUtils": 98, "lodash/array/intersection": 293, "lodash/collection/filter": 302, "lodash/object/assign": 433, "lodash/object/has": 434, "lodash/object/pick": 440 }], 79: [function (require, module, exports) {
        'use strict';

        module.exports.START_EVENT = [
            {
                label: 'Start Event',
                actionName: 'replace-with-none-start',
                className: 'bpmn-icon-start-event-none',
                target: {
                    type: 'bpmn:StartEvent'
                }
            },
            {
                label: 'Intermediate Throw Event',
                actionName: 'replace-with-none-intermediate-throwing',
                className: 'bpmn-icon-intermediate-event-none',
                target: {
                    type: 'bpmn:IntermediateThrowEvent'
                }
            },
            {
                label: 'End Event',
                actionName: 'replace-with-none-end',
                className: 'bpmn-icon-end-event-none',
                target: {
                    type: 'bpmn:EndEvent'
                }
            },
            {
                label: 'Message Start Event',
                actionName: 'replace-with-message-start',
                className: 'bpmn-icon-start-event-message',
                target: {
                    type: 'bpmn:StartEvent',
                    eventDefinitionType: 'bpmn:MessageEventDefinition'
                }
            },
            {
                label: 'Timer Start Event',
                actionName: 'replace-with-timer-start',
                className: 'bpmn-icon-start-event-timer',
                target: {
                    type: 'bpmn:StartEvent',
                    eventDefinitionType: 'bpmn:TimerEventDefinition'
                }
            },
            {
                label: 'Conditional Start Event',
                actionName: 'replace-with-conditional-start',
                className: 'bpmn-icon-start-event-condition',
                target: {
                    type: 'bpmn:StartEvent',
                    eventDefinitionType: 'bpmn:ConditionalEventDefinition'
                }
            },
            {
                label: 'Signal Start Event',
                actionName: 'replace-with-signal-start',
                className: 'bpmn-icon-start-event-signal',
                target: {
                    type: 'bpmn:StartEvent',
                    eventDefinitionType: 'bpmn:SignalEventDefinition'
                }
            }
        ];

        module.exports.INTERMEDIATE_EVENT = [
            {
                label: 'Start Event',
                actionName: 'replace-with-none-start',
                className: 'bpmn-icon-start-event-none',
                target: {
                    type: 'bpmn:StartEvent'
                }
            },
            {
                label: 'Intermediate Throw Event',
                actionName: 'replace-with-none-intermediate-throw',
                className: 'bpmn-icon-intermediate-event-none',
                target: {
                    type: 'bpmn:IntermediateThrowEvent'
                }
            },
            {
                label: 'End Event',
                actionName: 'replace-with-none-end',
                className: 'bpmn-icon-end-event-none',
                target: {
                    type: 'bpmn:EndEvent'
                }
            },
            {
                label: 'Message Intermediate Catch Event',
                actionName: 'replace-with-message-intermediate-catch',
                className: 'bpmn-icon-intermediate-event-catch-message',
                target: {
                    type: 'bpmn:IntermediateCatchEvent',
                    eventDefinitionType: 'bpmn:MessageEventDefinition'
                }
            },
            {
                label: 'Message Intermediate Throw Event',
                actionName: 'replace-with-message-intermediate-throw',
                className: 'bpmn-icon-intermediate-event-throw-message',
                target: {
                    type: 'bpmn:IntermediateThrowEvent',
                    eventDefinitionType: 'bpmn:MessageEventDefinition'
                }
            },
            {
                label: 'Timer Intermediate Catch Event',
                actionName: 'replace-with-timer-intermediate-catch',
                className: 'bpmn-icon-intermediate-event-catch-timer',
                target: {
                    type: 'bpmn:IntermediateCatchEvent',
                    eventDefinitionType: 'bpmn:TimerEventDefinition'
                }
            },
            {
                label: 'Escalation Intermediate Throw Event',
                actionName: 'replace-with-escalation-intermediate-throw',
                className: 'bpmn-icon-intermediate-event-throw-escalation',
                target: {
                    type: 'bpmn:IntermediateThrowEvent',
                    eventDefinitionType: 'bpmn:EscalationEventDefinition'
                }
            },
            {
                label: 'Conditional Intermediate Catch Event',
                actionName: 'replace-with-conditional-intermediate-catch',
                className: 'bpmn-icon-intermediate-event-catch-condition',
                target: {
                    type: 'bpmn:IntermediateCatchEvent',
                    eventDefinitionType: 'bpmn:ConditionalEventDefinition'
                }
            },
            {
                label: 'Link Intermediate Catch Event',
                actionName: 'replace-with-link-intermediate-catch',
                className: 'bpmn-icon-intermediate-event-catch-link',
                target: {
                    type: 'bpmn:IntermediateCatchEvent',
                    eventDefinitionType: 'bpmn:LinkEventDefinition'
                }
            },
            {
                label: 'Link Intermediate Throw Event',
                actionName: 'replace-with-link-intermediate-throw',
                className: 'bpmn-icon-intermediate-event-throw-link',
                target: {
                    type: 'bpmn:IntermediateThrowEvent',
                    eventDefinitionType: 'bpmn:LinkEventDefinition'
                }
            },
            {
                label: 'Compensation Intermediate Throw Event',
                actionName: 'replace-with-compensation-intermediate-throw',
                className: 'bpmn-icon-intermediate-event-throw-compensation',
                target: {
                    type: 'bpmn:IntermediateThrowEvent',
                    eventDefinitionType: 'bpmn:CompensateEventDefinition'
                }
            },
            {
                label: 'Signal Intermediate Catch Event',
                actionName: 'replace-with-signal-intermediate-catch',
                className: 'bpmn-icon-intermediate-event-catch-signal',
                target: {
                    type: 'bpmn:IntermediateCatchEvent',
                    eventDefinitionType: 'bpmn:SignalEventDefinition'
                }
            },
            {
                label: 'Signal Intermediate Throw Event',
                actionName: 'replace-with-signal-intermediate-throw',
                className: 'bpmn-icon-intermediate-event-throw-signal',
                target: {
                    type: 'bpmn:IntermediateThrowEvent',
                    eventDefinitionType: 'bpmn:SignalEventDefinition'
                }
            }
        ];

        module.exports.END_EVENT = [
            {
                label: 'Start Event',
                actionName: 'replace-with-none-start',
                className: 'bpmn-icon-start-event-none',
                target: {
                    type: 'bpmn:StartEvent'
                }
            },
            {
                label: 'Intermediate Throw Event',
                actionName: 'replace-with-none-intermediate-throw',
                className: 'bpmn-icon-intermediate-event-none',
                target: {
                    type: 'bpmn:IntermediateThrowEvent'
                }
            },
            {
                label: 'End Event',
                actionName: 'replace-with-none-end',
                className: 'bpmn-icon-end-event-none',
                target: {
                    type: 'bpmn:EndEvent'
                }
            },
            {
                label: 'Message End Event',
                actionName: 'replace-with-message-end',
                className: 'bpmn-icon-end-event-message',
                target: {
                    type: 'bpmn:EndEvent',
                    eventDefinitionType: 'bpmn:MessageEventDefinition'
                }
            },
            {
                label: 'Escalation End Event',
                actionName: 'replace-with-escalation-end',
                className: 'bpmn-icon-end-event-escalation',
                target: {
                    type: 'bpmn:EndEvent',
                    eventDefinitionType: 'bpmn:EscalationEventDefinition'
                }
            },
            {
                label: 'Error End Event',
                actionName: 'replace-with-error-end',
                className: 'bpmn-icon-end-event-error',
                target: {
                    type: 'bpmn:EndEvent',
                    eventDefinitionType: 'bpmn:ErrorEventDefinition'
                }
            },
            {
                label: 'Cancel End Event',
                actionName: 'replace-with-cancel-end',
                className: 'bpmn-icon-end-event-cancel',
                target: {
                    type: 'bpmn:EndEvent',
                    eventDefinitionType: 'bpmn:CancelEventDefinition'
                }
            },
            {
                label: 'Compensation End Event',
                actionName: 'replace-with-compensation-end',
                className: 'bpmn-icon-end-event-compensation',
                target: {
                    type: 'bpmn:EndEvent',
                    eventDefinitionType: 'bpmn:CompensateEventDefinition'
                }
            },
            {
                label: 'Signal End Event',
                actionName: 'replace-with-signal-end',
                className: 'bpmn-icon-end-event-signal',
                target: {
                    type: 'bpmn:EndEvent',
                    eventDefinitionType: 'bpmn:SignalEventDefinition'
                }
            },
            {
                label: 'Terminate End Event',
                actionName: 'replace-with-terminate-end',
                className: 'bpmn-icon-end-event-terminate',
                target: {
                    type: 'bpmn:EndEvent',
                    eventDefinitionType: 'bpmn:TerminateEventDefinition'
                }
            }
        ];

        module.exports.GATEWAY = [
            {
                label: 'Exclusive Gateway',
                actionName: 'replace-with-exclusive-gateway',
                className: 'bpmn-icon-gateway-xor',
                target: {
                    type: 'bpmn:ExclusiveGateway'
                }
            },
            {
                label: 'Parallel Gateway',
                actionName: 'replace-with-parallel-gateway',
                className: 'bpmn-icon-gateway-parallel',
                target: {
                    type: 'bpmn:ParallelGateway'
                }
            },
            {
                label: 'Inclusive Gateway',
                actionName: 'replace-with-inclusive-gateway',
                className: 'bpmn-icon-gateway-or',
                target: {
                    type: 'bpmn:InclusiveGateway'
                }
            },
            {
                label: 'Complex Gateway',
                actionName: 'replace-with-complex-gateway',
                className: 'bpmn-icon-gateway-complex',
                target: {
                    type: 'bpmn:ComplexGateway'
                }
            },
            {
                label: 'Event based Gateway',
                actionName: 'replace-with-event-based-gateway',
                className: 'bpmn-icon-gateway-eventbased',
                target: {
                    type: 'bpmn:EventBasedGateway',
                    instantiate: false,
                    eventGatewayType: 'Exclusive'
                }
            }
            // Gateways deactivated until https://github.com/bpmn-io/bpmn-js/issues/194
            // {
            //   label: 'Event based instantiating Gateway',
            //   actionName: 'replace-with-exclusive-event-based-gateway',
            //   className: 'bpmn-icon-exclusive-event-based',
            //   target: {
            //     type: 'bpmn:EventBasedGateway'
            //   },
            //   options: {
            //     businessObject: { instantiate: true, eventGatewayType: 'Exclusive' }
            //   }
            // },
            // {
            //   label: 'Parallel Event based instantiating Gateway',
            //   actionName: 'replace-with-parallel-event-based-instantiate-gateway',
            //   className: 'bpmn-icon-parallel-event-based-instantiate-gateway',
            //   target: {
            //     type: 'bpmn:EventBasedGateway'
            //   },
            //   options: {
            //     businessObject: { instantiate: true, eventGatewayType: 'Parallel' }
            //   }
            // }
        ];

        module.exports.SUBPROCESS_EXPANDED = [
            {
                label: 'Transaction',
                actionName: 'replace-with-transaction',
                className: 'bpmn-icon-transaction',
                target: {
                    type: 'bpmn:Transaction',
                    isExpanded: true
                }
            },
            {
                label: 'Event Sub Process',
                actionName: 'replace-with-event-subprocess',
                className: 'bpmn-icon-event-subprocess-expanded',
                target: {
                    type: 'bpmn:SubProcess',
                    triggeredByEvent: true,
                    isExpanded: true
                }
            },
            {
                label: 'Sub Process (collapsed)',
                actionName: 'replace-with-collapsed-subprocess',
                className: 'bpmn-icon-subprocess-collapsed',
                target: {
                    type: 'bpmn:SubProcess',
                    isExpanded: false
                }
            }
        ];

        module.exports.TRANSACTION = [
            {
                label: 'Sub Process',
                actionName: 'replace-with-subprocess',
                className: 'bpmn-icon-subprocess-expanded',
                target: {
                    type: 'bpmn:SubProcess',
                    isExpanded: true
                }
            },
            {
                label: 'Event Sub Process',
                actionName: 'replace-with-event-subprocess',
                className: 'bpmn-icon-event-subprocess-expanded',
                target: {
                    type: 'bpmn:SubProcess',
                    triggeredByEvent: true,
                    isExpanded: true
                }
            }
        ];

        module.exports.EVENT_SUB_PROCESS = [
            {
                label: 'Sub Process',
                actionName: 'replace-with-subprocess',
                className: 'bpmn-icon-subprocess-expanded',
                target: {
                    type: 'bpmn:SubProcess',
                    isExpanded: true
                }
            },
            {
                label: 'Transaction',
                actionName: 'replace-with-transaction',
                className: 'bpmn-icon-transaction',
                target: {
                    type: 'bpmn:Transaction',
                    isExpanded: true
                }
            }
        ];

        module.exports.TASK = [
            {
                label: 'Task',
                actionName: 'replace-with-task',
                className: 'bpmn-icon-task',
                target: {
                    type: 'bpmn:Task'
                }
            },
            {
                label: 'Send Task',
                actionName: 'replace-with-send-task',
                className: 'bpmn-icon-send',
                target: {
                    type: 'bpmn:SendTask'
                }
            },
            {
                label: 'Receive Task',
                actionName: 'replace-with-receive-task',
                className: 'bpmn-icon-receive',
                target: {
                    type: 'bpmn:ReceiveTask'
                }
            },
            {
                label: 'User Task',
                actionName: 'replace-with-user-task',
                className: 'bpmn-icon-user',
                target: {
                    type: 'bpmn:UserTask'
                }
            },
            {
                label: 'Manual Task',
                actionName: 'replace-with-manual-task',
                className: 'bpmn-icon-manual',
                target: {
                    type: 'bpmn:ManualTask'
                }
            },
            {
                label: 'Business Rule Task',
                actionName: 'replace-with-rule-task',
                className: 'bpmn-icon-business-rule',
                target: {
                    type: 'bpmn:BusinessRuleTask'
                }
            },
            {
                label: 'Service Task',
                actionName: 'replace-with-service-task',
                className: 'bpmn-icon-service',
                target: {
                    type: 'bpmn:ServiceTask'
                }
            },
            {
                label: 'Script Task',
                actionName: 'replace-with-script-task',
                className: 'bpmn-icon-script',
                target: {
                    type: 'bpmn:ScriptTask'
                }
            },
            {
                label: 'Call Activity',
                actionName: 'replace-with-call-activity',
                className: 'bpmn-icon-call-activity',
                target: {
                    type: 'bpmn:CallActivity'
                }
            },
            {
                label: 'Sub Process (collapsed)',
                actionName: 'replace-with-collapsed-subprocess',
                className: 'bpmn-icon-subprocess-collapsed',
                target: {
                    type: 'bpmn:SubProcess',
                    isExpanded: false
                }
            },
            {
                label: 'Sub Process (expanded)',
                actionName: 'replace-with-expanded-subprocess',
                className: 'bpmn-icon-subprocess-expanded',
                target: {
                    type: 'bpmn:SubProcess',
                    isExpanded: true
                }
            }
        ];

        module.exports.BOUNDARY_EVENT = [
            {
                label: 'Message Boundary Event',
                actionName: 'replace-with-message-boundary',
                className: 'bpmn-icon-intermediate-event-catch-message',
                target: {
                    type: 'bpmn:BoundaryEvent',
                    eventDefinitionType: 'bpmn:MessageEventDefinition'
                }
            },
            {
                label: 'Timer Boundary Event',
                actionName: 'replace-with-timer-boundary',
                className: 'bpmn-icon-intermediate-event-catch-timer',
                target: {
                    type: 'bpmn:BoundaryEvent',
                    eventDefinitionType: 'bpmn:TimerEventDefinition'
                }
            },
            {
                label: 'Escalation Boundary Event',
                actionName: 'replace-with-escalation-boundary',
                className: 'bpmn-icon-intermediate-event-catch-escalation',
                target: {
                    type: 'bpmn:BoundaryEvent',
                    eventDefinitionType: 'bpmn:EscalationEventDefinition'
                }
            },
            {
                label: 'Conditional Boundary Event',
                actionName: 'replace-with-conditional-boundary',
                className: 'bpmn-icon-intermediate-event-catch-condition',
                target: {
                    type: 'bpmn:BoundaryEvent',
                    eventDefinitionType: 'bpmn:ConditionalEventDefinition'
                }
            },
            {
                label: 'Error Boundary Event',
                actionName: 'replace-with-error-boundary',
                className: 'bpmn-icon-intermediate-event-catch-error',
                target: {
                    type: 'bpmn:BoundaryEvent',
                    eventDefinitionType: 'bpmn:ErrorEventDefinition'
                }
            },
            {
                label: 'Cancel Boundary Event',
                actionName: 'replace-with-cancel-boundary',
                className: 'bpmn-icon-intermediate-event-catch-cancel',
                target: {
                    type: 'bpmn:BoundaryEvent',
                    eventDefinitionType: 'bpmn:CancelEventDefinition'
                }
            },
            {
                label: 'Signal Boundary Event',
                actionName: 'replace-with-signal-boundary',
                className: 'bpmn-icon-intermediate-event-catch-signal',
                target: {
                    type: 'bpmn:BoundaryEvent',
                    eventDefinitionType: 'bpmn:SignalEventDefinition'
                }
            },
            {
                label: 'Compensation Boundary Event',
                actionName: 'replace-with-compensation-boundary',
                className: 'bpmn-icon-intermediate-event-catch-compensation',
                target: {
                    type: 'bpmn:BoundaryEvent',
                    eventDefinitionType: 'bpmn:CompensateEventDefinition'
                }
            },
            {
                label: 'Message Boundary Event (non-interrupting)',
                actionName: 'replace-with-non-interrupting-message-boundary',
                className: 'bpmn-icon-intermediate-event-catch-non-interrupting-message',
                target: {
                    type: 'bpmn:BoundaryEvent',
                    eventDefinitionType: 'bpmn:MessageEventDefinition',
                    cancelActivity: false
                }
            },
            {
                label: 'Timer Boundary Event (non-interrupting)',
                actionName: 'replace-with-non-interrupting-timer-boundary',
                className: 'bpmn-icon-intermediate-event-catch-non-interrupting-timer',
                target: {
                    type: 'bpmn:BoundaryEvent',
                    eventDefinitionType: 'bpmn:TimerEventDefinition',
                    cancelActivity: false
                }
            },
            {
                label: 'Escalation Boundary Event (non-interrupting)',
                actionName: 'replace-with-non-interrupting-escalation-boundary',
                className: 'bpmn-icon-intermediate-event-catch-non-interrupting-escalation',
                target: {
                    type: 'bpmn:BoundaryEvent',
                    eventDefinitionType: 'bpmn:EscalationEventDefinition',
                    cancelActivity: false
                }
            },
            {
                label: 'Conditional Boundary Event (non-interrupting)',
                actionName: 'replace-with-non-interrupting-conditional-boundary',
                className: 'bpmn-icon-intermediate-event-catch-non-interrupting-condition',
                target: {
                    type: 'bpmn:BoundaryEvent',
                    eventDefinitionType: 'bpmn:ConditionalEventDefinition',
                    cancelActivity: false
                }
            },
            {
                label: 'Signal Boundary Event (non-interrupting)',
                actionName: 'replace-with-non-interrupting-signal-boundary',
                className: 'bpmn-icon-intermediate-event-catch-non-interrupting-signal',
                target: {
                    type: 'bpmn:BoundaryEvent',
                    eventDefinitionType: 'bpmn:SignalEventDefinition',
                    cancelActivity: false
                }
            }
        ];

        module.exports.EVENT_SUB_PROCESS_START_EVENT = [
            {
                label: 'Message Start Event',
                actionName: 'replace-with-message-start',
                className: 'bpmn-icon-start-event-message',
                target: {
                    type: 'bpmn:StartEvent',
                    eventDefinitionType: 'bpmn:MessageEventDefinition'
                }
            },
            {
                label: 'Timer Start Event',
                actionName: 'replace-with-timer-start',
                className: 'bpmn-icon-start-event-timer',
                target: {
                    type: 'bpmn:StartEvent',
                    eventDefinitionType: 'bpmn:TimerEventDefinition'
                }
            },
            {
                label: 'Conditional Start Event',
                actionName: 'replace-with-conditional-start',
                className: 'bpmn-icon-start-event-condition',
                target: {
                    type: 'bpmn:StartEvent',
                    eventDefinitionType: 'bpmn:ConditionalEventDefinition'
                }
            },
            {
                label: 'Signal Start Event',
                actionName: 'replace-with-signal-start',
                className: 'bpmn-icon-start-event-signal',
                target: {
                    type: 'bpmn:StartEvent',
                    eventDefinitionType: 'bpmn:SignalEventDefinition'
                }
            },
            {
                label: 'Error Start Event',
                actionName: 'replace-with-error-start',
                className: 'bpmn-icon-start-event-error',
                target: {
                    type: 'bpmn:StartEvent',
                    eventDefinitionType: 'bpmn:ErrorEventDefinition'
                }
            },
            {
                label: 'Escalation Start Event',
                actionName: 'replace-with-escalation-start',
                className: 'bpmn-icon-start-event-escalation',
                target: {
                    type: 'bpmn:StartEvent',
                    eventDefinitionType: 'bpmn:EscalationEventDefinition'
                }
            },
            {
                label: 'Compensation Start Event',
                actionName: 'replace-with-compensation-start',
                className: 'bpmn-icon-start-event-compensation',
                target: {
                    type: 'bpmn:StartEvent',
                    eventDefinitionType: 'bpmn:CompensateEventDefinition'
                }
            },
            {
                label: 'Message Start Event (non-interrupting)',
                actionName: 'replace-with-non-interrupting-message-start',
                className: 'bpmn-icon-start-event-non-interrupting-message',
                target: {
                    type: 'bpmn:StartEvent',
                    eventDefinitionType: 'bpmn:MessageEventDefinition',
                    isInterrupting: false
                }
            },
            {
                label: 'Timer Start Event (non-interrupting)',
                actionName: 'replace-with-non-interrupting-timer-start',
                className: 'bpmn-icon-start-event-non-interrupting-timer',
                target: {
                    type: 'bpmn:StartEvent',
                    eventDefinitionType: 'bpmn:TimerEventDefinition',
                    isInterrupting: false
                }
            },
            {
                label: 'Conditional Start Event (non-interrupting)',
                actionName: 'replace-with-non-interrupting-conditional-start',
                className: 'bpmn-icon-start-event-non-interrupting-condition',
                target: {
                    type: 'bpmn:StartEvent',
                    eventDefinitionType: 'bpmn:ConditionalEventDefinition',
                    isInterrupting: false
                }
            },
            {
                label: 'Signal Start Event (non-interrupting)',
                actionName: 'replace-with-non-interrupting-signal-start',
                className: 'bpmn-icon-start-event-non-interrupting-signal',
                target: {
                    type: 'bpmn:StartEvent',
                    eventDefinitionType: 'bpmn:SignalEventDefinition',
                    isInterrupting: false
                }
            },
            {
                label: 'Escalation Start Event (non-interrupting)',
                actionName: 'replace-with-non-interrupting-escalation-start',
                className: 'bpmn-icon-start-event-non-interrupting-escalation',
                target: {
                    type: 'bpmn:StartEvent',
                    eventDefinitionType: 'bpmn:EscalationEventDefinition',
                    isInterrupting: false
                }
            }
        ];

        module.exports.SEQUENCE_FLOW = [
            {
                label: 'Sequence Flow',
                actionName: 'replace-with-sequence-flow',
                className: 'bpmn-icon-connection'
            },
            {
                label: 'Default Flow',
                actionName: 'replace-with-default-flow',
                className: 'bpmn-icon-default-flow'
            },
            {
                label: 'Conditional Flow',
                actionName: 'replace-with-conditional-flow',
                className: 'bpmn-icon-conditional-flow'
            }
        ];

        module.exports.PARTICIPANT = [
            {
                label: 'Expanded Pool',
                actionName: 'replace-with-expanded-pool',
                className: 'bpmn-icon-participant',
                target: {
                    type: 'bpmn:Participant',
                    isExpanded: true
                }
            },
            {
                label: 'Collapsed Pool',
                actionName: 'replace-with-collapsed-pool',
                // TODO(@janstuemmel): maybe design new icon
                className: 'bpmn-icon-lane',
                target: {
                    type: 'bpmn:Participant',
                    isExpanded: false
                }
            }
        ];

    }, {}], 80: [function (require, module, exports) {
        module.exports = {
            __depends__: [
                require('diagram-js/lib/features/replace'),
                require('diagram-js/lib/features/selection')
            ],
            bpmnReplace: ['type', require('./BpmnReplace')]
        };

    }, { "./BpmnReplace": 78, "diagram-js/lib/features/replace": 219, "diagram-js/lib/features/selection": 233 }], 81: [function (require, module, exports) {
        'use strict';

        var find = require('lodash/collection/find'),
            any = require('lodash/collection/any'),
            every = require('lodash/collection/every'),
            filter = require('lodash/collection/filter'),
            forEach = require('lodash/collection/forEach'),
            inherits = require('inherits');

        var is = require('../../util/ModelUtil').is,
            isAny = require('../modeling/util/ModelingUtil').isAny,
            getBusinessObject = require('../../util/ModelUtil').getBusinessObject,
            isExpanded = require('../../util/DiUtil').isExpanded,
            isEventSubProcess = require('../../util/DiUtil').isEventSubProcess,
            isInterrupting = require('../../util/DiUtil').isInterrupting,
            hasErrorEventDefinition = require('../../util/DiUtil').hasErrorEventDefinition,
            hasEscalationEventDefinition = require('../../util/DiUtil').hasEscalationEventDefinition,
            hasCompensateEventDefinition = require('../../util/DiUtil').hasCompensateEventDefinition;


        var RuleProvider = require('diagram-js/lib/features/rules/RuleProvider');

        var isBoundaryAttachment = require('../snapping/BpmnSnappingUtil').getBoundaryAttachment;

        /**
         * BPMN specific modeling rule
         */
        function BpmnRules(eventBus) {
            RuleProvider.call(this, eventBus);
        }

        inherits(BpmnRules, RuleProvider);

        BpmnRules.$inject = ['eventBus'];

        module.exports = BpmnRules;

        BpmnRules.prototype.init = function () {

            this.addRule('connection.create', function (context) {
                var source = context.source,
                    target = context.target;

                return canConnect(source, target);
            });

            this.addRule('connection.reconnectStart', function (context) {

                var connection = context.connection,
                    source = context.hover || context.source,
                    target = connection.target;

                return canConnect(source, target, connection);
            });

            this.addRule('connection.reconnectEnd', function (context) {

                var connection = context.connection,
                    source = connection.source,
                    target = context.hover || context.target;

                return canConnect(source, target, connection);
            });

            this.addRule('connection.updateWaypoints', function (context) {
                // OK! but visually ignore
                return null;
            });

            this.addRule('shape.resize', function (context) {

                var shape = context.shape,
                    newBounds = context.newBounds;

                return canResize(shape, newBounds);
            });

            this.addRule('elements.move', function (context) {

                var target = context.target,
                    shapes = context.shapes,
                    position = context.position;

                return canAttach(shapes, target, null, position) ||
                    canReplace(shapes, target, position) ||
                    canMove(shapes, target, position) ||
                    canInsert(shapes, target, position);
            });

            this.addRule(['shape.create', 'shape.append'], function (context) {
                var target = context.target,
                    shape = context.shape,
                    source = context.source,
                    position = context.position;

                return canAttach([shape], target, source, position) || canCreate(shape, target, source, position);
            });

            this.addRule('element.copy', function (context) {
                var collection = context.collection,
                    element = context.element;

                return canCopy(collection, element);
            });

            this.addRule('element.paste', function (context) {
                var parent = context.parent,
                    element = context.element,
                    position = context.position,
                    source = context.source,
                    target = context.target;

                if (source || target) {
                    return canConnect(source, target);
                }

                return canAttach([element], parent, null, position) || canCreate(element, parent, null, position);
            });

            this.addRule('elements.paste', function (context) {
                var tree = context.tree,
                    target = context.target;

                return canPaste(tree, target);
            });

            this.addRule(['elements.delete'], function (context) {

                // do not allow deletion of labels
                return filter(context.elements, function (e) {
                    return !isLabel(e);
                });
            });
        };

        BpmnRules.prototype.canConnectMessageFlow = canConnectMessageFlow;

        BpmnRules.prototype.canConnectSequenceFlow = canConnectSequenceFlow;

        BpmnRules.prototype.canConnectDataAssociation = canConnectDataAssociation;

        BpmnRules.prototype.canConnectAssociation = canConnectAssociation;

        BpmnRules.prototype.canMove = canMove;

        BpmnRules.prototype.canAttach = canAttach;

        BpmnRules.prototype.canReplace = canReplace;

        BpmnRules.prototype.canDrop = canDrop;

        BpmnRules.prototype.canInsert = canInsert;

        BpmnRules.prototype.canCreate = canCreate;

        BpmnRules.prototype.canConnect = canConnect;

        BpmnRules.prototype.canResize = canResize;

        BpmnRules.prototype.canCopy = canCopy;

        /**
         * Utility functions for rule checking
         */

        function nonExistantOrLabel(element) {
            return !element || isLabel(element);
        }

        function isSame(a, b) {
            return a === b;
        }

        function getOrganizationalParent(element) {

            var bo = getBusinessObject(element);

            while (bo && !is(bo, 'bpmn:Process')) {
                if (is(bo, 'bpmn:Participant')) {
                    return bo.processRef || bo;
                }

                bo = bo.$parent;
            }

            return bo;
        }

        function isTextAnnotation(element) {
            return is(element, 'bpmn:TextAnnotation');
        }

        function isCompensationBoundary(element) {
            return is(element, 'bpmn:BoundaryEvent') &&
                hasEventDefinition(element, 'bpmn:CompensateEventDefinition');
        }

        function isForCompensation(e) {
            return getBusinessObject(e).isForCompensation;
        }

        function isSameOrganization(a, b) {
            var parentA = getOrganizationalParent(a),
                parentB = getOrganizationalParent(b);

            return parentA === parentB;
        }

        function isMessageFlowSource(element) {
            return is(element, 'bpmn:InteractionNode') &&
                !isForCompensation(element) && (
                    !is(element, 'bpmn:Event') || (
                        is(element, 'bpmn:ThrowEvent') &&
                        hasEventDefinitionOrNone(element, 'bpmn:MessageEventDefinition')
                    )
                );
        }

        function isMessageFlowTarget(element) {
            return is(element, 'bpmn:InteractionNode') &&
                !isForCompensation(element) && (
                    !is(element, 'bpmn:Event') || (
                        is(element, 'bpmn:CatchEvent') &&
                        hasEventDefinitionOrNone(element, 'bpmn:MessageEventDefinition')
                    )
                );
        }

        function getScopeParent(element) {

            var bo = getBusinessObject(element);

            if (is(bo, 'bpmn:Participant')) {
                return null;
            }

            while (bo) {
                bo = bo.$parent;

                if (is(bo, 'bpmn:FlowElementsContainer')) {
                    return bo;
                }
            }

            return bo;
        }

        function isSameScope(a, b) {
            var scopeParentA = getScopeParent(a),
                scopeParentB = getScopeParent(b);

            return scopeParentA && (scopeParentA === scopeParentB);
        }

        function hasEventDefinition(element, eventDefinition) {
            var bo = getBusinessObject(element);

            return !!find(bo.eventDefinitions || [], function (definition) {
                return is(definition, eventDefinition);
            });
        }

        function hasEventDefinitionOrNone(element, eventDefinition) {
            var bo = getBusinessObject(element);

            return (bo.eventDefinitions || []).every(function (definition) {
                return is(definition, eventDefinition);
            });
        }

        function isSequenceFlowSource(element) {
            return is(element, 'bpmn:FlowNode') &&
                !is(element, 'bpmn:EndEvent') &&
                !isEventSubProcess(element) &&
                !(is(element, 'bpmn:IntermediateThrowEvent') &&
                    hasEventDefinition(element, 'bpmn:LinkEventDefinition')
                ) &&
                !isCompensationBoundary(element) &&
                !isForCompensation(element);
        }

        function isSequenceFlowTarget(element) {
            return is(element, 'bpmn:FlowNode') &&
                !is(element, 'bpmn:StartEvent') &&
                !is(element, 'bpmn:BoundaryEvent') &&
                !isEventSubProcess(element) &&
                !(is(element, 'bpmn:IntermediateCatchEvent') &&
                    hasEventDefinition(element, 'bpmn:LinkEventDefinition')
                ) &&
                !isForCompensation(element);

        }

        function isEventBasedTarget(element) {
            return is(element, 'bpmn:ReceiveTask') || (
                is(element, 'bpmn:IntermediateCatchEvent') && (
                    hasEventDefinition(element, 'bpmn:MessageEventDefinition') ||
                    hasEventDefinition(element, 'bpmn:TimerEventDefinition') ||
                    hasEventDefinition(element, 'bpmn:ConditionalEventDefinition') ||
                    hasEventDefinition(element, 'bpmn:SignalEventDefinition')
                )
            );
        }

        function isLabel(element) {
            return element.labelTarget;
        }

        function isConnection(element) {
            return element.waypoints;
        }

        function getParents(element) {

            var parents = [];

            while (element) {
                element = element.parent;

                if (element) {
                    parents.push(element);
                }
            }

            return parents;
        }

        function isParent(possibleParent, element) {
            var allParents = getParents(element);
            return allParents.indexOf(possibleParent) !== -1;
        }

        function canConnect(source, target, connection) {

            if (nonExistantOrLabel(source) || nonExistantOrLabel(target)) {
                return null;
            }

            // See https://github.com/bpmn-io/bpmn-js/issues/178
            // as a workround we disallow connections with same
            // target and source element.
            // This rule must be removed if a auto layout for this
            // connections is implemented.
            if (isSame(source, target)) {
                return false;
            }

            if (!is(connection, 'bpmn:DataAssociation')) {

                if (canConnectMessageFlow(source, target)) {
                    return { type: 'bpmn:MessageFlow' };
                }

                if (canConnectSequenceFlow(source, target)) {
                    return { type: 'bpmn:SequenceFlow' };
                }
            }

            var connectDataAssociation = canConnectDataAssociation(source, target);

            if (connectDataAssociation) {
                return connectDataAssociation;
            }

            if (isCompensationBoundary(source) && isForCompensation(target)) {
                return {
                    type: 'bpmn:Association',
                    associationDirection: 'One'
                };
            }

            if (canConnectAssociation(source, target)) {

                return {
                    type: 'bpmn:Association'
                };
            }

            return false;
        }

        /**
         * Can an element be dropped into the target element
         *
         * @return {Boolean}
         */
        function canDrop(element, target, position) {

            // can move labels everywhere
            if (isLabel(element) && !isConnection(target)) {
                return true;
            }

            // disallow to create elements on collapsed pools
            if (is(target, 'bpmn:Participant') && !isExpanded(target)) {
                return false;
            }

            // allow to create new participants on
            // on existing collaboration and process diagrams
            if (is(element, 'bpmn:Participant')) {
                return is(target, 'bpmn:Process') || is(target, 'bpmn:Collaboration');
            }

            // allow creating lanes on participants and other lanes only
            if (is(element, 'bpmn:Lane')) {
                return is(target, 'bpmn:Participant') || is(target, 'bpmn:Lane');
            }

            if (is(element, 'bpmn:BoundaryEvent')) {
                return false;
            }

            // drop flow elements onto flow element containers
            // and participants
            if (is(element, 'bpmn:FlowElement')) {
                if (is(target, 'bpmn:FlowElementsContainer')) {
                    return isExpanded(target);
                }

                return isAny(target, ['bpmn:Participant', 'bpmn:Lane']);
            }

            // account for the fact that data associations are always
            // rendered and moved to top (Process or Collaboration level)
            //
            // artifacts may be placed wherever, too
            if (isAny(element, ['bpmn:Artifact', 'bpmn:DataAssociation'])) {
                return isAny(target, [
                    'bpmn:Collaboration',
                    'bpmn:Lane',
                    'bpmn:Participant',
                    'bpmn:Process',
                    'bpmn:SubProcess']);
            }

            if (is(element, 'bpmn:MessageFlow')) {
                return is(target, 'bpmn:Collaboration')
                    || element.source.parent == target
                    || element.target.parent == target;
            }

            return false;
        }

        function canPaste(tree, target) {
            var topLevel = tree[0],
                participants;

            if (is(target, 'bpmn:Collaboration')) {
                return every(topLevel, function (e) {
                    return e.type === 'bpmn:Participant';
                });
            }

            if (is(target, 'bpmn:Process')) {
                participants = any(topLevel, function (e) {
                    return e.type === 'bpmn:Participant';
                });

                return !(participants && target.children.length > 0);
            }

            // disallow to create elements on collapsed pools
            if (is(target, 'bpmn:Participant') && !isExpanded(target)) {
                return false;
            }

            if (is(target, 'bpmn:FlowElementsContainer')) {
                return isExpanded(target);
            }

            return isAny(target, [
                'bpmn:Collaboration',
                'bpmn:Lane',
                'bpmn:Participant',
                'bpmn:Process',
                'bpmn:SubProcess']);
        }

        function isBoundaryEvent(element) {
            return !isLabel(element) && is(element, 'bpmn:BoundaryEvent');
        }

        function isLane(element) {
            return is(element, 'bpmn:Lane');
        }

        /**
         * We treat IntermediateThrowEvents as boundary events during create,
         * this must be reflected in the rules.
         */
        function isBoundaryCandidate(element) {
            return isBoundaryEvent(element) ||
                (is(element, 'bpmn:IntermediateThrowEvent') && !element.parent);
        }


        function canAttach(elements, target, source, position) {

            if (!Array.isArray(elements)) {
                elements = [elements];
            }

            // disallow appending as boundary event
            if (source) {
                return false;
            }

            // only (re-)attach one element at a time
            if (elements.length !== 1) {
                return false;
            }

            var element = elements[0];

            // do not attach labels
            if (isLabel(element)) {
                return false;
            }

            // only handle boundary events
            if (!isBoundaryCandidate(element)) {
                return false;
            }

            // allow default move operation
            if (!target) {
                return true;
            }

            // disallow drop on event sub processes
            if (isEventSubProcess(target)) {
                return false;
            }

            // only allow drop on non compensation activities
            if (!is(target, 'bpmn:Activity') || isForCompensation(target)) {
                return false;
            }

            // only attach to subprocess border
            if (position && !isBoundaryAttachment(position, target)) {
                return false;
            }

            return 'attach';
        }


        /**
         * Defines how to replace elements for a given target.
         *
         * Returns an array containing all elements which will be replaced.
         *
         * @example
         *
         *  [{ id: 'IntermediateEvent_2',
         *     type: 'bpmn:StartEvent'
         *   },
         *   { id: 'IntermediateEvent_5',
         *     type: 'bpmn:EndEvent'
         *   }]
         *
         * @param  {Array} elements
         * @param  {Object} target
         *
         * @return {Object} an object containing all elements which have to be replaced
         */
        function canReplace(elements, target, position) {

            if (!target) {
                return false;
            }

            var canExecute = {
                replacements: []
            };

            forEach(elements, function (element) {

                if (!isEventSubProcess(target)) {

                    if (is(element, 'bpmn:StartEvent') &&
                        element.type !== 'label' &&
                        canDrop(element, target)) {

                        // replace a non-interrupting start event by a blank interrupting start event
                        // when the target is not an event sub process
                        if (!isInterrupting(element)) {
                            canExecute.replacements.push({
                                oldElementId: element.id,
                                newElementType: 'bpmn:StartEvent'
                            });
                        }

                        // replace an error/escalation/compansate start event by a blank interrupting start event
                        // when the target is not an event sub process
                        if (hasErrorEventDefinition(element) ||
                            hasEscalationEventDefinition(element) ||
                            hasCompensateEventDefinition(element)) {
                            canExecute.replacements.push({
                                oldElementId: element.id,
                                newElementType: 'bpmn:StartEvent'
                            });
                        }
                    }
                }

                if (!is(target, 'bpmn:Transaction')) {
                    if (hasEventDefinition(element, 'bpmn:CancelEventDefinition') &&
                        element.type !== 'label') {

                        if (is(element, 'bpmn:EndEvent') && canDrop(element, target)) {
                            canExecute.replacements.push({
                                oldElementId: element.id,
                                newElementType: 'bpmn:EndEvent'
                            });
                        }

                        if (is(element, 'bpmn:BoundaryEvent') && canAttach(element, target, null, position)) {
                            canExecute.replacements.push({
                                oldElementId: element.id,
                                newElementType: 'bpmn:BoundaryEvent'
                            });
                        }
                    }
                }
            });

            return canExecute.replacements.length ? canExecute : false;
        }

        function canMove(elements, target) {

            // do not move selection containing boundary events
            if (any(elements, isBoundaryEvent)) {
                return false;
            }

            // do not move selection containing lanes
            if (any(elements, isLane)) {
                return false;
            }

            // allow default move check to start move operation
            if (!target) {
                return true;
            }

            return elements.every(function (element) {
                return canDrop(element, target);
            });
        }

        function canCreate(shape, target, source, position) {

            if (!target) {
                return false;
            }

            if (isLabel(target)) {
                return null;
            }

            if (isSame(source, target)) {
                return false;
            }

            // ensure we do not drop the element
            // into source
            if (source && isParent(source, target)) {
                return false;
            }

            return canDrop(shape, target, position) || canInsert(shape, target, position);
        }

        function canResize(shape, newBounds) {
            if (is(shape, 'bpmn:SubProcess')) {
                return (!!isExpanded(shape)) && (
                    !newBounds || (newBounds.width >= 100 && newBounds.height >= 80)
                );
            }

            if (is(shape, 'bpmn:Lane')) {
                return !newBounds || (newBounds.width >= 130 && newBounds.height >= 60);
            }

            if (is(shape, 'bpmn:Participant')) {
                return !newBounds || (newBounds.width >= 250 && newBounds.height >= 50);
            }

            if (isTextAnnotation(shape)) {
                return true;
            }

            return false;
        }

        /**
         * Check, whether one side of the relationship
         * is a text annotation.
         */
        function isOneTextAnnotation(source, target) {

            var sourceTextAnnotation = isTextAnnotation(source),
                targetTextAnnotation = isTextAnnotation(target);

            return (
                (sourceTextAnnotation || targetTextAnnotation) &&
                (sourceTextAnnotation !== targetTextAnnotation)
            );
        }


        function canConnectAssociation(source, target) {

            // do not connect connections
            if (isConnection(source) || isConnection(target)) {
                return false;
            }

            // compensation boundary events are exception
            if (isCompensationBoundary(source) && isForCompensation(target)) {
                return true;
            }

            // don't connect parent <-> child
            if (isParent(target, source) || isParent(source, target)) {
                return false;
            }

            // allow connection of associations between <!TextAnnotation> and <TextAnnotation>
            return isOneTextAnnotation(source, target);
        }

        function canConnectMessageFlow(source, target) {

            return isMessageFlowSource(source) &&
                isMessageFlowTarget(target) &&
                !isSameOrganization(source, target);
        }

        function canConnectSequenceFlow(source, target) {

            return isSequenceFlowSource(source) &&
                isSequenceFlowTarget(target) &&
                isSameScope(source, target) &&
                !(is(source, 'bpmn:EventBasedGateway') && !isEventBasedTarget(target));
        }


        function canConnectDataAssociation(source, target) {

            if (isAny(source, ['bpmn:DataObjectReference', 'bpmn:DataStoreReference']) &&
                isAny(target, ['bpmn:Activity', 'bpmn:ThrowEvent'])) {
                return { type: 'bpmn:DataInputAssociation' };
            }

            if (isAny(target, ['bpmn:DataObjectReference', 'bpmn:DataStoreReference']) &&
                isAny(source, ['bpmn:Activity', 'bpmn:CatchEvent'])) {
                return { type: 'bpmn:DataOutputAssociation' };
            }

            return false;
        }

        function canInsert(shape, flow, position) {

            if (Array.isArray(shape)) {
                if (shape.length !== 1) {
                    return false;
                }

                shape = shape[0];
            }

            // return true if we can drop on the
            // underlying flow parent
            //
            // at this point we are not really able to talk
            // about connection rules (yet)

            return (
                isAny(flow, ['bpmn:SequenceFlow', 'bpmn:MessageFlow']) &&
                !isLabel(flow) &&
                is(shape, 'bpmn:FlowNode') &&
                !is(shape, 'bpmn:BoundaryEvent') &&
                canDrop(shape, flow.parent, position));
        }

        function contains(collection, element) {
            return (collection && element) && collection.indexOf(element) !== -1;
        }

        function canCopy(collection, element) {
            if (is(element, 'bpmn:Lane') && !contains(collection, element.parent)) {
                return false;
            }

            if (is(element, 'bpmn:BoundaryEvent') && !contains(collection, element.host)) {
                return false;
            }

            return true;
        }

    }, { "../../util/DiUtil": 93, "../../util/ModelUtil": 95, "../modeling/util/ModelingUtil": 68, "../snapping/BpmnSnappingUtil": 86, "diagram-js/lib/features/rules/RuleProvider": 225, "inherits": 289, "lodash/collection/any": 300, "lodash/collection/every": 301, "lodash/collection/filter": 302, "lodash/collection/find": 303, "lodash/collection/forEach": 304 }], 82: [function (require, module, exports) {
        module.exports = {
            __depends__: [
                require('diagram-js/lib/features/rules')
            ],
            __init__: ['bpmnRules'],
            bpmnRules: ['type', require('./BpmnRules')]
        };

    }, { "./BpmnRules": 81, "diagram-js/lib/features/rules": 227 }], 83: [function (require, module, exports) {
        'use strict';

        var map = require('lodash/collection/map'),
            filter = require('lodash/collection/filter'),
            sortBy = require('lodash/collection/sortBy');

        var labelUtil = require('../label-editing/LabelUtil');


        /**
         * Provides ability to search through BPMN elements
         */
        function BpmnSearchProvider(elementRegistry, searchPad, canvas) {

            this._elementRegistry = elementRegistry;
            this._canvas = canvas;

            searchPad.registerProvider(this);
        }

        module.exports = BpmnSearchProvider;

        BpmnSearchProvider.$inject = [
            'elementRegistry',
            'searchPad',
            'canvas'
        ];


        /**
         * Finds all elements that match given pattern
         *
         * <Result> :
         *  {
         *    primaryTokens: <Array<Token>>,
         *    secondaryTokens: <Array<Token>>,
         *    element: <Element>
         *  }
         *
         * <Token> :
         *  {
         *    normal|matched: <String>
         *  }
         *
         * @param  {String} pattern
         * @return {Array<Result>}
         */
        BpmnSearchProvider.prototype.find = function (pattern) {
            var rootElement = this._canvas.getRootElement();

            var elements = this._elementRegistry.filter(function (element) {
                if (element.labelTarget) {
                    return false;
                }
                return true;
            });

            // do not include root element
            elements = filter(elements, function (element) {
                return element !== rootElement;
            });

            elements = map(elements, function (element) {
                return {
                    primaryTokens: matchAndSplit(labelUtil.getLabel(element), pattern),
                    secondaryTokens: matchAndSplit(element.id, pattern),
                    element: element
                };
            });

            // exclude non-matched elements
            elements = filter(elements, function (element) {
                return hasMatched(element.primaryTokens) || hasMatched(element.secondaryTokens);
            });

            elements = sortBy(elements, function (element) {
                return labelUtil.getLabel(element.element) + element.element.id;
            });

            return elements;
        };


        function hasMatched(tokens) {
            var matched = filter(tokens, function (t) {
                return !!t.matched;
            });

            return matched.length > 0;
        }


        function matchAndSplit(text, pattern) {
            var tokens = [],
                originalText = text;

            if (!text) {
                return tokens;
            }

            text = text.toLowerCase();
            pattern = pattern.toLowerCase();

            var i = text.indexOf(pattern);

            if (i > -1) {
                if (i !== 0) {
                    tokens.push({
                        normal: originalText.substr(0, i)
                    });
                }

                tokens.push({
                    matched: originalText.substr(i, pattern.length)
                });

                if (pattern.length + i < text.length) {
                    tokens.push({
                        normal: originalText.substr(pattern.length + i, text.length)
                    });
                }
            } else {
                tokens.push({
                    normal: originalText
                });
            }

            return tokens;
        }
    }, { "../label-editing/LabelUtil": 25, "lodash/collection/filter": 302, "lodash/collection/map": 306, "lodash/collection/sortBy": 311 }], 84: [function (require, module, exports) {
        module.exports = {
            __depends__: [
                require('diagram-js/lib/features/search-pad')
            ],
            __init__: ['bpmnSearch'],
            bpmnSearch: ['type', require('./BpmnSearchProvider')]
        };

    }, { "./BpmnSearchProvider": 83, "diagram-js/lib/features/search-pad": 229 }], 85: [function (require, module, exports) {
        'use strict';

        var inherits = require('inherits');

        var abs = Math.abs;

        var forEach = require('lodash/collection/forEach'),
            filter = require('lodash/collection/filter'),
            assign = require('lodash/object/assign');

        var getBoundingBox = require('diagram-js/lib/util/Elements').getBBox;

        var is = require('../../util/ModelUtil').is,
            isAny = require('../modeling/util/ModelingUtil').isAny,
            isExpanded = require('../../util/DiUtil').isExpanded;

        var Snapping = require('diagram-js/lib/features/snapping/Snapping'),
            SnapUtil = require('diagram-js/lib/features/snapping/SnapUtil');

        var asTRBL = require('diagram-js/lib/layout/LayoutUtil').asTRBL;

        var round = Math.round;

        var mid = SnapUtil.mid,
            topLeft = SnapUtil.topLeft,
            bottomRight = SnapUtil.bottomRight,
            isSnapped = SnapUtil.isSnapped,
            setSnapped = SnapUtil.setSnapped;

        var getBoundaryAttachment = require('./BpmnSnappingUtil').getBoundaryAttachment,
            getParticipantSizeConstraints = require('./BpmnSnappingUtil').getParticipantSizeConstraints,
            getLanesRoot = require('../modeling/util/LaneUtil').getLanesRoot;

        var HIGH_PRIORITY = 1500;


        /**
         * BPMN specific snapping functionality
         *
         *  * snap on process elements if a pool is created inside a
         *    process diagram
         *
         * @param {EventBus} eventBus
         * @param {Canvas} canvas
         */
        function BpmnSnapping(eventBus, canvas, bpmnRules, elementRegistry) {

            // instantiate super
            Snapping.call(this, eventBus, canvas);


            /**
             * Drop participant on process <> process elements snapping
             */
            eventBus.on('create.start', function (event) {

                var context = event.context,
                    shape = context.shape,
                    rootElement = canvas.getRootElement();

                // snap participant around existing elements (if any)
                if (is(shape, 'bpmn:Participant') && is(rootElement, 'bpmn:Process')) {
                    initParticipantSnapping(context, shape, rootElement.children);
                }
            });

            eventBus.on(['create.move', 'create.end'], HIGH_PRIORITY, function (event) {

                var context = event.context,
                    shape = context.shape,
                    participantSnapBox = context.participantSnapBox;

                if (!isSnapped(event) && participantSnapBox) {
                    snapParticipant(participantSnapBox, shape, event);
                }
            });

            eventBus.on('shape.move.start', function (event) {

                var context = event.context,
                    shape = context.shape,
                    rootElement = canvas.getRootElement();

                // snap participant around existing elements (if any)
                if (is(shape, 'bpmn:Participant') && is(rootElement, 'bpmn:Process')) {
                    initParticipantSnapping(context, shape, rootElement.children);
                }
            });


            function canAttach(shape, target, position) {
                return bpmnRules.canAttach([shape], target, null, position) === 'attach';
            }

            function canConnect(source, target) {
                return bpmnRules.canConnect(source, target);
            }

            /**
             * Snap boundary events to elements border
             */
            eventBus.on([
                'create.move',
                'create.end',
                'shape.move.move',
                'shape.move.end'
            ], HIGH_PRIORITY, function (event) {

                var context = event.context,
                    target = context.target,
                    shape = context.shape;

                if (target && !isSnapped(event) && canAttach(shape, target, event)) {
                    snapBoundaryEvent(event, shape, target);
                }
            });

            /**
             * Adjust parent for flowElements to the target participant
             * when droping onto lanes.
             */
            eventBus.on([
                'shape.move.hover',
                'shape.move.move',
                'shape.move.end',
                'create.hover',
                'create.move',
                'create.end'
            ], HIGH_PRIORITY, function (event) {
                var context = event.context,
                    shape = context.shape,
                    hover = event.hover;

                if (is(hover, 'bpmn:Lane') && !isAny(shape, ['bpmn:Lane', 'bpmn:Participant'])) {
                    event.hover = getLanesRoot(hover);
                    event.hoverGfx = elementRegistry.getGraphics(event.hover);
                }
            });

            /**
             * Snap sequence flows.
             */
            eventBus.on([
                'connect.move',
                'connect.hover',
                'connect.end'
            ], HIGH_PRIORITY, function (event) {
                var context = event.context,
                    source = context.source,
                    target = context.target;

                var connection = canConnect(source, target) || {};

                if (!context.initialSourcePosition) {
                    context.initialSourcePosition = context.sourcePosition;
                }

                if (target && connection.type === 'bpmn:SequenceFlow') {

                    // snap source
                    context.sourcePosition = mid(source);

                    // snap target
                    assign(event, mid(target));
                } else {

                    // otherwise reset source snap
                    context.sourcePosition = context.initialSourcePosition;
                }

            });


            eventBus.on([
                'create.move',
                'shape.move.move'
            ], function (event) {

                var context = event.context,
                    shape = context.shape,
                    target = context.target;

                var threshold = 30;

                if (is(shape, 'bpmn:Lane')) {
                    if (isAny(target, ['bpmn:Lane', 'bpmn:Participant'])) {

                        var childLanes = filter(target.children, function (c) {
                            return is(c, 'bpmn:Lane');
                        });

                        var y = event.y,
                            targetTrbl;

                        var insert = childLanes.reduce(function (insert, l) {

                            var laneTrbl = asTRBL(l);

                            if (abs(laneTrbl.top - y) < threshold) {
                                insert = assign(insert || {}, { before: { element: l, y: laneTrbl.top } });
                            } else
                                if (abs(laneTrbl.bottom - y) < threshold) {
                                    insert = assign(insert || {}, { after: { element: l, y: laneTrbl.bottom } });
                                } else
                                    if (laneTrbl.top < y && laneTrbl.bottom > y) {
                                        if (abs(laneTrbl.top - y) > abs(laneTrbl.bottom - y)) {
                                            insert = assign(insert || {}, { after: { element: l, y: laneTrbl.bottom } });
                                        } else {
                                            insert = assign(insert || {}, { before: { element: l, y: laneTrbl.top } });
                                        }

                                    }

                            return insert;
                        }, false);


                        if (!insert) {
                            targetTrbl = asTRBL(target);

                            if (abs(targetTrbl.top - y) < threshold) {
                                insert = { before: { element: target, y: targetTrbl.top } };
                            } else
                                if (abs(targetTrbl.bottom - y) < threshold) {
                                    insert = { after: { element: target, y: targetTrbl.bottom } };
                                } else {
                                    insert = { into: { element: target, y: (targetTrbl.top + targetTrbl.bottom) / 2 } };
                                }

                        }

                        if (insert.before && insert.after) {
                            console.log('insert between', insert.before.element.id, 'and', insert.after.element.id);
                            setSnapped(event, 'x', insert.before.element.x + insert.before.element.width / 2);
                            setSnapped(event, 'y', insert.before.y);
                        } else
                            if (insert.after) {
                                console.log('insert after', insert.after.element.id);
                                setSnapped(event, 'x', insert.after.element.x + insert.after.element.width / 2);
                                setSnapped(event, 'y', insert.after.y);
                            } else
                                if (insert.before) {
                                    console.log('insert before', insert.before.element.id);
                                    setSnapped(event, 'x', insert.before.element.x + insert.before.element.width / 2);
                                    setSnapped(event, 'y', insert.before.y);
                                } else
                                    if (insert.into) {
                                        console.log('insert into', insert.into.element.id);
                                        setSnapped(event, 'x', insert.into.element.x + insert.into.element.width / 2);
                                        setSnapped(event, 'y', insert.into.y);
                                    }
                    }
                }

            });

            eventBus.on('resize.start', HIGH_PRIORITY, function (event) {
                var context = event.context,
                    shape = context.shape;

                if (is(shape, 'bpmn:SubProcess') && isExpanded(shape)) {
                    context.minDimensions = { width: 140, height: 120 };
                }

                if (is(shape, 'bpmn:Participant')) {
                    context.minDimensions = { width: 300, height: 150 };
                }

                if (is(shape, 'bpmn:Lane') || is(shape, 'bpmn:Participant')) {
                    context.resizeConstraints = getParticipantSizeConstraints(shape, context.direction, context.balanced);
                }

                if (is(shape, 'bpmn:TextAnnotation')) {
                    context.minDimensions = { width: 50, height: 30 };
                }
            });

        }

        inherits(BpmnSnapping, Snapping);

        BpmnSnapping.$inject = ['eventBus', 'canvas', 'bpmnRules', 'elementRegistry'];

        module.exports = BpmnSnapping;


        BpmnSnapping.prototype.initSnap = function (event) {

            var context = event.context,
                shape = event.shape,
                shapeMid,
                shapeBounds,
                shapeTopLeft,
                shapeBottomRight,
                snapContext;


            snapContext = Snapping.prototype.initSnap.call(this, event);

            if (is(shape, 'bpmn:Participant')) {
                // assign higher priority for outer snaps on participants
                snapContext.setSnapLocations(['top-left', 'bottom-right', 'mid']);
            }


            if (shape) {

                shapeMid = mid(shape, event);

                shapeBounds = {
                    width: shape.width,
                    height: shape.height,
                    x: isNaN(shape.x) ? round(shapeMid.x - shape.width / 2) : shape.x,
                    y: isNaN(shape.y) ? round(shapeMid.y - shape.height / 2) : shape.y
                };

                shapeTopLeft = topLeft(shapeBounds);
                shapeBottomRight = bottomRight(shapeBounds);

                snapContext.setSnapOrigin('top-left', {
                    x: shapeTopLeft.x - event.x,
                    y: shapeTopLeft.y - event.y
                });

                snapContext.setSnapOrigin('bottom-right', {
                    x: shapeBottomRight.x - event.x,
                    y: shapeBottomRight.y - event.y
                });

                forEach(shape.outgoing, function (c) {
                    var docking = c.waypoints[0];

                    docking = docking.original || docking;

                    snapContext.setSnapOrigin(c.id + '-docking', {
                        x: docking.x - event.x,
                        y: docking.y - event.y
                    });
                });

                forEach(shape.incoming, function (c) {
                    var docking = c.waypoints[c.waypoints.length - 1];

                    docking = docking.original || docking;

                    snapContext.setSnapOrigin(c.id + '-docking', {
                        x: docking.x - event.x,
                        y: docking.y - event.y
                    });
                });

            }

            var source = context.source;

            if (source) {
                snapContext.addDefaultSnap('mid', mid(source));
            }
        };


        BpmnSnapping.prototype.addTargetSnaps = function (snapPoints, shape, target) {

            // use target parent as snap target
            if (is(shape, 'bpmn:BoundaryEvent') && shape.type !== 'label') {
                target = target.parent;
            }

            // add sequence flow parents as snap targets
            if (is(target, 'bpmn:SequenceFlow')) {
                this.addTargetSnaps(snapPoints, shape, target.parent);
            }

            var siblings = this.getSiblings(shape, target) || [];

            forEach(siblings, function (s) {

                // do not snap to lanes
                if (is(s, 'bpmn:Lane')) {
                    return;
                }

                snapPoints.add('mid', mid(s));

                if (is(s, 'bpmn:Participant')) {
                    snapPoints.add('top-left', topLeft(s));
                    snapPoints.add('bottom-right', bottomRight(s));
                }
            });


            forEach(shape.incoming, function (c) {

                if (siblings.indexOf(c.source) === -1) {
                    snapPoints.add('mid', mid(c.source));
                }

                var docking = c.waypoints[0];
                snapPoints.add(c.id + '-docking', docking.original || docking);
            });


            forEach(shape.outgoing, function (c) {

                if (siblings.indexOf(c.target) === -1) {
                    snapPoints.add('mid', mid(c.target));
                }

                var docking = c.waypoints[c.waypoints.length - 1];
                snapPoints.add(c.id + '-docking', docking.original || docking);
            });
        };


        /////// participant snapping //////////////////

        function initParticipantSnapping(context, shape, elements) {

            if (!elements.length) {
                return;
            }

            var snapBox = getBoundingBox(elements.filter(function (e) {
                return !e.labelTarget && !e.waypoints;
            }));

            snapBox.x -= 50;
            snapBox.y -= 20;
            snapBox.width += 70;
            snapBox.height += 40;

            // adjust shape height to include bounding box
            shape.width = Math.max(shape.width, snapBox.width);
            shape.height = Math.max(shape.height, snapBox.height);

            context.participantSnapBox = snapBox;
        }

        function snapParticipant(snapBox, shape, event, offset) {
            offset = offset || 0;

            var shapeHalfWidth = shape.width / 2 - offset,
                shapeHalfHeight = shape.height / 2;

            var currentTopLeft = {
                x: event.x - shapeHalfWidth - offset,
                y: event.y - shapeHalfHeight
            };

            var currentBottomRight = {
                x: event.x + shapeHalfWidth + offset,
                y: event.y + shapeHalfHeight
            };

            var snapTopLeft = snapBox,
                snapBottomRight = bottomRight(snapBox);

            if (currentTopLeft.x >= snapTopLeft.x) {
                setSnapped(event, 'x', snapTopLeft.x + offset + shapeHalfWidth);
            } else
                if (currentBottomRight.x <= snapBottomRight.x) {
                    setSnapped(event, 'x', snapBottomRight.x - offset - shapeHalfWidth);
                }

            if (currentTopLeft.y >= snapTopLeft.y) {
                setSnapped(event, 'y', snapTopLeft.y + shapeHalfHeight);
            } else
                if (currentBottomRight.y <= snapBottomRight.y) {
                    setSnapped(event, 'y', snapBottomRight.y - shapeHalfHeight);
                }
        }


        /////// boundary event snapping /////////////////////////


        function snapBoundaryEvent(event, shape, target) {
            var targetTRBL = asTRBL(target);

            var direction = getBoundaryAttachment(event, target);

            if (/top/.test(direction)) {
                setSnapped(event, 'y', targetTRBL.top);
            } else
                if (/bottom/.test(direction)) {
                    setSnapped(event, 'y', targetTRBL.bottom);
                }

            if (/left/.test(direction)) {
                setSnapped(event, 'x', targetTRBL.left);
            } else
                if (/right/.test(direction)) {
                    setSnapped(event, 'x', targetTRBL.right);
                }
        }

    }, { "../../util/DiUtil": 93, "../../util/ModelUtil": 95, "../modeling/util/LaneUtil": 67, "../modeling/util/ModelingUtil": 68, "./BpmnSnappingUtil": 86, "diagram-js/lib/features/snapping/SnapUtil": 235, "diagram-js/lib/features/snapping/Snapping": 236, "diagram-js/lib/layout/LayoutUtil": 252, "diagram-js/lib/util/Elements": 266, "inherits": 289, "lodash/collection/filter": 302, "lodash/collection/forEach": 304, "lodash/object/assign": 433 }], 86: [function (require, module, exports) {
        'use strict';

        var getOrientation = require('diagram-js/lib/layout/LayoutUtil').getOrientation;


        function getBoundaryAttachment(position, targetBounds) {

            var orientation = getOrientation(position, targetBounds, -15);

            if (orientation !== 'intersect') {
                return orientation;
            } else {
                return null;
            }
        }

        module.exports.getBoundaryAttachment = getBoundaryAttachment;



        // participant snapping box implementation /////////////////

        var is = require('../../util/ModelUtil').is;

        var asTRBL = require('diagram-js/lib/layout/LayoutUtil').asTRBL;

        var collectLanes = require('../modeling/util/LaneUtil').collectLanes,
            getLanesRoot = require('../modeling/util/LaneUtil').getLanesRoot;

        var abs = Math.abs,
            min = Math.min,
            max = Math.max;


        function addToTrbl(trbl, attr, value, choice) {

            var current = trbl[attr];

            // make sure to set the value if it does not exist
            // or apply the correct value by comparing against
            // choice(value, currentValue)
            trbl[attr] = current === undefined ? value : choice(value, current);
        }

        function addMin(trbl, attr, value) {
            return addToTrbl(trbl, attr, value, min);
        }

        function addMax(trbl, attr, value) {
            return addToTrbl(trbl, attr, value, max);
        }


        var LANE_MIN_HEIGHT = 60,
            LANE_MIN_WIDTH = 300,
            LANE_RIGHT_PADDING = 20,
            LANE_LEFT_PADDING = 50,
            LANE_TOP_PADDING = 20,
            LANE_BOTTOM_PADDING = 20;


        function getParticipantSizeConstraints(laneShape, resizeDirection, balanced) {

            var lanesRoot = getLanesRoot(laneShape);

            var isFirst = true,
                isLast = true;

            ///// max top/bottom size for lanes

            var allLanes = collectLanes(lanesRoot, [lanesRoot]);

            var laneTrbl = asTRBL(laneShape);

            var maxTrbl = {},
                minTrbl = {};

            if (/e/.test(resizeDirection)) {
                minTrbl.right = laneTrbl.left + LANE_MIN_WIDTH;
            } else
                if (/w/.test(resizeDirection)) {
                    minTrbl.left = laneTrbl.right - LANE_MIN_WIDTH;
                }

            allLanes.forEach(function (other) {

                var otherTrbl = asTRBL(other);

                if (/n/.test(resizeDirection)) {

                    if (otherTrbl.top < (laneTrbl.top - 10)) {
                        isFirst = false;
                    }

                    // max top size (based on next element)
                    if (balanced && abs(laneTrbl.top - otherTrbl.bottom) < 10) {
                        addMax(maxTrbl, 'top', otherTrbl.top + LANE_MIN_HEIGHT);
                    }

                    // min top size (based on self or nested element)
                    if (abs(laneTrbl.top - otherTrbl.top) < 5) {
                        addMin(minTrbl, 'top', otherTrbl.bottom - LANE_MIN_HEIGHT);
                    }
                }

                if (/s/.test(resizeDirection)) {

                    if (otherTrbl.bottom > (laneTrbl.bottom + 10)) {
                        isLast = false;
                    }

                    // max bottom size (based on previous element)
                    if (balanced && abs(laneTrbl.bottom - otherTrbl.top) < 10) {
                        addMin(maxTrbl, 'bottom', otherTrbl.bottom - LANE_MIN_HEIGHT);
                    }

                    // min bottom size (based on self or nested element)
                    if (abs(laneTrbl.bottom - otherTrbl.bottom) < 5) {
                        addMax(minTrbl, 'bottom', otherTrbl.top + LANE_MIN_HEIGHT);
                    }
                }
            });


            ///// max top/bottom/left/right size based on flow nodes

            var flowElements = lanesRoot.children.filter(function (s) {
                return !s.hidden && !s.waypoints && (is(s, 'bpmn:FlowElement') || is(s, 'bpmn:Artifact'));
            });

            flowElements.forEach(function (flowElement) {

                var flowElementTrbl = asTRBL(flowElement);

                if (isFirst && /n/.test(resizeDirection)) {
                    addMin(minTrbl, 'top', flowElementTrbl.top - LANE_TOP_PADDING);
                }

                if (/e/.test(resizeDirection)) {
                    addMax(minTrbl, 'right', flowElementTrbl.right + LANE_RIGHT_PADDING);
                }

                if (isLast && /s/.test(resizeDirection)) {
                    addMax(minTrbl, 'bottom', flowElementTrbl.bottom + LANE_BOTTOM_PADDING);
                }

                if (/w/.test(resizeDirection)) {
                    addMin(minTrbl, 'left', flowElementTrbl.left - LANE_LEFT_PADDING);
                }
            });


            return {
                min: minTrbl,
                max: maxTrbl
            };
        }


        module.exports.getParticipantSizeConstraints = getParticipantSizeConstraints;
    }, { "../../util/ModelUtil": 95, "../modeling/util/LaneUtil": 67, "diagram-js/lib/layout/LayoutUtil": 252 }], 87: [function (require, module, exports) {
        module.exports = {
            __init__: ['snapping'],
            snapping: ['type', require('./BpmnSnapping')]
        };
    }, { "./BpmnSnapping": 85 }], 88: [function (require, module, exports) {
        'use strict';

        var assign = require('lodash/object/assign'),
            map = require('lodash/collection/map');

        var LabelUtil = require('../util/LabelUtil');

        var TextUtil = require('diagram-js/lib/util/Text');

        var is = require('../util/ModelUtil').is;

        var hasExternalLabel = LabelUtil.hasExternalLabel,
            getExternalLabelBounds = LabelUtil.getExternalLabelBounds,
            isExpanded = require('../util/DiUtil').isExpanded,
            elementToString = require('./Util').elementToString;


        function elementData(semantic, attrs) {
            return assign({
                id: semantic.id,
                type: semantic.$type,
                businessObject: semantic
            }, attrs);
        }

        function collectWaypoints(waypoints) {
            return map(waypoints, function (p) {
                return { x: p.x, y: p.y };
            });
        }

        function notYetDrawn(translate, semantic, refSemantic, property) {
            return new Error(translate('element {element} referenced by {referenced}#{property} not yet drawn', {
                element: elementToString(refSemantic),
                referenced: elementToString(semantic),
                property: property
            }));
        }


        /**
         * An importer that adds bpmn elements to the canvas
         *
         * @param {EventBus} eventBus
         * @param {Canvas} canvas
         * @param {ElementFactory} elementFactory
         * @param {ElementRegistry} elementRegistry
         */
        function BpmnImporter(eventBus, canvas, elementFactory, elementRegistry, translate) {
            this._eventBus = eventBus;
            this._canvas = canvas;

            this._elementFactory = elementFactory;
            this._elementRegistry = elementRegistry;
            this._translate = translate;

            this._textUtil = new TextUtil();
        }

        BpmnImporter.$inject = ['eventBus', 'canvas', 'elementFactory', 'elementRegistry', 'translate'];

        module.exports = BpmnImporter;


        /**
         * Add bpmn element (semantic) to the canvas onto the
         * specified parent shape.
         */
        BpmnImporter.prototype.add = function (semantic, parentElement) {

            var di = semantic.di,
                element,
                translate = this._translate,
                hidden;

            // ROOT ELEMENT
            // handle the special case that we deal with a
            // invisible root element (process or collaboration)
            if (is(di, 'bpmndi:BPMNPlane')) {

                // add a virtual element (not being drawn)
                element = this._elementFactory.createRoot(elementData(semantic));

                this._canvas.setRootElement(element);
            }

            // SHAPE
            else if (is(di, 'bpmndi:BPMNShape')) {

                var collapsed = !isExpanded(semantic);
                hidden = parentElement && (parentElement.hidden || parentElement.collapsed);

                var bounds = semantic.di.bounds;

                element = this._elementFactory.createShape(elementData(semantic, {
                    collapsed: collapsed,
                    hidden: hidden,
                    x: Math.round(bounds.x),
                    y: Math.round(bounds.y),
                    width: Math.round(bounds.width),
                    height: Math.round(bounds.height)
                }));

                if (is(semantic, 'bpmn:BoundaryEvent')) {
                    this._attachBoundary(semantic, element);
                }

                this._canvas.addShape(element, parentElement);
            }

            // CONNECTION
            else if (is(di, 'bpmndi:BPMNEdge')) {

                var source = this._getSource(semantic),
                    target = this._getTarget(semantic);

                hidden = parentElement && (parentElement.hidden || parentElement.collapsed);

                element = this._elementFactory.createConnection(elementData(semantic, {
                    hidden: hidden,
                    source: source,
                    target: target,
                    waypoints: collectWaypoints(semantic.di.waypoint)
                }));

                if (is(semantic, 'bpmn:DataAssociation')) {

                    // render always on top; this ensures DataAssociations
                    // are rendered correctly across different "hacks" people
                    // love to model such as cross participant / sub process
                    // associations
                    parentElement = null;
                }

                this._canvas.addConnection(element, parentElement);
            } else {
                throw new Error(translate('unknown di {di} for element {semantic}', {
                    di: elementToString(di),
                    semantic: elementToString(semantic)
                }));
            }
            // (optional) LABEL
            if (hasExternalLabel(semantic)) {
                this.addLabel(semantic, element);
            }


            this._eventBus.fire('bpmnElement.added', { element: element });

            return element;
        };


        /**
         * Attach the boundary element to the given host
         *
         * @param {ModdleElement} boundarySemantic
         * @param {djs.model.Base} boundaryElement
         */
        BpmnImporter.prototype._attachBoundary = function (boundarySemantic, boundaryElement) {
            var translate = this._translate;
            var hostSemantic = boundarySemantic.attachedToRef;

            if (!hostSemantic) {
                throw new Error(translate('missing {semantic}#attachedToRef', {
                    semantic: elementToString(boundarySemantic)
                }));
            }

            var host = this._elementRegistry.get(hostSemantic.id),
                attachers = host && host.attachers;

            if (!host) {
                throw notYetDrawn(translate, boundarySemantic, hostSemantic, 'attachedToRef');
            }

            // wire element.host <> host.attachers
            boundaryElement.host = host;

            if (!attachers) {
                host.attachers = attachers = [];
            }

            if (attachers.indexOf(boundaryElement) === -1) {
                attachers.push(boundaryElement);
            }
        };


        /**
         * add label for an element
         */
        BpmnImporter.prototype.addLabel = function (semantic, element) {
            var bounds,
                text,
                label;

            bounds = getExternalLabelBounds(semantic, element);

            text = semantic.name;

            if (text) {
                // get corrected bounds from actual layouted text
                bounds = getLayoutedBounds(bounds, text, this._textUtil);
            }

            label = this._elementFactory.createLabel(elementData(semantic, {
                id: semantic.id + '_label',
                labelTarget: element,
                type: 'label',
                hidden: element.hidden || !semantic.name,
                x: Math.round(bounds.x),
                y: Math.round(bounds.y),
                width: Math.round(bounds.width),
                height: Math.round(bounds.height)
            }));

            return this._canvas.addShape(label, element.parent);
        };

        /**
         * Return the drawn connection end based on the given side.
         *
         * @throws {Error} if the end is not yet drawn
         */
        BpmnImporter.prototype._getEnd = function (semantic, side) {

            var element,
                refSemantic,
                type = semantic.$type,
                translate = this._translate;

            refSemantic = semantic[side + 'Ref'];

            // handle mysterious isMany DataAssociation#sourceRef
            if (side === 'source' && type === 'bpmn:DataInputAssociation') {
                refSemantic = refSemantic && refSemantic[0];
            }

            // fix source / target for DataInputAssociation / DataOutputAssociation
            if (side === 'source' && type === 'bpmn:DataOutputAssociation' ||
                side === 'target' && type === 'bpmn:DataInputAssociation') {

                refSemantic = semantic.$parent;
            }

            element = refSemantic && this._getElement(refSemantic);

            if (element) {
                return element;
            }

            if (refSemantic) {
                throw notYetDrawn(translate, semantic, refSemantic, side + 'Ref');
            } else {
                throw new Error(translate('{semantic}#{side} Ref not specified', {
                    semantic: elementToString(semantic),
                    side: side
                }));
            }
        };

        BpmnImporter.prototype._getSource = function (semantic) {
            return this._getEnd(semantic, 'source');
        };

        BpmnImporter.prototype._getTarget = function (semantic) {
            return this._getEnd(semantic, 'target');
        };


        BpmnImporter.prototype._getElement = function (semantic) {
            return this._elementRegistry.get(semantic.id);
        };


        // TODO(nikku): repeating code (search for <getLayoutedBounds>)

        var EXTERNAL_LABEL_STYLE = {
            fontFamily: 'Arial, sans-serif',
            fontSize: '11px'
        };

        function getLayoutedBounds(bounds, text, textUtil) {

            var layoutedLabelDimensions = textUtil.getDimensions(text, {
                box: {
                    width: 90,
                    height: 30,
                    x: bounds.width / 2 + bounds.x,
                    y: bounds.height / 2 + bounds.y
                },
                style: EXTERNAL_LABEL_STYLE
            });

            // resize label shape to fit label text
            return {
                x: Math.round(bounds.x + bounds.width / 2 - layoutedLabelDimensions.width / 2),
                y: Math.round(bounds.y),
                width: Math.ceil(layoutedLabelDimensions.width),
                height: Math.ceil(layoutedLabelDimensions.height)
            };
        }
    }, { "../util/DiUtil": 93, "../util/LabelUtil": 94, "../util/ModelUtil": 95, "./Util": 91, "diagram-js/lib/util/Text": 280, "lodash/collection/map": 306, "lodash/object/assign": 433 }], 89: [function (require, module, exports) {
        'use strict';

        var filter = require('lodash/collection/filter'),
            find = require('lodash/collection/find'),
            forEach = require('lodash/collection/forEach');

        var Refs = require('object-refs');

        var elementToString = require('./Util').elementToString;

        var diRefs = new Refs({ name: 'bpmnElement', enumerable: true }, { name: 'di' });

        /**
         * Returns true if an element has the given meta-model type
         *
         * @param  {ModdleElement}  element
         * @param  {String}         type
         *
         * @return {Boolean}
         */
        function is(element, type) {
            return element.$instanceOf(type);
        }


        /**
         * Find a suitable display candidate for definitions where the DI does not
         * correctly specify one.
         */
        function findDisplayCandidate(definitions) {
            return find(definitions.rootElements, function (e) {
                return is(e, 'bpmn:Process') || is(e, 'bpmn:Collaboration');
            });
        }


        function BpmnTreeWalker(handler, translate) {

            // list of containers already walked
            var handledElements = {};

            // list of elements to handle deferred to ensure
            // prerequisites are drawn
            var deferred = [];

            ///// Helpers /////////////////////////////////

            function contextual(fn, ctx) {
                return function (e) {
                    fn(e, ctx);
                };
            }

            function handled(element) {
                handledElements[element.id] = element;
            }

            function isHandled(element) {
                return handledElements[element.id];
            }

            function visit(element, ctx) {

                var gfx = element.gfx;

                // avoid multiple rendering of elements
                if (gfx) {
                    throw new Error(
                        translate('already rendered {element}', { element: elementToString(element) })
                    );
                }

                // call handler
                return handler.element(element, ctx);
            }

            function visitRoot(element, diagram) {
                return handler.root(element, diagram);
            }

            function visitIfDi(element, ctx) {

                try {
                    var gfx = element.di && visit(element, ctx);

                    handled(element);

                    return gfx;
                } catch (e) {
                    logError(e.message, { element: element, error: e });

                    console.error(translate('failed to import {element}', { element: elementToString(element) }));
                    console.error(e);
                }
            }

            function logError(message, context) {
                handler.error(message, context);
            }

            ////// DI handling ////////////////////////////

            function registerDi(di) {
                var bpmnElement = di.bpmnElement;

                if (bpmnElement) {
                    if (bpmnElement.di) {
                        logError(
                            translate('multiple DI elements defined for {element}', {
                                element: elementToString(bpmnElement)
                            }),
                            { element: bpmnElement }
                        );
                    } else {
                        diRefs.bind(bpmnElement, 'di');
                        bpmnElement.di = di;
                    }
                } else {
                    logError(
                        translate('no bpmnElement referenced in {element}', {
                            element: elementToString(di)
                        }),
                        { element: di }
                    );
                }
            }

            function handleDiagram(diagram) {
                handlePlane(diagram.plane);
            }

            function handlePlane(plane) {
                registerDi(plane);

                forEach(plane.planeElement, handlePlaneElement);
            }

            function handlePlaneElement(planeElement) {
                registerDi(planeElement);
            }


            ////// Semantic handling //////////////////////

            /**
             * Handle definitions and return the rendered diagram (if any)
             *
             * @param {ModdleElement} definitions to walk and import
             * @param {ModdleElement} [diagram] specific diagram to import and display
             *
             * @throws {Error} if no diagram to display could be found
             */
            function handleDefinitions(definitions, diagram) {
                // make sure we walk the correct bpmnElement

                var diagrams = definitions.diagrams;

                if (diagram && diagrams.indexOf(diagram) === -1) {
                    throw new Error(translate('diagram not part of bpmn:Definitions'));
                }

                if (!diagram && diagrams && diagrams.length) {
                    diagram = diagrams[0];
                }

                // no diagram -> nothing to import
                if (!diagram) {
                    throw new Error(translate('no diagram to display'));
                }

                // load DI from selected diagram only
                handleDiagram(diagram);


                var plane = diagram.plane;

                if (!plane) {
                    throw new Error(translate(
                        'no plane for {element}',
                        { element: elementToString(diagram) }
                    ));
                }

                var rootElement = plane.bpmnElement;

                // ensure we default to a suitable display candidate (process or collaboration),
                // even if non is specified in DI
                if (!rootElement) {
                    rootElement = findDisplayCandidate(definitions);

                    if (!rootElement) {
                        throw new Error(translate('no process or collaboration to display'));
                    } else {

                        logError(
                            translate('correcting missing bpmnElement on {plane} to {rootElement}', {
                                plane: elementToString(plane),
                                rootElement: elementToString(rootElement)
                            })
                        );

                        // correct DI on the fly
                        plane.bpmnElement = rootElement;
                        registerDi(plane);
                    }
                }


                var ctx = visitRoot(rootElement, plane);

                if (is(rootElement, 'bpmn:Process')) {
                    handleProcess(rootElement, ctx);
                } else if (is(rootElement, 'bpmn:Collaboration')) {
                    handleCollaboration(rootElement, ctx);

                    // force drawing of everything not yet drawn that is part of the target DI
                    handleUnhandledProcesses(definitions.rootElements, ctx);
                } else {
                    throw new Error(
                        translate('unsupported bpmnElement for {plane}: {rootElement}', {
                            plane: elementToString(plane),
                            rootElement: elementToString(rootElement)
                        })
                    );
                }

                // handle all deferred elements
                handleDeferred(deferred);
            }

            function handleDeferred(deferred) {
                forEach(deferred, function (d) { d(); });
            }

            function handleProcess(process, context) {
                handleFlowElementsContainer(process, context);
                handleIoSpecification(process.ioSpecification, context);

                handleArtifacts(process.artifacts, context);

                // log process handled
                handled(process);
            }

            function handleUnhandledProcesses(rootElements) {

                // walk through all processes that have not yet been drawn and draw them
                // if they contain lanes with DI information.
                // we do this to pass the free-floating lane test cases in the MIWG test suite
                var processes = filter(rootElements, function (e) {
                    return !isHandled(e) && is(e, 'bpmn:Process') && e.laneSets;
                });

                processes.forEach(contextual(handleProcess));
            }

            function handleMessageFlow(messageFlow, context) {
                visitIfDi(messageFlow, context);
            }

            function handleMessageFlows(messageFlows, context) {
                forEach(messageFlows, contextual(handleMessageFlow, context));
            }

            function handleDataAssociation(association, context) {
                visitIfDi(association, context);
            }

            function handleDataInput(dataInput, context) {
                visitIfDi(dataInput, context);
            }

            function handleDataOutput(dataOutput, context) {
                visitIfDi(dataOutput, context);
            }

            function handleArtifact(artifact, context) {

                // bpmn:TextAnnotation
                // bpmn:Group
                // bpmn:Association

                visitIfDi(artifact, context);
            }

            function handleArtifacts(artifacts, context) {

                forEach(artifacts, function (e) {
                    if (is(e, 'bpmn:Association')) {
                        deferred.push(function () {
                            handleArtifact(e, context);
                        });
                    } else {
                        handleArtifact(e, context);
                    }
                });
            }

            function handleIoSpecification(ioSpecification, context) {

                if (!ioSpecification) {
                    return;
                }

                forEach(ioSpecification.dataInputs, contextual(handleDataInput, context));
                forEach(ioSpecification.dataOutputs, contextual(handleDataOutput, context));
            }

            function handleSubProcess(subProcess, context) {
                handleFlowElementsContainer(subProcess, context);
                handleArtifacts(subProcess.artifacts, context);
            }

            function handleFlowNode(flowNode, context) {
                var childCtx = visitIfDi(flowNode, context);

                if (is(flowNode, 'bpmn:SubProcess')) {
                    handleSubProcess(flowNode, childCtx || context);
                }

                if (is(flowNode, 'bpmn:Activity')) {
                    handleIoSpecification(flowNode.ioSpecification, context);
                }

                // defer handling of associations
                // affected types:
                //
                //   * bpmn:Activity
                //   * bpmn:ThrowEvent
                //   * bpmn:CatchEvent
                //
                deferred.push(function () {
                    forEach(flowNode.dataInputAssociations, contextual(handleDataAssociation, context));
                    forEach(flowNode.dataOutputAssociations, contextual(handleDataAssociation, context));
                });
            }

            function handleSequenceFlow(sequenceFlow, context) {
                visitIfDi(sequenceFlow, context);
            }

            function handleDataElement(dataObject, context) {
                visitIfDi(dataObject, context);
            }

            function handleBoundaryEvent(dataObject, context) {
                visitIfDi(dataObject, context);
            }

            function handleLane(lane, context) {
                var newContext = visitIfDi(lane, context);

                if (lane.childLaneSet) {
                    handleLaneSet(lane.childLaneSet, newContext || context);
                }

                wireFlowNodeRefs(lane);
            }

            function handleLaneSet(laneSet, context) {
                forEach(laneSet.lanes, contextual(handleLane, context));
            }

            function handleLaneSets(laneSets, context) {
                forEach(laneSets, contextual(handleLaneSet, context));
            }

            function handleFlowElementsContainer(container, context) {
                if (container.laneSets) {
                    handleLaneSets(container.laneSets, context);
                }

                handleFlowElements(container.flowElements, context);
            }

            function handleFlowElements(flowElements, context) {
                forEach(flowElements, function (e) {
                    if (is(e, 'bpmn:SequenceFlow')) {
                        deferred.push(function () {
                            handleSequenceFlow(e, context);
                        });
                    } else if (is(e, 'bpmn:BoundaryEvent')) {
                        deferred.unshift(function () {
                            handleBoundaryEvent(e, context);
                        });
                    } else if (is(e, 'bpmn:FlowNode')) {
                        handleFlowNode(e, context);
                    } else if (is(e, 'bpmn:DataObject')) {
                        // SKIP (assume correct referencing via DataObjectReference)
                    } else if (is(e, 'bpmn:DataStoreReference')) {
                        handleDataElement(e, context);
                    } else if (is(e, 'bpmn:DataObjectReference')) {
                        handleDataElement(e, context);
                    } else {
                        logError(
                            translate('unrecognized flowElement {element} in context {context}', {
                                element: elementToString(e),
                                context: (context ? elementToString(context.businessObject) : 'null')
                            }),
                            { element: e, context: context }
                        );
                    }
                });
            }

            function handleParticipant(participant, context) {
                var newCtx = visitIfDi(participant, context);

                var process = participant.processRef;
                if (process) {
                    handleProcess(process, newCtx || context);
                }
            }

            function handleCollaboration(collaboration) {

                forEach(collaboration.participants, contextual(handleParticipant));

                handleArtifacts(collaboration.artifacts);

                // handle message flows latest in the process
                deferred.push(function () {
                    handleMessageFlows(collaboration.messageFlows);
                });
            }


            function wireFlowNodeRefs(lane) {
                // wire the virtual flowNodeRefs <-> relationship
                forEach(lane.flowNodeRef, function (flowNode) {
                    var lanes = flowNode.get('lanes');

                    if (lanes) {
                        lanes.push(lane);
                    }
                });
            }

            ///// API ////////////////////////////////

            return {
                handleDefinitions: handleDefinitions
            };
        }

        module.exports = BpmnTreeWalker;
    }, { "./Util": 91, "lodash/collection/filter": 302, "lodash/collection/find": 303, "lodash/collection/forEach": 304, "object-refs": 468 }], 90: [function (require, module, exports) {
        'use strict';

        var BpmnTreeWalker = require('./BpmnTreeWalker');


        /**
         * Import the definitions into a diagram.
         *
         * Errors and warnings are reported through the specified callback.
         *
         * @param  {Diagram} diagram
         * @param  {ModdleElement} definitions
         * @param  {Function} done the callback, invoked with (err, [ warning ]) once the import is done
         */
        function importBpmnDiagram(diagram, definitions, done) {

            var importer = diagram.get('bpmnImporter'),
                eventBus = diagram.get('eventBus'),
                translate = diagram.get('translate');

            var error,
                warnings = [];

            /**
             * Walk the diagram semantically, importing (=drawing)
             * all elements you encounter.
             *
             * @param {ModdleElement} definitions
             */
            function render(definitions) {

                var visitor = {

                    root: function (element) {
                        return importer.add(element);
                    },

                    element: function (element, parentShape) {
                        return importer.add(element, parentShape);
                    },

                    error: function (message, context) {
                        warnings.push({ message: message, context: context });
                    }
                };

                var walker = new BpmnTreeWalker(visitor, translate);

                // traverse BPMN 2.0 document model,
                // starting at definitions
                walker.handleDefinitions(definitions);
            }

            eventBus.fire('import.render.start', { definitions: definitions });

            try {
                render(definitions);
            } catch (e) {
                error = e;
            }

            eventBus.fire('import.render.complete', {
                error: error,
                warnings: warnings
            });

            done(error, warnings);
        }

        module.exports.importBpmnDiagram = importBpmnDiagram;
    }, { "./BpmnTreeWalker": 89 }], 91: [function (require, module, exports) {
        'use strict';

        module.exports.elementToString = function (e) {
            if (!e) {
                return '<null>';
            }

            return '<' + e.$type + (e.id ? ' id="' + e.id : '') + '" />';
        };
    }, {}], 92: [function (require, module, exports) {
        module.exports = {
            __depends__: [
                require('diagram-js/lib/i18n/translate')
            ],
            bpmnImporter: ['type', require('./BpmnImporter')]
        };
    }, { "./BpmnImporter": 88, "diagram-js/lib/i18n/translate": 248 }], 93: [function (require, module, exports) {
        'use strict';

        var is = require('./ModelUtil').is,
            getBusinessObject = require('./ModelUtil').getBusinessObject;

        var forEach = require('lodash/collection/forEach');

        module.exports.isExpanded = function (element) {

            if (is(element, 'bpmn:CallActivity')) {
                return false;
            }

            if (is(element, 'bpmn:SubProcess')) {
                return !!getBusinessObject(element).di.isExpanded;
            }

            if (is(element, 'bpmn:Participant')) {
                return !!getBusinessObject(element).processRef;
            }

            return true;
        };

        module.exports.isInterrupting = function (element) {
            return element && getBusinessObject(element).isInterrupting !== false;
        };

        module.exports.isEventSubProcess = function (element) {
            return element && !!getBusinessObject(element).triggeredByEvent;
        };

        function hasEventDefinition(element, eventType) {
            var bo = getBusinessObject(element),
                hasEventDefinition = false;

            if (bo.eventDefinitions) {
                forEach(bo.eventDefinitions, function (event) {
                    if (is(event, eventType)) {
                        hasEventDefinition = true;
                    }
                });
            }

            return hasEventDefinition;
        }

        module.exports.hasEventDefinition = hasEventDefinition;

        module.exports.hasErrorEventDefinition = function (element) {
            return hasEventDefinition(element, 'bpmn:ErrorEventDefinition');
        };

        module.exports.hasEscalationEventDefinition = function (element) {
            return hasEventDefinition(element, 'bpmn:EscalationEventDefinition');
        };

        module.exports.hasCompensateEventDefinition = function (element) {
            return hasEventDefinition(element, 'bpmn:CompensateEventDefinition');
        };

    }, { "./ModelUtil": 95, "lodash/collection/forEach": 304 }], 94: [function (require, module, exports) {
        'use strict';

        var assign = require('lodash/object/assign');

        var is = require('./ModelUtil').is;

        var DEFAULT_LABEL_SIZE = module.exports.DEFAULT_LABEL_SIZE = {
            width: 90,
            height: 20
        };

        var FLOW_LABEL_INDENT = module.exports.FLOW_LABEL_INDENT = 15;


        /**
         * Returns true if the given semantic has an external label
         *
         * @param {BpmnElement} semantic
         * @return {Boolean} true if has label
         */
        module.exports.hasExternalLabel = function (semantic) {
            return is(semantic, 'bpmn:Event') ||
                is(semantic, 'bpmn:Gateway') ||
                is(semantic, 'bpmn:DataStoreReference') ||
                is(semantic, 'bpmn:DataObjectReference') ||
                is(semantic, 'bpmn:SequenceFlow') ||
                is(semantic, 'bpmn:MessageFlow');
        };

        /**
         * Get the position for sequence flow labels
         *
         * @param  {Array<Point>} waypoints
         * @return {Point} the label position
         */
        function getFlowLabelPosition(waypoints) {

            // get the waypoints mid
            var mid = waypoints.length / 2 - 1;

            var first = waypoints[Math.floor(mid)];
            var second = waypoints[Math.ceil(mid + 0.01)];

            // get position
            var position = getWaypointsMid(waypoints);

            // calculate angle
            var angle = Math.atan((second.y - first.y) / (second.x - first.x));

            var x = position.x,
                y = position.y;

            if (Math.abs(angle) < Math.PI / 2) {
                y -= FLOW_LABEL_INDENT;
            } else {
                x += FLOW_LABEL_INDENT;
            }

            return { x: x, y: y };
        }

        module.exports.getFlowLabelPosition = getFlowLabelPosition;

        /**
         * Get the middle of a number of waypoints
         *
         * @param  {Array<Point>} waypoints
         * @return {Point} the mid point
         */
        function getWaypointsMid(waypoints) {

            var mid = waypoints.length / 2 - 1;

            var first = waypoints[Math.floor(mid)];
            var second = waypoints[Math.ceil(mid + 0.01)];

            return {
                x: first.x + (second.x - first.x) / 2,
                y: first.y + (second.y - first.y) / 2
            };
        }

        module.exports.getWaypointsMid = getWaypointsMid;


        function getExternalLabelMid(element) {

            if (element.waypoints) {
                return getFlowLabelPosition(element.waypoints);
            } else {
                return {
                    x: element.x + element.width / 2,
                    y: element.y + element.height + DEFAULT_LABEL_SIZE.height / 2
                };
            }
        }

        module.exports.getExternalLabelMid = getExternalLabelMid;


        /**
         * Returns the bounds of an elements label, parsed from the elements DI or
         * generated from its bounds.
         *
         * @param {BpmnElement} semantic
         * @param {djs.model.Base} element
         */
        module.exports.getExternalLabelBounds = function (semantic, element) {

            var mid,
                size,
                bounds,
                di = semantic.di,
                label = di.label;

            if (label && label.bounds) {
                bounds = label.bounds;

                size = {
                    width: Math.max(DEFAULT_LABEL_SIZE.width, bounds.width),
                    height: bounds.height
                };

                mid = {
                    x: bounds.x + bounds.width / 2,
                    y: bounds.y + bounds.height / 2
                };
            } else {

                mid = getExternalLabelMid(element);

                size = DEFAULT_LABEL_SIZE;
            }

            return assign({
                x: mid.x - size.width / 2,
                y: mid.y - size.height / 2
            }, size);
        };

    }, { "./ModelUtil": 95, "lodash/object/assign": 433 }], 95: [function (require, module, exports) {
        'use strict';

        /**
         * Is an element of the given BPMN type?
         *
         * @param  {djs.model.Base|ModdleElement} element
         * @param  {String} type
         *
         * @return {Boolean}
         */
        function is(element, type) {
            var bo = getBusinessObject(element);

            return bo && (typeof bo.$instanceOf === 'function') && bo.$instanceOf(type);
        }

        module.exports.is = is;


        /**
         * Return the business object for a given element.
         *
         * @param  {djs.model.Base|ModdleElement} element
         *
         * @return {ModdleElement}
         */
        function getBusinessObject(element) {
            return (element && element.businessObject) || element;
        }

        module.exports.getBusinessObject = getBusinessObject;

    }, {}], 96: [function (require, module, exports) {
        /**
         * This file must not be changed or exchanged.
         *
         * @see http://bpmn.io/license for more information.
         */

        'use strict';

        var domify = require('min-dom/lib/domify');

        var domDelegate = require('min-dom/lib/delegate');

        /* jshint -W101 */

        // inlined ../resources/bpmnjs.png
        var logoData = module.exports.BPMNIO_LOGO = 'iVBORw0KGgoAAAANSUhEUgAAADQAAAA0CAMAAADypuvZAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAADBQTFRFiMte9PrwldFwfcZPqtqN0+zEyOe1XLgjvuKncsJAZ70y6fXh3vDT////UrQV////G2zN+AAAABB0Uk5T////////////////////AOAjXRkAAAHDSURBVHjavJZJkoUgDEBJmAX8979tM8u3E6x20VlYJfFFMoL4vBDxATxZcakIOJTWSmxvKWVIkJ8jHvlRv1F2LFrVISCZI+tCtQx+XfewgVTfyY3plPiQEAzI3zWy+kR6NBhFBYeBuscJLOUuA2WVLpCjVIaFzrNQZArxAZKUQm6gsj37L9Cb7dnIBUKxENaaMJQqMpDXvSL+ktxdGRm2IsKgJGGPg7atwUG5CcFUEuSv+CwQqizTrvDTNXdMU2bMiDWZd8d7QIySWVRsb2vBBioxOFt4OinPBapL+neAb5KL5IJ8szOza2/DYoipUCx+CjO0Bpsv0V6mktNZ+k8rlABlWG0FrOpKYVo8DT3dBeLEjUBAj7moDogVii7nSS9QzZnFcOVBp1g2PyBQ3Vr5aIapN91VJy33HTJLC1iX2FY6F8gRdaAeIEfVONgtFCzZTmoLEdOjBDfsIOA6128gw3eu1shAajdZNAORxuQDJN5A5PbEG6gNIu24QJD5iNyRMZIr6bsHbCtCU/OaOaSvgkUyDMdDa1BXGf5HJ1To+/Ym6mCKT02Y+/Sa126ZKyd3jxhzpc1r8zVL6YM1Qy/kR4ABAFJ6iQUnivhAAAAAAElFTkSuQmCC';

        /* jshint +W101 */


        function css(attrs) {
            return attrs.join(';');
        }

        var LIGHTBOX_STYLES = css([
            'z-index: 1001',
            'position: fixed',
            'top: 0',
            'left: 0',
            'right: 0',
            'bottom: 0'
        ]);

        var BACKDROP_STYLES = css([
            'width: 100%',
            'height: 100%',
            'background: rgba(0,0,0,0.2)'
        ]);

        var NOTICE_STYLES = css([
            'position: absolute',
            'left: 50%',
            'top: 40%',
            'margin: 0 -130px',
            'width: 260px',
            'padding: 10px',
            'background: white',
            'border: solid 1px #AAA',
            'border-radius: 3px',
            'font-family: Helvetica, Arial, sans-serif',
            'font-size: 14px',
            'line-height: 1.2em'
        ]);

        var LIGHTBOX_MARKUP =
            '<div class="bjs-powered-by-lightbox" style="' + LIGHTBOX_STYLES + '">' +
            '<div class="backdrop" style="' + BACKDROP_STYLES + '"></div>' +
            '<div class="notice" style="' + NOTICE_STYLES + '">' +
            '<a href="http://bpmn.io" target="_blank" style="float: left; margin-right: 10px">' +
            '<img src="data:image/png;base64,' + logoData + '">' +
            '</a>' +
            'Web-based tooling for BPMN, DMN and CMMN diagrams ' +
            'powered by <a href="http://bpmn.io" target="_blank">bpmn.io</a>.' +
            '</div>' +
            '</div>';


        var lightbox;

        function open() {

            if (!lightbox) {
                lightbox = domify(LIGHTBOX_MARKUP);

                domDelegate.bind(lightbox, '.backdrop', 'click', function (event) {
                    document.body.removeChild(lightbox);
                });
            }

            document.body.appendChild(lightbox);
        }

        module.exports.open = open;
    }, { "min-dom/lib/delegate": 450, "min-dom/lib/domify": 451 }], 97: [function (require, module, exports) {
        'use strict';

        var forEach = require('lodash/collection/forEach'),
            filter = require('lodash/collection/filter'),
            any = require('lodash/collection/any'),
            sort = require('lodash/collection/sortBy'),
            isArray = require('lodash/lang/isArray');

        var IGNORED_PROPERTIES = require('./ModelCloneUtils').IGNORED_PROPERTIES;

        function isAllowedIn(extProp, type) {
            var allowedIn = extProp.meta.allowedIn;

            // '*' is a wildcard, which means any element is allowed to use this property
            if (allowedIn.length === 1 && allowedIn[0] === '*') {
                return true;
            }

            return allowedIn.indexOf(type) !== -1;
        }

        function isType(element, types) {
            return any(types, function (type) {
                return typeof element === type;
            });
        }

        /**
         * A bpmn properties cloning interface
         *
         */
        function ModelCloneHelper(eventBus) {
            this._eventBus = eventBus;
        }

        module.exports = ModelCloneHelper;


        ModelCloneHelper.prototype.clone = function (refElement, newElement, properties) {
            // hasNestedProperty: property allows us to avoid ending up with empty (xml) tags
            // f.ex: if extensionElements.values is empty, don't set it
            var context = {
                newElement: newElement,
                hasNestedProperty: false
            };

            // we want the extensionElements to be cloned last
            // so that they can check certain properties
            properties = sort(properties, function (prop) {
                return prop === 'bpmn:extensionElements';
            });

            forEach(properties, function (propName) {
                var refElementProp = refElement.get(propName),
                    newElementProp = newElement.get(propName),
                    propDescriptor = newElement.$model.getPropertyDescriptor(newElement, propName),
                    newProperty, name;

                // we're not interested in cloning:
                // - same values from simple types
                // - cloning id's
                // - cloning reference elements
                if (newElementProp === refElementProp ||
                    (propDescriptor && (propDescriptor.isId || propDescriptor.isReference))) {
                    return;
                }

                // if the property is of type 'boolean', 'string', 'number' or 'null', just set it
                if (isType(refElementProp, ['boolean', 'string', 'number']) || refElementProp === null) {
                    newElement.set(propName, refElementProp);

                    return;
                }

                if (isArray(refElementProp)) {

                    forEach(refElementProp, function (extElement) {
                        var newProp;

                        context.refTopLevelProperty = extElement;

                        newProp = this._deepClone(extElement, context);

                        if (context.hasNestedProperty) {
                            newProp.$parent = newElement;

                            newElementProp.push(newProp);
                        }

                        context.hasNestedProperty = false;
                    }, this);

                } else {
                    name = propName.replace(/bpmn:/, '');

                    context.refTopLevelProperty = refElementProp;

                    newProperty = this._deepClone(refElementProp, context);

                    if (context.hasNestedProperty) {
                        newElement[name] = newProperty;
                    }

                    context.hasNestedProperty = false;
                }
            }, this);

            return newElement;
        };

        ModelCloneHelper.prototype._deepClone = function _deepClone(propertyElement, context) {
            var eventBus = this._eventBus;

            var newProp = propertyElement.$model.create(propertyElement.$type);

            var properties = filter(Object.keys(propertyElement), function (prop) {
                var descriptor = newProp.$model.getPropertyDescriptor(newProp, prop);

                if (descriptor && (descriptor.isId || descriptor.isReference)) {
                    return false;
                }

                // we need to make sure we don't clone certain properties
                // which we cannot easily know if they hold references or not
                if (IGNORED_PROPERTIES.indexOf(prop) !== -1) {
                    return false;
                }

                // make sure we don't copy the type
                return prop !== '$type';
            });

            if (!properties.length) {
                context.hasNestedProperty = true;
            }

            forEach(properties, function (propName) {
                // check if the propertyElement has this property defined
                if (propertyElement[propName] !== undefined &&
                    (propertyElement[propName].$type || isArray(propertyElement[propName]))) {

                    if (isArray(propertyElement[propName])) {
                        newProp[propName] = [];

                        forEach(propertyElement[propName], function (property) {
                            var extProp = propertyElement.$model.getTypeDescriptor(property.$type),
                                newDeepProp;

                            // we're not going to copy undefined types
                            if (!extProp) {
                                return;
                            }

                            var canClone = eventBus.fire('property.clone', {
                                newElement: context.newElement,
                                refTopLevelProperty: context.refTopLevelProperty,
                                propertyDescriptor: extProp
                            });

                            if (!canClone) {
                                // if can clone is 'undefined' or 'false'
                                // check for the meta information if it is allowed
                                if (propertyElement.$type === 'bpmn:ExtensionElements' &&
                                    extProp.meta && extProp.meta.allowedIn &&
                                    !isAllowedIn(extProp, context.newElement.$type)) {
                                    return false;
                                }
                            }

                            newDeepProp = this._deepClone(property, context);

                            newDeepProp.$parent = newProp;

                            if (!newProp[propName]) {
                                newProp[propName] = [];
                            }

                            context.hasNestedProperty = true;

                            newProp[propName].push(newDeepProp);
                        }, this);

                    } else if (propertyElement[propName].$type) {
                        newProp[propName] = this._deepClone(propertyElement[propName], context);

                        if (newProp[propName]) {
                            context.hasNestedProperty = true;

                            newProp[propName].$parent = newProp;
                        }
                    }
                } else {
                    context.hasNestedProperty = true;

                    // just assign directly if it's a value
                    newProp[propName] = propertyElement[propName];
                }
            }, this);

            return newProp;
        };

    }, { "./ModelCloneUtils": 98, "lodash/collection/any": 300, "lodash/collection/filter": 302, "lodash/collection/forEach": 304, "lodash/collection/sortBy": 311, "lodash/lang/isArray": 424 }], 98: [function (require, module, exports) {
        'use strict';

        var forEach = require('lodash/collection/forEach');

        /**
         * These are the properties that should be ignored when cloning elements.
         *
         * @type {Array}
         */
        module.exports.IGNORED_PROPERTIES = [
            'lanes',
            'incoming',
            'outgoing',
            'artifacts',
            'default',
            'flowElements'
        ];


        function getProperties(descriptor, keepDefault) {
            var properties = [];

            forEach(descriptor.properties, function (property) {

                if (keepDefault && property.default) {
                    return;
                }

                properties.push(property.ns.name);
            });

            return properties;
        }

        module.exports.getProperties = getProperties;

    }, { "lodash/collection/forEach": 304 }], 99: [function (require, module, exports) {
        module.exports = require('./lib/simple');
    }, { "./lib/simple": 101 }], 100: [function (require, module, exports) {
        'use strict';

        var isString = require('lodash/lang/isString'),
            isFunction = require('lodash/lang/isFunction'),
            assign = require('lodash/object/assign');

        var Moddle = require('moddle'),
            XmlReader = require('moddle-xml/lib/reader'),
            XmlWriter = require('moddle-xml/lib/writer');

        /**
         * A sub class of {@link Moddle} with support for import and export of BPMN 2.0 xml files.
         *
         * @class BpmnModdle
         * @extends Moddle
         *
         * @param {Object|Array} packages to use for instantiating the model
         * @param {Object} [options] additional options to pass over
         */
        function BpmnModdle(packages, options) {
            Moddle.call(this, packages, options);
        }

        BpmnModdle.prototype = Object.create(Moddle.prototype);

        module.exports = BpmnModdle;


        /**
         * Instantiates a BPMN model tree from a given xml string.
         *
         * @param {String}   xmlStr
         * @param {String}   [typeName='bpmn:Definitions'] name of the root element
         * @param {Object}   [options]  options to pass to the underlying reader
         * @param {Function} done       callback that is invoked with (err, result, parseContext)
         *                              once the import completes
         */
        BpmnModdle.prototype.fromXML = function (xmlStr, typeName, options, done) {

            if (!isString(typeName)) {
                done = options;
                options = typeName;
                typeName = 'bpmn:Definitions';
            }

            if (isFunction(options)) {
                done = options;
                options = {};
            }

            var reader = new XmlReader(assign({ model: this, lax: true }, options));
            var rootHandler = reader.handler(typeName);

            reader.fromXML(xmlStr, rootHandler, done);
        };


        /**
         * Serializes a BPMN 2.0 object tree to XML.
         *
         * @param {String}   element    the root element, typically an instance of `bpmn:Definitions`
         * @param {Object}   [options]  to pass to the underlying writer
         * @param {Function} done       callback invoked with (err, xmlStr) once the import completes
         */
        BpmnModdle.prototype.toXML = function (element, options, done) {

            if (isFunction(options)) {
                done = options;
                options = {};
            }

            var writer = new XmlWriter(options);
            try {
                var result = writer.toXML(element);
                done(null, result);
            } catch (e) {
                done(e);
            }
        };

    }, { "lodash/lang/isFunction": 425, "lodash/lang/isString": 430, "lodash/object/assign": 433, "moddle": 459, "moddle-xml/lib/reader": 457, "moddle-xml/lib/writer": 458 }], 101: [function (require, module, exports) {
        'use strict';

        var assign = require('lodash/object/assign');

        var BpmnModdle = require('./bpmn-moddle');

        var packages = {
            bpmn: require('../resources/bpmn/json/bpmn.json'),
            bpmndi: require('../resources/bpmn/json/bpmndi.json'),
            dc: require('../resources/bpmn/json/dc.json'),
            di: require('../resources/bpmn/json/di.json'),
            bioc: require('../resources/bpmn-io/json/bioc.json')
        };

        module.exports = function (additionalPackages, options) {
            return new BpmnModdle(assign({}, packages, additionalPackages), options);
        };

    }, { "../resources/bpmn-io/json/bioc.json": 102, "../resources/bpmn/json/bpmn.json": 103, "../resources/bpmn/json/bpmndi.json": 104, "../resources/bpmn/json/dc.json": 105, "../resources/bpmn/json/di.json": 106, "./bpmn-moddle": 100, "lodash/object/assign": 433 }], 102: [function (require, module, exports) {
        module.exports = {
            "name": "bpmn.io colors for BPMN",
            "uri": "http://bpmn.io/schema/bpmn/biocolor/1.0",
            "prefix": "bioc",
            "types": [
                {
                    "name": "ColoredShape",
                    "extends": ["bpmndi:BPMNShape"],
                    "properties": [
                        {
                            "name": "stroke",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "fill",
                            "isAttr": true,
                            "type": "String"
                        }
                    ]
                },
                {
                    "name": "ColoredEdge",
                    "extends": ["bpmndi:BPMNEdge"],
                    "properties": [
                        {
                            "name": "stroke",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "fill",
                            "isAttr": true,
                            "type": "String"
                        }
                    ]
                }
            ],
            "emumerations": [],
            "associations": []
        }

    }, {}], 103: [function (require, module, exports) {
        module.exports = {
            "name": "BPMN20",
            "uri": "http://www.omg.org/spec/BPMN/20100524/MODEL",
            "associations": [],
            "types": [
                {
                    "name": "Interface",
                    "superClass": [
                        "RootElement"
                    ],
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "operations",
                            "type": "Operation",
                            "isMany": true
                        },
                        {
                            "name": "implementationRef",
                            "type": "String",
                            "isAttr": true
                        }
                    ]
                },
                {
                    "name": "Operation",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "inMessageRef",
                            "type": "Message",
                            "isReference": true
                        },
                        {
                            "name": "outMessageRef",
                            "type": "Message",
                            "isReference": true
                        },
                        {
                            "name": "errorRef",
                            "type": "Error",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "implementationRef",
                            "type": "String",
                            "isAttr": true
                        }
                    ]
                },
                {
                    "name": "EndPoint",
                    "superClass": [
                        "RootElement"
                    ]
                },
                {
                    "name": "Auditing",
                    "superClass": [
                        "BaseElement"
                    ]
                },
                {
                    "name": "GlobalTask",
                    "superClass": [
                        "CallableElement"
                    ],
                    "properties": [
                        {
                            "name": "resources",
                            "type": "ResourceRole",
                            "isMany": true
                        }
                    ]
                },
                {
                    "name": "Monitoring",
                    "superClass": [
                        "BaseElement"
                    ]
                },
                {
                    "name": "Performer",
                    "superClass": [
                        "ResourceRole"
                    ]
                },
                {
                    "name": "Process",
                    "superClass": [
                        "FlowElementsContainer",
                        "CallableElement"
                    ],
                    "properties": [
                        {
                            "name": "processType",
                            "type": "ProcessType",
                            "isAttr": true
                        },
                        {
                            "name": "isClosed",
                            "isAttr": true,
                            "type": "Boolean"
                        },
                        {
                            "name": "auditing",
                            "type": "Auditing"
                        },
                        {
                            "name": "monitoring",
                            "type": "Monitoring"
                        },
                        {
                            "name": "properties",
                            "type": "Property",
                            "isMany": true
                        },
                        {
                            "name": "laneSets",
                            "type": "LaneSet",
                            "isMany": true,
                            "replaces": "FlowElementsContainer#laneSets"
                        },
                        {
                            "name": "flowElements",
                            "type": "FlowElement",
                            "isMany": true,
                            "replaces": "FlowElementsContainer#flowElements"
                        },
                        {
                            "name": "artifacts",
                            "type": "Artifact",
                            "isMany": true
                        },
                        {
                            "name": "resources",
                            "type": "ResourceRole",
                            "isMany": true
                        },
                        {
                            "name": "correlationSubscriptions",
                            "type": "CorrelationSubscription",
                            "isMany": true
                        },
                        {
                            "name": "supports",
                            "type": "Process",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "definitionalCollaborationRef",
                            "type": "Collaboration",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "isExecutable",
                            "isAttr": true,
                            "type": "Boolean"
                        }
                    ]
                },
                {
                    "name": "LaneSet",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "lanes",
                            "type": "Lane",
                            "isMany": true
                        },
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        }
                    ]
                },
                {
                    "name": "Lane",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "partitionElementRef",
                            "type": "BaseElement",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "partitionElement",
                            "type": "BaseElement"
                        },
                        {
                            "name": "flowNodeRef",
                            "type": "FlowNode",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "childLaneSet",
                            "type": "LaneSet",
                            "xml": {
                                "serialize": "xsi:type"
                            }
                        }
                    ]
                },
                {
                    "name": "GlobalManualTask",
                    "superClass": [
                        "GlobalTask"
                    ]
                },
                {
                    "name": "ManualTask",
                    "superClass": [
                        "Task"
                    ]
                },
                {
                    "name": "UserTask",
                    "superClass": [
                        "Task"
                    ],
                    "properties": [
                        {
                            "name": "renderings",
                            "type": "Rendering",
                            "isMany": true
                        },
                        {
                            "name": "implementation",
                            "isAttr": true,
                            "type": "String"
                        }
                    ]
                },
                {
                    "name": "Rendering",
                    "superClass": [
                        "BaseElement"
                    ]
                },
                {
                    "name": "HumanPerformer",
                    "superClass": [
                        "Performer"
                    ]
                },
                {
                    "name": "PotentialOwner",
                    "superClass": [
                        "HumanPerformer"
                    ]
                },
                {
                    "name": "GlobalUserTask",
                    "superClass": [
                        "GlobalTask"
                    ],
                    "properties": [
                        {
                            "name": "implementation",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "renderings",
                            "type": "Rendering",
                            "isMany": true
                        }
                    ]
                },
                {
                    "name": "Gateway",
                    "isAbstract": true,
                    "superClass": [
                        "FlowNode"
                    ],
                    "properties": [
                        {
                            "name": "gatewayDirection",
                            "type": "GatewayDirection",
                            "default": "Unspecified",
                            "isAttr": true
                        }
                    ]
                },
                {
                    "name": "EventBasedGateway",
                    "superClass": [
                        "Gateway"
                    ],
                    "properties": [
                        {
                            "name": "instantiate",
                            "default": false,
                            "isAttr": true,
                            "type": "Boolean"
                        },
                        {
                            "name": "eventGatewayType",
                            "type": "EventBasedGatewayType",
                            "isAttr": true,
                            "default": "Exclusive"
                        }
                    ]
                },
                {
                    "name": "ComplexGateway",
                    "superClass": [
                        "Gateway"
                    ],
                    "properties": [
                        {
                            "name": "activationCondition",
                            "type": "Expression",
                            "xml": {
                                "serialize": "xsi:type"
                            }
                        },
                        {
                            "name": "default",
                            "type": "SequenceFlow",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "ExclusiveGateway",
                    "superClass": [
                        "Gateway"
                    ],
                    "properties": [
                        {
                            "name": "default",
                            "type": "SequenceFlow",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "InclusiveGateway",
                    "superClass": [
                        "Gateway"
                    ],
                    "properties": [
                        {
                            "name": "default",
                            "type": "SequenceFlow",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "ParallelGateway",
                    "superClass": [
                        "Gateway"
                    ]
                },
                {
                    "name": "RootElement",
                    "isAbstract": true,
                    "superClass": [
                        "BaseElement"
                    ]
                },
                {
                    "name": "Relationship",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "type",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "direction",
                            "type": "RelationshipDirection",
                            "isAttr": true
                        },
                        {
                            "name": "source",
                            "isMany": true,
                            "isReference": true,
                            "type": "Element"
                        },
                        {
                            "name": "target",
                            "isMany": true,
                            "isReference": true,
                            "type": "Element"
                        }
                    ]
                },
                {
                    "name": "BaseElement",
                    "isAbstract": true,
                    "properties": [
                        {
                            "name": "id",
                            "isAttr": true,
                            "type": "String",
                            "isId": true
                        },
                        {
                            "name": "documentation",
                            "type": "Documentation",
                            "isMany": true
                        },
                        {
                            "name": "extensionDefinitions",
                            "type": "ExtensionDefinition",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "extensionElements",
                            "type": "ExtensionElements"
                        }
                    ]
                },
                {
                    "name": "Extension",
                    "properties": [
                        {
                            "name": "mustUnderstand",
                            "default": false,
                            "isAttr": true,
                            "type": "Boolean"
                        },
                        {
                            "name": "definition",
                            "type": "ExtensionDefinition",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "ExtensionDefinition",
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "extensionAttributeDefinitions",
                            "type": "ExtensionAttributeDefinition",
                            "isMany": true
                        }
                    ]
                },
                {
                    "name": "ExtensionAttributeDefinition",
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "type",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "isReference",
                            "default": false,
                            "isAttr": true,
                            "type": "Boolean"
                        },
                        {
                            "name": "extensionDefinition",
                            "type": "ExtensionDefinition",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "ExtensionElements",
                    "properties": [
                        {
                            "name": "valueRef",
                            "isAttr": true,
                            "isReference": true,
                            "type": "Element"
                        },
                        {
                            "name": "values",
                            "type": "Element",
                            "isMany": true
                        },
                        {
                            "name": "extensionAttributeDefinition",
                            "type": "ExtensionAttributeDefinition",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "Documentation",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "text",
                            "type": "String",
                            "isBody": true
                        },
                        {
                            "name": "textFormat",
                            "default": "text/plain",
                            "isAttr": true,
                            "type": "String"
                        }
                    ]
                },
                {
                    "name": "Event",
                    "isAbstract": true,
                    "superClass": [
                        "FlowNode",
                        "InteractionNode"
                    ],
                    "properties": [
                        {
                            "name": "properties",
                            "type": "Property",
                            "isMany": true
                        }
                    ]
                },
                {
                    "name": "IntermediateCatchEvent",
                    "superClass": [
                        "CatchEvent"
                    ]
                },
                {
                    "name": "IntermediateThrowEvent",
                    "superClass": [
                        "ThrowEvent"
                    ]
                },
                {
                    "name": "EndEvent",
                    "superClass": [
                        "ThrowEvent"
                    ]
                },
                {
                    "name": "StartEvent",
                    "superClass": [
                        "CatchEvent"
                    ],
                    "properties": [
                        {
                            "name": "isInterrupting",
                            "default": true,
                            "isAttr": true,
                            "type": "Boolean"
                        }
                    ]
                },
                {
                    "name": "ThrowEvent",
                    "isAbstract": true,
                    "superClass": [
                        "Event"
                    ],
                    "properties": [
                        {
                            "name": "dataInputs",
                            "type": "DataInput",
                            "isMany": true
                        },
                        {
                            "name": "dataInputAssociations",
                            "type": "DataInputAssociation",
                            "isMany": true
                        },
                        {
                            "name": "inputSet",
                            "type": "InputSet"
                        },
                        {
                            "name": "eventDefinitions",
                            "type": "EventDefinition",
                            "isMany": true
                        },
                        {
                            "name": "eventDefinitionRef",
                            "type": "EventDefinition",
                            "isMany": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "CatchEvent",
                    "isAbstract": true,
                    "superClass": [
                        "Event"
                    ],
                    "properties": [
                        {
                            "name": "parallelMultiple",
                            "isAttr": true,
                            "type": "Boolean",
                            "default": false
                        },
                        {
                            "name": "dataOutputs",
                            "type": "DataOutput",
                            "isMany": true
                        },
                        {
                            "name": "dataOutputAssociations",
                            "type": "DataOutputAssociation",
                            "isMany": true
                        },
                        {
                            "name": "outputSet",
                            "type": "OutputSet"
                        },
                        {
                            "name": "eventDefinitions",
                            "type": "EventDefinition",
                            "isMany": true
                        },
                        {
                            "name": "eventDefinitionRef",
                            "type": "EventDefinition",
                            "isMany": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "BoundaryEvent",
                    "superClass": [
                        "CatchEvent"
                    ],
                    "properties": [
                        {
                            "name": "cancelActivity",
                            "default": true,
                            "isAttr": true,
                            "type": "Boolean"
                        },
                        {
                            "name": "attachedToRef",
                            "type": "Activity",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "EventDefinition",
                    "isAbstract": true,
                    "superClass": [
                        "RootElement"
                    ]
                },
                {
                    "name": "CancelEventDefinition",
                    "superClass": [
                        "EventDefinition"
                    ]
                },
                {
                    "name": "ErrorEventDefinition",
                    "superClass": [
                        "EventDefinition"
                    ],
                    "properties": [
                        {
                            "name": "errorRef",
                            "type": "Error",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "TerminateEventDefinition",
                    "superClass": [
                        "EventDefinition"
                    ]
                },
                {
                    "name": "EscalationEventDefinition",
                    "superClass": [
                        "EventDefinition"
                    ],
                    "properties": [
                        {
                            "name": "escalationRef",
                            "type": "Escalation",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "Escalation",
                    "properties": [
                        {
                            "name": "structureRef",
                            "type": "ItemDefinition",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "escalationCode",
                            "isAttr": true,
                            "type": "String"
                        }
                    ],
                    "superClass": [
                        "RootElement"
                    ]
                },
                {
                    "name": "CompensateEventDefinition",
                    "superClass": [
                        "EventDefinition"
                    ],
                    "properties": [
                        {
                            "name": "waitForCompletion",
                            "isAttr": true,
                            "type": "Boolean"
                        },
                        {
                            "name": "activityRef",
                            "type": "Activity",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "TimerEventDefinition",
                    "superClass": [
                        "EventDefinition"
                    ],
                    "properties": [
                        {
                            "name": "timeDate",
                            "type": "Expression",
                            "xml": {
                                "serialize": "xsi:type"
                            }
                        },
                        {
                            "name": "timeCycle",
                            "type": "Expression",
                            "xml": {
                                "serialize": "xsi:type"
                            }
                        },
                        {
                            "name": "timeDuration",
                            "type": "Expression",
                            "xml": {
                                "serialize": "xsi:type"
                            }
                        }
                    ]
                },
                {
                    "name": "LinkEventDefinition",
                    "superClass": [
                        "EventDefinition"
                    ],
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "target",
                            "type": "LinkEventDefinition",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "source",
                            "type": "LinkEventDefinition",
                            "isMany": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "MessageEventDefinition",
                    "superClass": [
                        "EventDefinition"
                    ],
                    "properties": [
                        {
                            "name": "messageRef",
                            "type": "Message",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "operationRef",
                            "type": "Operation",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "ConditionalEventDefinition",
                    "superClass": [
                        "EventDefinition"
                    ],
                    "properties": [
                        {
                            "name": "condition",
                            "type": "Expression",
                            "xml": {
                                "serialize": "xsi:type"
                            }
                        }
                    ]
                },
                {
                    "name": "SignalEventDefinition",
                    "superClass": [
                        "EventDefinition"
                    ],
                    "properties": [
                        {
                            "name": "signalRef",
                            "type": "Signal",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "Signal",
                    "superClass": [
                        "RootElement"
                    ],
                    "properties": [
                        {
                            "name": "structureRef",
                            "type": "ItemDefinition",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        }
                    ]
                },
                {
                    "name": "ImplicitThrowEvent",
                    "superClass": [
                        "ThrowEvent"
                    ]
                },
                {
                    "name": "DataState",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        }
                    ]
                },
                {
                    "name": "ItemAwareElement",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "itemSubjectRef",
                            "type": "ItemDefinition",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "dataState",
                            "type": "DataState"
                        }
                    ]
                },
                {
                    "name": "DataAssociation",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "assignment",
                            "type": "Assignment",
                            "isMany": true
                        },
                        {
                            "name": "sourceRef",
                            "type": "ItemAwareElement",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "targetRef",
                            "type": "ItemAwareElement",
                            "isReference": true
                        },
                        {
                            "name": "transformation",
                            "type": "FormalExpression",
                            "xml": {
                                "serialize": "property"
                            }
                        }
                    ]
                },
                {
                    "name": "DataInput",
                    "superClass": [
                        "ItemAwareElement"
                    ],
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "isCollection",
                            "default": false,
                            "isAttr": true,
                            "type": "Boolean"
                        },
                        {
                            "name": "inputSetRef",
                            "type": "InputSet",
                            "isVirtual": true,
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "inputSetWithOptional",
                            "type": "InputSet",
                            "isVirtual": true,
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "inputSetWithWhileExecuting",
                            "type": "InputSet",
                            "isVirtual": true,
                            "isMany": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "DataOutput",
                    "superClass": [
                        "ItemAwareElement"
                    ],
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "isCollection",
                            "default": false,
                            "isAttr": true,
                            "type": "Boolean"
                        },
                        {
                            "name": "outputSetRef",
                            "type": "OutputSet",
                            "isVirtual": true,
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "outputSetWithOptional",
                            "type": "OutputSet",
                            "isVirtual": true,
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "outputSetWithWhileExecuting",
                            "type": "OutputSet",
                            "isVirtual": true,
                            "isMany": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "InputSet",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "dataInputRefs",
                            "type": "DataInput",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "optionalInputRefs",
                            "type": "DataInput",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "whileExecutingInputRefs",
                            "type": "DataInput",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "outputSetRefs",
                            "type": "OutputSet",
                            "isMany": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "OutputSet",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "dataOutputRefs",
                            "type": "DataOutput",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "inputSetRefs",
                            "type": "InputSet",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "optionalOutputRefs",
                            "type": "DataOutput",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "whileExecutingOutputRefs",
                            "type": "DataOutput",
                            "isMany": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "Property",
                    "superClass": [
                        "ItemAwareElement"
                    ],
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        }
                    ]
                },
                {
                    "name": "DataInputAssociation",
                    "superClass": [
                        "DataAssociation"
                    ]
                },
                {
                    "name": "DataOutputAssociation",
                    "superClass": [
                        "DataAssociation"
                    ]
                },
                {
                    "name": "InputOutputSpecification",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "dataInputs",
                            "type": "DataInput",
                            "isMany": true
                        },
                        {
                            "name": "dataOutputs",
                            "type": "DataOutput",
                            "isMany": true
                        },
                        {
                            "name": "inputSets",
                            "type": "InputSet",
                            "isMany": true
                        },
                        {
                            "name": "outputSets",
                            "type": "OutputSet",
                            "isMany": true
                        }
                    ]
                },
                {
                    "name": "DataObject",
                    "superClass": [
                        "FlowElement",
                        "ItemAwareElement"
                    ],
                    "properties": [
                        {
                            "name": "isCollection",
                            "default": false,
                            "isAttr": true,
                            "type": "Boolean"
                        }
                    ]
                },
                {
                    "name": "InputOutputBinding",
                    "properties": [
                        {
                            "name": "inputDataRef",
                            "type": "InputSet",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "outputDataRef",
                            "type": "OutputSet",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "operationRef",
                            "type": "Operation",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "Assignment",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "from",
                            "type": "Expression",
                            "xml": {
                                "serialize": "xsi:type"
                            }
                        },
                        {
                            "name": "to",
                            "type": "Expression",
                            "xml": {
                                "serialize": "xsi:type"
                            }
                        }
                    ]
                },
                {
                    "name": "DataStore",
                    "superClass": [
                        "RootElement",
                        "ItemAwareElement"
                    ],
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "capacity",
                            "isAttr": true,
                            "type": "Integer"
                        },
                        {
                            "name": "isUnlimited",
                            "default": true,
                            "isAttr": true,
                            "type": "Boolean"
                        }
                    ]
                },
                {
                    "name": "DataStoreReference",
                    "superClass": [
                        "ItemAwareElement",
                        "FlowElement"
                    ],
                    "properties": [
                        {
                            "name": "dataStoreRef",
                            "type": "DataStore",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "DataObjectReference",
                    "superClass": [
                        "ItemAwareElement",
                        "FlowElement"
                    ],
                    "properties": [
                        {
                            "name": "dataObjectRef",
                            "type": "DataObject",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "ConversationLink",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "sourceRef",
                            "type": "InteractionNode",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "targetRef",
                            "type": "InteractionNode",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        }
                    ]
                },
                {
                    "name": "ConversationAssociation",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "innerConversationNodeRef",
                            "type": "ConversationNode",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "outerConversationNodeRef",
                            "type": "ConversationNode",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "CallConversation",
                    "superClass": [
                        "ConversationNode"
                    ],
                    "properties": [
                        {
                            "name": "calledCollaborationRef",
                            "type": "Collaboration",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "participantAssociations",
                            "type": "ParticipantAssociation",
                            "isMany": true
                        }
                    ]
                },
                {
                    "name": "Conversation",
                    "superClass": [
                        "ConversationNode"
                    ]
                },
                {
                    "name": "SubConversation",
                    "superClass": [
                        "ConversationNode"
                    ],
                    "properties": [
                        {
                            "name": "conversationNodes",
                            "type": "ConversationNode",
                            "isMany": true
                        }
                    ]
                },
                {
                    "name": "ConversationNode",
                    "isAbstract": true,
                    "superClass": [
                        "InteractionNode",
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "participantRefs",
                            "type": "Participant",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "messageFlowRefs",
                            "type": "MessageFlow",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "correlationKeys",
                            "type": "CorrelationKey",
                            "isMany": true
                        }
                    ]
                },
                {
                    "name": "GlobalConversation",
                    "superClass": [
                        "Collaboration"
                    ]
                },
                {
                    "name": "PartnerEntity",
                    "superClass": [
                        "RootElement"
                    ],
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "participantRef",
                            "type": "Participant",
                            "isMany": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "PartnerRole",
                    "superClass": [
                        "RootElement"
                    ],
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "participantRef",
                            "type": "Participant",
                            "isMany": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "CorrelationProperty",
                    "superClass": [
                        "RootElement"
                    ],
                    "properties": [
                        {
                            "name": "correlationPropertyRetrievalExpression",
                            "type": "CorrelationPropertyRetrievalExpression",
                            "isMany": true
                        },
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "type",
                            "type": "ItemDefinition",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "Error",
                    "superClass": [
                        "RootElement"
                    ],
                    "properties": [
                        {
                            "name": "structureRef",
                            "type": "ItemDefinition",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "errorCode",
                            "isAttr": true,
                            "type": "String"
                        }
                    ]
                },
                {
                    "name": "CorrelationKey",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "correlationPropertyRef",
                            "type": "CorrelationProperty",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        }
                    ]
                },
                {
                    "name": "Expression",
                    "superClass": [
                        "BaseElement"
                    ],
                    "isAbstract": false,
                    "properties": [
                        {
                            "name": "body",
                            "type": "String",
                            "isBody": true
                        }
                    ]
                },
                {
                    "name": "FormalExpression",
                    "superClass": [
                        "Expression"
                    ],
                    "properties": [
                        {
                            "name": "language",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "evaluatesToTypeRef",
                            "type": "ItemDefinition",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "Message",
                    "superClass": [
                        "RootElement"
                    ],
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "itemRef",
                            "type": "ItemDefinition",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "ItemDefinition",
                    "superClass": [
                        "RootElement"
                    ],
                    "properties": [
                        {
                            "name": "itemKind",
                            "type": "ItemKind",
                            "isAttr": true
                        },
                        {
                            "name": "structureRef",
                            "type": "String",
                            "isAttr": true
                        },
                        {
                            "name": "isCollection",
                            "default": false,
                            "isAttr": true,
                            "type": "Boolean"
                        },
                        {
                            "name": "import",
                            "type": "Import",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "FlowElement",
                    "isAbstract": true,
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "auditing",
                            "type": "Auditing"
                        },
                        {
                            "name": "monitoring",
                            "type": "Monitoring"
                        },
                        {
                            "name": "categoryValueRef",
                            "type": "CategoryValue",
                            "isMany": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "SequenceFlow",
                    "superClass": [
                        "FlowElement"
                    ],
                    "properties": [
                        {
                            "name": "isImmediate",
                            "isAttr": true,
                            "type": "Boolean"
                        },
                        {
                            "name": "conditionExpression",
                            "type": "Expression",
                            "xml": {
                                "serialize": "xsi:type"
                            }
                        },
                        {
                            "name": "sourceRef",
                            "type": "FlowNode",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "targetRef",
                            "type": "FlowNode",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "FlowElementsContainer",
                    "isAbstract": true,
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "laneSets",
                            "type": "LaneSet",
                            "isMany": true
                        },
                        {
                            "name": "flowElements",
                            "type": "FlowElement",
                            "isMany": true
                        }
                    ]
                },
                {
                    "name": "CallableElement",
                    "isAbstract": true,
                    "superClass": [
                        "RootElement"
                    ],
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "ioSpecification",
                            "type": "InputOutputSpecification",
                            "xml": {
                                "serialize": "property"
                            }
                        },
                        {
                            "name": "supportedInterfaceRef",
                            "type": "Interface",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "ioBinding",
                            "type": "InputOutputBinding",
                            "isMany": true,
                            "xml": {
                                "serialize": "property"
                            }
                        }
                    ]
                },
                {
                    "name": "FlowNode",
                    "isAbstract": true,
                    "superClass": [
                        "FlowElement"
                    ],
                    "properties": [
                        {
                            "name": "incoming",
                            "type": "SequenceFlow",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "outgoing",
                            "type": "SequenceFlow",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "lanes",
                            "type": "Lane",
                            "isVirtual": true,
                            "isMany": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "CorrelationPropertyRetrievalExpression",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "messagePath",
                            "type": "FormalExpression"
                        },
                        {
                            "name": "messageRef",
                            "type": "Message",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "CorrelationPropertyBinding",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "dataPath",
                            "type": "FormalExpression"
                        },
                        {
                            "name": "correlationPropertyRef",
                            "type": "CorrelationProperty",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "Resource",
                    "superClass": [
                        "RootElement"
                    ],
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "resourceParameters",
                            "type": "ResourceParameter",
                            "isMany": true
                        }
                    ]
                },
                {
                    "name": "ResourceParameter",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "isRequired",
                            "isAttr": true,
                            "type": "Boolean"
                        },
                        {
                            "name": "type",
                            "type": "ItemDefinition",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "CorrelationSubscription",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "correlationKeyRef",
                            "type": "CorrelationKey",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "correlationPropertyBinding",
                            "type": "CorrelationPropertyBinding",
                            "isMany": true
                        }
                    ]
                },
                {
                    "name": "MessageFlow",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "sourceRef",
                            "type": "InteractionNode",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "targetRef",
                            "type": "InteractionNode",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "messageRef",
                            "type": "Message",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "MessageFlowAssociation",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "innerMessageFlowRef",
                            "type": "MessageFlow",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "outerMessageFlowRef",
                            "type": "MessageFlow",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "InteractionNode",
                    "isAbstract": true,
                    "properties": [
                        {
                            "name": "incomingConversationLinks",
                            "type": "ConversationLink",
                            "isVirtual": true,
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "outgoingConversationLinks",
                            "type": "ConversationLink",
                            "isVirtual": true,
                            "isMany": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "Participant",
                    "superClass": [
                        "InteractionNode",
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "interfaceRef",
                            "type": "Interface",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "participantMultiplicity",
                            "type": "ParticipantMultiplicity"
                        },
                        {
                            "name": "endPointRefs",
                            "type": "EndPoint",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "processRef",
                            "type": "Process",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "ParticipantAssociation",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "innerParticipantRef",
                            "type": "Participant",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "outerParticipantRef",
                            "type": "Participant",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "ParticipantMultiplicity",
                    "properties": [
                        {
                            "name": "minimum",
                            "default": 0,
                            "isAttr": true,
                            "type": "Integer"
                        },
                        {
                            "name": "maximum",
                            "default": 1,
                            "isAttr": true,
                            "type": "Integer"
                        }
                    ]
                },
                {
                    "name": "Collaboration",
                    "superClass": [
                        "RootElement"
                    ],
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "isClosed",
                            "isAttr": true,
                            "type": "Boolean"
                        },
                        {
                            "name": "participants",
                            "type": "Participant",
                            "isMany": true
                        },
                        {
                            "name": "messageFlows",
                            "type": "MessageFlow",
                            "isMany": true
                        },
                        {
                            "name": "artifacts",
                            "type": "Artifact",
                            "isMany": true
                        },
                        {
                            "name": "conversations",
                            "type": "ConversationNode",
                            "isMany": true
                        },
                        {
                            "name": "conversationAssociations",
                            "type": "ConversationAssociation"
                        },
                        {
                            "name": "participantAssociations",
                            "type": "ParticipantAssociation",
                            "isMany": true
                        },
                        {
                            "name": "messageFlowAssociations",
                            "type": "MessageFlowAssociation",
                            "isMany": true
                        },
                        {
                            "name": "correlationKeys",
                            "type": "CorrelationKey",
                            "isMany": true
                        },
                        {
                            "name": "choreographyRef",
                            "type": "Choreography",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "conversationLinks",
                            "type": "ConversationLink",
                            "isMany": true
                        }
                    ]
                },
                {
                    "name": "ChoreographyActivity",
                    "isAbstract": true,
                    "superClass": [
                        "FlowNode"
                    ],
                    "properties": [
                        {
                            "name": "participantRefs",
                            "type": "Participant",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "initiatingParticipantRef",
                            "type": "Participant",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "correlationKeys",
                            "type": "CorrelationKey",
                            "isMany": true
                        },
                        {
                            "name": "loopType",
                            "type": "ChoreographyLoopType",
                            "default": "None",
                            "isAttr": true
                        }
                    ]
                },
                {
                    "name": "CallChoreography",
                    "superClass": [
                        "ChoreographyActivity"
                    ],
                    "properties": [
                        {
                            "name": "calledChoreographyRef",
                            "type": "Choreography",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "participantAssociations",
                            "type": "ParticipantAssociation",
                            "isMany": true
                        }
                    ]
                },
                {
                    "name": "SubChoreography",
                    "superClass": [
                        "ChoreographyActivity",
                        "FlowElementsContainer"
                    ],
                    "properties": [
                        {
                            "name": "artifacts",
                            "type": "Artifact",
                            "isMany": true
                        }
                    ]
                },
                {
                    "name": "ChoreographyTask",
                    "superClass": [
                        "ChoreographyActivity"
                    ],
                    "properties": [
                        {
                            "name": "messageFlowRef",
                            "type": "MessageFlow",
                            "isMany": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "Choreography",
                    "superClass": [
                        "FlowElementsContainer",
                        "Collaboration"
                    ]
                },
                {
                    "name": "GlobalChoreographyTask",
                    "superClass": [
                        "Choreography"
                    ],
                    "properties": [
                        {
                            "name": "initiatingParticipantRef",
                            "type": "Participant",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "TextAnnotation",
                    "superClass": [
                        "Artifact"
                    ],
                    "properties": [
                        {
                            "name": "text",
                            "type": "String"
                        },
                        {
                            "name": "textFormat",
                            "default": "text/plain",
                            "isAttr": true,
                            "type": "String"
                        }
                    ]
                },
                {
                    "name": "Group",
                    "superClass": [
                        "Artifact"
                    ],
                    "properties": [
                        {
                            "name": "categoryValueRef",
                            "type": "CategoryValue",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "Association",
                    "superClass": [
                        "Artifact"
                    ],
                    "properties": [
                        {
                            "name": "associationDirection",
                            "type": "AssociationDirection",
                            "isAttr": true
                        },
                        {
                            "name": "sourceRef",
                            "type": "BaseElement",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "targetRef",
                            "type": "BaseElement",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "Category",
                    "superClass": [
                        "RootElement"
                    ],
                    "properties": [
                        {
                            "name": "categoryValue",
                            "type": "CategoryValue",
                            "isMany": true
                        },
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        }
                    ]
                },
                {
                    "name": "Artifact",
                    "isAbstract": true,
                    "superClass": [
                        "BaseElement"
                    ]
                },
                {
                    "name": "CategoryValue",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "categorizedFlowElements",
                            "type": "FlowElement",
                            "isVirtual": true,
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "value",
                            "isAttr": true,
                            "type": "String"
                        }
                    ]
                },
                {
                    "name": "Activity",
                    "isAbstract": true,
                    "superClass": [
                        "FlowNode"
                    ],
                    "properties": [
                        {
                            "name": "isForCompensation",
                            "default": false,
                            "isAttr": true,
                            "type": "Boolean"
                        },
                        {
                            "name": "default",
                            "type": "SequenceFlow",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "ioSpecification",
                            "type": "InputOutputSpecification",
                            "xml": {
                                "serialize": "property"
                            }
                        },
                        {
                            "name": "boundaryEventRefs",
                            "type": "BoundaryEvent",
                            "isMany": true,
                            "isReference": true
                        },
                        {
                            "name": "properties",
                            "type": "Property",
                            "isMany": true
                        },
                        {
                            "name": "dataInputAssociations",
                            "type": "DataInputAssociation",
                            "isMany": true
                        },
                        {
                            "name": "dataOutputAssociations",
                            "type": "DataOutputAssociation",
                            "isMany": true
                        },
                        {
                            "name": "startQuantity",
                            "default": 1,
                            "isAttr": true,
                            "type": "Integer"
                        },
                        {
                            "name": "resources",
                            "type": "ResourceRole",
                            "isMany": true
                        },
                        {
                            "name": "completionQuantity",
                            "default": 1,
                            "isAttr": true,
                            "type": "Integer"
                        },
                        {
                            "name": "loopCharacteristics",
                            "type": "LoopCharacteristics"
                        }
                    ]
                },
                {
                    "name": "ServiceTask",
                    "superClass": [
                        "Task"
                    ],
                    "properties": [
                        {
                            "name": "implementation",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "operationRef",
                            "type": "Operation",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "SubProcess",
                    "superClass": [
                        "Activity",
                        "FlowElementsContainer",
                        "InteractionNode"
                    ],
                    "properties": [
                        {
                            "name": "triggeredByEvent",
                            "default": false,
                            "isAttr": true,
                            "type": "Boolean"
                        },
                        {
                            "name": "artifacts",
                            "type": "Artifact",
                            "isMany": true
                        }
                    ]
                },
                {
                    "name": "LoopCharacteristics",
                    "isAbstract": true,
                    "superClass": [
                        "BaseElement"
                    ]
                },
                {
                    "name": "MultiInstanceLoopCharacteristics",
                    "superClass": [
                        "LoopCharacteristics"
                    ],
                    "properties": [
                        {
                            "name": "isSequential",
                            "default": false,
                            "isAttr": true,
                            "type": "Boolean"
                        },
                        {
                            "name": "behavior",
                            "type": "MultiInstanceBehavior",
                            "default": "All",
                            "isAttr": true
                        },
                        {
                            "name": "loopCardinality",
                            "type": "Expression",
                            "xml": {
                                "serialize": "xsi:type"
                            }
                        },
                        {
                            "name": "loopDataInputRef",
                            "type": "ItemAwareElement",
                            "isReference": true
                        },
                        {
                            "name": "loopDataOutputRef",
                            "type": "ItemAwareElement",
                            "isReference": true
                        },
                        {
                            "name": "inputDataItem",
                            "type": "DataInput",
                            "xml": {
                                "serialize": "property"
                            }
                        },
                        {
                            "name": "outputDataItem",
                            "type": "DataOutput",
                            "xml": {
                                "serialize": "property"
                            }
                        },
                        {
                            "name": "complexBehaviorDefinition",
                            "type": "ComplexBehaviorDefinition",
                            "isMany": true
                        },
                        {
                            "name": "completionCondition",
                            "type": "Expression",
                            "xml": {
                                "serialize": "xsi:type"
                            }
                        },
                        {
                            "name": "oneBehaviorEventRef",
                            "type": "EventDefinition",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "noneBehaviorEventRef",
                            "type": "EventDefinition",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "StandardLoopCharacteristics",
                    "superClass": [
                        "LoopCharacteristics"
                    ],
                    "properties": [
                        {
                            "name": "testBefore",
                            "default": false,
                            "isAttr": true,
                            "type": "Boolean"
                        },
                        {
                            "name": "loopCondition",
                            "type": "Expression",
                            "xml": {
                                "serialize": "xsi:type"
                            }
                        },
                        {
                            "name": "loopMaximum",
                            "type": "Expression",
                            "xml": {
                                "serialize": "xsi:type"
                            }
                        }
                    ]
                },
                {
                    "name": "CallActivity",
                    "superClass": [
                        "Activity"
                    ],
                    "properties": [
                        {
                            "name": "calledElement",
                            "type": "String",
                            "isAttr": true
                        }
                    ]
                },
                {
                    "name": "Task",
                    "superClass": [
                        "Activity",
                        "InteractionNode"
                    ]
                },
                {
                    "name": "SendTask",
                    "superClass": [
                        "Task"
                    ],
                    "properties": [
                        {
                            "name": "implementation",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "operationRef",
                            "type": "Operation",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "messageRef",
                            "type": "Message",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "ReceiveTask",
                    "superClass": [
                        "Task"
                    ],
                    "properties": [
                        {
                            "name": "implementation",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "instantiate",
                            "default": false,
                            "isAttr": true,
                            "type": "Boolean"
                        },
                        {
                            "name": "operationRef",
                            "type": "Operation",
                            "isAttr": true,
                            "isReference": true
                        },
                        {
                            "name": "messageRef",
                            "type": "Message",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "ScriptTask",
                    "superClass": [
                        "Task"
                    ],
                    "properties": [
                        {
                            "name": "scriptFormat",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "script",
                            "type": "String"
                        }
                    ]
                },
                {
                    "name": "BusinessRuleTask",
                    "superClass": [
                        "Task"
                    ],
                    "properties": [
                        {
                            "name": "implementation",
                            "isAttr": true,
                            "type": "String"
                        }
                    ]
                },
                {
                    "name": "AdHocSubProcess",
                    "superClass": [
                        "SubProcess"
                    ],
                    "properties": [
                        {
                            "name": "completionCondition",
                            "type": "Expression",
                            "xml": {
                                "serialize": "xsi:type"
                            }
                        },
                        {
                            "name": "ordering",
                            "type": "AdHocOrdering",
                            "isAttr": true
                        },
                        {
                            "name": "cancelRemainingInstances",
                            "default": true,
                            "isAttr": true,
                            "type": "Boolean"
                        }
                    ]
                },
                {
                    "name": "Transaction",
                    "superClass": [
                        "SubProcess"
                    ],
                    "properties": [
                        {
                            "name": "protocol",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "method",
                            "isAttr": true,
                            "type": "String"
                        }
                    ]
                },
                {
                    "name": "GlobalScriptTask",
                    "superClass": [
                        "GlobalTask"
                    ],
                    "properties": [
                        {
                            "name": "scriptLanguage",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "script",
                            "isAttr": true,
                            "type": "String"
                        }
                    ]
                },
                {
                    "name": "GlobalBusinessRuleTask",
                    "superClass": [
                        "GlobalTask"
                    ],
                    "properties": [
                        {
                            "name": "implementation",
                            "isAttr": true,
                            "type": "String"
                        }
                    ]
                },
                {
                    "name": "ComplexBehaviorDefinition",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "condition",
                            "type": "FormalExpression"
                        },
                        {
                            "name": "event",
                            "type": "ImplicitThrowEvent"
                        }
                    ]
                },
                {
                    "name": "ResourceRole",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "resourceRef",
                            "type": "Resource",
                            "isReference": true
                        },
                        {
                            "name": "resourceParameterBindings",
                            "type": "ResourceParameterBinding",
                            "isMany": true
                        },
                        {
                            "name": "resourceAssignmentExpression",
                            "type": "ResourceAssignmentExpression"
                        },
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        }
                    ]
                },
                {
                    "name": "ResourceParameterBinding",
                    "properties": [
                        {
                            "name": "expression",
                            "type": "Expression",
                            "xml": {
                                "serialize": "xsi:type"
                            }
                        },
                        {
                            "name": "parameterRef",
                            "type": "ResourceParameter",
                            "isAttr": true,
                            "isReference": true
                        }
                    ]
                },
                {
                    "name": "ResourceAssignmentExpression",
                    "properties": [
                        {
                            "name": "expression",
                            "type": "Expression",
                            "xml": {
                                "serialize": "xsi:type"
                            }
                        }
                    ],
                    "superClass": [
                        "BaseElement"
                    ]
                },
                {
                    "name": "Import",
                    "properties": [
                        {
                            "name": "importType",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "location",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "namespace",
                            "isAttr": true,
                            "type": "String"
                        }
                    ]
                },
                {
                    "name": "Definitions",
                    "superClass": [
                        "BaseElement"
                    ],
                    "properties": [
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "targetNamespace",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "expressionLanguage",
                            "default": "http://www.w3.org/1999/XPath",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "typeLanguage",
                            "default": "http://www.w3.org/2001/XMLSchema",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "imports",
                            "type": "Import",
                            "isMany": true
                        },
                        {
                            "name": "extensions",
                            "type": "Extension",
                            "isMany": true
                        },
                        {
                            "name": "rootElements",
                            "type": "RootElement",
                            "isMany": true
                        },
                        {
                            "name": "diagrams",
                            "isMany": true,
                            "type": "bpmndi:BPMNDiagram"
                        },
                        {
                            "name": "exporter",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "relationships",
                            "type": "Relationship",
                            "isMany": true
                        },
                        {
                            "name": "exporterVersion",
                            "isAttr": true,
                            "type": "String"
                        }
                    ]
                }
            ],
            "emumerations": [
                {
                    "name": "ProcessType",
                    "literalValues": [
                        {
                            "name": "None"
                        },
                        {
                            "name": "Public"
                        },
                        {
                            "name": "Private"
                        }
                    ]
                },
                {
                    "name": "GatewayDirection",
                    "literalValues": [
                        {
                            "name": "Unspecified"
                        },
                        {
                            "name": "Converging"
                        },
                        {
                            "name": "Diverging"
                        },
                        {
                            "name": "Mixed"
                        }
                    ]
                },
                {
                    "name": "EventBasedGatewayType",
                    "literalValues": [
                        {
                            "name": "Parallel"
                        },
                        {
                            "name": "Exclusive"
                        }
                    ]
                },
                {
                    "name": "RelationshipDirection",
                    "literalValues": [
                        {
                            "name": "None"
                        },
                        {
                            "name": "Forward"
                        },
                        {
                            "name": "Backward"
                        },
                        {
                            "name": "Both"
                        }
                    ]
                },
                {
                    "name": "ItemKind",
                    "literalValues": [
                        {
                            "name": "Physical"
                        },
                        {
                            "name": "Information"
                        }
                    ]
                },
                {
                    "name": "ChoreographyLoopType",
                    "literalValues": [
                        {
                            "name": "None"
                        },
                        {
                            "name": "Standard"
                        },
                        {
                            "name": "MultiInstanceSequential"
                        },
                        {
                            "name": "MultiInstanceParallel"
                        }
                    ]
                },
                {
                    "name": "AssociationDirection",
                    "literalValues": [
                        {
                            "name": "None"
                        },
                        {
                            "name": "One"
                        },
                        {
                            "name": "Both"
                        }
                    ]
                },
                {
                    "name": "MultiInstanceBehavior",
                    "literalValues": [
                        {
                            "name": "None"
                        },
                        {
                            "name": "One"
                        },
                        {
                            "name": "All"
                        },
                        {
                            "name": "Complex"
                        }
                    ]
                },
                {
                    "name": "AdHocOrdering",
                    "literalValues": [
                        {
                            "name": "Parallel"
                        },
                        {
                            "name": "Sequential"
                        }
                    ]
                }
            ],
            "prefix": "bpmn",
            "xml": {
                "tagAlias": "lowerCase",
                "typePrefix": "t"
            }
        }
    }, {}], 104: [function (require, module, exports) {
        module.exports = {
            "name": "BPMNDI",
            "uri": "http://www.omg.org/spec/BPMN/20100524/DI",
            "types": [
                {
                    "name": "BPMNDiagram",
                    "properties": [
                        {
                            "name": "plane",
                            "type": "BPMNPlane",
                            "redefines": "di:Diagram#rootElement"
                        },
                        {
                            "name": "labelStyle",
                            "type": "BPMNLabelStyle",
                            "isMany": true
                        }
                    ],
                    "superClass": [
                        "di:Diagram"
                    ]
                },
                {
                    "name": "BPMNPlane",
                    "properties": [
                        {
                            "name": "bpmnElement",
                            "isAttr": true,
                            "isReference": true,
                            "type": "bpmn:BaseElement",
                            "redefines": "di:DiagramElement#modelElement"
                        }
                    ],
                    "superClass": [
                        "di:Plane"
                    ]
                },
                {
                    "name": "BPMNShape",
                    "properties": [
                        {
                            "name": "bpmnElement",
                            "isAttr": true,
                            "isReference": true,
                            "type": "bpmn:BaseElement",
                            "redefines": "di:DiagramElement#modelElement"
                        },
                        {
                            "name": "isHorizontal",
                            "isAttr": true,
                            "type": "Boolean"
                        },
                        {
                            "name": "isExpanded",
                            "isAttr": true,
                            "type": "Boolean"
                        },
                        {
                            "name": "isMarkerVisible",
                            "isAttr": true,
                            "type": "Boolean"
                        },
                        {
                            "name": "label",
                            "type": "BPMNLabel"
                        },
                        {
                            "name": "isMessageVisible",
                            "isAttr": true,
                            "type": "Boolean"
                        },
                        {
                            "name": "participantBandKind",
                            "type": "ParticipantBandKind",
                            "isAttr": true
                        },
                        {
                            "name": "choreographyActivityShape",
                            "type": "BPMNShape",
                            "isAttr": true,
                            "isReference": true
                        }
                    ],
                    "superClass": [
                        "di:LabeledShape"
                    ]
                },
                {
                    "name": "BPMNEdge",
                    "properties": [
                        {
                            "name": "label",
                            "type": "BPMNLabel"
                        },
                        {
                            "name": "bpmnElement",
                            "isAttr": true,
                            "isReference": true,
                            "type": "bpmn:BaseElement",
                            "redefines": "di:DiagramElement#modelElement"
                        },
                        {
                            "name": "sourceElement",
                            "isAttr": true,
                            "isReference": true,
                            "type": "di:DiagramElement",
                            "redefines": "di:Edge#source"
                        },
                        {
                            "name": "targetElement",
                            "isAttr": true,
                            "isReference": true,
                            "type": "di:DiagramElement",
                            "redefines": "di:Edge#target"
                        },
                        {
                            "name": "messageVisibleKind",
                            "type": "MessageVisibleKind",
                            "isAttr": true,
                            "default": "initiating"
                        }
                    ],
                    "superClass": [
                        "di:LabeledEdge"
                    ]
                },
                {
                    "name": "BPMNLabel",
                    "properties": [
                        {
                            "name": "labelStyle",
                            "type": "BPMNLabelStyle",
                            "isAttr": true,
                            "isReference": true,
                            "redefines": "di:DiagramElement#style"
                        }
                    ],
                    "superClass": [
                        "di:Label"
                    ]
                },
                {
                    "name": "BPMNLabelStyle",
                    "properties": [
                        {
                            "name": "font",
                            "type": "dc:Font"
                        }
                    ],
                    "superClass": [
                        "di:Style"
                    ]
                }
            ],
            "emumerations": [
                {
                    "name": "ParticipantBandKind",
                    "literalValues": [
                        {
                            "name": "top_initiating"
                        },
                        {
                            "name": "middle_initiating"
                        },
                        {
                            "name": "bottom_initiating"
                        },
                        {
                            "name": "top_non_initiating"
                        },
                        {
                            "name": "middle_non_initiating"
                        },
                        {
                            "name": "bottom_non_initiating"
                        }
                    ]
                },
                {
                    "name": "MessageVisibleKind",
                    "literalValues": [
                        {
                            "name": "initiating"
                        },
                        {
                            "name": "non_initiating"
                        }
                    ]
                }
            ],
            "associations": [],
            "prefix": "bpmndi"
        }
    }, {}], 105: [function (require, module, exports) {
        module.exports = {
            "name": "DC",
            "uri": "http://www.omg.org/spec/DD/20100524/DC",
            "types": [
                {
                    "name": "Boolean"
                },
                {
                    "name": "Integer"
                },
                {
                    "name": "Real"
                },
                {
                    "name": "String"
                },
                {
                    "name": "Font",
                    "properties": [
                        {
                            "name": "name",
                            "type": "String",
                            "isAttr": true
                        },
                        {
                            "name": "size",
                            "type": "Real",
                            "isAttr": true
                        },
                        {
                            "name": "isBold",
                            "type": "Boolean",
                            "isAttr": true
                        },
                        {
                            "name": "isItalic",
                            "type": "Boolean",
                            "isAttr": true
                        },
                        {
                            "name": "isUnderline",
                            "type": "Boolean",
                            "isAttr": true
                        },
                        {
                            "name": "isStrikeThrough",
                            "type": "Boolean",
                            "isAttr": true
                        }
                    ]
                },
                {
                    "name": "Point",
                    "properties": [
                        {
                            "name": "x",
                            "type": "Real",
                            "default": "0",
                            "isAttr": true
                        },
                        {
                            "name": "y",
                            "type": "Real",
                            "default": "0",
                            "isAttr": true
                        }
                    ]
                },
                {
                    "name": "Bounds",
                    "properties": [
                        {
                            "name": "x",
                            "type": "Real",
                            "default": "0",
                            "isAttr": true
                        },
                        {
                            "name": "y",
                            "type": "Real",
                            "default": "0",
                            "isAttr": true
                        },
                        {
                            "name": "width",
                            "type": "Real",
                            "isAttr": true
                        },
                        {
                            "name": "height",
                            "type": "Real",
                            "isAttr": true
                        }
                    ]
                }
            ],
            "prefix": "dc",
            "associations": []
        }
    }, {}], 106: [function (require, module, exports) {
        module.exports = {
            "name": "DI",
            "uri": "http://www.omg.org/spec/DD/20100524/DI",
            "types": [
                {
                    "name": "DiagramElement",
                    "isAbstract": true,
                    "properties": [
                        {
                            "name": "id",
                            "type": "String",
                            "isAttr": true,
                            "isId": true
                        },
                        {
                            "name": "extension",
                            "type": "Extension"
                        },
                        {
                            "name": "owningDiagram",
                            "type": "Diagram",
                            "isReadOnly": true,
                            "isVirtual": true,
                            "isReference": true
                        },
                        {
                            "name": "owningElement",
                            "type": "DiagramElement",
                            "isReadOnly": true,
                            "isVirtual": true,
                            "isReference": true
                        },
                        {
                            "name": "modelElement",
                            "isReadOnly": true,
                            "isVirtual": true,
                            "isReference": true,
                            "type": "Element"
                        },
                        {
                            "name": "style",
                            "type": "Style",
                            "isReadOnly": true,
                            "isVirtual": true,
                            "isReference": true
                        },
                        {
                            "name": "ownedElement",
                            "type": "DiagramElement",
                            "isReadOnly": true,
                            "isVirtual": true,
                            "isMany": true
                        }
                    ]
                },
                {
                    "name": "Node",
                    "isAbstract": true,
                    "superClass": [
                        "DiagramElement"
                    ]
                },
                {
                    "name": "Edge",
                    "isAbstract": true,
                    "superClass": [
                        "DiagramElement"
                    ],
                    "properties": [
                        {
                            "name": "source",
                            "type": "DiagramElement",
                            "isReadOnly": true,
                            "isVirtual": true,
                            "isReference": true
                        },
                        {
                            "name": "target",
                            "type": "DiagramElement",
                            "isReadOnly": true,
                            "isVirtual": true,
                            "isReference": true
                        },
                        {
                            "name": "waypoint",
                            "isUnique": false,
                            "isMany": true,
                            "type": "dc:Point",
                            "xml": {
                                "serialize": "xsi:type"
                            }
                        }
                    ]
                },
                {
                    "name": "Diagram",
                    "isAbstract": true,
                    "properties": [
                        {
                            "name": "id",
                            "type": "String",
                            "isAttr": true,
                            "isId": true
                        },
                        {
                            "name": "rootElement",
                            "type": "DiagramElement",
                            "isReadOnly": true,
                            "isVirtual": true
                        },
                        {
                            "name": "name",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "documentation",
                            "isAttr": true,
                            "type": "String"
                        },
                        {
                            "name": "resolution",
                            "isAttr": true,
                            "type": "Real"
                        },
                        {
                            "name": "ownedStyle",
                            "type": "Style",
                            "isReadOnly": true,
                            "isVirtual": true,
                            "isMany": true
                        }
                    ]
                },
                {
                    "name": "Shape",
                    "isAbstract": true,
                    "superClass": [
                        "Node"
                    ],
                    "properties": [
                        {
                            "name": "bounds",
                            "type": "dc:Bounds"
                        }
                    ]
                },
                {
                    "name": "Plane",
                    "isAbstract": true,
                    "superClass": [
                        "Node"
                    ],
                    "properties": [
                        {
                            "name": "planeElement",
                            "type": "DiagramElement",
                            "subsettedProperty": "DiagramElement-ownedElement",
                            "isMany": true
                        }
                    ]
                },
                {
                    "name": "LabeledEdge",
                    "isAbstract": true,
                    "superClass": [
                        "Edge"
                    ],
                    "properties": [
                        {
                            "name": "ownedLabel",
                            "type": "Label",
                            "isReadOnly": true,
                            "subsettedProperty": "DiagramElement-ownedElement",
                            "isVirtual": true,
                            "isMany": true
                        }
                    ]
                },
                {
                    "name": "LabeledShape",
                    "isAbstract": true,
                    "superClass": [
                        "Shape"
                    ],
                    "properties": [
                        {
                            "name": "ownedLabel",
                            "type": "Label",
                            "isReadOnly": true,
                            "subsettedProperty": "DiagramElement-ownedElement",
                            "isVirtual": true,
                            "isMany": true
                        }
                    ]
                },
                {
                    "name": "Label",
                    "isAbstract": true,
                    "superClass": [
                        "Node"
                    ],
                    "properties": [
                        {
                            "name": "bounds",
                            "type": "dc:Bounds"
                        }
                    ]
                },
                {
                    "name": "Style",
                    "isAbstract": true,
                    "properties": [
                        {
                            "name": "id",
                            "type": "String",
                            "isAttr": true,
                            "isId": true
                        }
                    ]
                },
                {
                    "name": "Extension",
                    "properties": [
                        {
                            "name": "values",
                            "type": "Element",
                            "isMany": true
                        }
                    ]
                }
            ],
            "associations": [],
            "prefix": "di",
            "xml": {
                "tagAlias": "lowerCase"
            }
        }
    }, {}], 107: [function (require, module, exports) {
        /**
         * Module dependencies.
         */

        try {
            var index = require('indexof');
        } catch (err) {
            var index = require('component-indexof');
        }

        /**
         * Whitespace regexp.
         */

        var re = /\s+/;

        /**
         * toString reference.
         */

        var toString = Object.prototype.toString;

        /**
         * Wrap `el` in a `ClassList`.
         *
         * @param {Element} el
         * @return {ClassList}
         * @api public
         */

        module.exports = function (el) {
            return new ClassList(el);
        };

        /**
         * Initialize a new ClassList for `el`.
         *
         * @param {Element} el
         * @api private
         */

        function ClassList(el) {
            if (!el || !el.nodeType) {
                throw new Error('A DOM element reference is required');
            }
            this.el = el;
            this.list = el.classList;
        }

        /**
         * Add class `name` if not already present.
         *
         * @param {String} name
         * @return {ClassList}
         * @api public
         */

        ClassList.prototype.add = function (name) {
            // classList
            if (this.list) {
                this.list.add(name);
                return this;
            }

            // fallback
            var arr = this.array();
            var i = index(arr, name);
            if (!~i) arr.push(name);
            this.el.className = arr.join(' ');
            return this;
        };

        /**
         * Remove class `name` when present, or
         * pass a regular expression to remove
         * any which match.
         *
         * @param {String|RegExp} name
         * @return {ClassList}
         * @api public
         */

        ClassList.prototype.remove = function (name) {
            if ('[object RegExp]' == toString.call(name)) {
                return this.removeMatching(name);
            }

            // classList
            if (this.list) {
                this.list.remove(name);
                return this;
            }

            // fallback
            var arr = this.array();
            var i = index(arr, name);
            if (~i) arr.splice(i, 1);
            this.el.className = arr.join(' ');
            return this;
        };

        /**
         * Remove all classes matching `re`.
         *
         * @param {RegExp} re
         * @return {ClassList}
         * @api private
         */

        ClassList.prototype.removeMatching = function (re) {
            var arr = this.array();
            for (var i = 0; i < arr.length; i++) {
                if (re.test(arr[i])) {
                    this.remove(arr[i]);
                }
            }
            return this;
        };

        /**
         * Toggle class `name`, can force state via `force`.
         *
         * For browsers that support classList, but do not support `force` yet,
         * the mistake will be detected and corrected.
         *
         * @param {String} name
         * @param {Boolean} force
         * @return {ClassList}
         * @api public
         */

        ClassList.prototype.toggle = function (name, force) {
            // classList
            if (this.list) {
                if ("undefined" !== typeof force) {
                    if (force !== this.list.toggle(name, force)) {
                        this.list.toggle(name); // toggle again to correct
                    }
                } else {
                    this.list.toggle(name);
                }
                return this;
            }

            // fallback
            if ("undefined" !== typeof force) {
                if (!force) {
                    this.remove(name);
                } else {
                    this.add(name);
                }
            } else {
                if (this.has(name)) {
                    this.remove(name);
                } else {
                    this.add(name);
                }
            }

            return this;
        };

        /**
         * Return an array of classes.
         *
         * @return {Array}
         * @api public
         */

        ClassList.prototype.array = function () {
            var className = this.el.getAttribute('class') || '';
            var str = className.replace(/^\s+|\s+$/g, '');
            var arr = str.split(re);
            if ('' === arr[0]) arr.shift();
            return arr;
        };

        /**
         * Check if class `name` is present.
         *
         * @param {String} name
         * @return {ClassList}
         * @api public
         */

        ClassList.prototype.has =
            ClassList.prototype.contains = function (name) {
                return this.list
                    ? this.list.contains(name)
                    : !! ~index(this.array(), name);
            };

    }, { "component-indexof": 111, "indexof": 111 }], 108: [function (require, module, exports) {
        var matches = require('matches-selector')

        module.exports = function (element, selector, checkYoSelf, root) {
            element = checkYoSelf ? { parentNode: element } : element

            root = root || document

            // Make sure `element !== document` and `element != null`
            // otherwise we get an illegal invocation
            while ((element = element.parentNode) && element !== document) {
                if (matches(element, selector))
                    return element
                // After `matches` on the edge case that
                // the selector matches the root
                // (when the root is not the document)
                if (element === root)
                    return
            }
        }

    }, { "matches-selector": 112 }], 109: [function (require, module, exports) {
        /**
         * Module dependencies.
         */

        try {
            var closest = require('closest');
        } catch (err) {
            var closest = require('component-closest');
        }

        try {
            var event = require('event');
        } catch (err) {
            var event = require('component-event');
        }

        /**
         * Delegate event `type` to `selector`
         * and invoke `fn(e)`. A callback function
         * is returned which may be passed to `.unbind()`.
         *
         * @param {Element} el
         * @param {String} selector
         * @param {String} type
         * @param {Function} fn
         * @param {Boolean} capture
         * @return {Function}
         * @api public
         */

        exports.bind = function (el, selector, type, fn, capture) {
            return event.bind(el, type, function (e) {
                var target = e.target || e.srcElement;
                e.delegateTarget = closest(target, selector, true, el);
                if (e.delegateTarget) fn.call(el, e);
            }, capture);
        };

        /**
         * Unbind event `type`'s callback `fn`.
         *
         * @param {Element} el
         * @param {String} type
         * @param {Function} fn
         * @param {Boolean} capture
         * @api public
         */

        exports.unbind = function (el, type, fn, capture) {
            event.unbind(el, type, fn, capture);
        };

    }, { "closest": 108, "component-closest": 108, "component-event": 110, "event": 110 }], 110: [function (require, module, exports) {
        var bind = window.addEventListener ? 'addEventListener' : 'attachEvent',
            unbind = window.removeEventListener ? 'removeEventListener' : 'detachEvent',
            prefix = bind !== 'addEventListener' ? 'on' : '';

        /**
         * Bind `el` event `type` to `fn`.
         *
         * @param {Element} el
         * @param {String} type
         * @param {Function} fn
         * @param {Boolean} capture
         * @return {Function}
         * @api public
         */

        exports.bind = function (el, type, fn, capture) {
            el[bind](prefix + type, fn, capture || false);
            return fn;
        };

        /**
         * Unbind `el` event `type`'s callback `fn`.
         *
         * @param {Element} el
         * @param {String} type
         * @param {Function} fn
         * @param {Boolean} capture
         * @return {Function}
         * @api public
         */

        exports.unbind = function (el, type, fn, capture) {
            el[unbind](prefix + type, fn, capture || false);
            return fn;
        };
    }, {}], 111: [function (require, module, exports) {
        module.exports = function (arr, obj) {
            if (arr.indexOf) return arr.indexOf(obj);
            for (var i = 0; i < arr.length; ++i) {
                if (arr[i] === obj) return i;
            }
            return -1;
        };
    }, {}], 112: [function (require, module, exports) {
        /**
         * Module dependencies.
         */

        try {
            var query = require('query');
        } catch (err) {
            var query = require('component-query');
        }

        /**
         * Element prototype.
         */

        var proto = Element.prototype;

        /**
         * Vendor function.
         */

        var vendor = proto.matches
            || proto.webkitMatchesSelector
            || proto.mozMatchesSelector
            || proto.msMatchesSelector
            || proto.oMatchesSelector;

        /**
         * Expose `match()`.
         */

        module.exports = match;

        /**
         * Match `el` to `selector`.
         *
         * @param {Element} el
         * @param {String} selector
         * @return {Boolean}
         * @api public
         */

        function match(el, selector) {
            if (!el || el.nodeType !== 1) return false;
            if (vendor) return vendor.call(el, selector);
            var nodes = query.all(selector, el.parentNode);
            for (var i = 0; i < nodes.length; ++i) {
                if (nodes[i] == el) return true;
            }
            return false;
        }

    }, { "component-query": 113, "query": 113 }], 113: [function (require, module, exports) {
        function one(selector, el) {
            return el.querySelector(selector);
        }

        exports = module.exports = function (selector, el) {
            el = el || document;
            return one(selector, el);
        };

        exports.all = function (selector, el) {
            el = el || document;
            return el.querySelectorAll(selector);
        };

        exports.engine = function (obj) {
            if (!obj.one) throw new Error('.one callback required');
            if (!obj.all) throw new Error('.all callback required');
            one = obj.one;
            exports.all = obj.all;
            return exports;
        };

    }, {}], 114: [function (require, module, exports) {
        module.exports = {
            __depends__: [require('diagram-js/lib/features/interaction-events')],
            __init__: ['directEditing'],
            directEditing: ['type', require('./lib/DirectEditing')]
        };
    }, { "./lib/DirectEditing": 115, "diagram-js/lib/features/interaction-events": 170 }], 115: [function (require, module, exports) {
        'use strict';

        var bind = require('lodash/function/bind'),
            find = require('lodash/collection/find');

        var TextBox = require('./TextBox');


        /**
         * A direct editing component that allows users
         * to edit an elements text directly in the diagram
         *
         * @param {EventBus} eventBus the event bus
         */
        function DirectEditing(eventBus, canvas) {

            this._eventBus = eventBus;

            this._providers = [];
            this._textbox = new TextBox({
                container: canvas.getContainer(),
                keyHandler: bind(this._handleKey, this)
            });
        }

        DirectEditing.$inject = ['eventBus', 'canvas'];


        /**
         * Register a direct editing provider
        
         * @param {Object} provider the provider, must expose an #activate(element) method that returns
         *                          an activation context ({ bounds: {x, y, width, height }, text }) if
         *                          direct editing is available for the given element.
         *                          Additionally the provider must expose a #update(element, value) method
         *                          to receive direct editing updates.
         */
        DirectEditing.prototype.registerProvider = function (provider) {
            this._providers.push(provider);
        };


        /**
         * Returns true if direct editing is currently active
         *
         * @return {Boolean}
         */
        DirectEditing.prototype.isActive = function () {
            return !!this._active;
        };


        /**
         * Cancel direct editing, if it is currently active
         */
        DirectEditing.prototype.cancel = function () {
            if (!this._active) {
                return;
            }

            this._fire('cancel');
            this.close();
        };


        DirectEditing.prototype._fire = function (event) {
            this._eventBus.fire('directEditing.' + event, { active: this._active });
        };

        DirectEditing.prototype.close = function () {
            this._textbox.destroy();

            this._fire('deactivate');

            this._active = null;
        };


        DirectEditing.prototype.complete = function () {

            var active = this._active;

            if (!active) {
                return;
            }

            var text = this.getValue();

            if (text !== active.context.text) {
                active.provider.update(active.element, text, active.context.text);
            }

            this._fire('complete');

            this.close();
        };


        DirectEditing.prototype.getValue = function () {
            return this._textbox.getValue();
        };


        DirectEditing.prototype._handleKey = function (e) {

            // stop bubble
            e.stopPropagation();

            var key = e.keyCode || e.charCode;

            // ESC
            if (key === 27) {
                e.preventDefault();
                return this.cancel();
            }

            // Enter
            if (key === 13 && !e.shiftKey) {
                e.preventDefault();
                return this.complete();
            }
        };


        /**
         * Activate direct editing on the given element
         *
         * @param {Object} ElementDescriptor the descriptor for a shape or connection
         * @return {Boolean} true if the activation was possible
         */
        DirectEditing.prototype.activate = function (element) {

            if (this.isActive()) {
                this.cancel();
            }

            // the direct editing context
            var context;

            var provider = find(this._providers, function (p) {
                return (context = p.activate(element)) ? p : null;
            });

            // check if activation took place
            if (context) {
                this._textbox.create(context.bounds, context.style, context.text);

                this._active = {
                    element: element,
                    context: context,
                    provider: provider
                };

                this._fire('activate');
            }

            return !!context;
        };


        module.exports = DirectEditing;
    }, { "./TextBox": 116, "lodash/collection/find": 303, "lodash/function/bind": 313 }], 116: [function (require, module, exports) {
        'use strict';

        var assign = require('lodash/object/assign'),
            domEvent = require('min-dom/lib/event'),
            domRemove = require('min-dom/lib/remove');

        function stopPropagation(event) {
            event.stopPropagation();
        }


        /**
         * Initializes a container div 'contentContainer' which contains an editable content div 'content'.
         *
         * @param {object} options
         * @param {DOMElement} options.container The DOM element to append the contentContainer to
         * @param {String} options.keyHandler
         */
        function TextBox(options) {

            this.container = options.container;

            this.content = document.createElement('div');

            this.content.contentEditable = 'true';

            this.keyHandler = options.keyHandler || function () { };
        }

        module.exports = TextBox;


        /**
         * Create a text box with the given position, size, style and text content
         *
         * @param {Object} bounds
         * @param {Number} bounds.x absolute x position
         * @param {Number} bounds.y absolute y position
         * @param {Number} [bounds.width] fixed width value
         * @param {Number} [bounds.height] fixed height value
         * @param {Number} [bounds.maxWidth] maximum width value
         * @param {Number} [bounds.maxHeight] maximum height value
         * @param {Number} [bounds.minWidth] minimum width value
         * @param {Number} [bounds.minHeight] minimum height value
         * @param {Object} [style]
         * @param {String} value text content
         *
         * @return {DOMElement} The created content DOM element
         */
        TextBox.prototype.create = function (bounds, style, value) {

            var content = this.content,
                container = this.container;

            assign(content.style, {
                width: bounds.width + 'px',
                height: bounds.height + 'px',
                maxWidth: bounds.maxWidth + 'px',
                maxHeight: bounds.maxHeight + 'px',
                minWidth: bounds.minWidth + 'px',
                minHeight: bounds.minHeight + 'px',
                left: bounds.x + 'px',
                top: bounds.y + 'px',
                backgroundColor: '#ffffff',
                position: 'absolute',
                overflowY: 'auto',
                border: '1px solid #ccc',
                padding: '2px',
                wordWrap: 'normal',
                textAlign: 'center',
                outline: 'none'
            }, style || {});

            content.innerText = value;

            domEvent.bind(content, 'keydown', this.keyHandler);
            domEvent.bind(content, 'mousedown', stopPropagation);

            container.appendChild(content);

            this.setCursor();

            return content;
        };


        /**
         * Clear content and style of the textbox, unbind listeners and
         * reset CSS style.
         */
        TextBox.prototype.destroy = function () {
            var content = this.content;

            // clear content
            content.innerText = '';

            // clear optional bounds values
            assign(content.style, {
                width: '',
                height: '',
                maxWidth: '',
                maxHeight: '',
                minWidth: '',
                minHeight: ''
            });

            domEvent.unbind(content, 'keydown', this.keyHandler);
            domEvent.unbind(content, 'mousedown', stopPropagation);

            domRemove(content);
        };


        TextBox.prototype.getValue = function () {
            return this.content.innerText;
        };


        /**
         * Set the cursor to the end of the text
         */
        TextBox.prototype.setCursor = function () {

            this.content.focus();

            // scroll to the bottom
            this.content.scrollTop = this.content.scrollHeight;

            if (typeof window.getSelection != 'undefined' && typeof document.createRange != 'undefined') {

                var range = document.createRange();

                range.selectNodeContents(this.content);
                range.collapse(false);

                var selection = window.getSelection();

                selection.removeAllRanges();
                selection.addRange(range);

            } else if (typeof document.body.createTextRange != 'undefined') {

                var textRange = document.body.createTextRange();

                textRange.moveToElementText(this.content);
                textRange.collapse(false);
                textRange.select();
            }
        };

    }, { "lodash/object/assign": 433, "min-dom/lib/event": 452, "min-dom/lib/remove": 455 }], 117: [function (require, module, exports) {
        module.exports = require('./lib/Diagram');
    }, { "./lib/Diagram": 118 }], 118: [function (require, module, exports) {
        'use strict';

        var di = require('didi');


        /**
         * Bootstrap an injector from a list of modules, instantiating a number of default components
         *
         * @ignore
         * @param {Array<didi.Module>} bootstrapModules
         *
         * @return {didi.Injector} a injector to use to access the components
         */
        function bootstrap(bootstrapModules) {

            var modules = [],
                components = [];

            function hasModule(m) {
                return modules.indexOf(m) >= 0;
            }

            function addModule(m) {
                modules.push(m);
            }

            function visit(m) {
                if (hasModule(m)) {
                    return;
                }

                (m.__depends__ || []).forEach(visit);

                if (hasModule(m)) {
                    return;
                }

                addModule(m);

                (m.__init__ || []).forEach(function (c) {
                    components.push(c);
                });
            }

            bootstrapModules.forEach(visit);

            var injector = new di.Injector(modules);

            components.forEach(function (c) {

                try {
                    // eagerly resolve component (fn or string)
                    injector[typeof c === 'string' ? 'get' : 'invoke'](c);
                } catch (e) {
                    console.error('Failed to instantiate component');
                    console.error(e.stack);

                    throw e;
                }
            });

            return injector;
        }

        /**
         * Creates an injector from passed options.
         *
         * @ignore
         * @param  {Object} options
         * @return {didi.Injector}
         */
        function createInjector(options) {

            options = options || {};

            var configModule = {
                'config': ['value', options]
            };

            var coreModule = require('./core');

            var modules = [configModule, coreModule].concat(options.modules || []);

            return bootstrap(modules);
        }


        /**
         * The main diagram-js entry point that bootstraps the diagram with the given
         * configuration.
         *
         * To register extensions with the diagram, pass them as Array<didi.Module> to the constructor.
         *
         * @class djs.Diagram
         * @memberOf djs
         * @constructor
         *
         * @example
         *
         * <caption>Creating a plug-in that logs whenever a shape is added to the canvas.</caption>
         *
         * // plug-in implemenentation
         * function MyLoggingPlugin(eventBus) {
         *   eventBus.on('shape.added', function(event) {
         *     console.log('shape ', event.shape, ' was added to the diagram');
         *   });
         * }
         *
         * // export as module
         * module.exports = {
         *   __init__: [ 'myLoggingPlugin' ],
         *     myLoggingPlugin: [ 'type', MyLoggingPlugin ]
         * };
         *
         *
         * // instantiate the diagram with the new plug-in
         *
         * var diagram = new Diagram({ modules: [ require('path-to-my-logging-plugin') ] });
         *
         * diagram.invoke([ 'canvas', function(canvas) {
         *   // add shape to drawing canvas
         *   canvas.addShape({ x: 10, y: 10 });
         * });
         *
         * // 'shape ... was added to the diagram' logged to console
         *
         * @param {Object} options
         * @param {Array<didi.Module>} [options.modules] external modules to instantiate with the diagram
         * @param {didi.Injector} [injector] an (optional) injector to bootstrap the diagram with
         */
        function Diagram(options, injector) {

            // create injector unless explicitly specified
            this.injector = injector = injector || createInjector(options);

            // API

            /**
             * Resolves a diagram service
             *
             * @method Diagram#get
             *
             * @param {String} name the name of the diagram service to be retrieved
             * @param {Boolean} [strict=true] if false, resolve missing services to null
             */
            this.get = injector.get;

            /**
             * Executes a function into which diagram services are injected
             *
             * @method Diagram#invoke
             *
             * @param {Function|Object[]} fn the function to resolve
             * @param {Object} locals a number of locals to use to resolve certain dependencies
             */
            this.invoke = injector.invoke;

            // init

            // indicate via event


            /**
             * An event indicating that all plug-ins are loaded.
             *
             * Use this event to fire other events to interested plug-ins
             *
             * @memberOf Diagram
             *
             * @event diagram.init
             *
             * @example
             *
             * eventBus.on('diagram.init', function() {
             *   eventBus.fire('my-custom-event', { foo: 'BAR' });
             * });
             *
             * @type {Object}
             */
            this.get('eventBus').fire('diagram.init');
        }

        module.exports = Diagram;


        /**
         * Destroys the diagram
         *
         * @method  Diagram#destroy
         */
        Diagram.prototype.destroy = function () {
            this.get('eventBus').fire('diagram.destroy');
        };

        /**
         * Clear the diagram, removing all contents.
         */
        Diagram.prototype.clear = function () {
            this.get('eventBus').fire('diagram.clear');
        };

    }, { "./core": 127, "didi": 282 }], 119: [function (require, module, exports) {
        'use strict';

        var forEach = require('lodash/collection/forEach'),
            isFunction = require('lodash/lang/isFunction'),
            isArray = require('lodash/lang/isArray'),
            isNumber = require('lodash/lang/isNumber');


        var DEFAULT_PRIORITY = 1000;


        function isObject(element) {
            return typeof element === 'object';
        }

        /**
         * A utility that can be used to plug-in into the command execution for
         * extension and/or validation.
         *
         * @param {EventBus} eventBus
         *
         * @example
         *
         * var inherits = require('inherits');
         *
         * var CommandInterceptor = require('diagram-js/lib/command/CommandInterceptor');
         *
         * function CommandLogger(eventBus) {
         *   CommandInterceptor.call(this, eventBus);
         *
         *   this.preExecute(function(event) {
         *     console.log('command pre-execute', event);
         *   });
         * }
         *
         * inherits(CommandLogger, CommandInterceptor);
         *
         */
        function CommandInterceptor(eventBus) {
            this._eventBus = eventBus;
        }

        CommandInterceptor.$inject = ['eventBus'];

        module.exports = CommandInterceptor;

        function unwrapEvent(fn, that) {
            return function (event) {
                return fn.call(that || null, event.context, event.command, event);
            };
        }

        /**
         * Register an interceptor for a command execution
         *
         * @param {String|Array<String>} [events] list of commands to register on
         * @param {String} [hook] command hook, i.e. preExecute, executed to listen on
         * @param {Number} [priority] the priority on which to hook into the execution
         * @param {Function} handlerFn interceptor to be invoked with (event)
         * @param {Boolean} unwrap if true, unwrap the event and pass (context, command, event) to the
         *                          listener instead
         * @param {Object} [that] Pass context (`this`) to the handler function
         */
        CommandInterceptor.prototype.on = function (events, hook, priority, handlerFn, unwrap, that) {

            if (isFunction(hook) || isNumber(hook)) {
                that = unwrap;
                unwrap = handlerFn;
                handlerFn = priority;
                priority = hook;
                hook = null;
            }

            if (isFunction(priority)) {
                that = unwrap;
                unwrap = handlerFn;
                handlerFn = priority;
                priority = DEFAULT_PRIORITY;
            }

            if (isObject(unwrap)) {
                that = unwrap;
                unwrap = false;
            }

            if (!isFunction(handlerFn)) {
                throw new Error('handlerFn must be a function');
            }

            if (!isArray(events)) {
                events = [events];
            }

            var eventBus = this._eventBus;

            forEach(events, function (event) {
                // concat commandStack(.event)?(.hook)?
                var fullEvent = ['commandStack', event, hook].filter(function (e) { return e; }).join('.');

                eventBus.on(fullEvent, priority, unwrap ? unwrapEvent(handlerFn, that) : handlerFn, that);
            });
        };


        var hooks = [
            'canExecute',
            'preExecute',
            'preExecuted',
            'execute',
            'executed',
            'postExecute',
            'postExecuted',
            'revert',
            'reverted'
        ];

        /*
         * Install hook shortcuts
         *
         * This will generate the CommandInterceptor#(preExecute|...|reverted) methods
         * which will in term forward to CommandInterceptor#on.
         */
        forEach(hooks, function (hook) {

            /**
             * {canExecute|preExecute|preExecuted|execute|executed|postExecute|postExecuted|revert|reverted}
             *
             * A named hook for plugging into the command execution
             *
             * @param {String|Array<String>} [events] list of commands to register on
             * @param {Number} [priority] the priority on which to hook into the execution
             * @param {Function} handlerFn interceptor to be invoked with (event)
             * @param {Boolean} [unwrap=false] if true, unwrap the event and pass (context, command, event) to the
             *                          listener instead
             * @param {Object} [that] Pass context (`this`) to the handler function
             */
            CommandInterceptor.prototype[hook] = function (events, priority, handlerFn, unwrap, that) {

                if (isFunction(events) || isNumber(events)) {
                    that = unwrap;
                    unwrap = handlerFn;
                    handlerFn = priority;
                    priority = events;
                    events = null;
                }

                this.on(events, hook, priority, handlerFn, unwrap, that);
            };
        });

    }, { "lodash/collection/forEach": 304, "lodash/lang/isArray": 424, "lodash/lang/isFunction": 425, "lodash/lang/isNumber": 427 }], 120: [function (require, module, exports) {
        'use strict';

        var unique = require('lodash/array/unique'),
            isArray = require('lodash/lang/isArray'),
            assign = require('lodash/object/assign');

        var InternalEvent = require('../core/EventBus').Event;


        /**
         * A service that offers un- and redoable execution of commands.
         *
         * The command stack is responsible for executing modeling actions
         * in a un- and redoable manner. To do this it delegates the actual
         * command execution to {@link CommandHandler}s.
         *
         * Command handlers provide {@link CommandHandler#execute(ctx)} and
         * {@link CommandHandler#revert(ctx)} methods to un- and redo a command
         * identified by a command context.
         *
         *
         * ## Life-Cycle events
         *
         * In the process the command stack fires a number of life-cycle events
         * that other components to participate in the command execution.
         *
         *    * preExecute
         *    * preExecuted
         *    * execute
         *    * executed
         *    * postExecute
         *    * postExecuted
         *    * revert
         *    * reverted
         *
         * A special event is used for validating, whether a command can be
         * performed prior to its execution.
         *
         *    * canExecute
         *
         * Each of the events is fired as `commandStack.{eventName}` and
         * `commandStack.{commandName}.{eventName}`, respectively. This gives
         * components fine grained control on where to hook into.
         *
         * The event object fired transports `command`, the name of the
         * command and `context`, the command context.
         *
         *
         * ## Creating Command Handlers
         *
         * Command handlers should provide the {@link CommandHandler#execute(ctx)}
         * and {@link CommandHandler#revert(ctx)} methods to implement
         * redoing and undoing of a command.
         *
         * A command handler _must_ ensure undo is performed properly in order
         * not to break the undo chain. It must also return the shapes that
         * got changed during the `execute` and `revert` operations.
         *
         * Command handlers may execute other modeling operations (and thus
         * commands) in their `preExecute` and `postExecute` phases. The command
         * stack will properly group all commands together into a logical unit
         * that may be re- and undone atomically.
         *
         * Command handlers must not execute other commands from within their
         * core implementation (`execute`, `revert`).
         *
         *
         * ## Change Tracking
         *
         * During the execution of the CommandStack it will keep track of all
         * elements that have been touched during the command's execution.
         *
         * At the end of the CommandStack execution it will notify interested
         * components via an 'elements.changed' event with all the dirty
         * elements.
         *
         * The event can be picked up by components that are interested in the fact
         * that elements have been changed. One use case for this is updating
         * their graphical representation after moving / resizing or deletion.
         *
         * @see CommandHandler
         *
         * @param {EventBus} eventBus
         * @param {Injector} injector
         */
        function CommandStack(eventBus, injector) {

            /**
             * A map of all registered command handlers.
             *
             * @type {Object}
             */
            this._handlerMap = {};

            /**
             * A stack containing all re/undoable actions on the diagram
             *
             * @type {Array<Object>}
             */
            this._stack = [];

            /**
             * The current index on the stack
             *
             * @type {Number}
             */
            this._stackIdx = -1;

            /**
             * Current active commandStack execution
             *
             * @type {Object}
             */
            this._currentExecution = {
                actions: [],
                dirty: []
            };


            this._injector = injector;
            this._eventBus = eventBus;

            this._uid = 1;

            eventBus.on(['diagram.destroy', 'diagram.clear'], this.clear, this);
        }

        CommandStack.$inject = ['eventBus', 'injector'];

        module.exports = CommandStack;


        /**
         * Execute a command
         *
         * @param {String} command the command to execute
         * @param {Object} context the environment to execute the command in
         */
        CommandStack.prototype.execute = function (command, context) {
            if (!command) {
                throw new Error('command required');
            }

            var action = { command: command, context: context };

            this._pushAction(action);
            this._internalExecute(action);
            this._popAction(action);
        };


        /**
         * Ask whether a given command can be executed.
         *
         * Implementors may hook into the mechanism on two ways:
         *
         *   * in event listeners:
         *
         *     Users may prevent the execution via an event listener.
         *     It must prevent the default action for `commandStack.(<command>.)canExecute` events.
         *
         *   * in command handlers:
         *
         *     If the method {@link CommandHandler#canExecute} is implemented in a handler
         *     it will be called to figure out whether the execution is allowed.
         *
         * @param  {String} command the command to execute
         * @param  {Object} context the environment to execute the command in
         *
         * @return {Boolean} true if the command can be executed
         */
        CommandStack.prototype.canExecute = function (command, context) {

            var action = { command: command, context: context };

            var handler = this._getHandler(command);

            var result = this._fire(command, 'canExecute', action);

            // handler#canExecute will only be called if no listener
            // decided on a result already
            if (result === undefined) {
                if (!handler) {
                    return false;
                }

                if (handler.canExecute) {
                    result = handler.canExecute(context);
                }
            }

            return result;
        };


        /**
         * Clear the command stack, erasing all undo / redo history
         */
        CommandStack.prototype.clear = function () {
            this._stack.length = 0;
            this._stackIdx = -1;

            this._fire('changed');
        };


        /**
         * Undo last command(s)
         */
        CommandStack.prototype.undo = function () {
            var action = this._getUndoAction(),
                next;

            if (action) {
                this._pushAction(action);

                while (action) {
                    this._internalUndo(action);
                    next = this._getUndoAction();

                    if (!next || next.id !== action.id) {
                        break;
                    }

                    action = next;
                }

                this._popAction();
            }
        };


        /**
         * Redo last command(s)
         */
        CommandStack.prototype.redo = function () {
            var action = this._getRedoAction(),
                next;

            if (action) {
                this._pushAction(action);

                while (action) {
                    this._internalExecute(action, true);
                    next = this._getRedoAction();

                    if (!next || next.id !== action.id) {
                        break;
                    }

                    action = next;
                }

                this._popAction();
            }
        };


        /**
         * Register a handler instance with the command stack
         *
         * @param {String} command
         * @param {CommandHandler} handler
         */
        CommandStack.prototype.register = function (command, handler) {
            this._setHandler(command, handler);
        };


        /**
         * Register a handler type with the command stack
         * by instantiating it and injecting its dependencies.
         *
         * @param {String} command
         * @param {Function} a constructor for a {@link CommandHandler}
         */
        CommandStack.prototype.registerHandler = function (command, handlerCls) {

            if (!command || !handlerCls) {
                throw new Error('command and handlerCls must be defined');
            }

            var handler = this._injector.instantiate(handlerCls);
            this.register(command, handler);
        };

        CommandStack.prototype.canUndo = function () {
            return !!this._getUndoAction();
        };

        CommandStack.prototype.canRedo = function () {
            return !!this._getRedoAction();
        };

        ////// stack access  //////////////////////////////////////

        CommandStack.prototype._getRedoAction = function () {
            return this._stack[this._stackIdx + 1];
        };


        CommandStack.prototype._getUndoAction = function () {
            return this._stack[this._stackIdx];
        };


        ////// internal functionality /////////////////////////////

        CommandStack.prototype._internalUndo = function (action) {
            var self = this;

            var command = action.command,
                context = action.context;

            var handler = this._getHandler(command);

            // guard against illegal nested command stack invocations
            this._atomicDo(function () {
                self._fire(command, 'revert', action);

                if (handler.revert) {
                    self._markDirty(handler.revert(context));
                }

                self._revertedAction(action);

                self._fire(command, 'reverted', action);
            });
        };


        CommandStack.prototype._fire = function (command, qualifier, event) {
            if (arguments.length < 3) {
                event = qualifier;
                qualifier = null;
            }

            var names = qualifier ? [command + '.' + qualifier, qualifier] : [command],
                i, name, result;

            event = assign(new InternalEvent(), event);

            for (i = 0; (name = names[i]); i++) {
                result = this._eventBus.fire('commandStack.' + name, event);

                if (event.cancelBubble) {
                    break;
                }
            }

            return result;
        };

        CommandStack.prototype._createId = function () {
            return this._uid++;
        };

        CommandStack.prototype._atomicDo = function (fn) {

            var execution = this._currentExecution;

            execution.atomic = true;

            try {
                fn();
            } finally {
                execution.atomic = false;
            }
        };

        CommandStack.prototype._internalExecute = function (action, redo) {
            var self = this;

            var command = action.command,
                context = action.context;

            var handler = this._getHandler(command);

            if (!handler) {
                throw new Error('no command handler registered for <' + command + '>');
            }

            this._pushAction(action);

            if (!redo) {
                this._fire(command, 'preExecute', action);

                if (handler.preExecute) {
                    handler.preExecute(context);
                }

                this._fire(command, 'preExecuted', action);
            }

            // guard against illegal nested command stack invocations
            this._atomicDo(function () {

                self._fire(command, 'execute', action);

                if (handler.execute) {
                    // actual execute + mark return results as dirty
                    self._markDirty(handler.execute(context));
                }

                // log to stack
                self._executedAction(action, redo);

                self._fire(command, 'executed', action);
            });

            if (!redo) {
                this._fire(command, 'postExecute', action);

                if (handler.postExecute) {
                    handler.postExecute(context);
                }

                this._fire(command, 'postExecuted', action);
            }

            this._popAction(action);
        };


        CommandStack.prototype._pushAction = function (action) {

            var execution = this._currentExecution,
                actions = execution.actions;

            var baseAction = actions[0];

            if (execution.atomic) {
                throw new Error('illegal invocation in <execute> or <revert> phase (action: ' + action.command + ')');
            }

            if (!action.id) {
                action.id = (baseAction && baseAction.id) || this._createId();
            }

            actions.push(action);
        };


        CommandStack.prototype._popAction = function () {
            var execution = this._currentExecution,
                actions = execution.actions,
                dirty = execution.dirty;

            actions.pop();

            if (!actions.length) {
                this._eventBus.fire('elements.changed', { elements: unique(dirty) });

                dirty.length = 0;

                this._fire('changed');
            }
        };


        CommandStack.prototype._markDirty = function (elements) {
            var execution = this._currentExecution;

            if (!elements) {
                return;
            }

            elements = isArray(elements) ? elements : [elements];

            execution.dirty = execution.dirty.concat(elements);
        };


        CommandStack.prototype._executedAction = function (action, redo) {
            var stackIdx = ++this._stackIdx;

            if (!redo) {
                this._stack.splice(stackIdx, this._stack.length, action);
            }
        };


        CommandStack.prototype._revertedAction = function (action) {
            this._stackIdx--;
        };


        CommandStack.prototype._getHandler = function (command) {
            return this._handlerMap[command];
        };

        CommandStack.prototype._setHandler = function (command, handler) {
            if (!command || !handler) {
                throw new Error('command and handler required');
            }

            if (this._handlerMap[command]) {
                throw new Error('overriding handler for command <' + command + '>');
            }

            this._handlerMap[command] = handler;
        };

    }, { "../core/EventBus": 125, "lodash/array/unique": 297, "lodash/lang/isArray": 424, "lodash/object/assign": 433 }], 121: [function (require, module, exports) {
        module.exports = {
            commandStack: ['type', require('./CommandStack')]
        };

    }, { "./CommandStack": 120 }], 122: [function (require, module, exports) {
        'use strict';

        var isNumber = require('lodash/lang/isNumber'),
            assign = require('lodash/object/assign'),
            forEach = require('lodash/collection/forEach'),
            every = require('lodash/collection/every'),
            debounce = require('lodash/function/debounce');

        var Collections = require('../util/Collections'),
            Elements = require('../util/Elements');

        var svgAppend = require('tiny-svg/lib/append'),
            svgAttr = require('tiny-svg/lib/attr'),
            svgClasses = require('tiny-svg/lib/classes'),
            svgCreate = require('tiny-svg/lib/create'),
            svgTransform = require('tiny-svg/lib/transform');

        var createMatrix = require('tiny-svg/lib/geometry').createMatrix;


        function round(number, resolution) {
            return Math.round(number * resolution) / resolution;
        }

        function ensurePx(number) {
            return isNumber(number) ? number + 'px' : number;
        }

        /**
         * Creates a HTML container element for a SVG element with
         * the given configuration
         *
         * @param  {Object} options
         * @return {HTMLElement} the container element
         */
        function createContainer(options) {

            options = assign({}, { width: '100%', height: '100%' }, options);

            var container = options.container || document.body;

            // create a <div> around the svg element with the respective size
            // this way we can always get the correct container size
            // (this is impossible for <svg> elements at the moment)
            var parent = document.createElement('div');
            parent.setAttribute('class', 'djs-container');

            assign(parent.style, {
                position: 'relative',
                overflow: 'hidden',
                width: ensurePx(options.width),
                height: ensurePx(options.height)
            });

            container.appendChild(parent);

            return parent;
        }

        function createGroup(parent, cls) {
            var group = svgCreate('g');
            svgClasses(group).add(cls);

            svgAppend(parent, group);

            return group;
        }

        var BASE_LAYER = 'base';


        var REQUIRED_MODEL_ATTRS = {
            shape: ['x', 'y', 'width', 'height'],
            connection: ['waypoints']
        };

        /**
         * The main drawing canvas.
         *
         * @class
         * @constructor
         *
         * @emits Canvas#canvas.init
         *
         * @param {Object} config
         * @param {EventBus} eventBus
         * @param {GraphicsFactory} graphicsFactory
         * @param {ElementRegistry} elementRegistry
         */
        function Canvas(config, eventBus, graphicsFactory, elementRegistry) {

            this._eventBus = eventBus;
            this._elementRegistry = elementRegistry;
            this._graphicsFactory = graphicsFactory;

            this._init(config || {});
        }

        Canvas.$inject = ['config.canvas', 'eventBus', 'graphicsFactory', 'elementRegistry'];

        module.exports = Canvas;


        Canvas.prototype._init = function (config) {

            var eventBus = this._eventBus;

            // Creates a <svg> element that is wrapped into a <div>.
            // This way we are always able to correctly figure out the size of the svg element
            // by querying the parent node.
            //
            // (It is not possible to get the size of a svg element cross browser @ 2014-04-01)
            //
            // <div class="djs-container" style="width: {desired-width}, height: {desired-height}">
            //   <svg width="100%" height="100%">
            //    ...
            //   </svg>
            // </div>

            // html container
            var container = this._container = createContainer(config);

            var svg = this._svg = svgCreate('svg');
            svgAttr(svg, { width: '100%', height: '100%' });

            svgAppend(container, svg);

            var viewport = this._viewport = createGroup(svg, 'viewport');

            this._layers = {};

            // debounce canvas.viewbox.changed events
            // for smoother diagram interaction
            if (config.deferUpdate !== false) {
                this._viewboxChanged = debounce(this._viewboxChanged, 300);
            }

            eventBus.on('diagram.init', function () {

                /**
                 * An event indicating that the canvas is ready to be drawn on.
                 *
                 * @memberOf Canvas
                 *
                 * @event canvas.init
                 *
                 * @type {Object}
                 * @property {Snap<SVGSVGElement>} svg the created svg element
                 * @property {Snap<SVGGroup>} viewport the direct parent of diagram elements and shapes
                 */
                eventBus.fire('canvas.init', {
                    svg: svg,
                    viewport: viewport
                });

                // fire this in order for certain components to check
                // if they need to be adjusted due the canvas size
                this.resized();

            }, this);

            eventBus.on('diagram.destroy', 500, this._destroy, this);
            eventBus.on('diagram.clear', 500, this._clear, this);
        };

        Canvas.prototype._destroy = function (emit) {
            this._eventBus.fire('canvas.destroy', {
                svg: this._svg,
                viewport: this._viewport
            });

            var parent = this._container.parentNode;

            if (parent) {
                parent.removeChild(this._container);
            }

            delete this._svg;
            delete this._container;
            delete this._layers;
            delete this._rootElement;
            delete this._viewport;
        };

        Canvas.prototype._clear = function () {

            var self = this;

            var allElements = this._elementRegistry.getAll();

            // remove all elements
            allElements.forEach(function (element) {
                var type = Elements.getType(element);

                if (type === 'root') {
                    self.setRootElement(null, true);
                } else {
                    self._removeElement(element, type);
                }
            });

            // force recomputation of view box
            delete this._cachedViewbox;
        };

        /**
         * Returns the default layer on which
         * all elements are drawn.
         *
         * @returns {Snap<SVGGroup>}
         */
        Canvas.prototype.getDefaultLayer = function () {
            return this.getLayer(BASE_LAYER);
        };

        /**
         * Returns a layer that is used to draw elements
         * or annotations on it.
         *
         * @param  {String} name
         *
         * @returns {Snap<SVGGroup>}
         */
        Canvas.prototype.getLayer = function (name) {

            if (!name) {
                throw new Error('must specify a name');
            }

            var layer = this._layers[name];
            if (!layer) {
                layer = this._layers[name] = createGroup(this._viewport, 'layer-' + name);
            }

            return layer;
        };


        /**
         * Returns the html element that encloses the
         * drawing canvas.
         *
         * @return {DOMNode}
         */
        Canvas.prototype.getContainer = function () {
            return this._container;
        };


        /////////////// markers ///////////////////////////////////

        Canvas.prototype._updateMarker = function (element, marker, add) {
            var container;

            if (!element.id) {
                element = this._elementRegistry.get(element);
            }

            // we need to access all
            container = this._elementRegistry._elements[element.id];

            if (!container) {
                return;
            }

            forEach([container.gfx, container.secondaryGfx], function (gfx) {
                if (gfx) {
                    // invoke either addClass or removeClass based on mode
                    if (add) {
                        svgClasses(gfx).add(marker);
                    } else {
                        svgClasses(gfx).remove(marker);
                    }
                }
            });

            /**
             * An event indicating that a marker has been updated for an element
             *
             * @event element.marker.update
             * @type {Object}
             * @property {djs.model.Element} element the shape
             * @property {Object} gfx the graphical representation of the shape
             * @property {String} marker
             * @property {Boolean} add true if the marker was added, false if it got removed
             */
            this._eventBus.fire('element.marker.update', { element: element, gfx: container.gfx, marker: marker, add: !!add });
        };


        /**
         * Adds a marker to an element (basically a css class).
         *
         * Fires the element.marker.update event, making it possible to
         * integrate extension into the marker life-cycle, too.
         *
         * @example
         * canvas.addMarker('foo', 'some-marker');
         *
         * var fooGfx = canvas.getGraphics('foo');
         *
         * fooGfx; // <g class="... some-marker"> ... </g>
         *
         * @param {String|djs.model.Base} element
         * @param {String} marker
         */
        Canvas.prototype.addMarker = function (element, marker) {
            this._updateMarker(element, marker, true);
        };


        /**
         * Remove a marker from an element.
         *
         * Fires the element.marker.update event, making it possible to
         * integrate extension into the marker life-cycle, too.
         *
         * @param  {String|djs.model.Base} element
         * @param  {String} marker
         */
        Canvas.prototype.removeMarker = function (element, marker) {
            this._updateMarker(element, marker, false);
        };

        /**
         * Check the existence of a marker on element.
         *
         * @param  {String|djs.model.Base} element
         * @param  {String} marker
         */
        Canvas.prototype.hasMarker = function (element, marker) {
            if (!element.id) {
                element = this._elementRegistry.get(element);
            }

            var gfx = this.getGraphics(element);

            return svgClasses(gfx).has(marker);
        };

        /**
         * Toggles a marker on an element.
         *
         * Fires the element.marker.update event, making it possible to
         * integrate extension into the marker life-cycle, too.
         *
         * @param  {String|djs.model.Base} element
         * @param  {String} marker
         */
        Canvas.prototype.toggleMarker = function (element, marker) {
            if (this.hasMarker(element, marker)) {
                this.removeMarker(element, marker);
            } else {
                this.addMarker(element, marker);
            }
        };

        Canvas.prototype.getRootElement = function () {
            if (!this._rootElement) {
                this.setRootElement({ id: '__implicitroot', children: [] });
            }

            return this._rootElement;
        };



        //////////////// root element handling ///////////////////////////

        /**
         * Sets a given element as the new root element for the canvas
         * and returns the new root element.
         *
         * @param {Object|djs.model.Root} element
         * @param {Boolean} [override] whether to override the current root element, if any
         *
         * @return {Object|djs.model.Root} new root element
         */
        Canvas.prototype.setRootElement = function (element, override) {

            if (element) {
                this._ensureValid('root', element);
            }

            var currentRoot = this._rootElement,
                elementRegistry = this._elementRegistry,
                eventBus = this._eventBus;

            if (currentRoot) {
                if (!override) {
                    throw new Error('rootElement already set, need to specify override');
                }

                // simulate element remove event sequence
                eventBus.fire('root.remove', { element: currentRoot });
                eventBus.fire('root.removed', { element: currentRoot });

                elementRegistry.remove(currentRoot);
            }

            if (element) {
                var gfx = this.getDefaultLayer();

                // resemble element add event sequence
                eventBus.fire('root.add', { element: element });

                elementRegistry.add(element, gfx, this._svg);

                eventBus.fire('root.added', { element: element, gfx: gfx });
            }

            this._rootElement = element;

            return element;
        };



        ///////////// add functionality ///////////////////////////////

        Canvas.prototype._ensureValid = function (type, element) {
            if (!element.id) {
                throw new Error('element must have an id');
            }

            if (this._elementRegistry.get(element.id)) {
                throw new Error('element with id ' + element.id + ' already exists');
            }

            var requiredAttrs = REQUIRED_MODEL_ATTRS[type];

            var valid = every(requiredAttrs, function (attr) {
                return typeof element[attr] !== 'undefined';
            });

            if (!valid) {
                throw new Error(
                    'must supply { ' + requiredAttrs.join(', ') + ' } with ' + type);
            }
        };

        Canvas.prototype._setParent = function (element, parent, parentIndex) {
            Collections.add(parent.children, element, parentIndex);
            element.parent = parent;
        };

        /**
         * Adds an element to the canvas.
         *
         * This wires the parent <-> child relationship between the element and
         * a explicitly specified parent or an implicit root element.
         *
         * During add it emits the events
         *
         *  * <{type}.add> (element, parent)
         *  * <{type}.added> (element, gfx)
         *
         * Extensions may hook into these events to perform their magic.
         *
         * @param {String} type
         * @param {Object|djs.model.Base} element
         * @param {Object|djs.model.Base} [parent]
         * @param {Number} [parentIndex]
         *
         * @return {Object|djs.model.Base} the added element
         */
        Canvas.prototype._addElement = function (type, element, parent, parentIndex) {

            parent = parent || this.getRootElement();

            var eventBus = this._eventBus,
                graphicsFactory = this._graphicsFactory;

            this._ensureValid(type, element);

            eventBus.fire(type + '.add', { element: element, parent: parent });

            this._setParent(element, parent, parentIndex);

            // create graphics
            var gfx = graphicsFactory.create(type, element);

            this._elementRegistry.add(element, gfx);

            // update its visual
            graphicsFactory.update(type, element, gfx);

            eventBus.fire(type + '.added', { element: element, gfx: gfx });

            return element;
        };

        /**
         * Adds a shape to the canvas
         *
         * @param {Object|djs.model.Shape} shape to add to the diagram
         * @param {djs.model.Base} [parent]
         * @param {Number} [parentIndex]
         *
         * @return {djs.model.Shape} the added shape
         */
        Canvas.prototype.addShape = function (shape, parent, parentIndex) {
            return this._addElement('shape', shape, parent, parentIndex);
        };

        /**
         * Adds a connection to the canvas
         *
         * @param {Object|djs.model.Connection} connection to add to the diagram
         * @param {djs.model.Base} [parent]
         * @param {Number} [parentIndex]
         *
         * @return {djs.model.Connection} the added connection
         */
        Canvas.prototype.addConnection = function (connection, parent, parentIndex) {
            return this._addElement('connection', connection, parent, parentIndex);
        };


        /**
         * Internal remove element
         */
        Canvas.prototype._removeElement = function (element, type) {

            var elementRegistry = this._elementRegistry,
                graphicsFactory = this._graphicsFactory,
                eventBus = this._eventBus;

            element = elementRegistry.get(element.id || element);

            if (!element) {
                // element was removed already
                return;
            }

            eventBus.fire(type + '.remove', { element: element });

            graphicsFactory.remove(element);

            // unset parent <-> child relationship
            Collections.remove(element.parent && element.parent.children, element);
            element.parent = null;

            eventBus.fire(type + '.removed', { element: element });

            elementRegistry.remove(element);

            return element;
        };


        /**
         * Removes a shape from the canvas
         *
         * @param {String|djs.model.Shape} shape or shape id to be removed
         *
         * @return {djs.model.Shape} the removed shape
         */
        Canvas.prototype.removeShape = function (shape) {

            /**
             * An event indicating that a shape is about to be removed from the canvas.
             *
             * @memberOf Canvas
             *
             * @event shape.remove
             * @type {Object}
             * @property {djs.model.Shape} element the shape descriptor
             * @property {Object} gfx the graphical representation of the shape
             */

            /**
             * An event indicating that a shape has been removed from the canvas.
             *
             * @memberOf Canvas
             *
             * @event shape.removed
             * @type {Object}
             * @property {djs.model.Shape} element the shape descriptor
             * @property {Object} gfx the graphical representation of the shape
             */
            return this._removeElement(shape, 'shape');
        };


        /**
         * Removes a connection from the canvas
         *
         * @param {String|djs.model.Connection} connection or connection id to be removed
         *
         * @return {djs.model.Connection} the removed connection
         */
        Canvas.prototype.removeConnection = function (connection) {

            /**
             * An event indicating that a connection is about to be removed from the canvas.
             *
             * @memberOf Canvas
             *
             * @event connection.remove
             * @type {Object}
             * @property {djs.model.Connection} element the connection descriptor
             * @property {Object} gfx the graphical representation of the connection
             */

            /**
             * An event indicating that a connection has been removed from the canvas.
             *
             * @memberOf Canvas
             *
             * @event connection.removed
             * @type {Object}
             * @property {djs.model.Connection} element the connection descriptor
             * @property {Object} gfx the graphical representation of the connection
             */
            return this._removeElement(connection, 'connection');
        };


        /**
         * Return the graphical object underlaying a certain diagram element
         *
         * @param {String|djs.model.Base} element descriptor of the element
         * @param {Boolean} [secondary=false] whether to return the secondary connected element
         *
         * @return {SVGElement}
         */
        Canvas.prototype.getGraphics = function (element, secondary) {
            return this._elementRegistry.getGraphics(element, secondary);
        };


        /**
         * Perform a viewbox update via a given change function.
         *
         * @param {Function} changeFn
         */
        Canvas.prototype._changeViewbox = function (changeFn) {

            // notify others of the upcoming viewbox change
            this._eventBus.fire('canvas.viewbox.changing');

            // perform actual change
            changeFn.apply(this);

            // reset the cached viewbox so that
            // a new get operation on viewbox or zoom
            // triggers a viewbox re-computation
            this._cachedViewbox = null;

            // notify others of the change; this step
            // may or may not be debounced
            this._viewboxChanged();
        };

        Canvas.prototype._viewboxChanged = function () {
            this._eventBus.fire('canvas.viewbox.changed', { viewbox: this.viewbox() });
        };


        /**
         * Gets or sets the view box of the canvas, i.e. the
         * area that is currently displayed.
         *
         * The getter may return a cached viewbox (if it is currently
         * changing). To force a recomputation, pass `false` as the first argument.
         *
         * @example
         *
         * canvas.viewbox({ x: 100, y: 100, width: 500, height: 500 })
         *
         * // sets the visible area of the diagram to (100|100) -> (600|100)
         * // and and scales it according to the diagram width
         *
         * var viewbox = canvas.viewbox(); // pass `false` to force recomputing the box.
         *
         * console.log(viewbox);
         * // {
         * //   inner: Dimensions,
         * //   outer: Dimensions,
         * //   scale,
         * //   x, y,
         * //   width, height
         * // }
         *
         * // if the current diagram is zoomed and scrolled, you may reset it to the
         * // default zoom via this method, too:
         *
         * var zoomedAndScrolledViewbox = canvas.viewbox();
         *
         * canvas.viewbox({
         *   x: 0,
         *   y: 0,
         *   width: zoomedAndScrolledViewbox.outer.width,
         *   height: zoomedAndScrolledViewbox.outer.height
         * });
         *
         * @param  {Object} [box] the new view box to set
         * @param  {Number} box.x the top left X coordinate of the canvas visible in view box
         * @param  {Number} box.y the top left Y coordinate of the canvas visible in view box
         * @param  {Number} box.width the visible width
         * @param  {Number} box.height
         *
         * @return {Object} the current view box
         */
        Canvas.prototype.viewbox = function (box) {

            if (box === undefined && this._cachedViewbox) {
                return this._cachedViewbox;
            }

            var viewport = this._viewport,
                innerBox,
                outerBox = this.getSize(),
                matrix,
                scale,
                x, y;

            if (!box) {
                // compute the inner box based on the
                // diagrams default layer. This allows us to exclude
                // external components, such as overlays
                innerBox = this.getDefaultLayer().getBBox();

                var transform = svgTransform(viewport);
                matrix = transform ? transform.matrix : createMatrix();
                scale = round(matrix.a, 1000);

                x = round(-matrix.e || 0, 1000);
                y = round(-matrix.f || 0, 1000);

                box = this._cachedViewbox = {
                    x: x ? x / scale : 0,
                    y: y ? y / scale : 0,
                    width: outerBox.width / scale,
                    height: outerBox.height / scale,
                    scale: scale,
                    inner: {
                        width: innerBox.width,
                        height: innerBox.height,
                        x: innerBox.x,
                        y: innerBox.y
                    },
                    outer: outerBox
                };

                return box;
            } else {

                this._changeViewbox(function () {
                    scale = Math.min(outerBox.width / box.width, outerBox.height / box.height);

                    var matrix = this._svg.createSVGMatrix()
                        .scale(scale)
                        .translate(-box.x, -box.y);

                    svgTransform(viewport, matrix);
                });
            }

            return box;
        };


        /**
         * Gets or sets the scroll of the canvas.
         *
         * @param {Object} [delta] the new scroll to apply.
         *
         * @param {Number} [delta.dx]
         * @param {Number} [delta.dy]
         */
        Canvas.prototype.scroll = function (delta) {

            var node = this._viewport;
            var matrix = node.getCTM();

            if (delta) {
                this._changeViewbox(function () {
                    delta = assign({ dx: 0, dy: 0 }, delta || {});

                    matrix = this._svg.createSVGMatrix().translate(delta.dx, delta.dy).multiply(matrix);

                    setCTM(node, matrix);
                });
            }

            return { x: matrix.e, y: matrix.f };
        };


        /**
         * Gets or sets the current zoom of the canvas, optionally zooming
         * to the specified position.
         *
         * The getter may return a cached zoom level. Call it with `false` as
         * the first argument to force recomputation of the current level.
         *
         * @param {String|Number} [newScale] the new zoom level, either a number, i.e. 0.9,
         *                                   or `fit-viewport` to adjust the size to fit the current viewport
         * @param {String|Point} [center] the reference point { x: .., y: ..} to zoom to, 'auto' to zoom into mid or null
         *
         * @return {Number} the current scale
         */
        Canvas.prototype.zoom = function (newScale, center) {

            if (!newScale) {
                return this.viewbox(newScale).scale;
            }

            if (newScale === 'fit-viewport') {
                return this._fitViewport(center);
            }

            var outer,
                matrix;

            this._changeViewbox(function () {

                if (typeof center !== 'object') {
                    outer = this.viewbox().outer;

                    center = {
                        x: outer.width / 2,
                        y: outer.height / 2
                    };
                }

                matrix = this._setZoom(newScale, center);
            });

            return round(matrix.a, 1000);
        };

        function setCTM(node, m) {
            var mstr = 'matrix(' + m.a + ',' + m.b + ',' + m.c + ',' + m.d + ',' + m.e + ',' + m.f + ')';
            node.setAttribute('transform', mstr);
        }

        Canvas.prototype._fitViewport = function (center) {

            var vbox = this.viewbox(),
                outer = vbox.outer,
                inner = vbox.inner,
                newScale,
                newViewbox;

            // display the complete diagram without zooming in.
            // instead of relying on internal zoom, we perform a
            // hard reset on the canvas viewbox to realize this
            //
            // if diagram does not need to be zoomed in, we focus it around
            // the diagram origin instead

            if (inner.x >= 0 &&
                inner.y >= 0 &&
                inner.x + inner.width <= outer.width &&
                inner.y + inner.height <= outer.height &&
                !center) {

                newViewbox = {
                    x: 0,
                    y: 0,
                    width: Math.max(inner.width + inner.x, outer.width),
                    height: Math.max(inner.height + inner.y, outer.height)
                };
            } else {

                newScale = Math.min(1, outer.width / inner.width, outer.height / inner.height);
                newViewbox = {
                    x: inner.x + (center ? inner.width / 2 - outer.width / newScale / 2 : 0),
                    y: inner.y + (center ? inner.height / 2 - outer.height / newScale / 2 : 0),
                    width: outer.width / newScale,
                    height: outer.height / newScale
                };
            }

            this.viewbox(newViewbox);

            return this.viewbox(false).scale;
        };


        Canvas.prototype._setZoom = function (scale, center) {

            var svg = this._svg,
                viewport = this._viewport;

            var matrix = svg.createSVGMatrix();
            var point = svg.createSVGPoint();

            var centerPoint,
                originalPoint,
                currentMatrix,
                scaleMatrix,
                newMatrix;

            currentMatrix = viewport.getCTM();

            var currentScale = currentMatrix.a;

            if (center) {
                centerPoint = assign(point, center);

                // revert applied viewport transformations
                originalPoint = centerPoint.matrixTransform(currentMatrix.inverse());

                // create scale matrix
                scaleMatrix = matrix
                    .translate(originalPoint.x, originalPoint.y)
                    .scale(1 / currentScale * scale)
                    .translate(-originalPoint.x, -originalPoint.y);

                newMatrix = currentMatrix.multiply(scaleMatrix);
            } else {
                newMatrix = matrix.scale(scale);
            }

            setCTM(this._viewport, newMatrix);

            return newMatrix;
        };


        /**
         * Returns the size of the canvas
         *
         * @return {Dimensions}
         */
        Canvas.prototype.getSize = function () {
            return {
                width: this._container.clientWidth,
                height: this._container.clientHeight
            };
        };


        /**
         * Return the absolute bounding box for the given element
         *
         * The absolute bounding box may be used to display overlays in the
         * callers (browser) coordinate system rather than the zoomed in/out
         * canvas coordinates.
         *
         * @param  {ElementDescriptor} element
         * @return {Bounds} the absolute bounding box
         */
        Canvas.prototype.getAbsoluteBBox = function (element) {
            var vbox = this.viewbox();
            var bbox;

            // connection
            // use svg bbox
            if (element.waypoints) {
                var gfx = this.getGraphics(element);

                var transformBBox = gfx.getBBox(true);
                bbox = gfx.getBBox();

                bbox.x -= transformBBox.x;
                bbox.y -= transformBBox.y;

                bbox.width += 2 * transformBBox.x;
                bbox.height += 2 * transformBBox.y;
            }
            // shapes
            // use data
            else {
                bbox = element;
            }

            var x = bbox.x * vbox.scale - vbox.x * vbox.scale;
            var y = bbox.y * vbox.scale - vbox.y * vbox.scale;

            var width = bbox.width * vbox.scale;
            var height = bbox.height * vbox.scale;

            return {
                x: x,
                y: y,
                width: width,
                height: height
            };
        };

        /**
         * Fires an event in order other modules can react to the
         * canvas resizing
         */
        Canvas.prototype.resized = function () {

            // force recomputation of view box
            delete this._cachedViewbox;

            this._eventBus.fire('canvas.resized');
        };

    }, { "../util/Collections": 263, "../util/Elements": 266, "lodash/collection/every": 301, "lodash/collection/forEach": 304, "lodash/function/debounce": 314, "lodash/lang/isNumber": 427, "lodash/object/assign": 433, "tiny-svg/lib/append": 473, "tiny-svg/lib/attr": 475, "tiny-svg/lib/classes": 476, "tiny-svg/lib/create": 479, "tiny-svg/lib/geometry": 480, "tiny-svg/lib/transform": 483 }], 123: [function (require, module, exports) {
        'use strict';

        var Model = require('../model');

        var assign = require('lodash/object/assign');

        /**
         * A factory for diagram-js shapes
         */
        function ElementFactory() {
            this._uid = 12;
        }

        module.exports = ElementFactory;


        ElementFactory.prototype.createRoot = function (attrs) {
            return this.create('root', attrs);
        };

        ElementFactory.prototype.createLabel = function (attrs) {
            return this.create('label', attrs);
        };

        ElementFactory.prototype.createShape = function (attrs) {
            return this.create('shape', attrs);
        };

        ElementFactory.prototype.createConnection = function (attrs) {
            return this.create('connection', attrs);
        };

        /**
         * Create a model element with the given type and
         * a number of pre-set attributes.
         *
         * @param  {String} type
         * @param  {Object} attrs
         * @return {djs.model.Base} the newly created model instance
         */
        ElementFactory.prototype.create = function (type, attrs) {

            attrs = assign({}, attrs || {});

            if (!attrs.id) {
                attrs.id = type + '_' + (this._uid++);
            }

            return Model.create(type, attrs);
        };
    }, { "../model": 254, "lodash/object/assign": 433 }], 124: [function (require, module, exports) {
        'use strict';

        var ELEMENT_ID = 'data-element-id';

        var svgAttr = require('tiny-svg/lib/attr');


        /**
         * @class
         *
         * A registry that keeps track of all shapes in the diagram.
         */
        function ElementRegistry(eventBus) {
            this._elements = {};

            this._eventBus = eventBus;
        }

        ElementRegistry.$inject = ['eventBus'];

        module.exports = ElementRegistry;

        /**
         * Register a pair of (element, gfx, (secondaryGfx)).
         *
         * @param {djs.model.Base} element
         * @param {SVGElement} gfx
         * @param {SVGElement} [secondaryGfx] optional other element to register, too
         */
        ElementRegistry.prototype.add = function (element, gfx, secondaryGfx) {

            var id = element.id;

            this._validateId(id);

            // associate dom node with element
            svgAttr(gfx, ELEMENT_ID, id);

            if (secondaryGfx) {
                svgAttr(secondaryGfx, ELEMENT_ID, id);
            }

            this._elements[id] = { element: element, gfx: gfx, secondaryGfx: secondaryGfx };
        };

        /**
         * Removes an element from the registry.
         *
         * @param {djs.model.Base} element
         */
        ElementRegistry.prototype.remove = function (element) {
            var elements = this._elements,
                id = element.id || element,
                container = id && elements[id];

            if (container) {

                // unset element id on gfx
                svgAttr(container.gfx, ELEMENT_ID, '');

                if (container.secondaryGfx) {
                    svgAttr(container.secondaryGfx, ELEMENT_ID, '');
                }

                delete elements[id];
            }
        };

        /**
         * Update the id of an element
         *
         * @param {djs.model.Base} element
         * @param {String} newId
         */
        ElementRegistry.prototype.updateId = function (element, newId) {

            this._validateId(newId);

            if (typeof element === 'string') {
                element = this.get(element);
            }

            this._eventBus.fire('element.updateId', {
                element: element,
                newId: newId
            });

            var gfx = this.getGraphics(element),
                secondaryGfx = this.getGraphics(element, true);

            this.remove(element);

            element.id = newId;

            this.add(element, gfx, secondaryGfx);
        };

        /**
         * Return the model element for a given id or graphics.
         *
         * @example
         *
         * elementRegistry.get('SomeElementId_1');
         * elementRegistry.get(gfx);
         *
         *
         * @param {String|SVGElement} filter for selecting the element
         *
         * @return {djs.model.Base}
         */
        ElementRegistry.prototype.get = function (filter) {
            var id;

            if (typeof filter === 'string') {
                id = filter;
            } else {
                id = filter && svgAttr(filter, ELEMENT_ID);
            }

            var container = this._elements[id];
            return container && container.element;
        };

        /**
         * Return all elements that match a given filter function.
         *
         * @param {Function} fn
         *
         * @return {Array<djs.model.Base>}
         */
        ElementRegistry.prototype.filter = function (fn) {

            var filtered = [];

            this.forEach(function (element, gfx) {
                if (fn(element, gfx)) {
                    filtered.push(element);
                }
            });

            return filtered;
        };

        /**
         * Return all rendered model elements.
         *
         * @return {Array<djs.model.Base>}
         */
        ElementRegistry.prototype.getAll = function () {
            return this.filter(function (e) { return e; });
        };

        /**
         * Iterate over all diagram elements.
         *
         * @param {Function} fn
         */
        ElementRegistry.prototype.forEach = function (fn) {

            var map = this._elements;

            Object.keys(map).forEach(function (id) {
                var container = map[id],
                    element = container.element,
                    gfx = container.gfx;

                return fn(element, gfx);
            });
        };

        /**
         * Return the graphical representation of an element or its id.
         *
         * @example
         * elementRegistry.getGraphics('SomeElementId_1');
         * elementRegistry.getGraphics(rootElement); // <g ...>
         *
         * elementRegistry.getGraphics(rootElement, true); // <svg ...>
         *
         *
         * @param {String|djs.model.Base} filter
         * @param {Boolean} [secondary=false] whether to return the secondary connected element
         *
         * @return {SVGElement}
         */
        ElementRegistry.prototype.getGraphics = function (filter, secondary) {
            var id = filter.id || filter;

            var container = this._elements[id];
            return container && (secondary ? container.secondaryGfx : container.gfx);
        };

        /**
         * Validate the suitability of the given id and signals a problem
         * with an exception.
         *
         * @param {String} id
         *
         * @throws {Error} if id is empty or already assigned
         */
        ElementRegistry.prototype._validateId = function (id) {
            if (!id) {
                throw new Error('element must have an id');
            }

            if (this._elements[id]) {
                throw new Error('element with id ' + id + ' already added');
            }
        };

    }, { "tiny-svg/lib/attr": 475 }], 125: [function (require, module, exports) {
        'use strict';

        var isFunction = require('lodash/lang/isFunction'),
            isArray = require('lodash/lang/isArray'),
            isNumber = require('lodash/lang/isNumber'),
            bind = require('lodash/function/bind'),
            assign = require('lodash/object/assign');

        var FN_REF = '__fn';

        var DEFAULT_PRIORITY = 1000;

        var slice = Array.prototype.slice;

        /**
         * A general purpose event bus.
         *
         * This component is used to communicate across a diagram instance.
         * Other parts of a diagram can use it to listen to and broadcast events.
         *
         *
         * ## Registering for Events
         *
         * The event bus provides the {@link EventBus#on} and {@link EventBus#once}
         * methods to register for events. {@link EventBus#off} can be used to
         * remove event registrations. Listeners receive an instance of {@link Event}
         * as the first argument. It allows them to hook into the event execution.
         *
         * ```javascript
         *
         * // listen for event
         * eventBus.on('foo', function(event) {
         *
         *   // access event type
         *   event.type; // 'foo'
         *
         *   // stop propagation to other listeners
         *   event.stopPropagation();
         *
         *   // prevent event default
         *   event.preventDefault();
         * });
         *
         * // listen for event with custom payload
         * eventBus.on('bar', function(event, payload) {
         *   console.log(payload);
         * });
         *
         * // listen for event returning value
         * eventBus.on('foobar', function(event) {
         *
         *   // stop event propagation + prevent default
         *   return false;
         *
         *   // stop event propagation + return custom result
         *   return {
         *     complex: 'listening result'
         *   };
         * });
         *
         *
         * // listen with custom priority (default=1000, higher is better)
         * eventBus.on('priorityfoo', 1500, function(event) {
         *   console.log('invoked first!');
         * });
         *
         *
         * // listen for event and pass the context (`this`)
         * eventBus.on('foobar', function(event) {
         *   this.foo();
         * }, this);
         * ```
         *
         *
         * ## Emitting Events
         *
         * Events can be emitted via the event bus using {@link EventBus#fire}.
         *
         * ```javascript
         *
         * // false indicates that the default action
         * // was prevented by listeners
         * if (eventBus.fire('foo') === false) {
         *   console.log('default has been prevented!');
         * };
         *
         *
         * // custom args + return value listener
         * eventBus.on('sum', function(event, a, b) {
         *   return a + b;
         * });
         *
         * // you can pass custom arguments + retrieve result values.
         * var sum = eventBus.fire('sum', 1, 2);
         * console.log(sum); // 3
         * ```
         */
        function EventBus() {
            this._listeners = {};

            // cleanup on destroy on lowest priority to allow
            // message passing until the bitter end
            this.on('diagram.destroy', 1, this._destroy, this);
        }

        module.exports = EventBus;


        /**
         * Register an event listener for events with the given name.
         *
         * The callback will be invoked with `event, ...additionalArguments`
         * that have been passed to {@link EventBus#fire}.
         *
         * Returning false from a listener will prevent the events default action
         * (if any is specified). To stop an event from being processed further in
         * other listeners execute {@link Event#stopPropagation}.
         *
         * Returning anything but `undefined` from a listener will stop the listener propagation.
         *
         * @param {String|Array<String>} events
         * @param {Number} [priority=1000] the priority in which this listener is called, larger is higher
         * @param {Function} callback
         * @param {Object} [that] Pass context (`this`) to the callback
         */
        EventBus.prototype.on = function (events, priority, callback, that) {

            events = isArray(events) ? events : [events];

            if (isFunction(priority)) {
                that = callback;
                callback = priority;
                priority = DEFAULT_PRIORITY;
            }

            if (!isNumber(priority)) {
                throw new Error('priority must be a number');
            }

            var actualCallback = callback;

            if (that) {
                actualCallback = bind(callback, that);

                // make sure we remember and are able to remove
                // bound callbacks via {@link #off} using the original
                // callback
                actualCallback[FN_REF] = callback[FN_REF] || callback;
            }

            var self = this,
                listener = { priority: priority, callback: actualCallback };

            events.forEach(function (e) {
                self._addListener(e, listener);
            });
        };


        /**
         * Register an event listener that is executed only once.
         *
         * @param {String} event the event name to register for
         * @param {Function} callback the callback to execute
         * @param {Object} [that] Pass context (`this`) to the callback
         */
        EventBus.prototype.once = function (event, priority, callback, that) {
            var self = this;

            if (isFunction(priority)) {
                that = callback;
                callback = priority;
                priority = DEFAULT_PRIORITY;
            }

            if (!isNumber(priority)) {
                throw new Error('priority must be a number');
            }

            function wrappedCallback() {
                self.off(event, wrappedCallback);
                return callback.apply(that, arguments);
            }

            // make sure we remember and are able to remove
            // bound callbacks via {@link #off} using the original
            // callback
            wrappedCallback[FN_REF] = callback;

            this.on(event, priority, wrappedCallback);
        };


        /**
         * Removes event listeners by event and callback.
         *
         * If no callback is given, all listeners for a given event name are being removed.
         *
         * @param {String} event
         * @param {Function} [callback]
         */
        EventBus.prototype.off = function (event, callback) {
            var listeners = this._getListeners(event),
                listener,
                listenerCallback,
                idx;

            if (callback) {

                // move through listeners from back to front
                // and remove matching listeners
                for (idx = listeners.length - 1; (listener = listeners[idx]); idx--) {
                    listenerCallback = listener.callback;

                    if (listenerCallback === callback || listenerCallback[FN_REF] === callback) {
                        listeners.splice(idx, 1);
                    }
                }
            } else {
                // clear listeners
                listeners.length = 0;
            }
        };


        /**
         * Fires a named event.
         *
         * @example
         *
         * // fire event by name
         * events.fire('foo');
         *
         * // fire event object with nested type
         * var event = { type: 'foo' };
         * events.fire(event);
         *
         * // fire event with explicit type
         * var event = { x: 10, y: 20 };
         * events.fire('element.moved', event);
         *
         * // pass additional arguments to the event
         * events.on('foo', function(event, bar) {
         *   alert(bar);
         * });
         *
         * events.fire({ type: 'foo' }, 'I am bar!');
         *
         * @param {String} [name] the optional event name
         * @param {Object} [event] the event object
         * @param {...Object} additional arguments to be passed to the callback functions
         *
         * @return {Boolean} the events return value, if specified or false if the
         *                   default action was prevented by listeners
         */
        EventBus.prototype.fire = function (type, data) {

            var event,
                listeners,
                returnValue,
                args;

            args = slice.call(arguments);

            if (typeof type === 'object') {
                event = type;
                type = event.type;
            }

            if (!type) {
                throw new Error('no event type specified');
            }

            listeners = this._listeners[type];

            if (!listeners) {
                return;
            }

            // we make sure we fire instances of our home made
            // events here. We wrap them only once, though
            if (data instanceof Event) {
                // we are fine, we alread have an event
                event = data;
            } else {
                event = new Event();
                event.init(data);
            }

            // ensure we pass the event as the first parameter
            args[0] = event;

            // original event type (in case we delegate)
            var originalType = event.type;

            // update event type before delegation
            if (type !== originalType) {
                event.type = type;
            }

            try {
                returnValue = this._invokeListeners(event, args, listeners);
            } finally {
                // reset event type after delegation
                if (type !== originalType) {
                    event.type = originalType;
                }
            }

            // set the return value to false if the event default
            // got prevented and no other return value exists
            if (returnValue === undefined && event.defaultPrevented) {
                returnValue = false;
            }

            return returnValue;
        };


        EventBus.prototype.handleError = function (error) {
            return this.fire('error', { error: error }) === false;
        };


        EventBus.prototype._destroy = function () {
            this._listeners = {};
        };

        EventBus.prototype._invokeListeners = function (event, args, listeners) {

            var idx,
                listener,
                returnValue;

            for (idx = 0; (listener = listeners[idx]); idx++) {

                // handle stopped propagation
                if (event.cancelBubble) {
                    break;
                }

                returnValue = this._invokeListener(event, args, listener);
            }

            return returnValue;
        };

        EventBus.prototype._invokeListener = function (event, args, listener) {

            var returnValue;

            try {
                // returning false prevents the default action
                returnValue = invokeFunction(listener.callback, args);

                // stop propagation on return value
                if (returnValue !== undefined) {
                    event.returnValue = returnValue;
                    event.stopPropagation();
                }

                // prevent default on return false
                if (returnValue === false) {
                    event.preventDefault();
                }
            } catch (e) {
                if (!this.handleError(e)) {
                    console.error('unhandled error in event listener');
                    console.error(e.stack);

                    throw e;
                }
            }

            return returnValue;
        };

        /*
         * Add new listener with a certain priority to the list
         * of listeners (for the given event).
         *
         * The semantics of listener registration / listener execution are
         * first register, first serve: New listeners will always be inserted
         * after existing listeners with the same priority.
         *
         * Example: Inserting two listeners with priority 1000 and 1300
         *
         *    * before: [ 1500, 1500, 1000, 1000 ]
         *    * after: [ 1500, 1500, (new=1300), 1000, 1000, (new=1000) ]
         *
         * @param {String} event
         * @param {Object} listener { priority, callback }
         */
        EventBus.prototype._addListener = function (event, newListener) {

            var listeners = this._getListeners(event),
                existingListener,
                idx;

            // ensure we order listeners by priority from
            // 0 (high) to n > 0 (low)
            for (idx = 0; (existingListener = listeners[idx]); idx++) {
                if (existingListener.priority < newListener.priority) {

                    // prepend newListener at before existingListener
                    listeners.splice(idx, 0, newListener);
                    return;
                }
            }

            listeners.push(newListener);
        };


        EventBus.prototype._getListeners = function (name) {
            var listeners = this._listeners[name];

            if (!listeners) {
                this._listeners[name] = listeners = [];
            }

            return listeners;
        };


        /**
         * A event that is emitted via the event bus.
         */
        function Event() { }

        module.exports.Event = Event;

        Event.prototype.stopPropagation = function () {
            this.cancelBubble = true;
        };

        Event.prototype.preventDefault = function () {
            this.defaultPrevented = true;
        };

        Event.prototype.init = function (data) {
            assign(this, data || {});
        };


        /**
         * Invoke function. Be fast...
         *
         * @param {Function} fn
         * @param {Array<Object>} args
         *
         * @return {Any}
         */
        function invokeFunction(fn, args) {
            return fn.apply(null, args);
        }

    }, { "lodash/function/bind": 313, "lodash/lang/isArray": 424, "lodash/lang/isFunction": 425, "lodash/lang/isNumber": 427, "lodash/object/assign": 433 }], 126: [function (require, module, exports) {
        'use strict';

        var forEach = require('lodash/collection/forEach'),
            reduce = require('lodash/collection/reduce');

        var GraphicsUtil = require('../util/GraphicsUtil');

        var translate = require('../util/SvgTransformUtil').translate;

        var domClear = require('min-dom/lib/clear');

        var svgAppend = require('tiny-svg/lib/append'),
            svgAttr = require('tiny-svg/lib/attr'),
            svgClasses = require('tiny-svg/lib/classes'),
            svgCreate = require('tiny-svg/lib/create'),
            svgRemove = require('tiny-svg/lib/remove');


        /**
         * A factory that creates graphical elements
         *
         * @param {EventBus} eventBus
         * @param {ElementRegistry} elementRegistry
         */
        function GraphicsFactory(eventBus, elementRegistry) {
            this._eventBus = eventBus;
            this._elementRegistry = elementRegistry;
        }

        GraphicsFactory.$inject = ['eventBus', 'elementRegistry'];

        module.exports = GraphicsFactory;


        GraphicsFactory.prototype._getChildren = function (element) {

            var gfx = this._elementRegistry.getGraphics(element);

            var childrenGfx;

            // root element
            if (!element.parent) {
                childrenGfx = gfx;
            } else {
                childrenGfx = GraphicsUtil.getChildren(gfx);
                if (!childrenGfx) {
                    childrenGfx = svgCreate('g');
                    svgClasses(childrenGfx).add('djs-children');

                    svgAppend(gfx.parentNode, childrenGfx);
                }
            }

            return childrenGfx;
        };

        /**
         * Clears the graphical representation of the element and returns the
         * cleared visual (the <g class="djs-visual" /> element).
         */
        GraphicsFactory.prototype._clear = function (gfx) {
            var visual = GraphicsUtil.getVisual(gfx);

            domClear(visual);

            return visual;
        };

        /**
         * Creates a gfx container for shapes and connections
         *
         * The layout is as follows:
         *
         * <g class="djs-group">
         *
         *   <!-- the gfx -->
         *   <g class="djs-element djs-(shape|connection)">
         *     <g class="djs-visual">
         *       <!-- the renderer draws in here -->
         *     </g>
         *
         *     <!-- extensions (overlays, click box, ...) goes here
         *   </g>
         *
         *   <!-- the gfx child nodes -->
         *   <g class="djs-children"></g>
         * </g>
         *
         * @param {Object} parent
         * @param {String} type the type of the element, i.e. shape | connection
         */
        GraphicsFactory.prototype._createContainer = function (type, parentGfx) {
            var outerGfx = svgCreate('g');
            svgClasses(outerGfx).add('djs-group');

            svgAppend(parentGfx, outerGfx);

            var gfx = svgCreate('g');
            svgClasses(gfx).add('djs-element');
            svgClasses(gfx).add('djs-' + type);

            svgAppend(outerGfx, gfx);

            // create visual
            var visual = svgCreate('g');
            svgClasses(visual).add('djs-visual');

            svgAppend(gfx, visual);

            return gfx;
        };

        GraphicsFactory.prototype.create = function (type, element) {
            var childrenGfx = this._getChildren(element.parent);
            return this._createContainer(type, childrenGfx);
        };

        GraphicsFactory.prototype.updateContainments = function (elements) {

            var self = this,
                elementRegistry = this._elementRegistry,
                parents;

            parents = reduce(elements, function (map, e) {

                if (e.parent) {
                    map[e.parent.id] = e.parent;
                }

                return map;
            }, {});

            // update all parents of changed and reorganized their children
            // in the correct order (as indicated in our model)
            forEach(parents, function (parent) {

                var childGfx = self._getChildren(parent),
                    children = parent.children;

                if (!children) {
                    return;
                }

                forEach(children.slice().reverse(), function (c) {
                    var gfx = elementRegistry.getGraphics(c);

                    prependTo(gfx.parentNode, childGfx);
                });
            });
        };

        GraphicsFactory.prototype.drawShape = function (visual, element) {
            var eventBus = this._eventBus;

            return eventBus.fire('render.shape', { gfx: visual, element: element });
        };

        GraphicsFactory.prototype.getShapePath = function (element) {
            var eventBus = this._eventBus;

            return eventBus.fire('render.getShapePath', element);
        };

        GraphicsFactory.prototype.drawConnection = function (visual, element) {
            var eventBus = this._eventBus;

            return eventBus.fire('render.connection', { gfx: visual, element: element });
        };

        GraphicsFactory.prototype.getConnectionPath = function (waypoints) {
            var eventBus = this._eventBus;

            return eventBus.fire('render.getConnectionPath', waypoints);
        };

        GraphicsFactory.prototype.update = function (type, element, gfx) {
            // Do not update root element
            if (!element.parent) {
                return;
            }

            var visual = this._clear(gfx);

            // redraw
            if (type === 'shape') {
                this.drawShape(visual, element);

                // update positioning
                translate(gfx, element.x, element.y);
            } else
                if (type === 'connection') {
                    this.drawConnection(visual, element);
                } else {
                    throw new Error('unknown type: ' + type);
                }

            if (element.hidden) {
                svgAttr(gfx, 'display', 'none');
            } else {
                svgAttr(gfx, 'display', 'block');
            }
        };

        GraphicsFactory.prototype.remove = function (element) {
            var gfx = this._elementRegistry.getGraphics(element);

            // remove
            svgRemove(gfx.parentNode);
        };

        ////////// helpers ///////////

        function prependTo(newNode, parentNode) {
            parentNode.insertBefore(newNode, parentNode.firstChild);
        }

    }, { "../util/GraphicsUtil": 269, "../util/SvgTransformUtil": 279, "lodash/collection/forEach": 304, "lodash/collection/reduce": 307, "min-dom/lib/clear": 448, "tiny-svg/lib/append": 473, "tiny-svg/lib/attr": 475, "tiny-svg/lib/classes": 476, "tiny-svg/lib/create": 479, "tiny-svg/lib/remove": 482 }], 127: [function (require, module, exports) {
        module.exports = {
            __depends__: [require('../draw')],
            __init__: ['canvas'],
            canvas: ['type', require('./Canvas')],
            elementRegistry: ['type', require('./ElementRegistry')],
            elementFactory: ['type', require('./ElementFactory')],
            eventBus: ['type', require('./EventBus')],
            graphicsFactory: ['type', require('./GraphicsFactory')]
        };
    }, { "../draw": 131, "./Canvas": 122, "./ElementFactory": 123, "./ElementRegistry": 124, "./EventBus": 125, "./GraphicsFactory": 126 }], 128: [function (require, module, exports) {
        'use strict';

        var DEFAULT_RENDER_PRIORITY = 1000;

        /**
         * The base implementation of shape and connection renderers.
         *
         * @param {EventBus} eventBus
         * @param {Number} [renderPriority=1000]
         */
        function BaseRenderer(eventBus, renderPriority) {
            var self = this;

            renderPriority = renderPriority || DEFAULT_RENDER_PRIORITY;

            eventBus.on(['render.shape', 'render.connection'], renderPriority, function (evt, context) {
                var type = evt.type,
                    element = context.element,
                    visuals = context.gfx;

                if (self.canRender(element)) {
                    if (type === 'render.shape') {
                        return self.drawShape(visuals, element);
                    } else {
                        return self.drawConnection(visuals, element);
                    }
                }
            });

            eventBus.on(['render.getShapePath', 'render.getConnectionPath'], renderPriority, function (evt, element) {
                if (self.canRender(element)) {
                    if (evt.type === 'render.getShapePath') {
                        return self.getShapePath(element);
                    } else {
                        return self.getConnectionPath(element);
                    }
                }
            });
        }

        /**
         * Should check whether *this* renderer can render
         * the element/connection.
         *
         * @param {element} element
         *
         * @returns {Boolean}
         */
        BaseRenderer.prototype.canRender = function () { };

        /**
         * Provides the shape's snap svg element to be drawn on the `canvas`.
         *
         * @param {djs.Graphics} visuals
         * @param {Shape} shape
         *
         * @returns {Snap.svg} [returns a Snap.svg paper element ]
         */
        BaseRenderer.prototype.drawShape = function () { };

        /**
         * Provides the shape's snap svg element to be drawn on the `canvas`.
         *
         * @param {djs.Graphics} visuals
         * @param {Connection} connection
         *
         * @returns {Snap.svg} [returns a Snap.svg paper element ]
         */
        BaseRenderer.prototype.drawConnection = function () { };

        /**
         * Gets the SVG path of a shape that represents it's visual bounds.
         *
         * @param {Shape} shape
         *
         * @return {string} svg path
         */
        BaseRenderer.prototype.getShapePath = function () { };

        /**
         * Gets the SVG path of a connection that represents it's visual bounds.
         *
         * @param {Connection} connection
         *
         * @return {string} svg path
         */
        BaseRenderer.prototype.getConnectionPath = function () { };

        module.exports = BaseRenderer;

    }, {}], 129: [function (require, module, exports) {
        'use strict';

        var inherits = require('inherits');

        var BaseRenderer = require('./BaseRenderer');

        var renderUtil = require('../util/RenderUtil');

        var componentsToPath = renderUtil.componentsToPath,
            createLine = renderUtil.createLine;

        var svgAppend = require('tiny-svg/lib/append'),
            svgAttr = require('tiny-svg/lib/attr'),
            svgCreate = require('tiny-svg/lib/create');

        // apply default renderer with lowest possible priority
        // so that it only kicks in if noone else could render
        var DEFAULT_RENDER_PRIORITY = 1;

        /**
         * The default renderer used for shapes and connections.
         *
         * @param {EventBus} eventBus
         * @param {Styles} styles
         */
        function DefaultRenderer(eventBus, styles) {
            //
            BaseRenderer.call(this, eventBus, DEFAULT_RENDER_PRIORITY);

            this.CONNECTION_STYLE = styles.style(['no-fill'], { strokeWidth: 5, stroke: 'fuchsia' });
            this.SHAPE_STYLE = styles.style({ fill: 'white', stroke: 'fuchsia', strokeWidth: 2 });
        }

        inherits(DefaultRenderer, BaseRenderer);


        DefaultRenderer.prototype.canRender = function () {
            return true;
        };

        DefaultRenderer.prototype.drawShape = function drawShape(visuals, element) {

            var rect = svgCreate('rect');
            svgAttr(rect, {
                x: 0,
                y: 0,
                width: element.width || 0,
                height: element.height || 0
            });
            svgAttr(rect, this.SHAPE_STYLE);

            svgAppend(visuals, rect);

            return rect;
        };

        DefaultRenderer.prototype.drawConnection = function drawConnection(visuals, connection) {

            var line = createLine(connection.waypoints, this.CONNECTION_STYLE);
            svgAppend(visuals, line);

            return line;
        };

        DefaultRenderer.prototype.getShapePath = function getShapePath(shape) {

            var x = shape.x,
                y = shape.y,
                width = shape.width,
                height = shape.height;

            var shapePath = [
                ['M', x, y],
                ['l', width, 0],
                ['l', 0, height],
                ['l', -width, 0],
                ['z']
            ];

            return componentsToPath(shapePath);
        };

        DefaultRenderer.prototype.getConnectionPath = function getConnectionPath(connection) {
            var waypoints = connection.waypoints;

            var idx, point, connectionPath = [];

            for (idx = 0; (point = waypoints[idx]); idx++) {

                // take invisible docking into account
                // when creating the path
                point = point.original || point;

                connectionPath.push([idx === 0 ? 'M' : 'L', point.x, point.y]);
            }

            return componentsToPath(connectionPath);
        };


        DefaultRenderer.$inject = ['eventBus', 'styles'];

        module.exports = DefaultRenderer;

    }, { "../util/RenderUtil": 278, "./BaseRenderer": 128, "inherits": 289, "tiny-svg/lib/append": 473, "tiny-svg/lib/attr": 475, "tiny-svg/lib/create": 479 }], 130: [function (require, module, exports) {
        'use strict';

        var isArray = require('lodash/lang/isArray'),
            assign = require('lodash/object/assign'),
            reduce = require('lodash/collection/reduce');


        /**
         * A component that manages shape styles
         */
        function Styles() {

            var defaultTraits = {

                'no-fill': {
                    fill: 'none'
                },
                'no-border': {
                    strokeOpacity: 0.0
                },
                'no-events': {
                    pointerEvents: 'none'
                }
            };

            var self = this;

            /**
             * Builds a style definition from a className, a list of traits and an object of additional attributes.
             *
             * @param  {String} className
             * @param  {Array<String>} traits
             * @param  {Object} additionalAttrs
             *
             * @return {Object} the style defintion
             */
            this.cls = function (className, traits, additionalAttrs) {
                var attrs = this.style(traits, additionalAttrs);

                return assign(attrs, { 'class': className });
            };

            /**
             * Builds a style definition from a list of traits and an object of additional attributes.
             *
             * @param  {Array<String>} traits
             * @param  {Object} additionalAttrs
             *
             * @return {Object} the style defintion
             */
            this.style = function (traits, additionalAttrs) {

                if (!isArray(traits) && !additionalAttrs) {
                    additionalAttrs = traits;
                    traits = [];
                }

                var attrs = reduce(traits, function (attrs, t) {
                    return assign(attrs, defaultTraits[t] || {});
                }, {});

                return additionalAttrs ? assign(attrs, additionalAttrs) : attrs;
            };

            this.computeStyle = function (custom, traits, defaultStyles) {
                if (!isArray(traits)) {
                    defaultStyles = traits;
                    traits = [];
                }

                return self.style(traits || [], assign({}, defaultStyles, custom || {}));
            };
        }

        module.exports = Styles;

    }, { "lodash/collection/reduce": 307, "lodash/lang/isArray": 424, "lodash/object/assign": 433 }], 131: [function (require, module, exports) {
        module.exports = {
            __init__: ['defaultRenderer'],
            defaultRenderer: ['type', require('./DefaultRenderer')],
            styles: ['type', require('./Styles')]
        };

    }, { "./DefaultRenderer": 129, "./Styles": 130 }], 132: [function (require, module, exports) {
        'use strict';

        var filter = require('lodash/collection/filter'),
            forEach = require('lodash/collection/forEach'),
            sortBy = require('lodash/collection/sortBy');

        function last(arr) {
            return arr && arr[arr.length - 1];
        }

        function sortTopOrMiddle(element) {
            return element.y;
        }

        function sortLeftOrCenter(element) {
            return element.x;
        }

        /**
         * Sorting functions for different types of alignment
         *
         * @type {Object}
         *
         * @return {Function}
         */
        var ALIGNMENT_SORTING = {
            left: sortLeftOrCenter,
            center: sortLeftOrCenter,
            right: function (element) {
                return element.x + element.width;
            },
            top: sortTopOrMiddle,
            middle: sortTopOrMiddle,
            bottom: function (element) {
                return element.y + element.height;
            }
        };


        function AlignElements(modeling) {
            this._modeling = modeling;
        }

        module.exports = AlignElements;

        AlignElements.$inject = ['modeling'];


        /**
         * Get the relevant "axis" and "dimension" related to the current type of alignment
         *
         * @param  {String} type left|right|center|top|bottom|middle
         *
         * @return {Object} { axis, dimension }
         */
        AlignElements.prototype._getOrientationDetails = function (type) {
            var vertical = ['top', 'bottom', 'middle'],
                axis = 'x',
                dimension = 'width';

            if (vertical.indexOf(type) !== -1) {
                axis = 'y';
                dimension = 'height';
            }

            return {
                axis: axis,
                dimension: dimension
            };
        };

        AlignElements.prototype._isType = function (type, types) {
            return types.indexOf(type) !== -1;
        };

        /**
         * Get a point on the relevant axis where elements should align to
         *
         * @param  {String} type left|right|center|top|bottom|middle
         * @param  {Array} sortedElements
         *
         * @return {Object}
         */
        AlignElements.prototype._alignmentPosition = function (type, sortedElements) {
            var orientation = this._getOrientationDetails(type),
                axis = orientation.axis,
                dimension = orientation.dimension,
                alignment = {},
                centers = {},
                hasSharedCenters = false,
                centeredElements,
                firstElement,
                lastElement;

            function getMiddleOrTop(first, last) {
                return Math.round((first[axis] + last[axis] + last[dimension]) / 2);
            }

            if (this._isType(type, ['left', 'top'])) {
                alignment[type] = sortedElements[0][axis];

            } else if (this._isType(type, ['right', 'bottom'])) {
                lastElement = last(sortedElements);

                alignment[type] = lastElement[axis] + lastElement[dimension];

            } else if (this._isType(type, ['center', 'middle'])) {

                // check if there is a center shared by more than one shape
                // if not, just take the middle of the range
                forEach(sortedElements, function (element) {
                    var center = element[axis] + Math.round(element[dimension] / 2);

                    if (centers[center]) {
                        centers[center].elements.push(element);
                    } else {
                        centers[center] = {
                            elements: [element],
                            center: center
                        };
                    }
                });

                centeredElements = sortBy(centers, function (center) {
                    if (center.elements.length > 1) {
                        hasSharedCenters = true;
                    }

                    return center.elements.length;
                });

                if (hasSharedCenters) {
                    alignment[type] = last(centeredElements).center;

                    return alignment;
                }

                firstElement = sortedElements[0];

                sortedElements = sortBy(sortedElements, function (element) {
                    return element[axis] + element[dimension];
                });

                lastElement = last(sortedElements);

                alignment[type] = getMiddleOrTop(firstElement, lastElement);
            }

            return alignment;
        };

        /**
         * Executes the alignment of a selection of elements
         *
         * @param  {Array} elements [description]
         * @param  {String} type left|right|center|top|bottom|middle
         */
        AlignElements.prototype.trigger = function (elements, type) {
            var modeling = this._modeling;

            var filteredElements = filter(elements, function (element) {
                return !(element.waypoints || element.host || element.labelTarget);
            });

            var sortFn = ALIGNMENT_SORTING[type];

            var sortedElements = sortBy(filteredElements, sortFn);

            var alignment = this._alignmentPosition(type, sortedElements);

            modeling.alignElements(sortedElements, alignment);
        };

    }, { "lodash/collection/filter": 302, "lodash/collection/forEach": 304, "lodash/collection/sortBy": 311 }], 133: [function (require, module, exports) {
        'use strict';

        module.exports = {
            __init__: ['alignElements'],
            alignElements: ['type', require('./AlignElements')]
        };

    }, { "./AlignElements": 132 }], 134: [function (require, module, exports) {
        'use strict';

        var forEach = require('lodash/collection/forEach'),
            flatten = require('lodash/array/flatten'),
            union = require('lodash/array/union'),
            filter = require('lodash/collection/filter'),
            groupBy = require('lodash/collection/groupBy'),
            map = require('lodash/collection/map');

        var saveClear = require('../../util/Removal').saveClear,
            Collections = require('../../util/Collections');

        var getNewAttachShapeDelta = require('../../util/AttachUtil').getNewAttachShapeDelta;

        var inherits = require('inherits');

        var HIGH_PRIORITY = 1500;

        var CommandInterceptor = require('../../command/CommandInterceptor');


        function AttachSupport(eventBus, modeling, movePreview, rules) {

            CommandInterceptor.call(this, eventBus);


            // remove all the attached elements from the shapes to be validated
            // add all the attached shapes to the overall list of moved shapes
            eventBus.on('shape.move.start', HIGH_PRIORITY, function (e) {

                var context = e.context,
                    shapes = context.shapes,
                    validatedShapes = context.validatedShapes;

                context.shapes = addAttached(shapes);

                context.validatedShapes = removeAttached(validatedShapes);
            });


            // move all attachments after the other shapes are done moving
            this.postExecuted(['elements.move'], function (event) {

                var context = event.context,
                    delta = context.delta,
                    newParent = context.newParent,
                    closure = context.closure,
                    enclosedElements = closure.enclosedElements,
                    attachers = getAttachers(enclosedElements);

                // ensure we move all attachers with their hosts
                // if they have not been moved already
                forEach(attachers, function (attacher) {
                    if (!enclosedElements[attacher.id]) {
                        modeling.moveShape(attacher, delta, newParent);
                    }
                });
            });

            // perform the attaching after shapes are done moving
            this.postExecuted(['elements.move'], function (e) {

                var context = e.context,
                    shapes = context.shapes,
                    newHost = context.newHost,
                    attachers;

                // we only support attachment / detachment of one element
                if (shapes.length > 1) {
                    return;
                }

                if (newHost) {

                    attachers = shapes;
                } else {

                    attachers = filter(shapes, function (s) {
                        return !!s.host;
                    });
                }

                forEach(attachers, function (attacher) {
                    modeling.updateAttachment(attacher, newHost);
                });
            });

            // ensure invalid attachment connections are removed
            this.postExecuted(['elements.move'], function (e) {

                var shapes = e.context.shapes;

                forEach(shapes, function (shape) {

                    forEach(shape.attachers, function (attacher) {

                        // remove invalid outgoing connections
                        forEach(attacher.outgoing.slice(), function (connection) {
                            var allowed = rules.allowed('connection.reconnectStart', {
                                connection: connection,
                                source: connection.source,
                                target: connection.target
                            });

                            if (!allowed) {
                                modeling.removeConnection(connection);
                            }
                        });

                        // remove invalid incoming connections
                        forEach(attacher.incoming.slice(), function (connection) {
                            var allowed = rules.allowed('connection.reconnectEnd', {
                                connection: connection,
                                source: connection.source,
                                target: connection.target
                            });

                            if (!allowed) {
                                modeling.removeConnection(connection);
                            }
                        });
                    });
                });
            });

            this.postExecute(['shape.create'], function (e) {
                var context = e.context,
                    shape = context.shape,
                    host = context.host;

                if (host) {
                    modeling.updateAttachment(shape, host);
                }
            });

            // update attachments if the host is replaced
            this.postExecute(['shape.replace'], function (e) {

                var context = e.context,
                    oldShape = context.oldShape,
                    newShape = context.newShape;

                // move the attachers to the new host
                saveClear(oldShape.attachers, function (attacher) {
                    var allowed = rules.allowed('elements.move', {
                        target: newShape,
                        shapes: [attacher]
                    });

                    if (allowed === 'attach') {
                        modeling.updateAttachment(attacher, newShape);
                    } else {
                        modeling.removeShape(attacher);
                    }
                });

                // move attachers if new host has different size
                if (newShape.attachers.length) {

                    forEach(newShape.attachers, function (attacher) {
                        var delta = getNewAttachShapeDelta(attacher, oldShape, newShape);
                        modeling.moveShape(attacher, delta, attacher.parent);
                    });
                }

            });

            // move shape on host resize
            this.postExecute(['shape.resize'], function (event) {
                var context = event.context,
                    shape = context.shape,
                    oldBounds = context.oldBounds,
                    newBounds = context.newBounds,
                    attachers = shape.attachers;

                if (!attachers.length) {
                    return;
                }

                forEach(attachers, function (attacher) {
                    var delta = getNewAttachShapeDelta(attacher, oldBounds, newBounds);

                    modeling.moveShape(attacher, delta, attacher.parent);

                    if (attacher.label) {
                        modeling.moveShape(attacher.label, delta, attacher.label.parent);
                    }
                });
            });

            // remove attachments
            this.preExecute(['shape.delete'], function (event) {

                var shape = event.context.shape;

                saveClear(shape.attachers, function (attacher) {
                    modeling.removeShape(attacher);
                });

                if (shape.host) {
                    modeling.updateAttachment(shape, null);
                }
            });


            // Prevent attachers and their labels from moving, when the space tool is performed.
            // Otherwise the attachers and their labels would be moved twice.
            eventBus.on('spaceTool.move', function (event) {

                var movingShapes = event.context.movingShapes;

                // Collect all attachers which would be moved using the space tool
                var movingAttachers = filter(movingShapes, function (shape) {
                    return shape.host && shape.host.id;
                });

                forEach(movingAttachers, function (shape) {
                    // Remove all attachers and their labels from the movingShapes, because they
                    // already will be moved along with the host.
                    Collections.remove(movingShapes, shape);
                    if (shape.label) {
                        Collections.remove(movingShapes, shape.label);
                    }
                });

            });
        }

        inherits(AttachSupport, CommandInterceptor);

        AttachSupport.$inject = ['eventBus', 'modeling', 'movePreview', 'rules'];

        module.exports = AttachSupport;


        /**
         * Return attachers of the given shapes
         *
         * @param {Array<djs.model.Base>} shapes
         * @return {Array<djs.model.Base>}
         */
        function getAttachers(shapes) {
            return flatten(map(shapes, function (s) {
                return s.attachers || [];
            }));
        }

        /**
         * Return a combined list of elements and
         * attachers.
         *
         * @param {Array<djs.model.Base>} elements
         * @return {Array<djs.model.Base>} filtered
         */
        function addAttached(elements) {
            var attachers = getAttachers(elements);

            return union(elements, attachers);
        }

        /**
         * Return a filtered list of elements that do not
         * contain attached elements with hosts being part
         * of the selection.
         *
         * @param  {Array<djs.model.Base>} elements
         *
         * @return {Array<djs.model.Base>} filtered
         */
        function removeAttached(elements) {

            var ids = groupBy(elements, 'id');

            return filter(elements, function (element) {
                while (element) {

                    // host in selection
                    if (element.host && ids[element.host.id]) {
                        return false;
                    }

                    element = element.parent;
                }

                return true;
            });
        }

    }, { "../../command/CommandInterceptor": 119, "../../util/AttachUtil": 261, "../../util/Collections": 263, "../../util/Removal": 277, "inherits": 289, "lodash/array/flatten": 292, "lodash/array/union": 295, "lodash/collection/filter": 302, "lodash/collection/forEach": 304, "lodash/collection/groupBy": 305, "lodash/collection/map": 306 }], 135: [function (require, module, exports) {
        module.exports = {
            __depends__: [
                require('../move'),
                require('../label-support')
            ],
            __init__: ['attachSupport'],
            attachSupport: ['type', require('./AttachSupport')]
        };

    }, { "../label-support": 174, "../move": 206, "./AttachSupport": 134 }], 136: [function (require, module, exports) {
        'use strict';

        var inherits = require('inherits');

        var getBoundingBox = require('../../util/Elements').getBBox;

        var asTRBL = require('../../layout/LayoutUtil').asTRBL,
            asBounds = require('../../layout/LayoutUtil').asBounds;

        var assign = require('lodash/object/assign'),
            forEach = require('lodash/collection/forEach'),
            values = require('lodash/object/values'),
            flatten = require('lodash/array/flatten'),
            groupBy = require('lodash/collection/groupBy');

        var CommandInterceptor = require('../../command/CommandInterceptor');


        /**
         * An auto resize component that takes care of expanding a parent element
         * if child elements are created or moved close the parents edge.
         *
         * @param {EventBus} eventBus
         * @param {ElementRegistry} elementRegistry
         * @param {Modeling} modeling
         * @param {Rules} rules
         */
        function AutoResize(eventBus, elementRegistry, modeling, rules) {

            CommandInterceptor.call(this, eventBus);

            this._elementRegistry = elementRegistry;
            this._modeling = modeling;
            this._rules = rules;

            var self = this;

            this.postExecuted(['shape.create'], function (event) {

                var context = event.context,
                    hints = context.hints,
                    shape = context.shape,
                    parent = context.parent || context.newParent;

                if (hints && hints.root === false) {
                    return;
                }

                self._expand([shape], parent);
            });

            this.postExecuted(['elements.move'], function (event) {

                var context = event.context,
                    elements = flatten(values(context.closure.topLevel)),
                    hints = context.hints;

                if (hints && hints.autoResize === false) {
                    return;
                }

                var expandings = groupBy(elements, function (element) {
                    return element.parent.id;
                });

                forEach(expandings, function (elements, parentId) {
                    self._expand(elements, parentId);
                });
            });
        }

        AutoResize.$inject = ['eventBus', 'elementRegistry', 'modeling', 'rules'];

        inherits(AutoResize, CommandInterceptor);

        module.exports = AutoResize;


        /**
         * Calculate the new bounds of the target shape, given
         * a number of elements have been moved or added into the parent.
         *
         * This method considers the current size, the added elements as well as
         * the provided padding for the new bounds.
         *
         * @param {Array<djs.model.Shape>} elements
         * @param {djs.model.Shape} target
         */
        AutoResize.prototype._getOptimalBounds = function (elements, target) {

            var offset = this.getOffset(target),
                padding = this.getPadding(target);

            var elementsTrbl = asTRBL(getBoundingBox(elements)),
                targetTrbl = asTRBL(target);

            var newTrbl = {};

            if (elementsTrbl.top - targetTrbl.top < padding.top) {
                newTrbl.top = elementsTrbl.top - offset.top;
            }

            if (elementsTrbl.left - targetTrbl.left < padding.left) {
                newTrbl.left = elementsTrbl.left - offset.left;
            }

            if (targetTrbl.right - elementsTrbl.right < padding.right) {
                newTrbl.right = elementsTrbl.right + offset.right;
            }

            if (targetTrbl.bottom - elementsTrbl.bottom < padding.bottom) {
                newTrbl.bottom = elementsTrbl.bottom + offset.bottom;
            }

            return asBounds(assign({}, targetTrbl, newTrbl));
        };


        /**
         * Expand the target shape respecting rules, offset and padding
         *
         * @param {Array<djs.model.Shape>} elements
         * @param {djs.model.Shape|String} target|targetId
         */
        AutoResize.prototype._expand = function (elements, target) {

            if (typeof target === 'string') {
                target = this._elementRegistry.get(target);
            }

            var allowed = this._rules.allowed('element.autoResize', {
                elements: elements,
                target: target
            });

            if (!allowed) {
                return;
            }

            // calculate the new bounds
            var newBounds = this._getOptimalBounds(elements, target);

            if (!boundsChanged(newBounds, target)) {
                return;
            }

            // resize the parent shape
            this.resize(target, newBounds);

            var parent = target.parent;

            // recursively expand parent elements
            if (parent) {
                this._expand([target], parent);
            }
        };


        /**
         * Get the amount to expand the given shape in each direction.
         *
         * @param {djs.model.Shape} shape
         *
         * @return {Object} {top, bottom, left, right}
         */
        AutoResize.prototype.getOffset = function (shape) {
            return { top: 60, bottom: 60, left: 100, right: 100 };
        };


        /**
         * Get the activation threshold for each side for which
         * resize triggers.
         *
         * @param {djs.model.Shape} shape
         *
         * @return {Object} {top, bottom, left, right}
         */
        AutoResize.prototype.getPadding = function (shape) {
            return { top: 2, bottom: 2, left: 15, right: 15 };
        };


        /**
         * Perform the actual resize operation.
         *
         * @param {djs.model.Shape} target
         * @param {Object} newBounds
         */
        AutoResize.prototype.resize = function (target, newBounds) {
            this._modeling.resizeShape(target, newBounds);
        };


        function boundsChanged(newBounds, oldBounds) {
            return (
                newBounds.x !== oldBounds.x ||
                newBounds.y !== oldBounds.y ||
                newBounds.width !== oldBounds.width ||
                newBounds.height !== oldBounds.height
            );
        }
    }, { "../../command/CommandInterceptor": 119, "../../layout/LayoutUtil": 252, "../../util/Elements": 266, "inherits": 289, "lodash/array/flatten": 292, "lodash/collection/forEach": 304, "lodash/collection/groupBy": 305, "lodash/object/assign": 433, "lodash/object/values": 442 }], 137: [function (require, module, exports) {
        var RuleProvider = require('../rules/RuleProvider');

        var inherits = require('inherits');

        /**
         * This is a base rule provider for the element.autoResize rule.
         */
        function AutoResizeProvider(eventBus) {

            RuleProvider.call(this, eventBus);

            var self = this;

            this.addRule('element.autoResize', function (context) {
                return self.canResize(context.elements, context.target);
            });
        }

        AutoResizeProvider.$inject = ['eventBus'];

        inherits(AutoResizeProvider, RuleProvider);

        module.exports = AutoResizeProvider;

        /**
         * Needs to be implemented by sub classes to allow actual auto resize
         *
         * @param  {Array<djs.model.Shape>} elements
         * @param  {djs.model.Shape} target
         *
         * @return {Boolean}
         */
        AutoResizeProvider.prototype.canResize = function (elements, target) {
            return false;
        };
    }, { "../rules/RuleProvider": 225, "inherits": 289 }], 138: [function (require, module, exports) {
        'use strict';

        var assign = require('lodash/object/assign');

        var EventUtil = require('../../util/Event');


        /**
         * Initiates canvas scrolling if current cursor point is close to a border.
         * Cancelled when current point moves back inside the scrolling borders
         * or cancelled manually.
         *
         * Default options :
         *   scrollThresholdIn: [ 20, 20, 20, 20 ],
         *   scrollThresholdOut: [ 0, 0, 0, 0 ],
         *   scrollRepeatTimeout: 15,
         *   scrollStep: 10
         *
         * Threshold order:
         *   [ left, top, right, bottom ]
         */
        function AutoScroll(config, eventBus, canvas, mouseTracking) {

            this._canvas = canvas;
            this._mouseTracking = mouseTracking;

            this._opts = assign({
                scrollThresholdIn: [20, 20, 20, 20],
                scrollThresholdOut: [0, 0, 0, 0],
                scrollRepeatTimeout: 15,
                scrollStep: 10
            }, config);

            var self = this;

            eventBus.on('drag.move', function (e) {
                var point = self._toBorderPoint(e);

                self.startScroll(point);
            });

            eventBus.on(['drag.cleanup'], function () {
                self.stopScroll();
            });
        }

        AutoScroll.$inject = ['config.autoScroll', 'eventBus', 'canvas', 'mouseTracking'];

        module.exports = AutoScroll;


        /**
         * Starts scrolling loop.
         * Point is given in global scale in canvas container box plane.
         *
         * @param  {Object} point { x: X, y: Y }
         */
        AutoScroll.prototype.startScroll = function (point) {

            var canvas = this._canvas;
            var opts = this._opts;
            var self = this;

            var clientRect = canvas.getContainer().getBoundingClientRect();

            var diff = [
                point.x,
                point.y,
                clientRect.width - point.x,
                clientRect.height - point.y
            ];

            this.stopScroll();

            var dx = 0,
                dy = 0;

            for (var i = 0; i < 4; i++) {
                if (between(diff[i], opts.scrollThresholdOut[i], opts.scrollThresholdIn[i])) {
                    if (i === 0) {
                        dx = opts.scrollStep;
                    } else if (i == 1) {
                        dy = opts.scrollStep;
                    } else if (i == 2) {
                        dx = -opts.scrollStep;
                    } else if (i == 3) {
                        dy = -opts.scrollStep;
                    }
                }
            }

            if (dx !== 0 || dy !== 0) {
                canvas.scroll({ dx: dx, dy: dy });

                this._scrolling = setTimeout(function () {
                    self.startScroll(point);
                }, opts.scrollRepeatTimeout);
            }
        };

        function between(val, start, end) {
            if (start < val && val < end) {
                return true;
            }

            return false;
        }


        /**
         * Stops scrolling loop.
         */
        AutoScroll.prototype.stopScroll = function () {
            clearTimeout(this._scrolling);
        };


        /**
         * Overrides defaults options.
         *
         * @param  {Object} options
         */
        AutoScroll.prototype.setOptions = function (options) {
            this._opts = assign({}, this._opts, options);
        };


        /**
         * Converts event to a point in canvas container plane in global scale.
         *
         * @param  {Event} event
         * @return {Point}
         */
        AutoScroll.prototype._toBorderPoint = function (event) {
            var clientRect = this._canvas._container.getBoundingClientRect();

            var globalPosition = EventUtil.toPoint(event.originalEvent);

            return {
                x: globalPosition.x - clientRect.left,
                y: globalPosition.y - clientRect.top
            };
        };
    }, { "../../util/Event": 267, "lodash/object/assign": 433 }], 139: [function (require, module, exports) {
        module.exports = {
            __depends__: [
                require('../dragging'),
                require('../mouse-tracking')
            ],
            __init__: ['autoScroll'],
            autoScroll: ['type', require('./AutoScroll')]
        };
    }, { "../dragging": 162, "../mouse-tracking": 203, "./AutoScroll": 138 }], 140: [function (require, module, exports) {
        'use strict';

        var Geometry = require('../../util/Geometry'),
            BendpointUtil = require('./BendpointUtil');

        var MARKER_OK = 'connect-ok',
            MARKER_NOT_OK = 'connect-not-ok',
            MARKER_CONNECT_HOVER = 'connect-hover',
            MARKER_CONNECT_UPDATING = 'djs-updating';

        var COMMAND_BENDPOINT_UPDATE = 'connection.updateWaypoints',
            COMMAND_RECONNECT_START = 'connection.reconnectStart',
            COMMAND_RECONNECT_END = 'connection.reconnectEnd';

        var round = Math.round;

        var svgClasses = require('tiny-svg/lib/classes'),
            svgRemove = require('tiny-svg/lib/remove');

        var translate = require('../../util/SvgTransformUtil').translate;


        /**
         * A component that implements moving of bendpoints
         */
        function BendpointMove(injector, eventBus, canvas, dragging, graphicsFactory, rules, modeling) {

            // optional connection docking integration
            var connectionDocking = injector.get('connectionDocking', false);


            // API

            this.start = function (event, connection, bendpointIndex, insert) {

                var type,
                    context,
                    waypoints = connection.waypoints,
                    gfx = canvas.getGraphics(connection);

                if (!insert && bendpointIndex === 0) {
                    type = COMMAND_RECONNECT_START;
                } else
                    if (!insert && bendpointIndex === waypoints.length - 1) {
                        type = COMMAND_RECONNECT_END;
                    } else {
                        type = COMMAND_BENDPOINT_UPDATE;
                    }

                context = {
                    connection: connection,
                    bendpointIndex: bendpointIndex,
                    insert: insert,
                    type: type
                };

                dragging.init(event, 'bendpoint.move', {
                    data: {
                        connection: connection,
                        connectionGfx: gfx,
                        context: context
                    }
                });
            };


            // DRAGGING IMPLEMENTATION


            function redrawConnection(data) {
                graphicsFactory.update('connection', data.connection, data.connectionGfx);
            }

            function filterRedundantWaypoints(waypoints) {

                // alter copy of waypoints, not original
                waypoints = waypoints.slice();

                var idx = 0,
                    point,
                    previousPoint,
                    nextPoint;

                while (waypoints[idx]) {
                    point = waypoints[idx];
                    previousPoint = waypoints[idx - 1];
                    nextPoint = waypoints[idx + 1];

                    if (Geometry.pointDistance(point, nextPoint) === 0 ||
                        Geometry.pointsOnLine(previousPoint, nextPoint, point)) {

                        // remove point, if overlapping with {nextPoint}
                        // or on line with {previousPoint} -> {point} -> {nextPoint}
                        waypoints.splice(idx, 1);
                    } else {
                        idx++;
                    }
                }

                return waypoints;
            }

            eventBus.on('bendpoint.move.start', function (e) {

                var context = e.context,
                    connection = context.connection,
                    originalWaypoints = connection.waypoints,
                    waypoints = originalWaypoints.slice(),
                    insert = context.insert,
                    idx = context.bendpointIndex;

                context.originalWaypoints = originalWaypoints;

                if (insert) {
                    // insert placeholder for bendpoint to-be-added
                    waypoints.splice(idx, 0, null);
                }

                connection.waypoints = waypoints;

                // add dragger gfx
                context.draggerGfx = BendpointUtil.addBendpoint(canvas.getLayer('overlays'));
                svgClasses(context.draggerGfx).add('djs-dragging');

                canvas.addMarker(connection, MARKER_CONNECT_UPDATING);
            });

            eventBus.on('bendpoint.move.hover', function (e) {

                e.context.hover = e.hover;
                canvas.addMarker(e.hover, MARKER_CONNECT_HOVER);
            });

            eventBus.on([
                'bendpoint.move.out',
                'bendpoint.move.cleanup'
            ], function (e) {

                // remove connect marker
                // if it was added
                var hover = e.context.hover;

                if (hover) {
                    canvas.removeMarker(hover, MARKER_CONNECT_HOVER);
                    canvas.removeMarker(hover, e.context.target ? MARKER_OK : MARKER_NOT_OK);
                }
            });

            eventBus.on('bendpoint.move.move', function (e) {

                var context = e.context,
                    moveType = context.type,
                    connection = e.connection,
                    source, target;

                connection.waypoints[context.bendpointIndex] = { x: e.x, y: e.y };

                if (connectionDocking) {

                    if (context.hover) {
                        if (moveType === COMMAND_RECONNECT_START) {
                            source = context.hover;
                        }

                        if (moveType === COMMAND_RECONNECT_END) {
                            target = context.hover;
                        }
                    }

                    connection.waypoints = connectionDocking.getCroppedWaypoints(connection, source, target);
                }

                // asks whether reconnect / bendpoint move / bendpoint add
                // is allowed at the given position
                var allowed = context.allowed = rules.allowed(context.type, context);

                if (allowed) {

                    if (context.hover) {
                        canvas.removeMarker(context.hover, MARKER_NOT_OK);
                        canvas.addMarker(context.hover, MARKER_OK);

                        context.target = context.hover;
                    }
                } else
                    if (allowed === false) {
                        if (context.hover) {
                            canvas.removeMarker(context.hover, MARKER_OK);
                            canvas.addMarker(context.hover, MARKER_NOT_OK);

                            context.target = null;
                        }
                    }

                // add dragger gfx
                translate(context.draggerGfx, e.x, e.y);

                redrawConnection(e);
            });

            eventBus.on([
                'bendpoint.move.end',
                'bendpoint.move.cancel'
            ], function (e) {

                var context = e.context,
                    hover = context.hover,
                    connection = context.connection;

                // remove dragger gfx
                svgRemove(context.draggerGfx);
                context.newWaypoints = connection.waypoints.slice();
                connection.waypoints = context.originalWaypoints;
                canvas.removeMarker(connection, MARKER_CONNECT_UPDATING);

                if (hover) {
                    canvas.removeMarker(hover, MARKER_OK);
                    canvas.removeMarker(hover, MARKER_NOT_OK);
                }
            });

            eventBus.on('bendpoint.move.end', function (e) {

                var context = e.context,
                    waypoints = context.newWaypoints,
                    bendpointIndex = context.bendpointIndex,
                    bendpoint = waypoints[bendpointIndex],
                    allowed = context.allowed,
                    hints;

                // ensure we have actual pixel values bendpoint
                // coordinates (important when zoom level was > 1 during move)
                bendpoint.x = round(bendpoint.x);
                bendpoint.y = round(bendpoint.y);

                if (allowed && context.type === COMMAND_RECONNECT_START) {
                    modeling.reconnectStart(context.connection, context.target, bendpoint);
                } else
                    if (allowed && context.type === COMMAND_RECONNECT_END) {
                        modeling.reconnectEnd(context.connection, context.target, bendpoint);
                    } else
                        if (allowed !== false && context.type === COMMAND_BENDPOINT_UPDATE) {

                            // pass hints on the actual moved bendpoint
                            // this is useful for connection and label layouting
                            hints = {
                                bendpointMove: {
                                    insert: e.context.insert,
                                    bendpointIndex: bendpointIndex
                                }
                            };

                            modeling.updateWaypoints(context.connection, filterRedundantWaypoints(waypoints), hints);
                        } else {
                            redrawConnection(e);

                            return false;
                        }
            });

            eventBus.on('bendpoint.move.cancel', function (e) {
                redrawConnection(e);
            });
        }

        BendpointMove.$inject = ['injector', 'eventBus', 'canvas', 'dragging', 'graphicsFactory', 'rules', 'modeling'];

        module.exports = BendpointMove;

    }, { "../../util/Geometry": 268, "../../util/SvgTransformUtil": 279, "./BendpointUtil": 142, "tiny-svg/lib/classes": 476, "tiny-svg/lib/remove": 482 }], 141: [function (require, module, exports) {
        'use strict';

        var assign = require('lodash/object/assign'),
            forEach = require('lodash/collection/forEach'),
            isArray = require('lodash/lang/isArray');

        var abs = Math.abs,
            round = Math.round;

        var TOLERANCE = 10;


        function BendpointSnapping(eventBus) {

            function snapTo(values, value) {

                if (isArray(values)) {
                    var i = values.length;

                    while (i--) if (abs(values[i] - value) <= TOLERANCE) {
                        return values[i];
                    }
                } else {
                    values = +values;
                    var rem = value % values;

                    if (rem < TOLERANCE) {
                        return value - rem;
                    }

                    if (rem > values - TOLERANCE) {
                        return value - rem + values;
                    }
                }

                return value;
            }

            function mid(element) {
                if (element.width) {
                    return {
                        x: round(element.width / 2 + element.x),
                        y: round(element.height / 2 + element.y)
                    };
                }
            }

            ////////// connection segment snapping //////////////////////////////////////

            function getConnectionSegmentSnaps(context) {

                var snapPoints = context.snapPoints,
                    connection = context.connection,
                    waypoints = connection.waypoints,
                    segmentStart = context.segmentStart,
                    segmentStartIndex = context.segmentStartIndex,
                    segmentEnd = context.segmentEnd,
                    segmentEndIndex = context.segmentEndIndex,
                    axis = context.axis;

                if (snapPoints) {
                    return snapPoints;
                }

                var referenceWaypoints = [
                    waypoints[segmentStartIndex - 1],
                    segmentStart,
                    segmentEnd,
                    waypoints[segmentEndIndex + 1]
                ];

                if (segmentStartIndex < 2) {
                    referenceWaypoints.unshift(mid(connection.source));
                }

                if (segmentEndIndex > waypoints.length - 3) {
                    referenceWaypoints.unshift(mid(connection.target));
                }

                context.snapPoints = snapPoints = { horizontal: [], vertical: [] };

                forEach(referenceWaypoints, function (p) {
                    // we snap on existing bendpoints only,
                    // not placeholders that are inserted during add
                    if (p) {
                        p = p.original || p;

                        if (axis === 'y') {
                            snapPoints.horizontal.push(p.y);
                        }

                        if (axis === 'x') {
                            snapPoints.vertical.push(p.x);
                        }
                    }
                });

                return snapPoints;
            }

            eventBus.on('connectionSegment.move.move', 1500, function (event) {
                var context = event.context,
                    snapPoints = getConnectionSegmentSnaps(context),
                    x = event.x,
                    y = event.y,
                    sx, sy;

                if (!snapPoints) {
                    return;
                }

                // snap
                sx = snapTo(snapPoints.vertical, x);
                sy = snapTo(snapPoints.horizontal, y);


                // correction x/y
                var cx = (x - sx),
                    cy = (y - sy);

                // update delta
                assign(event, {
                    dx: event.dx - cx,
                    dy: event.dy - cy,
                    x: sx,
                    y: sy
                });
            });


            ///////// bendpoint snapping /////////////////////////////

            function getBendpointSnaps(context) {

                var snapPoints = context.snapPoints,
                    waypoints = context.connection.waypoints,
                    bendpointIndex = context.bendpointIndex;

                if (snapPoints) {
                    return snapPoints;
                }

                var referenceWaypoints = [waypoints[bendpointIndex - 1], waypoints[bendpointIndex + 1]];

                context.snapPoints = snapPoints = { horizontal: [], vertical: [] };

                forEach(referenceWaypoints, function (p) {
                    // we snap on existing bendpoints only,
                    // not placeholders that are inserted during add
                    if (p) {
                        p = p.original || p;

                        snapPoints.horizontal.push(p.y);
                        snapPoints.vertical.push(p.x);
                    }
                });

                return snapPoints;
            }


            eventBus.on('bendpoint.move.move', 1500, function (event) {

                var context = event.context,
                    snapPoints = getBendpointSnaps(context),
                    target = context.target,
                    targetMid = target && mid(target),
                    x = event.x,
                    y = event.y,
                    sx, sy;

                if (!snapPoints) {
                    return;
                }

                // snap
                sx = snapTo(targetMid ? snapPoints.vertical.concat([targetMid.x]) : snapPoints.vertical, x);
                sy = snapTo(targetMid ? snapPoints.horizontal.concat([targetMid.y]) : snapPoints.horizontal, y);


                // correction x/y
                var cx = (x - sx),
                    cy = (y - sy);

                // update delta
                assign(event, {
                    dx: event.dx - cx,
                    dy: event.dy - cy,
                    x: event.x - cx,
                    y: event.y - cy
                });
            });
        }


        BendpointSnapping.$inject = ['eventBus'];

        module.exports = BendpointSnapping;

    }, { "lodash/collection/forEach": 304, "lodash/lang/isArray": 424, "lodash/object/assign": 433 }], 142: [function (require, module, exports) {
        'use strict';

        var Events = require('../../util/Event'),
            Geometry = require('../../util/Geometry');

        var BENDPOINT_CLS = module.exports.BENDPOINT_CLS = 'djs-bendpoint';
        var SEGMENT_DRAGGER_CLS = module.exports.SEGMENT_DRAGGER_CLS = 'djs-segment-dragger';

        var svgAppend = require('tiny-svg/lib/append'),
            svgAttr = require('tiny-svg/lib/attr'),
            svgClasses = require('tiny-svg/lib/classes'),
            svgCreate = require('tiny-svg/lib/create');

        var rotate = require('../../util/SvgTransformUtil').rotate,
            translate = require('../../util/SvgTransformUtil').translate;


        module.exports.toCanvasCoordinates = function (canvas, event) {

            var position = Events.toPoint(event),
                clientRect = canvas._container.getBoundingClientRect(),
                offset;

            // canvas relative position

            offset = {
                x: clientRect.left,
                y: clientRect.top
            };

            // update actual event payload with canvas relative measures

            var viewbox = canvas.viewbox();

            return {
                x: viewbox.x + (position.x - offset.x) / viewbox.scale,
                y: viewbox.y + (position.y - offset.y) / viewbox.scale
            };
        };

        module.exports.addBendpoint = function (parentGfx, cls) {
            var groupGfx = svgCreate('g');
            svgClasses(groupGfx).add(BENDPOINT_CLS);

            svgAppend(parentGfx, groupGfx);

            var visual = svgCreate('circle');
            svgAttr(visual, {
                cx: 0,
                cy: 0,
                r: 4
            });
            svgClasses(visual).add('djs-visual');

            svgAppend(groupGfx, visual);

            var hit = svgCreate('circle');
            svgAttr(hit, {
                cx: 0,
                cy: 0,
                r: 10
            });
            svgClasses(hit).add('djs-hit');

            svgAppend(groupGfx, hit);

            if (cls) {
                svgClasses(groupGfx).add(cls);
            }

            return groupGfx;
        };

        function createParallelDragger(parentGfx, position, alignment) {
            var draggerGfx = svgCreate('g');

            svgAppend(parentGfx, draggerGfx);

            var width = 14,
                height = 3,
                padding = 6,
                hitWidth = width + padding,
                hitHeight = height + padding;

            var visual = svgCreate('rect');
            svgAttr(visual, {
                x: -width / 2,
                y: -height / 2,
                width: width,
                height: height
            });
            svgClasses(visual).add('djs-visual');

            svgAppend(draggerGfx, visual);

            var hit = svgCreate('rect');
            svgAttr(hit, {
                x: -hitWidth / 2,
                y: -hitHeight / 2,
                width: hitWidth,
                height: hitHeight
            });
            svgClasses(hit).add('djs-hit');

            svgAppend(draggerGfx, hit);

            rotate(draggerGfx, alignment === 'h' ? 90 : 0, 0, 0);

            return draggerGfx;
        }


        module.exports.addSegmentDragger = function (parentGfx, segmentStart, segmentEnd) {

            var groupGfx = svgCreate('g'),
                mid = Geometry.getMidPoint(segmentStart, segmentEnd),
                alignment = Geometry.pointsAligned(segmentStart, segmentEnd);

            svgAppend(parentGfx, groupGfx);

            createParallelDragger(groupGfx, mid, alignment);

            svgClasses(groupGfx).add(SEGMENT_DRAGGER_CLS);
            svgClasses(groupGfx).add(alignment === 'h' ? 'vertical' : 'horizontal');

            translate(groupGfx, mid.x, mid.y);

            return groupGfx;
        };

    }, { "../../util/Event": 267, "../../util/Geometry": 268, "../../util/SvgTransformUtil": 279, "tiny-svg/lib/append": 473, "tiny-svg/lib/attr": 475, "tiny-svg/lib/classes": 476, "tiny-svg/lib/create": 479 }], 143: [function (require, module, exports) {
        'use strict';

        var forEach = require('lodash/collection/forEach');

        var domEvent = require('min-dom/lib/event'),
            domQuery = require('min-dom/lib/query'),
            BendpointUtil = require('./BendpointUtil');

        var pointsAligned = require('../../util/Geometry').pointsAligned,
            getMidPoint = require('../../util/Geometry').getMidPoint;

        var BENDPOINT_CLS = BendpointUtil.BENDPOINT_CLS,
            SEGMENT_DRAGGER_CLS = BendpointUtil.SEGMENT_DRAGGER_CLS;

        var getApproxIntersection = require('../../util/LineIntersection').getApproxIntersection;

        var svgAppend = require('tiny-svg/lib/append'),
            svgAttr = require('tiny-svg/lib/attr'),
            svgClasses = require('tiny-svg/lib/classes'),
            svgCreate = require('tiny-svg/lib/create'),
            svgRemove = require('tiny-svg/lib/remove');

        var translate = require('../../util/SvgTransformUtil').translate;


        /**
         * A service that adds editable bendpoints to connections.
         */
        function Bendpoints(eventBus, canvas, interactionEvents,
            bendpointMove, connectionSegmentMove) {

            function getConnectionIntersection(waypoints, event) {
                var localPosition = BendpointUtil.toCanvasCoordinates(canvas, event),
                    intersection = getApproxIntersection(waypoints, localPosition);

                return intersection;
            }

            function isIntersectionMiddle(intersection, waypoints, treshold) {
                var idx = intersection.index,
                    p = intersection.point,
                    p0, p1, mid, aligned, xDelta, yDelta;

                if (idx <= 0 || intersection.bendpoint) {
                    return false;
                }

                p0 = waypoints[idx - 1];
                p1 = waypoints[idx];
                mid = getMidPoint(p0, p1),
                    aligned = pointsAligned(p0, p1);
                xDelta = Math.abs(p.x - mid.x);
                yDelta = Math.abs(p.y - mid.y);

                return aligned && xDelta <= treshold && yDelta <= treshold;
            }

            function activateBendpointMove(event, connection) {
                var waypoints = connection.waypoints,
                    intersection = getConnectionIntersection(waypoints, event);

                if (!intersection) {
                    return;
                }

                if (isIntersectionMiddle(intersection, waypoints, 10)) {
                    connectionSegmentMove.start(event, connection, intersection.index);
                } else {
                    bendpointMove.start(event, connection, intersection.index, !intersection.bendpoint);
                }
            }

            function bindInteractionEvents(node, eventName, element) {

                domEvent.bind(node, eventName, function (event) {
                    interactionEvents.triggerMouseEvent(eventName, event, element);
                    event.stopPropagation();
                });
            }

            function getBendpointsContainer(element, create) {

                var layer = canvas.getLayer('overlays'),
                    gfx = domQuery('.djs-bendpoints[data-element-id=' + element.id + ']', layer);

                if (!gfx && create) {
                    gfx = svgCreate('g');
                    svgAttr(gfx, { 'data-element-id': element.id });
                    svgClasses(gfx).add('djs-bendpoints');

                    svgAppend(layer, gfx);

                    bindInteractionEvents(gfx, 'mousedown', element);
                    bindInteractionEvents(gfx, 'click', element);
                    bindInteractionEvents(gfx, 'dblclick', element);
                }

                return gfx;
            }

            function createBendpoints(gfx, connection) {
                connection.waypoints.forEach(function (p, idx) {
                    var bendpoint = BendpointUtil.addBendpoint(gfx);

                    svgAppend(gfx, bendpoint);

                    translate(bendpoint, p.x, p.y);
                });

                // add floating bendpoint
                BendpointUtil.addBendpoint(gfx, 'floating');
            }

            function createSegmentDraggers(gfx, connection) {

                var waypoints = connection.waypoints;

                var segmentStart,
                    segmentEnd;

                for (var i = 1; i < waypoints.length; i++) {

                    segmentStart = waypoints[i - 1];
                    segmentEnd = waypoints[i];

                    if (pointsAligned(segmentStart, segmentEnd)) {
                        BendpointUtil.addSegmentDragger(gfx, segmentStart, segmentEnd);
                    }
                }
            }

            function clearBendpoints(gfx) {
                forEach(domQuery.all('.' + BENDPOINT_CLS, gfx), function (node) {
                    svgRemove(node);
                });
            }

            function clearSegmentDraggers(gfx) {
                forEach(domQuery.all('.' + SEGMENT_DRAGGER_CLS, gfx), function (node) {
                    svgRemove(node);
                });
            }

            function addHandles(connection) {

                var gfx = getBendpointsContainer(connection);

                if (!gfx) {
                    gfx = getBendpointsContainer(connection, true);

                    createBendpoints(gfx, connection);
                    createSegmentDraggers(gfx, connection);
                }

                return gfx;
            }

            function updateHandles(connection) {

                var gfx = getBendpointsContainer(connection);

                if (gfx) {
                    clearSegmentDraggers(gfx);
                    clearBendpoints(gfx);
                    createSegmentDraggers(gfx, connection);
                    createBendpoints(gfx, connection);
                }
            }

            eventBus.on('connection.changed', function (event) {
                updateHandles(event.element);
            });

            eventBus.on('connection.remove', function (event) {
                var gfx = getBendpointsContainer(event.element);

                if (gfx) {
                    svgRemove(gfx);
                }
            });

            eventBus.on('element.marker.update', function (event) {

                var element = event.element,
                    bendpointsGfx;

                if (!element.waypoints) {
                    return;
                }

                bendpointsGfx = addHandles(element);

                if (event.add) {
                    svgClasses(bendpointsGfx).add(event.marker);
                } else {
                    svgClasses(bendpointsGfx).remove(event.marker);
                }
            });

            eventBus.on('element.mousemove', function (event) {

                var element = event.element,
                    waypoints = element.waypoints,
                    bendpointsGfx,
                    floating,
                    intersection;

                if (waypoints) {
                    bendpointsGfx = getBendpointsContainer(element, true);
                    floating = domQuery('.floating', bendpointsGfx);

                    if (!floating) {
                        return;
                    }

                    intersection = getConnectionIntersection(waypoints, event.originalEvent);

                    if (intersection) {
                        translate(floating, intersection.point.x, intersection.point.y);
                    }
                }
            });

            eventBus.on('element.mousedown', function (event) {

                var originalEvent = event.originalEvent,
                    element = event.element,
                    waypoints = element.waypoints;

                if (!waypoints) {
                    return;
                }

                activateBendpointMove(originalEvent, element, waypoints);
            });

            eventBus.on('selection.changed', function (event) {
                var newSelection = event.newSelection,
                    primary = newSelection[0];

                if (primary && primary.waypoints) {
                    addHandles(primary);
                }
            });

            eventBus.on('element.hover', function (event) {
                var element = event.element;

                if (element.waypoints) {
                    addHandles(element);
                    interactionEvents.registerEvent(event.gfx, 'mousemove', 'element.mousemove');
                }
            });

            eventBus.on('element.out', function (event) {
                interactionEvents.unregisterEvent(event.gfx, 'mousemove', 'element.mousemove');
            });

            // update bendpoint container data attribute on element ID change
            eventBus.on('element.updateId', function (context) {
                var element = context.element,
                    newId = context.newId;

                if (element.waypoints) {
                    var bendpointContainer = getBendpointsContainer(element);

                    if (bendpointContainer) {
                        svgAttr(bendpointContainer, { 'data-element-id': newId });
                    }
                }
            });

            // API

            this.addHandles = addHandles;
            this.updateHandles = updateHandles;
            this.getBendpointsContainer = getBendpointsContainer;
        }

        Bendpoints.$inject = [
            'eventBus', 'canvas', 'interactionEvents',
            'bendpointMove', 'connectionSegmentMove'
        ];

        module.exports = Bendpoints;

    }, { "../../util/Geometry": 268, "../../util/LineIntersection": 272, "../../util/SvgTransformUtil": 279, "./BendpointUtil": 142, "lodash/collection/forEach": 304, "min-dom/lib/event": 452, "min-dom/lib/query": 454, "tiny-svg/lib/append": 473, "tiny-svg/lib/attr": 475, "tiny-svg/lib/classes": 476, "tiny-svg/lib/create": 479, "tiny-svg/lib/remove": 482 }], 144: [function (require, module, exports) {
        'use strict';

        var Geometry = require('../../util/Geometry'),
            BendpointUtil = require('./BendpointUtil'),
            LayoutUtil = require('../../layout/LayoutUtil');

        var MARKER_CONNECT_HOVER = 'connect-hover',
            MARKER_CONNECT_UPDATING = 'djs-updating';

        var svgClasses = require('tiny-svg/lib/classes'),
            svgRemove = require('tiny-svg/lib/remove');

        var translate = require('../../util/SvgTransformUtil').translate;


        function axisAdd(point, axis, delta) {
            return axisSet(point, axis, point[axis] + delta);
        }

        function axisSet(point, axis, value) {
            return {
                x: (axis === 'x' ? value : point.x),
                y: (axis === 'y' ? value : point.y)
            };
        }

        function axisFenced(position, segmentStart, segmentEnd, axis) {

            var maxValue = Math.max(segmentStart[axis], segmentEnd[axis]),
                minValue = Math.min(segmentStart[axis], segmentEnd[axis]);

            var padding = 20;

            var fencedValue = Math.min(Math.max(minValue + padding, position[axis]), maxValue - padding);

            return axisSet(segmentStart, axis, fencedValue);
        }

        function flipAxis(axis) {
            return axis === 'x' ? 'y' : 'x';
        }

        /**
         * Get the docking point on the given element.
         *
         * Compute a reasonable docking, if non exists.
         *
         * @param  {Point} point
         * @param  {djs.model.Shape} referenceElement
         * @param  {String} moveAxis (x|y)
         *
         * @return {Point}
         */
        function getDocking(point, referenceElement, moveAxis) {

            var referenceMid,
                inverseAxis;

            if (point.original) {
                return point.original;
            } else {
                referenceMid = LayoutUtil.getMid(referenceElement);
                inverseAxis = flipAxis(moveAxis);

                return axisSet(point, inverseAxis, referenceMid[inverseAxis]);
            }
        }

        /**
         * A component that implements moving of bendpoints
         */
        function ConnectionSegmentMove(injector, eventBus, canvas, dragging, graphicsFactory, rules, modeling) {

            // optional connection docking integration
            var connectionDocking = injector.get('connectionDocking', false);


            // API

            this.start = function (event, connection, idx) {

                var context,
                    gfx = canvas.getGraphics(connection),
                    segmentStartIndex = idx - 1,
                    segmentEndIndex = idx,
                    waypoints = connection.waypoints,
                    segmentStart = waypoints[segmentStartIndex],
                    segmentEnd = waypoints[segmentEndIndex],
                    direction,
                    axis;

                direction = Geometry.pointsAligned(segmentStart, segmentEnd);

                // do not move diagonal connection
                if (!direction) {
                    return;
                }

                // the axis where we are going to move things
                axis = direction === 'v' ? 'y' : 'x';

                if (segmentStartIndex === 0) {
                    segmentStart = getDocking(segmentStart, connection.source, axis);
                }

                if (segmentEndIndex === waypoints.length - 1) {
                    segmentEnd = getDocking(segmentEnd, connection.target, axis);
                }

                context = {
                    connection: connection,
                    segmentStartIndex: segmentStartIndex,
                    segmentEndIndex: segmentEndIndex,
                    segmentStart: segmentStart,
                    segmentEnd: segmentEnd,
                    axis: axis
                };

                dragging.init(event, {
                    x: (segmentStart.x + segmentEnd.x) / 2,
                    y: (segmentStart.y + segmentEnd.y) / 2
                }, 'connectionSegment.move', {
                    cursor: axis === 'x' ? 'resize-ew' : 'resize-ns',
                    data: {
                        connection: connection,
                        connectionGfx: gfx,
                        context: context
                    }
                });
            };

            /**
             * Crop connection if connection cropping is provided.
             *
             * @param {Connection} connection
             * @param {Array<Point>} newWaypoints
             *
             * @return {Array<Point>} cropped connection waypoints
             */
            function cropConnection(connection, newWaypoints) {

                // crop connection, if docking service is provided only
                if (!connectionDocking) {
                    return newWaypoints;
                }

                var oldWaypoints = connection.waypoints,
                    croppedWaypoints;

                // temporary set new waypoints
                connection.waypoints = newWaypoints;

                croppedWaypoints = connectionDocking.getCroppedWaypoints(connection);

                // restore old waypoints
                connection.waypoints = oldWaypoints;

                return croppedWaypoints;
            }

            // DRAGGING IMPLEMENTATION

            function redrawConnection(data) {
                graphicsFactory.update('connection', data.connection, data.connectionGfx);
            }

            function updateDragger(context, segmentOffset, event) {

                var newWaypoints = context.newWaypoints,
                    segmentStartIndex = context.segmentStartIndex + segmentOffset,
                    segmentStart = newWaypoints[segmentStartIndex],
                    segmentEndIndex = context.segmentEndIndex + segmentOffset,
                    segmentEnd = newWaypoints[segmentEndIndex],
                    axis = flipAxis(context.axis);

                // make sure the dragger does not move
                // outside the connection
                var draggerPosition = axisFenced(event, segmentStart, segmentEnd, axis);

                // update dragger
                translate(context.draggerGfx, draggerPosition.x, draggerPosition.y);
            }

            /**
             * Filter waypoints for redundant ones (i.e. on the same axis).
             * Returns the filtered waypoints and the offset related to the segment move.
             *
             * @param {Array<Point>} waypoints
             * @param {Integer} segmentStartIndex of moved segment start
             *
             * @return {Object} { filteredWaypoints, segmentOffset }
             */
            function filterRedundantWaypoints(waypoints, segmentStartIndex) {

                var segmentOffset = 0;

                var filteredWaypoints = waypoints.filter(function (r, idx) {
                    if (Geometry.pointsOnLine(waypoints[idx - 1], waypoints[idx + 1], r)) {

                        // remove point and increment offset
                        segmentOffset = idx <= segmentStartIndex ? segmentOffset - 1 : segmentOffset;
                        return false;
                    }

                    // dont remove point
                    return true;
                });

                return {
                    waypoints: filteredWaypoints,
                    segmentOffset: segmentOffset
                };
            }

            eventBus.on('connectionSegment.move.start', function (e) {

                var context = e.context,
                    connection = e.connection,
                    layer = canvas.getLayer('overlays');

                context.originalWaypoints = connection.waypoints.slice();

                // add dragger gfx
                context.draggerGfx = BendpointUtil.addSegmentDragger(layer, context.segmentStart, context.segmentEnd);
                svgClasses(context.draggerGfx).add('djs-dragging');

                canvas.addMarker(connection, MARKER_CONNECT_UPDATING);
            });

            eventBus.on('connectionSegment.move.move', function (e) {

                var context = e.context,
                    connection = context.connection,
                    segmentStartIndex = context.segmentStartIndex,
                    segmentEndIndex = context.segmentEndIndex,
                    segmentStart = context.segmentStart,
                    segmentEnd = context.segmentEnd,
                    axis = context.axis;

                var newWaypoints = context.originalWaypoints.slice(),
                    newSegmentStart = axisAdd(segmentStart, axis, e['d' + axis]),
                    newSegmentEnd = axisAdd(segmentEnd, axis, e['d' + axis]);

                // original waypoint count and added / removed
                // from start waypoint delta. We use the later
                // to retrieve the updated segmentStartIndex / segmentEndIndex
                var waypointCount = newWaypoints.length,
                    segmentOffset = 0;

                // move segment start / end by axis delta
                newWaypoints[segmentStartIndex] = newSegmentStart;
                newWaypoints[segmentEndIndex] = newSegmentEnd;

                var sourceToSegmentOrientation,
                    targetToSegmentOrientation;

                // handle first segment
                if (segmentStartIndex < 2) {
                    sourceToSegmentOrientation = LayoutUtil.getOrientation(connection.source, newSegmentStart);

                    // first bendpoint, remove first segment if intersecting
                    if (segmentStartIndex === 1) {

                        if (sourceToSegmentOrientation === 'intersect') {
                            newWaypoints.shift();
                            newWaypoints[0] = newSegmentStart;
                            segmentOffset--;
                        }
                    }

                    // docking point, add segment if not intersecting anymore
                    else {
                        if (sourceToSegmentOrientation !== 'intersect') {
                            newWaypoints.unshift(segmentStart);
                            segmentOffset++;
                        }
                    }
                }

                // handle last segment
                if (segmentEndIndex > waypointCount - 3) {
                    targetToSegmentOrientation = LayoutUtil.getOrientation(connection.target, newSegmentEnd);

                    // last bendpoint, remove last segment if intersecting
                    if (segmentEndIndex === waypointCount - 2) {

                        if (targetToSegmentOrientation === 'intersect') {
                            newWaypoints.pop();
                            newWaypoints[newWaypoints.length - 1] = newSegmentEnd;
                        }
                    }

                    // last bendpoint, remove last segment if intersecting
                    else {
                        if (targetToSegmentOrientation !== 'intersect') {
                            newWaypoints.push(segmentEnd);
                        }
                    }
                }

                // update connection waypoints
                context.newWaypoints = connection.waypoints = cropConnection(connection, newWaypoints);

                // update dragger position
                updateDragger(context, segmentOffset, e);

                // save segmentOffset in context
                context.newSegmentStartIndex = segmentStartIndex + segmentOffset;

                // redraw connection
                redrawConnection(e);
            });

            eventBus.on('connectionSegment.move.hover', function (e) {

                e.context.hover = e.hover;
                canvas.addMarker(e.hover, MARKER_CONNECT_HOVER);
            });

            eventBus.on([
                'connectionSegment.move.out',
                'connectionSegment.move.cleanup'
            ], function (e) {

                // remove connect marker
                // if it was added
                var hover = e.context.hover;

                if (hover) {
                    canvas.removeMarker(hover, MARKER_CONNECT_HOVER);
                }
            });

            eventBus.on('connectionSegment.move.cleanup', function (e) {

                var context = e.context,
                    connection = context.connection;

                // remove dragger gfx
                if (context.draggerGfx) {
                    svgRemove(context.draggerGfx);
                }

                canvas.removeMarker(connection, MARKER_CONNECT_UPDATING);
            });

            eventBus.on([
                'connectionSegment.move.cancel',
                'connectionSegment.move.end'
            ], function (e) {
                var context = e.context,
                    connection = context.connection;

                connection.waypoints = context.originalWaypoints;

                redrawConnection(e);
            });

            eventBus.on('connectionSegment.move.end', function (e) {

                var context = e.context,
                    connection = context.connection,
                    newWaypoints = context.newWaypoints,
                    newSegmentStartIndex = context.newSegmentStartIndex;

                // ensure we have actual pixel values bendpoint
                // coordinates (important when zoom level was > 1 during move)
                newWaypoints = newWaypoints.map(function (p) {
                    return {
                        original: p.original,
                        x: Math.round(p.x),
                        y: Math.round(p.y)
                    };
                });

                // apply filter redunant waypoints
                var filtered = filterRedundantWaypoints(newWaypoints, newSegmentStartIndex);

                // get filtered waypoints
                var filteredWaypoints = filtered.waypoints,
                    croppedWaypoints = cropConnection(connection, filteredWaypoints),
                    segmentOffset = filtered.segmentOffset;

                var hints = {
                    segmentMove: {
                        segmentStartIndex: context.segmentStartIndex,
                        newSegmentStartIndex: newSegmentStartIndex + segmentOffset
                    }
                };

                modeling.updateWaypoints(connection, croppedWaypoints, hints);
            });
        }

        ConnectionSegmentMove.$inject = [
            'injector', 'eventBus', 'canvas',
            'dragging', 'graphicsFactory', 'rules',
            'modeling'
        ];

        module.exports = ConnectionSegmentMove;

    }, { "../../layout/LayoutUtil": 252, "../../util/Geometry": 268, "../../util/SvgTransformUtil": 279, "./BendpointUtil": 142, "tiny-svg/lib/classes": 476, "tiny-svg/lib/remove": 482 }], 145: [function (require, module, exports) {
        module.exports = {
            __depends__: [require('../dragging'), require('../rules')],
            __init__: ['bendpoints', 'bendpointSnapping'],
            bendpoints: ['type', require('./Bendpoints')],
            bendpointMove: ['type', require('./BendpointMove')],
            connectionSegmentMove: ['type', require('./ConnectionSegmentMove')],
            bendpointSnapping: ['type', require('./BendpointSnapping')]
        };

    }, { "../dragging": 162, "../rules": 227, "./BendpointMove": 140, "./BendpointSnapping": 141, "./Bendpoints": 143, "./ConnectionSegmentMove": 144 }], 146: [function (require, module, exports) {
        'use strict';

        var getElementType = require('../../util/Elements').getType;

        /**
         * Adds change support to the diagram, including
         *
         * <ul>
         *   <li>redrawing shapes and connections on change</li>
         * </ul>
         *
         * @param {EventBus} eventBus
         * @param {Canvas} canvas
         * @param {ElementRegistry} elementRegistry
         * @param {GraphicsFactory} graphicsFactory
         */
        function ChangeSupport(eventBus, canvas, elementRegistry, graphicsFactory) {

            // redraw shapes / connections on change

            eventBus.on('element.changed', function (event) {

                var element = event.element;

                // element might have been deleted and replaced by new element with same ID
                // thus check for parent of element except for root element
                if (element.parent || element === canvas.getRootElement()) {
                    event.gfx = elementRegistry.getGraphics(element);
                }

                // shape + gfx may have been deleted
                if (!event.gfx) {
                    return;
                }

                eventBus.fire(getElementType(element) + '.changed', event);
            });

            eventBus.on('elements.changed', function (event) {

                var elements = event.elements;

                elements.forEach(function (e) {
                    eventBus.fire('element.changed', { element: e });
                });

                graphicsFactory.updateContainments(elements);
            });

            eventBus.on('shape.changed', function (event) {
                graphicsFactory.update('shape', event.element, event.gfx);
            });

            eventBus.on('connection.changed', function (event) {
                graphicsFactory.update('connection', event.element, event.gfx);
            });
        }

        ChangeSupport.$inject = ['eventBus', 'canvas', 'elementRegistry', 'graphicsFactory'];

        module.exports = ChangeSupport;

    }, { "../../util/Elements": 266 }], 147: [function (require, module, exports) {
        module.exports = {
            __init__: ['changeSupport'],
            changeSupport: ['type', require('./ChangeSupport')]
        };
    }, { "./ChangeSupport": 146 }], 148: [function (require, module, exports) {
        'use strict';

        /**
         * A clip board stub
         */
        function Clipboard() { }

        module.exports = Clipboard;


        Clipboard.prototype.get = function () {
            return this._data;
        };

        Clipboard.prototype.set = function (data) {
            this._data = data;
        };

        Clipboard.prototype.clear = function () {
            var data = this._data;

            delete this._data;

            return data;
        };

        Clipboard.prototype.isEmpty = function () {
            return !this._data;
        };
    }, {}], 149: [function (require, module, exports) {
        module.exports = {
            clipboard: ['type', require('./Clipboard')]
        };

    }, { "./Clipboard": 148 }], 150: [function (require, module, exports) {
        'use strict';

        var LayoutUtil = require('../../layout/LayoutUtil');

        var MARKER_OK = 'connect-ok',
            MARKER_NOT_OK = 'connect-not-ok';

        var svgAppend = require('tiny-svg/lib/append'),
            svgAttr = require('tiny-svg/lib/attr'),
            svgCreate = require('tiny-svg/lib/create'),
            svgRemove = require('tiny-svg/lib/remove');


        function Connect(eventBus, dragging, modeling, rules, canvas, graphicsFactory) {

            // TODO(nre): separate UI and events

            // rules

            function canConnect(source, target) {
                return rules.allowed('connection.create', {
                    source: source,
                    target: target
                });
            }


            // layouting

            function crop(start, end, source, target) {

                var sourcePath = graphicsFactory.getShapePath(source),
                    targetPath = target && graphicsFactory.getShapePath(target),
                    connectionPath = graphicsFactory.getConnectionPath({ waypoints: [start, end] });

                start = LayoutUtil.getElementLineIntersection(sourcePath, connectionPath, true) || start;
                end = (target && LayoutUtil.getElementLineIntersection(targetPath, connectionPath, false)) || end;

                return [start, end];
            }


            // event handlers

            eventBus.on('connect.move', function (event) {

                var context = event.context,
                    source = context.source,
                    target = context.target,
                    visual = context.visual,
                    sourcePosition = context.sourcePosition,
                    endPosition,
                    waypoints;

                // update connection visuals during drag

                endPosition = {
                    x: event.x,
                    y: event.y
                };

                waypoints = crop(sourcePosition, endPosition, source, target);

                svgAttr(visual, { 'points': [waypoints[0].x, waypoints[0].y, waypoints[1].x, waypoints[1].y] });
            });

            eventBus.on('connect.hover', function (event) {
                var context = event.context,
                    source = context.source,
                    hover = event.hover,
                    canExecute;

                canExecute = context.canExecute = canConnect(source, hover);

                // simply ignore hover
                if (canExecute === null) {
                    return;
                }

                context.target = hover;

                canvas.addMarker(hover, canExecute ? MARKER_OK : MARKER_NOT_OK);
            });

            eventBus.on(['connect.out', 'connect.cleanup'], function (event) {
                var context = event.context;

                if (context.target) {
                    canvas.removeMarker(context.target, context.canExecute ? MARKER_OK : MARKER_NOT_OK);
                }

                context.target = null;
            });

            eventBus.on('connect.cleanup', function (event) {
                var context = event.context;

                if (context.visual) {
                    svgRemove(context.visual);
                }
            });

            eventBus.on('connect.start', function (event) {
                var context = event.context,
                    visual;

                visual = svgCreate('polyline');
                svgAttr(visual, {
                    'stroke': '#333',
                    'strokeDasharray': [1],
                    'strokeWidth': 2,
                    'pointer-events': 'none'
                });

                svgAppend(canvas.getDefaultLayer(), visual);

                context.visual = visual;
            });

            eventBus.on('connect.end', function (event) {

                var context = event.context,
                    source = context.source,
                    sourcePosition = context.sourcePosition,
                    target = context.target,
                    targetPosition = {
                        x: event.x,
                        y: event.y
                    },
                    canExecute = context.canExecute || canConnect(source, target);

                if (!canExecute) {
                    return false;
                }

                var attrs = null,
                    hints = {
                        connectionStart: sourcePosition,
                        connectionEnd: targetPosition
                    };

                if (typeof canExecute === 'object') {
                    attrs = canExecute;
                }

                modeling.connect(source, target, attrs, hints);
            });


            // API

            /**
             * Start connect operation.
             *
             * @param {DOMEvent} event
             * @param {djs.model.Base} source
             * @param {Point} [sourcePosition]
             * @param {Boolean} [autoActivate=false]
             */
            this.start = function (event, source, sourcePosition, autoActivate) {

                if (typeof sourcePosition !== 'object') {
                    autoActivate = sourcePosition;
                    sourcePosition = LayoutUtil.getMid(source);
                }

                dragging.init(event, 'connect', {
                    autoActivate: autoActivate,
                    data: {
                        shape: source,
                        context: {
                            source: source,
                            sourcePosition: sourcePosition
                        }
                    }
                });
            };
        }

        Connect.$inject = ['eventBus', 'dragging', 'modeling', 'rules', 'canvas', 'graphicsFactory'];

        module.exports = Connect;

    }, { "../../layout/LayoutUtil": 252, "tiny-svg/lib/append": 473, "tiny-svg/lib/attr": 475, "tiny-svg/lib/create": 479, "tiny-svg/lib/remove": 482 }], 151: [function (require, module, exports) {
        module.exports = {
            __depends__: [
                require('../selection'),
                require('../rules'),
                require('../dragging')
            ],
            connect: ['type', require('./Connect')]
        };

    }, { "../dragging": 162, "../rules": 227, "../selection": 233, "./Connect": 150 }], 152: [function (require, module, exports) {
        'use strict';

        var isFunction = require('lodash/lang/isFunction'),
            isArray = require('lodash/lang/isArray'),
            forEach = require('lodash/collection/forEach'),

            domDelegate = require('min-dom/lib/delegate'),
            domEvent = require('min-dom/lib/event'),
            domAttr = require('min-dom/lib/attr'),
            domQuery = require('min-dom/lib/query'),
            domClasses = require('min-dom/lib/classes'),
            domify = require('min-dom/lib/domify');


        var entrySelector = '.entry';


        /**
         * A context pad that displays element specific, contextual actions next
         * to a diagram element.
         *
         * @param {EventBus} eventBus
         * @param {Overlays} overlays
         */
        function ContextPad(eventBus, overlays) {

            this._providers = [];

            this._eventBus = eventBus;
            this._overlays = overlays;

            this._current = null;

            this._init();
        }

        ContextPad.$inject = ['eventBus', 'overlays'];

        module.exports = ContextPad;


        /**
         * Registers events needed for interaction with other components
         */
        ContextPad.prototype._init = function () {

            var eventBus = this._eventBus;

            var self = this;

            eventBus.on('selection.changed', function (e) {

                var selection = e.newSelection;

                if (selection.length === 1) {
                    self.open(selection[0]);
                } else {
                    self.close();
                }
            });

            eventBus.on('elements.delete', function (event) {
                var elements = event.elements;

                forEach(elements, function (e) {
                    if (self.isOpen(e)) {
                        self.close();
                    }
                });
            });

            eventBus.on('element.changed', function (event) {
                var element = event.element,
                    current = self._current;

                // force reopen if element for which we are currently opened changed
                if (current && current.element === element) {
                    self.open(element, true);
                }
            });
        };


        /**
         * Register a provider with the context pad
         *
         * @param  {ContextPadProvider} provider
         */
        ContextPad.prototype.registerProvider = function (provider) {
            this._providers.push(provider);
        };


        /**
         * Returns the context pad entries for a given element
         *
         * @param {djs.element.Base} element
         *
         * @return {Array<ContextPadEntryDescriptor>} list of entries
         */
        ContextPad.prototype.getEntries = function (element) {
            var entries = {};

            // loop through all providers and their entries.
            // group entries by id so that overriding an entry is possible
            forEach(this._providers, function (provider) {
                var e = provider.getContextPadEntries(element);

                forEach(e, function (entry, id) {
                    entries[id] = entry;
                });
            });

            return entries;
        };


        /**
         * Trigger an action available on the opened context pad
         *
         * @param  {String} action
         * @param  {Event} event
         * @param  {Boolean} [autoActivate=false]
         */
        ContextPad.prototype.trigger = function (action, event, autoActivate) {

            var element = this._current.element,
                entries = this._current.entries,
                entry,
                handler,
                originalEvent,
                button = event.delegateTarget || event.target;

            if (!button) {
                return event.preventDefault();
            }

            entry = entries[domAttr(button, 'data-action')];
            handler = entry.action;

            originalEvent = event.originalEvent || event;

            // simple action (via callback function)
            if (isFunction(handler)) {
                if (action === 'click') {
                    return handler(originalEvent, element, autoActivate);
                }
            } else {
                if (handler[action]) {
                    return handler[action](originalEvent, element, autoActivate);
                }
            }

            // silence other actions
            event.preventDefault();
        };


        /**
         * Open the context pad for the given element
         *
         * @param {djs.model.Base} element
         * @param {Boolean} force if true, force reopening the context pad
         */
        ContextPad.prototype.open = function (element, force) {
            if (!force && this.isOpen(element)) {
                return;
            }

            this.close();
            this._updateAndOpen(element);
        };


        ContextPad.prototype._updateAndOpen = function (element) {

            var entries = this.getEntries(element),
                pad = this.getPad(element),
                html = pad.html;

            forEach(entries, function (entry, id) {
                var grouping = entry.group || 'default',
                    control = domify(entry.html || '<div class="entry" draggable="true"></div>'),
                    container;

                domAttr(control, 'data-action', id);

                container = domQuery('[data-group=' + grouping + ']', html);
                if (!container) {
                    container = domify('<div class="group" data-group="' + grouping + '"></div>');
                    html.appendChild(container);
                }

                container.appendChild(control);

                if (entry.className) {
                    addClasses(control, entry.className);
                }

                if (entry.title) {
                    domAttr(control, 'title', entry.title);
                }

                if (entry.imageUrl) {
                    control.appendChild(domify('<img src="' + entry.imageUrl + '">'));
                }
            });

            domClasses(html).add('open');

            this._current = {
                element: element,
                pad: pad,
                entries: entries
            };

            this._eventBus.fire('contextPad.open', { current: this._current });
        };


        ContextPad.prototype.getPad = function (element) {
            if (this.isOpen()) {
                return this._current.pad;
            }

            var self = this;

            var overlays = this._overlays;

            var html = domify('<div class="djs-context-pad"></div>');

            domDelegate.bind(html, entrySelector, 'click', function (event) {
                self.trigger('click', event);
            });

            domDelegate.bind(html, entrySelector, 'dragstart', function (event) {
                self.trigger('dragstart', event);
            });

            // stop propagation of mouse events
            domEvent.bind(html, 'mousedown', function (event) {
                event.stopPropagation();
            });

            this._overlayId = overlays.add(element, 'context-pad', {
                position: {
                    right: -9,
                    top: -6
                },
                html: html
            });

            var pad = overlays.get(this._overlayId);

            this._eventBus.fire('contextPad.create', { element: element, pad: pad });

            return pad;
        };


        /**
         * Close the context pad
         */
        ContextPad.prototype.close = function () {
            if (!this.isOpen()) {
                return;
            }

            this._overlays.remove(this._overlayId);

            this._overlayId = null;

            this._eventBus.fire('contextPad.close', { current: this._current });

            this._current = null;
        };

        /**
         * Check if pad is open. If element is given, will check
         * if pad is opened with given element.
         *
         * @param {Element} element
         * @return {Boolean}
         */
        ContextPad.prototype.isOpen = function (element) {
            return !!this._current && (!element ? true : this._current.element === element);
        };




        ////////// helpers /////////////////////////////

        function addClasses(element, classNames) {

            var classes = domClasses(element);

            var actualClassNames = isArray(classNames) ? classNames : classNames.split(/\s+/g);
            actualClassNames.forEach(function (cls) {
                classes.add(cls);
            });
        }
    }, { "lodash/collection/forEach": 304, "lodash/lang/isArray": 424, "lodash/lang/isFunction": 425, "min-dom/lib/attr": 446, "min-dom/lib/classes": 447, "min-dom/lib/delegate": 450, "min-dom/lib/domify": 451, "min-dom/lib/event": 452, "min-dom/lib/query": 454 }], 153: [function (require, module, exports) {
        module.exports = {
            __depends__: [
                require('../interaction-events'),
                require('../overlays')
            ],
            contextPad: ['type', require('./ContextPad')]
        };
    }, { "../interaction-events": 170, "../overlays": 211, "./ContextPad": 152 }], 154: [function (require, module, exports) {
        'use strict';

        var isArray = require('lodash/lang/isArray'),
            forEach = require('lodash/collection/forEach'),
            map = require('lodash/collection/map'),
            find = require('lodash/collection/find'),
            findIndex = require('lodash/array/findIndex'),
            sortBy = require('lodash/collection/sortBy'),
            reduce = require('lodash/collection/reduce');

        var getBBox = require('../../util/Elements').getBBox;

        var PositionUtil = require('../../util/PositionUtil');

        var CopyPasteUtil = require('../../util/CopyPasteUtil'),
            ElementsUtil = require('../../util/Elements');



        function CopyPaste(eventBus, modeling, elementFactory, rules, clipboard, canvas) {
            this._eventBus = eventBus;
            this._modeling = modeling;
            this._elementFactory = elementFactory;
            this._rules = rules;
            this._canvas = canvas;

            this._clipboard = clipboard;

            this._descriptors = [];


            // Element creation priorities:
            // - 1: Independent shapes
            // - 2: Attached shapes
            // - 3: Connections
            // - 4: labels
            this.registerDescriptor(function (element, descriptor) {
                // Base priority
                descriptor.priority = 1;

                descriptor.id = element.id;

                if (element.parent) {
                    descriptor.parent = element.parent.id;
                }

                if (element.labelTarget) {
                    // Labels priority
                    descriptor.priority = 4;
                    descriptor.labelTarget = element.labelTarget.id;
                }

                if (element.host) {
                    // Attached shapes priority
                    descriptor.priority = 2;
                    descriptor.host = element.host.id;
                }

                if (typeof element.x === 'number') {
                    descriptor.x = element.x;
                    descriptor.y = element.y;
                }

                if (element.width) {
                    descriptor.width = element.width;
                    descriptor.height = element.height;
                }

                if (element.waypoints) {
                    // Connections priority
                    descriptor.priority = 3;
                    descriptor.waypoints = [];

                    forEach(element.waypoints, function (waypoint) {
                        var wp = {
                            x: waypoint.x,
                            y: waypoint.y
                        };

                        if (waypoint.original) {
                            wp.original = {
                                x: waypoint.original.x,
                                y: waypoint.original.y
                            };
                        }

                        descriptor.waypoints.push(wp);
                    });
                }

                if (element.source && element.target) {
                    descriptor.source = element.source.id;
                    descriptor.target = element.target.id;
                }

                return descriptor;
            });
        }

        CopyPaste.$inject = [
            'eventBus',
            'modeling',
            'elementFactory',
            'rules',
            'clipboard',
            'canvas'
        ];

        module.exports = CopyPaste;

        /**
         * Copy a number of elements.
         *
         * @param {djs.model.Base} selectedElements
         *
         * @return {Object} the copied tree
         */
        CopyPaste.prototype.copy = function (selectedElements) {
            var clipboard = this._clipboard,
                tree, bbox;

            if (!isArray(selectedElements)) {
                selectedElements = selectedElements ? [selectedElements] : [];
            }

            if (!selectedElements.length) {
                return;
            }

            tree = this.createTree(selectedElements);

            bbox = this._bbox = PositionUtil.center(getBBox(tree.allShapes));

            // not needed after computing the center position of the copied elements
            delete tree.allShapes;

            forEach(tree, function (elements) {

                forEach(elements, function (element) {
                    var delta, labelTarget;

                    // set label's relative position to their label target
                    if (element.labelTarget) {
                        labelTarget = find(elements, { id: element.labelTarget });

                        // just grab the delta from the first waypoint
                        if (labelTarget.waypoints) {
                            delta = PositionUtil.delta(element, labelTarget.waypoints[0]);
                        } else {
                            delta = PositionUtil.delta(element, labelTarget);
                        }

                    } else
                        if (element.priority === 3) {
                            // connections have priority 3
                            delta = [];

                            forEach(element.waypoints, function (waypoint) {
                                var waypointDelta = PositionUtil.delta(waypoint, bbox);

                                delta.push(waypointDelta);
                            }, this);
                        } else {
                            delta = PositionUtil.delta(element, bbox);
                        }

                    element.delta = delta;
                });
            });

            this._eventBus.fire('elements.copy', { context: { tree: tree } });

            // if tree is empty, means that nothing can be or is allowed to be copied
            if (Object.keys(tree).length === 0) {
                clipboard.clear();
            } else {
                clipboard.set(tree);
            }

            this._eventBus.fire('elements.copied', { context: { tree: tree } });

            return tree;
        };


        // Allow pasting under the cursor
        CopyPaste.prototype.paste = function (context) {
            var clipboard = this._clipboard,
                modeling = this._modeling,
                eventBus = this._eventBus,
                rules = this._rules;

            var tree = clipboard.get(),
                topParent = context.element,
                position = context.point,
                newTree, canPaste;

            if (clipboard.isEmpty()) {
                return;
            }

            newTree = reduce(tree, function (pasteTree, elements, depthStr) {
                var depth = parseInt(depthStr, 10);

                if (isNaN(depth)) {
                    return pasteTree;
                }

                pasteTree[depth] = elements;

                return pasteTree;
            }, {}, this);


            canPaste = rules.allowed('elements.paste', {
                tree: newTree,
                target: topParent
            });

            if (!canPaste) {
                eventBus.fire('elements.paste.rejected', {
                    context: {
                        tree: newTree,
                        position: position,
                        target: topParent
                    }
                });

                return;
            }

            modeling.pasteElements(newTree, topParent, position);
        };


        CopyPaste.prototype._computeDelta = function (elements, element) {
            var bbox = this._bbox,
                delta = {};

            // set label's relative position to their label target
            if (element.labelTarget) {
                return PositionUtil.delta(element, element.labelTarget);
            }

            // connections have prority 3
            if (element.priority === 3) {
                delta = [];

                forEach(element.waypoints, function (waypoint) {
                    var waypointDelta = PositionUtil.delta(waypoint, bbox);

                    delta.push(waypointDelta);
                }, this);
            } else {
                delta = PositionUtil.delta(element, bbox);
            }

            return delta;
        };


        /**
         * Checks if the element in question has a relations to other elements.
         * Possible dependants: connections, labels, attachers
         *
         * @param  {Array} elements
         * @param  {Object} element
         *
         * @return {Boolean}
         */
        CopyPaste.prototype.hasRelations = function (elements, element) {
            var source, target, labelTarget;

            if (element.waypoints) {
                source = find(elements, { id: element.source.id });
                target = find(elements, { id: element.target.id });

                if (!source || !target) {
                    return false;
                }
            }

            if (element.labelTarget) {
                labelTarget = find(elements, { id: element.labelTarget.id });

                if (!labelTarget) {
                    return false;
                }
            }

            return true;
        };


        CopyPaste.prototype.registerDescriptor = function (descriptor) {
            if (typeof descriptor !== 'function') {
                throw new Error('the descriptor must be a function');
            }

            if (this._descriptors.indexOf(descriptor) !== -1) {
                throw new Error('this descriptor is already registered');
            }

            this._descriptors.push(descriptor);
        };


        CopyPaste.prototype._executeDescriptors = function (data) {
            if (!data.descriptor) {
                data.descriptor = {};
            }

            forEach(this._descriptors, function (descriptor) {
                data.descriptor = descriptor(data.element, data.descriptor);
            });

            return data;
        };

        /**
         * Creates a tree like structure from an arbitrary collection of elements
         *
         * @example
         * tree: {
         *	0: [
         *		{ id: 'shape_12da', priority: 1, ... },
         *		{ id: 'shape_01bj', priority: 1, ... },
         *		{ id: 'connection_79fa', source: 'shape_12da', target: 'shape_01bj', priority: 3, ... },
         *	],
         *	1: [ ... ]
         * };
         *
         * @param  {Array} elements
         * @return {Object}
         */
        CopyPaste.prototype.createTree = function (elements) {
            var rules = this._rules;

            var tree = {},
                includedElements = [],
                _elements;

            var topLevel = CopyPasteUtil.getTopLevel(elements);

            tree.allShapes = [];

            function canCopy(collection, element) {
                return rules.allowed('element.copy', {
                    collection: collection,
                    element: element
                });
            }

            function includeElement(data) {
                var idx = findIndex(includedElements, { element: data.element }),
                    element;

                if (idx !== -1) {
                    element = includedElements[idx];
                } else {
                    return includedElements.push(data);
                }

                // makes sure that it has the correct depth
                if (element.depth < data.depth) {
                    includedElements.splice(idx, 1);

                    includedElements.push(data);
                }
            }


            ElementsUtil.eachElement(topLevel, function (element, i, depth) {
                var nestedChildren = element.children;

                // don't add labels directly
                if (element.labelTarget) {
                    return;
                }

                function getNested(lists) {
                    forEach(lists, function (list) {
                        if (list && list.length) {

                            forEach(list, function (elem) {
                                // fetch element's label
                                if (elem.label) {
                                    includeElement({
                                        element: elem.label,
                                        depth: depth
                                    });
                                }

                                includeElement({
                                    element: elem,
                                    depth: depth
                                });
                            });
                        }
                    });
                }

                // fetch element's label
                if (element.label) {
                    includeElement({
                        element: element.label,
                        depth: depth
                    });
                }

                getNested([element.attachers, element.incoming, element.outgoing]);

                includeElement({
                    element: element,
                    depth: depth
                });

                if (nestedChildren) {
                    return nestedChildren;
                }
            });

            includedElements = map(includedElements, function (data) {
                // this is where other registered descriptors hook in
                return this._executeDescriptors(data);
            }, this);

            // order the elements to check if the ones dependant on others (by relationship)
            // can be copied. f.ex: label needs it's label target
            includedElements = sortBy(includedElements, function (data) {
                return data.descriptor.priority;
            });

            _elements = map(includedElements, function (data) {
                return data.element;
            });

            forEach(includedElements, function (data) {
                var depth = data.depth;

                if (!this.hasRelations(tree.allShapes, data.element)) {
                    return;
                }

                if (!canCopy(_elements, data.element)) {
                    return;
                }

                tree.allShapes.push(data.element);

                // create depth branches
                if (!tree[depth]) {
                    tree[depth] = [];
                }

                tree[depth].push(data.descriptor);
            }, this);

            return tree;
        };

    }, { "../../util/CopyPasteUtil": 264, "../../util/Elements": 266, "../../util/PositionUtil": 276, "lodash/array/findIndex": 291, "lodash/collection/find": 303, "lodash/collection/forEach": 304, "lodash/collection/map": 306, "lodash/collection/reduce": 307, "lodash/collection/sortBy": 311, "lodash/lang/isArray": 424 }], 155: [function (require, module, exports) {
        module.exports = {
            __depends__: [
                require('../clipboard'),
                require('../rules'),
                require('../mouse-tracking')
            ],
            __init__: ['copyPaste'],
            copyPaste: ['type', require('./CopyPaste')]
        };

    }, { "../clipboard": 149, "../mouse-tracking": 203, "../rules": 227, "./CopyPaste": 154 }], 156: [function (require, module, exports) {
        'use strict';

        var LOW_PRIORITY = 750;

        var MARKER_OK = 'drop-ok',
            MARKER_NOT_OK = 'drop-not-ok',
            MARKER_ATTACH = 'attach-ok',
            MARKER_NEW_PARENT = 'new-parent';

        var svgAppend = require('tiny-svg/lib/append'),
            svgAttr = require('tiny-svg/lib/attr'),
            svgClasses = require('tiny-svg/lib/classes'),
            svgCreate = require('tiny-svg/lib/create'),
            svgRemove = require('tiny-svg/lib/remove');

        var translate = require('../../util/SvgTransformUtil').translate;


        function Create(eventBus, dragging, rules, modeling, canvas, styles, graphicsFactory) {

            // rules

            function canCreate(shape, target, source, position) {

                if (source) {
                    return rules.allowed('shape.append', {
                        source: source,
                        shape: shape,
                        target: target,
                        position: position
                    });
                } else {
                    return rules.allowed('shape.create', {
                        shape: shape,
                        target: target,
                        position: position
                    });
                }
            }


            /** set drop marker on an element */
            function setMarker(element, marker) {

                [MARKER_ATTACH, MARKER_OK, MARKER_NOT_OK, MARKER_NEW_PARENT].forEach(function (m) {

                    if (m === marker) {
                        canvas.addMarker(element, m);
                    } else {
                        canvas.removeMarker(element, m);
                    }
                });
            }


            // visual helpers

            function createVisual(shape) {
                var group, preview, visual;

                group = svgCreate('g');
                svgAttr(group, styles.cls('djs-drag-group', ['no-events']));

                svgAppend(canvas.getDefaultLayer(), group);

                preview = svgCreate('g');
                svgClasses(preview).add('djs-dragger');

                svgAppend(group, preview);

                translate(preview, shape.width / -2, shape.height / -2);

                var visualGroup = svgCreate('g');
                svgClasses(visualGroup).add('djs-visual');

                svgAppend(preview, visualGroup);

                visual = visualGroup;

                // hijack renderer to draw preview
                graphicsFactory.drawShape(visual, shape);

                return group;
            }


            // event handlers

            eventBus.on('create.move', function (event) {

                var context = event.context,
                    hover = event.hover,
                    canExecute;

                var position = {
                    x: event.x,
                    y: event.y
                };

                canExecute = context.canExecute = hover && canCreate(context.shape, hover, context.source, position);

                // ignore hover visually if canExecute is null
                if (hover && canExecute !== null) {
                    context.target = hover;

                    if (canExecute === 'attach') {
                        setMarker(hover, MARKER_ATTACH);
                    } else {
                        setMarker(hover, context.canExecute ? MARKER_NEW_PARENT : MARKER_NOT_OK);
                    }
                }
            });

            eventBus.on('create.move', LOW_PRIORITY, function (event) {

                var context = event.context,
                    shape = context.shape,
                    visual = context.visual;

                // lazy init drag visual once we received the first real
                // drag move event (this allows us to get the proper canvas local coordinates)
                if (!visual) {
                    visual = context.visual = createVisual(shape);
                }

                translate(visual, event.x, event.y);
            });


            eventBus.on(['create.end', 'create.out', 'create.cleanup'], function (event) {
                var context = event.context,
                    target = context.target;

                if (target) {
                    setMarker(target, null);
                }
            });

            eventBus.on('create.end', function (event) {
                var context = event.context,
                    source = context.source,
                    shape = context.shape,
                    target = context.target,
                    canExecute = context.canExecute,
                    isAttach,
                    position = {
                        x: event.x,
                        y: event.y
                    };

                if (!canExecute) {
                    return false;
                }

                if (source) {
                    shape = modeling.appendShape(source, shape, position, target);
                } else {
                    isAttach = canExecute === 'attach';

                    shape = modeling.createShape(shape, position, target, isAttach);
                }

                // make sure we provide the actual attached
                // shape with the context so that selection and
                // other components can use it right after the create
                // operation ends
                context.shape = shape;
            });


            eventBus.on('create.cleanup', function (event) {
                var context = event.context;

                if (context.visual) {
                    svgRemove(context.visual);
                }
            });

            // API

            this.start = function (event, shape, source) {

                dragging.init(event, 'create', {
                    cursor: 'grabbing',
                    autoActivate: true,
                    data: {
                        shape: shape,
                        context: {
                            shape: shape,
                            source: source
                        }
                    }
                });
            };
        }

        Create.$inject = ['eventBus', 'dragging', 'rules', 'modeling', 'canvas', 'styles', 'graphicsFactory'];

        module.exports = Create;

    }, { "../../util/SvgTransformUtil": 279, "tiny-svg/lib/append": 473, "tiny-svg/lib/attr": 475, "tiny-svg/lib/classes": 476, "tiny-svg/lib/create": 479, "tiny-svg/lib/remove": 482 }], 157: [function (require, module, exports) {
        module.exports = {
            __depends__: [
                require('../dragging'),
                require('../selection'),
                require('../rules')
            ],
            create: ['type', require('./Create')]
        };

    }, { "../dragging": 162, "../rules": 227, "../selection": 233, "./Create": 156 }], 158: [function (require, module, exports) {
        'use strict';

        var sortBy = require('lodash/collection/sortBy'),
            forEach = require('lodash/collection/forEach'),
            filter = require('lodash/collection/filter');

        var AXIS_DIMENSIONS = {
            horizontal: ['x', 'width'],
            vertical: ['y', 'height']
        };

        var THRESHOLD = 5;

        /**
         * Groups and filters elements and then trigger even distribution.
         */
        function DistributeElements(modeling) {
            this._modeling = modeling;

            this._filters = [];

            // register filter for filtering big elements
            this.registerFilter(function (elements, axis, dimension) {
                var elementsSize = 0,
                    numOfShapes = 0,
                    avgDimension;

                forEach(elements, function (element) {
                    if (element.waypoints || element.labelTarget) {
                        return;
                    }

                    elementsSize += element[dimension];

                    numOfShapes += 1;
                });

                avgDimension = Math.round(elementsSize / numOfShapes);

                return filter(elements, function (element) {
                    return element[dimension] < (avgDimension + 50);
                });
            });

        }

        module.exports = DistributeElements;

        DistributeElements.$inject = ['modeling'];


        /**
         * Registers filter functions that allow external parties to filter
         * out certain elements.
         *
         * @param  {Function} filterFn
         */
        DistributeElements.prototype.registerFilter = function (filterFn) {
            if (typeof filterFn !== 'function') {
                throw new Error('the filter has to be a function');
            }

            this._filters.push(filterFn);
        };

        /**
         * Distributes the elements with a given orientation
         *
         * @param  {Array} elements    [description]
         * @param  {String} orientation [description]
         */
        DistributeElements.prototype.trigger = function (elements, orientation) {
            var modeling = this._modeling;

            var groups,
                distributableElements;

            if (elements.length < 3) {
                return;
            }

            this._setOrientation(orientation);

            distributableElements = this._filterElements(elements);

            groups = this._createGroups(distributableElements);

            // nothing to distribute
            if (groups.length <= 2) {
                return;
            }

            modeling.distributeElements(groups, this._axis, this._dimension);

            return groups;
        };

        /**
         * Filters the elements with provided filters by external parties
         *
         * @param  {Array[Elements]} elements
         *
         * @return {Array[Elements]}
         */
        DistributeElements.prototype._filterElements = function (elements) {
            var filters = this._filters,
                axis = this._axis,
                dimension = this._dimension,
                distributableElements = [].concat(elements);

            if (!filters.length) {
                return elements;
            }

            forEach(filters, function (filterFn) {
                distributableElements = filterFn(distributableElements, axis, dimension);
            });

            return distributableElements;
        };


        /**
         * Create range (min, max) groups. Also tries to group elements
         * together that share the same range.
         *
         * @example
         * 	var distributableElements = [
         * 		{
         * 			range: {
         * 				min: 100,
         * 				max: 200
         * 			},
         * 			elements: [ { id: 'shape1', .. }]
         * 		}
         * 	]
         *
         * @param  {Array} elements
         *
         * @return {Array[Objects]}
         */
        DistributeElements.prototype._createGroups = function (elements) {
            var rangeGroups = [],
                axis = this._axis,
                dimension = this._dimension;

            if (!axis) {
                throw new Error('must have a defined "axis" and "dimension"');
            }

            // sort by 'left->right' or 'top->bottom'
            var sortedElements = sortBy(elements, axis);

            forEach(sortedElements, function (element, idx) {
                var elementRange = this._findRange(element, axis, dimension),
                    range;

                var previous = rangeGroups[rangeGroups.length - 1];

                if (previous && this._hasIntersection(previous.range, elementRange)) {
                    rangeGroups[rangeGroups.length - 1].elements.push(element);
                } else {
                    range = { range: elementRange, elements: [element] };

                    rangeGroups.push(range);
                }
            }, this);

            return rangeGroups;
        };


        /**
         * Maps a direction to the according axis and dimension
         *
         * @param  {String} direction 'horizontal' or 'vertical'
         */
        DistributeElements.prototype._setOrientation = function (direction) {
            var orientation = AXIS_DIMENSIONS[direction];

            this._axis = orientation[0];
            this._dimension = orientation[1];
        };


        /**
         * Checks if the two ranges intercept each other
         *
         * @param  {Object} rangeA {min, max}
         * @param  {Object} rangeB {min, max}
         *
         * @return {Boolean}
         */
        DistributeElements.prototype._hasIntersection = function (rangeA, rangeB) {
            return Math.max(rangeA.min, rangeA.max) >= Math.min(rangeB.min, rangeB.max) &&
                Math.min(rangeA.min, rangeA.max) <= Math.max(rangeB.min, rangeB.max);
        };


        /**
         * Returns the min and max values for an element
         *
         * @param  {[type]} element   [description]
         * @param  {[type]} axis      [description]
         * @param  {[type]} dimension [description]
         *
         * @return {[type]}           [description]
         */
        DistributeElements.prototype._findRange = function (element) {
            var axis = element[this._axis],
                dimension = element[this._dimension];

            return {
                min: axis + THRESHOLD,
                max: axis + dimension - THRESHOLD
            };
        };

    }, { "lodash/collection/filter": 302, "lodash/collection/forEach": 304, "lodash/collection/sortBy": 311 }], 159: [function (require, module, exports) {
        'use strict';

        module.exports = {
            __init__: ['distributeElements'],
            distributeElements: ['type', require('./DistributeElements')]
        };

    }, { "./DistributeElements": 158 }], 160: [function (require, module, exports) {
        'use strict';

        /* global TouchEvent */

        var round = Math.round;

        var assign = require('lodash/object/assign');

        var domEvent = require('min-dom/lib/event'),
            Event = require('../../util/Event'),
            ClickTrap = require('../../util/ClickTrap'),
            Cursor = require('../../util/Cursor');

        var EventBusEvent = require('../../core/EventBus').Event;

        var DRAG_ACTIVE_CLS = 'djs-drag-active';


        function suppressEvent(event) {
            if (event instanceof MouseEvent) {
                Event.stopEvent(event, true);
            } else {
                Event.preventDefault(event);
            }
        }

        function getLength(point) {
            return Math.sqrt(Math.pow(point.x, 2) + Math.pow(point.y, 2));
        }

        function substract(p1, p2) {
            return {
                x: p1.x - p2.x,
                y: p1.y - p2.y
            };
        }

        /**
         * A helper that fires canvas localized drag events and realizes
         * the general "drag-and-drop" look and feel.
         *
         * Calling {@link Dragging#activate} activates dragging on a canvas.
         *
         * It provides the following:
         *
         *   * emits life cycle events, namespaced with a prefix assigned
         *     during dragging activation
         *   * sets and restores the cursor
         *   * sets and restores the selection
         *   * ensures there can be only one drag operation active at a time
         *
         * Dragging may be canceled manually by calling {@link Dragging#cancel}
         * or by pressing ESC.
         *
         *
         * ## Life-cycle events
         *
         * Dragging can be in three different states, off, initialized
         * and active.
         *
         * (1) off: no dragging operation is in progress
         * (2) initialized: a new drag operation got initialized but not yet
         *                  started (i.e. because of no initial move)
         * (3) started: dragging is in progress
         *
         * Eventually dragging will be off again after a drag operation has
         * been ended or canceled via user click or ESC key press.
         *
         * To indicate transitions between these states dragging emits generic
         * life-cycle events with the `drag.` prefix _and_ events namespaced
         * to a prefix choosen by a user during drag initialization.
         *
         * The following events are emitted (appropriately prefixed) via
         * the {@link EventBus}.
         *
         * * `init`
         * * `start`
         * * `move`
         * * `end`
         * * `ended` (dragging already in off state)
         * * `cancel` (only if previously started)
         * * `canceled` (dragging already in off state, only if previously started)
         * * `cleanup`
         *
         *
         * @example
         *
         * function MyDragComponent(eventBus, dragging) {
         *
         *   eventBus.on('mydrag.start', function(event) {
         *     console.log('yes, we start dragging');
         *   });
         *
         *   eventBus.on('mydrag.move', function(event) {
         *     console.log('canvas local coordinates', event.x, event.y, event.dx, event.dy);
         *
         *     // local drag data is passed with the event
         *     event.context.foo; // "BAR"
         *
         *     // the original mouse event, too
         *     event.originalEvent; // MouseEvent(...)
         *   });
         *
         *   eventBus.on('element.click', function(event) {
         *     dragging.init(event, 'mydrag', {
         *       cursor: 'grabbing',
         *       data: {
         *         context: {
         *           foo: "BAR"
         *         }
         *       }
         *     });
         *   });
         * }
         */
        function Dragging(eventBus, canvas, selection) {

            var defaultOptions = {
                threshold: 5,
                trapClick: true
            };

            // the currently active drag operation
            // dragging is active as soon as this context exists.
            //
            // it is visually _active_ only when a context.active flag is set to true.
            var context;

            /* convert a global event into local coordinates */
            function toLocalPoint(globalPosition) {

                var viewbox = canvas.viewbox();

                var clientRect = canvas._container.getBoundingClientRect();

                return {
                    x: viewbox.x + round((globalPosition.x - clientRect.left) / viewbox.scale),
                    y: viewbox.y + round((globalPosition.y - clientRect.top) / viewbox.scale)
                };
            }

            // helpers

            function fire(type, dragContext) {
                dragContext = dragContext || context;

                var event = assign(new EventBusEvent(), dragContext.payload, dragContext.data);

                // default integration
                if (eventBus.fire('drag.' + type, event) === false) {
                    return false;
                }

                return eventBus.fire(dragContext.prefix + '.' + type, event);
            }

            // event listeners

            function move(event, activate) {
                var payload = context.payload,
                    displacement = context.displacement;

                var globalStart = context.globalStart,
                    globalCurrent = Event.toPoint(event),
                    globalDelta = substract(globalCurrent, globalStart);

                var localStart = context.localStart,
                    localCurrent = toLocalPoint(globalCurrent),
                    localDelta = substract(localCurrent, localStart);

                // activate context explicitly or once threshold is reached
                if (!context.active && (activate || getLength(globalDelta) > context.threshold)) {

                    // fire start event with original
                    // starting coordinates

                    assign(payload, {
                        x: localStart.x + displacement.x,
                        y: localStart.y + displacement.y,
                        dx: 0,
                        dy: 0
                    }, { originalEvent: event });

                    if (false === fire('start')) {
                        return cancel();
                    }

                    context.active = true;

                    // unset selection and remember old selection
                    // the previous (old) selection will always passed
                    // with the event via the event.previousSelection property
                    if (!context.keepSelection) {
                        payload.previousSelection = selection.get();
                        selection.select(null);
                    }

                    // allow custom cursor
                    if (context.cursor) {
                        Cursor.set(context.cursor);
                    }

                    // indicate dragging via marker on root element
                    canvas.addMarker(canvas.getRootElement(), DRAG_ACTIVE_CLS);
                }

                suppressEvent(event);

                if (context.active) {

                    // update payload with actual coordinates
                    assign(payload, {
                        x: localCurrent.x + displacement.x,
                        y: localCurrent.y + displacement.y,
                        dx: localDelta.x,
                        dy: localDelta.y
                    }, { originalEvent: event });

                    // emit move event
                    fire('move');
                }
            }

            function end(event) {
                var previousContext,
                    returnValue = true;

                if (context.active) {

                    if (event) {
                        context.payload.originalEvent = event;

                        // suppress original event (click, ...)
                        // because we just ended a drag operation
                        suppressEvent(event);
                    }

                    // implementations may stop restoring the
                    // original state (selections, ...) by preventing the
                    // end events default action
                    returnValue = fire('end');
                }

                if (returnValue === false) {
                    fire('rejected');
                }

                previousContext = cleanup(returnValue !== true);

                // last event to be fired when all drag operations are done
                // at this point in time no drag operation is in progress anymore
                fire('ended', previousContext);
            }


            // cancel active drag operation if the user presses
            // the ESC key on the keyboard

            function checkCancel(event) {

                if (event.which === 27) {
                    event.preventDefault();

                    cancel();
                }
            }


            // prevent ghost click that might occur after a finished
            // drag and drop session

            function trapClickAndEnd(event) {

                var untrap;

                // trap the click in case we are part of an active
                // drag operation. This will effectively prevent
                // the ghost click that cannot be canceled otherwise.
                if (context.active) {
                    untrap = ClickTrap.install();
                    setTimeout(untrap, 400);
                }

                end(event);
            }

            function trapTouch(event) {
                move(event);
            }

            // update the drag events hover (djs.model.Base) and hoverGfx (Snap<SVGElement>)
            // properties during hover and out and fire {prefix}.hover and {prefix}.out properties
            // respectively

            function hover(event) {
                var payload = context.payload;

                payload.hoverGfx = event.gfx;
                payload.hover = event.element;

                fire('hover');
            }

            function out(event) {
                fire('out');

                var payload = context.payload;

                payload.hoverGfx = null;
                payload.hover = null;
            }


            // life-cycle methods

            function cancel(restore) {
                var previousContext;

                if (!context) {
                    return;
                }

                var wasActive = context.active;

                if (wasActive) {
                    fire('cancel');
                }

                previousContext = cleanup(restore);

                if (wasActive) {
                    // last event to be fired when all drag operations are done
                    // at this point in time no drag operation is in progress anymore
                    fire('canceled', previousContext);
                }
            }

            function cleanup(restore) {
                var previousContext,
                    endDrag;

                fire('cleanup');

                // reset cursor
                Cursor.unset();

                if (context.trapClick) {
                    endDrag = trapClickAndEnd;
                } else {
                    endDrag = end;
                }

                // reset dom listeners
                domEvent.unbind(document, 'mousemove', move);

                domEvent.unbind(document, 'mousedown', endDrag, true);
                domEvent.unbind(document, 'mouseup', endDrag, true);

                domEvent.unbind(document, 'keyup', checkCancel);

                domEvent.unbind(document, 'touchstart', trapTouch, true);
                domEvent.unbind(document, 'touchcancel', cancel, true);
                domEvent.unbind(document, 'touchmove', move, true);
                domEvent.unbind(document, 'touchend', end, true);

                eventBus.off('element.hover', hover);
                eventBus.off('element.out', out);

                // remove drag marker on root element
                canvas.removeMarker(canvas.getRootElement(), DRAG_ACTIVE_CLS);

                // restore selection, unless it has changed
                var previousSelection = context.payload.previousSelection;

                if (restore !== false && previousSelection && !selection.get().length) {
                    selection.select(previousSelection);
                }

                previousContext = context;

                context = null;

                return previousContext;
            }

            /**
             * Initialize a drag operation.
             *
             * If `localPosition` is given, drag events will be emitted
             * relative to it.
             *
             * @param {MouseEvent|TouchEvent} [event]
             * @param {Point} [localPosition] actual diagram local position this drag operation should start at
             * @param {String} prefix
             * @param {Object} [options]
             */
            function init(event, relativeTo, prefix, options) {

                // only one drag operation may be active, at a time
                if (context) {
                    cancel(false);
                }

                if (typeof relativeTo === 'string') {
                    options = prefix;
                    prefix = relativeTo;
                    relativeTo = null;
                }

                options = assign({}, defaultOptions, options || {});

                var data = options.data || {},
                    originalEvent,
                    globalStart,
                    endDrag;

                if (options.trapClick) {
                    endDrag = trapClickAndEnd;
                } else {
                    endDrag = end;
                }

                if (event) {
                    originalEvent = Event.getOriginal(event) || event;
                    globalStart = Event.toPoint(event);

                    suppressEvent(event);
                } else {
                    originalEvent = null;
                    globalStart = { x: 0, y: 0 };
                }

                var localStart = toLocalPoint(globalStart);

                if (!relativeTo) {
                    relativeTo = localStart;
                }

                context = assign({
                    prefix: prefix,
                    data: data,
                    payload: {},
                    globalStart: globalStart,
                    displacement: substract(relativeTo, localStart),
                    localStart: localStart
                }, options);

                // skip dom registration if trigger
                // is set to manual (during testing)
                if (!options.manual) {

                    // add dom listeners

                    // fixes TouchEvent not being available on desktop Firefox
                    if (typeof TouchEvent !== 'undefined' && originalEvent instanceof TouchEvent) {
                        domEvent.bind(document, 'touchstart', trapTouch, true);
                        domEvent.bind(document, 'touchcancel', cancel, true);
                        domEvent.bind(document, 'touchmove', move, true);
                        domEvent.bind(document, 'touchend', end, true);
                    } else {
                        // assume we use the mouse to interact per default
                        domEvent.bind(document, 'mousemove', move);

                        domEvent.bind(document, 'mousedown', endDrag, true);
                        domEvent.bind(document, 'mouseup', endDrag, true);
                    }

                    domEvent.bind(document, 'keyup', checkCancel);

                    eventBus.on('element.hover', hover);
                    eventBus.on('element.out', out);
                }

                fire('init');

                if (options.autoActivate) {
                    move(event, true);
                }
            }

            // cancel on diagram destruction
            eventBus.on('diagram.destroy', cancel);


            // API

            this.init = init;
            this.move = move;
            this.hover = hover;
            this.out = out;
            this.end = end;

            this.cancel = cancel;

            // for introspection

            this.context = function () {
                return context;
            };

            this.setOptions = function (options) {
                assign(defaultOptions, options);
            };
        }

        Dragging.$inject = ['eventBus', 'canvas', 'selection'];

        module.exports = Dragging;

    }, { "../../core/EventBus": 125, "../../util/ClickTrap": 262, "../../util/Cursor": 265, "../../util/Event": 267, "lodash/object/assign": 433, "min-dom/lib/event": 452 }], 161: [function (require, module, exports) {
        'use strict';

        var domClosest = require('min-dom/lib/closest');

        var Event = require('../../util/Event');

        function getGfx(target) {
            var node = domClosest(target, 'svg, .djs-element', true);
            return node;
        }


        /**
         * Browsers may swallow the hover event if users are to
         * fast with the mouse.
         *
         * @see http://stackoverflow.com/questions/7448468/why-cant-i-reliably-capture-a-mouseout-event
         *
         * The fix implemented in this component ensure that we
         * have a hover state after a successive drag.move event.
         *
         * @param {EventBus} eventBus
         * @param {Dragging} dragging
         * @param {ElementRegistry} elementRegistry
         */
        function HoverFix(eventBus, dragging, elementRegistry) {

            var self = this;

            // we wait for a specific sequence of events before
            // emitting a fake drag.hover event.
            //
            // Event Sequence:
            //
            // drag.start
            // drag.move
            // drag.move >> ensure we are hovering
            //
            eventBus.on('drag.start', function (event) {

                eventBus.once('drag.move', function () {

                    eventBus.once('drag.move', function (event) {

                        self.ensureHover(event);
                    });
                });
            });

            /**
             * Make sure we are god damn hovering!
             *
             * @param {Event} dragging event
             */
            this.ensureHover = function (event) {

                if (event.hover) {
                    return;
                }

                var originalEvent = event.originalEvent,
                    position,
                    target,
                    element,
                    gfx;

                if (!(originalEvent instanceof MouseEvent)) {
                    return;
                }

                position = Event.toPoint(originalEvent);

                // damn expensive operation, ouch!
                target = document.elementFromPoint(position.x, position.y);

                gfx = getGfx(target);

                if (gfx) {
                    element = elementRegistry.get(gfx);

                    dragging.hover({ element: element, gfx: gfx });
                }
            };

        }

        HoverFix.$inject = ['eventBus', 'dragging', 'elementRegistry'];

        module.exports = HoverFix;

    }, { "../../util/Event": 267, "min-dom/lib/closest": 449 }], 162: [function (require, module, exports) {
        module.exports = {
            __init__: [
                'hoverFix'
            ],
            __depends__: [
                require('../selection')
            ],
            dragging: ['type', require('./Dragging')],
            hoverFix: ['type', require('./HoverFix')]
        };
    }, { "../selection": 233, "./Dragging": 160, "./HoverFix": 161 }], 163: [function (require, module, exports) {
        'use strict';

        var forEach = require('lodash/collection/forEach'),
            isArray = require('lodash/lang/isArray');

        var NOT_REGISTERED_ERROR = 'is not a registered action',
            IS_REGISTERED_ERROR = 'is already registered';


        /**
         * An interface that provides access to modeling actions by decoupling
         * the one who requests the action to be triggered and the trigger itself.
         *
         * It's possible to add new actions by registering them with registerAction and likewise
         * unregister existing ones with unregisterAction.
         *
         */
        function EditorActions(eventBus, commandStack, modeling, selection,
            zoomScroll, copyPaste, canvas, rules, mouseTracking) {

            this._actions = {
                undo: function () {
                    commandStack.undo();
                },
                redo: function () {
                    commandStack.redo();
                },
                copy: function () {
                    var selectedElements = selection.get();

                    copyPaste.copy(selectedElements);
                },
                paste: function () {
                    var context = mouseTracking.getHoverContext();

                    copyPaste.paste(context);
                },
                stepZoom: function (opts) {
                    zoomScroll.stepZoom(opts.value);
                },
                zoom: function (opts) {
                    canvas.zoom(opts.value);
                },
                removeSelection: function () {
                    var selectedElements = selection.get();

                    if (selectedElements.length) {
                        var allowed = rules.allowed('elements.delete', { elements: selectedElements }),
                            removableElements;

                        if (allowed === false) {
                            return;
                        }
                        else if (isArray(allowed)) {
                            removableElements = allowed;
                        }
                        else {
                            removableElements = selectedElements;
                        }

                        if (removableElements.length) {
                            modeling.removeElements(removableElements.slice());
                        }
                    }
                },
                moveCanvas: function (opts) {
                    var dx = 0,
                        dy = 0,
                        invertY = opts.invertY,
                        speed = opts.speed;

                    var actualSpeed = speed / Math.min(Math.sqrt(canvas.viewbox().scale), 1);

                    switch (opts.direction) {
                        case 'left':    // Left
                            dx = actualSpeed;
                            break;
                        case 'up':    // Up
                            dy = actualSpeed;
                            break;
                        case 'right':    // Right
                            dx = -actualSpeed;
                            break;
                        case 'down':    // Down
                            dy = -actualSpeed;
                            break;
                    }

                    if (dy && invertY) {
                        dy = -dy;
                    }

                    canvas.scroll({ dx: dx, dy: dy });
                }
            };
        }

        EditorActions.$inject = [
            'eventBus',
            'commandStack',
            'modeling',
            'selection',
            'zoomScroll',
            'copyPaste',
            'canvas',
            'rules',
            'mouseTracking'
        ];

        module.exports = EditorActions;


        /**
         * Triggers a registered action
         *
         * @param  {String} action
         * @param  {Object} opts
         *
         * @return {Unknown} Returns what the registered listener returns
         */
        EditorActions.prototype.trigger = function (action, opts) {
            if (!this._actions[action]) {
                throw error(action, NOT_REGISTERED_ERROR);
            }

            return this._actions[action](opts);
        };


        /**
         * Registers a collections of actions.
         * The key of the object will be the name of the action.
         *
         * @example
         * 
         * var actions = {
         *   spaceTool: function() {
         *     spaceTool.activateSelection();
         *   },
         *   lassoTool: function() {
         *     lassoTool.activateSelection();
         *   }
         * ];
         *
         * editorActions.register(actions);
         *
         * editorActions.isRegistered('spaceTool'); // true
         * 
         *
         * @param  {Object} actions
         */
        EditorActions.prototype.register = function (actions, listener) {
            if (typeof actions === 'string') {
                return this._registerAction(actions, listener);
            }

            forEach(actions, function (listener, action) {
                this._registerAction(action, listener);
            }, this);
        };

        /**
         * Registers a listener to an action key
         *
         * @param  {String} action
         * @param  {Function} listener
         */
        EditorActions.prototype._registerAction = function (action, listener) {
            if (this.isRegistered(action)) {
                throw error(action, IS_REGISTERED_ERROR);
            }

            this._actions[action] = listener;
        };

        /**
         * Unregister an existing action
         *
         * @param {String} action
         */
        EditorActions.prototype.unregister = function (action) {
            if (!this.isRegistered(action)) {
                throw error(action, NOT_REGISTERED_ERROR);
            }

            this._actions[action] = undefined;
        };

        /**
         * Returns the number of actions that are currently registered
         *
         * @return {Number}
         */
        EditorActions.prototype.length = function () {
            return Object.keys(this._actions).length;
        };

        /**
         * Checks wether the given action is registered
         *
         * @param {String} action
         *
         * @return {Boolean}
         */
        EditorActions.prototype.isRegistered = function (action) {
            return !!this._actions[action];
        };


        function error(action, message) {
            return new Error(action + ' ' + message);
        }

    }, { "lodash/collection/forEach": 304, "lodash/lang/isArray": 424 }], 164: [function (require, module, exports) {
        module.exports = {
            __depends__: [
                require('../selection'),
                require('../copy-paste'),
                require('../../navigation/zoomscroll')
            ],
            __init__: ['editorActions'],
            editorActions: ['type', require('./EditorActions')]
        };

    }, { "../../navigation/zoomscroll": 260, "../copy-paste": 155, "../selection": 233, "./EditorActions": 163 }], 165: [function (require, module, exports) {
        'use strict';

        var MARKER_OK = 'connect-ok',
            MARKER_NOT_OK = 'connect-not-ok';


        function GlobalConnect(eventBus, dragging, connect, canvas, toolManager) {
            var self = this;

            this._dragging = dragging;

            toolManager.registerTool('global-connect', {
                tool: 'global-connect',
                dragging: 'global-connect.drag'
            });

            eventBus.on('global-connect.hover', function (event) {
                var context = event.context,
                    startTarget = event.hover;

                var canStartConnect = context.canStartConnect = self.canStartConnect(startTarget);

                // simply ignore hover
                if (canStartConnect === null) {
                    return;
                }

                context.startTarget = startTarget;

                canvas.addMarker(startTarget, canStartConnect ? MARKER_OK : MARKER_NOT_OK);
            });


            eventBus.on(['global-connect.out', 'global-connect.cleanup'], function (event) {
                var startTarget = event.context.startTarget,
                    canStartConnect = event.context.canStartConnect;

                if (startTarget) {
                    canvas.removeMarker(startTarget, canStartConnect ? MARKER_OK : MARKER_NOT_OK);
                }
            });


            eventBus.on(['global-connect.ended'], function (event) {
                var context = event.context,
                    startTarget = context.startTarget,
                    startPosition = {
                        x: event.x,
                        y: event.y
                    };

                var canStartConnect = self.canStartConnect(startTarget);

                if (!canStartConnect) {
                    return;
                }

                eventBus.once('element.out', function () {
                    eventBus.once(['connect.ended', 'connect.canceled'], function () {
                        eventBus.fire('global-connect.drag.ended');
                    });

                    connect.start(null, startTarget, startPosition);
                });

                return false;
            });
        }

        GlobalConnect.$inject = ['eventBus', 'dragging', 'connect', 'canvas', 'toolManager'];

        module.exports = GlobalConnect;


        /**
         * Initiates tool activity.
         */
        GlobalConnect.prototype.start = function (event) {
            this._dragging.init(event, 'global-connect', {
                trapClick: false,
                data: {
                    context: {}
                }
            });
        };


        GlobalConnect.prototype.toggle = function () {
            if (this.isActive()) {
                this._dragging.cancel();
            } else {
                this.start();
            }
        };

        GlobalConnect.prototype.isActive = function () {
            var context = this._dragging.context();

            return context && /^global-connect/.test(context.prefix);
        };


        GlobalConnect.prototype.registerProvider = function (provider) {
            this._provider = provider;
        };


        /**
         * Check if source shape can initiate connection.
         *
         * @param  {Shape} startTarget
         * @return {Boolean}
         */
        GlobalConnect.prototype.canStartConnect = function (startTarget) {
            return this._provider.canStartConnect(startTarget);
        };

    }, {}], 166: [function (require, module, exports) {
        module.exports = {
            __depends__: [
                require('../connect'),
                require('../rules'),
                require('../dragging'),
                require('../tool-manager')
            ],
            globalConnect: ['type', require('./GlobalConnect')]
        };

    }, { "../connect": 151, "../dragging": 162, "../rules": 227, "../tool-manager": 242, "./GlobalConnect": 165 }], 167: [function (require, module, exports) {
        'use strict';

        var hasPrimaryModifier = require('../../util/Mouse').hasPrimaryModifier;


        var HIGH_PRIORITY = 1500;
        var HAND_CURSOR = 'grab';

        function HandTool(eventBus, canvas, dragging, toolManager) {
            this._dragging = dragging;


            toolManager.registerTool('hand', {
                tool: 'hand',
                dragging: 'hand.move'
            });

            eventBus.on('element.mousedown', HIGH_PRIORITY, function (event) {
                if (hasPrimaryModifier(event)) {
                    this.activateMove(event.originalEvent);

                    return false;
                }
            }, this);


            eventBus.on('hand.end', function (event) {
                var target = event.originalEvent.target;

                // only reactive on diagram click
                // on some occasions, event.hover is not set and we have to check if the target is an svg
                if (!event.hover && !(target instanceof SVGElement)) {
                    return false;
                }

                eventBus.once('hand.ended', function () {
                    this.activateMove(event.originalEvent, { reactivate: true });
                }, this);

            }, this);


            eventBus.on('hand.move.move', function (event) {
                var scale = canvas.viewbox().scale;

                canvas.scroll({
                    dx: event.dx * scale,
                    dy: event.dy * scale
                });
            });

            eventBus.on('hand.move.end', function (event) {
                var context = event.context,
                    reactivate = context.reactivate;

                // Don't reactivate if the user is using the keyboard keybinding
                if (!hasPrimaryModifier(event) && reactivate) {

                    eventBus.once('hand.move.ended', function (event) {
                        this.activateHand(event.originalEvent, true, true);
                    }, this);

                }

                return false;
            }, this);

        }

        HandTool.$inject = [
            'eventBus',
            'canvas',
            'dragging',
            'toolManager'
        ];

        module.exports = HandTool;


        HandTool.prototype.activateMove = function (event, autoActivate, context) {
            if (typeof autoActivate === 'object') {
                context = autoActivate;
                autoActivate = false;
            }

            this._dragging.init(event, 'hand.move', {
                autoActivate: autoActivate,
                cursor: HAND_CURSOR,
                data: {
                    context: context || {}
                }
            });
        };

        HandTool.prototype.activateHand = function (event, autoActivate, reactivate) {
            this._dragging.init(event, 'hand', {
                trapClick: false,
                autoActivate: autoActivate,
                cursor: HAND_CURSOR,
                data: {
                    context: {
                        reactivate: reactivate
                    }
                }
            });
        };

        HandTool.prototype.toggle = function () {
            if (this.isActive()) {
                this._dragging.cancel();
            } else {
                this.activateHand();
            }
        };

        HandTool.prototype.isActive = function () {
            var context = this._dragging.context();

            return context && /^hand/.test(context.prefix);
        };

    }, { "../../util/Mouse": 274 }], 168: [function (require, module, exports) {
        'use strict';

        module.exports = {
            __depends__: [require('../tool-manager')],
            __init__: ['handTool'],
            handTool: ['type', require('./HandTool')]
        };

    }, { "../tool-manager": 242, "./HandTool": 167 }], 169: [function (require, module, exports) {
        'use strict';

        var forEach = require('lodash/collection/forEach'),
            domDelegate = require('min-dom/lib/delegate');

        var isPrimaryButton = require('../../util/Mouse').isPrimaryButton;

        var svgAppend = require('tiny-svg/lib/append'),
            svgAttr = require('tiny-svg/lib/attr'),
            svgCreate = require('tiny-svg/lib/create');

        var domQuery = require('min-dom/lib/query');

        var renderUtil = require('../../util/RenderUtil');

        var createLine = renderUtil.createLine,
            updateLine = renderUtil.updateLine;

        var LOW_PRIORITY = 500;

        /**
         * A plugin that provides interaction events for diagram elements.
         *
         * It emits the following events:
         *
         *   * element.hover
         *   * element.out
         *   * element.click
         *   * element.dblclick
         *   * element.mousedown
         *
         * Each event is a tuple { element, gfx, originalEvent }.
         *
         * Canceling the event via Event#preventDefault() prevents the original DOM operation.
         *
         * @param {EventBus} eventBus
         */
        function InteractionEvents(eventBus, elementRegistry, styles) {

            var HIT_STYLE = styles.cls('djs-hit', ['no-fill', 'no-border'], {
                stroke: 'white',
                strokeWidth: 15
            });

            /**
             * Fire an interaction event.
             *
             * @param {String} type local event name, e.g. element.click.
             * @param {DOMEvent} event native event
             * @param {djs.model.Base} [element] the diagram element to emit the event on;
             *                                   defaults to the event target
             */
            function fire(type, event, element) {

                // only react on left mouse button interactions
                // for interaction events
                if (!isPrimaryButton(event)) {
                    return;
                }

                var target, gfx, returnValue;

                if (!element) {
                    target = event.delegateTarget || event.target;

                    if (target) {
                        gfx = target;
                        element = elementRegistry.get(gfx);
                    }
                } else {
                    gfx = elementRegistry.getGraphics(element);
                }

                if (!gfx || !element) {
                    return;
                }

                returnValue = eventBus.fire(type, { element: element, gfx: gfx, originalEvent: event });

                if (returnValue === false) {
                    event.stopPropagation();
                    event.preventDefault();
                }
            }

            // TODO(nikku): document this
            var handlers = {};

            function mouseHandler(type) {

                var fn = handlers[type];

                if (!fn) {
                    fn = handlers[type] = function (event) {
                        fire(type, event);
                    };
                }

                return fn;
            }

            var bindings = {
                mouseover: 'element.hover',
                mouseout: 'element.out',
                click: 'element.click',
                dblclick: 'element.dblclick',
                mousedown: 'element.mousedown',
                mouseup: 'element.mouseup'
            };


            ///// manual event trigger

            /**
             * Trigger an interaction event (based on a native dom event)
             * on the target shape or connection.
             *
             * @param {String} eventName the name of the triggered DOM event
             * @param {MouseEvent} event
             * @param {djs.model.Base} targetElement
             */
            function triggerMouseEvent(eventName, event, targetElement) {

                // i.e. element.mousedown...
                var localEventName = bindings[eventName];

                if (!localEventName) {
                    throw new Error('unmapped DOM event name <' + eventName + '>');
                }

                return fire(localEventName, event, targetElement);
            }


            var elementSelector = 'svg, .djs-element';

            ///// event registration

            function registerEvent(node, event, localEvent) {
                var handler = mouseHandler(localEvent);
                handler.$delegate = domDelegate.bind(node, elementSelector, event, handler);
            }

            function unregisterEvent(node, event, localEvent) {
                domDelegate.unbind(node, event, mouseHandler(localEvent).$delegate);
            }

            function registerEvents(svg) {
                forEach(bindings, function (val, key) {
                    registerEvent(svg, key, val);
                });
            }

            function unregisterEvents(svg) {
                forEach(bindings, function (val, key) {
                    unregisterEvent(svg, key, val);
                });
            }

            eventBus.on('canvas.destroy', function (event) {
                unregisterEvents(event.svg);
            });

            eventBus.on('canvas.init', function (event) {
                registerEvents(event.svg);
            });


            eventBus.on(['shape.added', 'connection.added'], function (event) {
                var element = event.element,
                    gfx = event.gfx,
                    hit;

                if (element.waypoints) {
                    hit = createLine(element.waypoints);
                } else {
                    hit = svgCreate('rect');
                    svgAttr(hit, {
                        x: 0,
                        y: 0,
                        width: element.width,
                        height: element.height
                    });
                }

                svgAttr(hit, HIT_STYLE);

                svgAppend(gfx, hit);
            });

            // Update djs-hit on change.
            // A low priortity is necessary, because djs-hit of labels has to be updated
            // after the label bounds have been updated in the renderer.
            eventBus.on('shape.changed', LOW_PRIORITY, function (event) {

                var element = event.element,
                    gfx = event.gfx,
                    hit = domQuery('.djs-hit', gfx);

                svgAttr(hit, {
                    width: element.width,
                    height: element.height
                });
            });

            eventBus.on('connection.changed', function (event) {

                var element = event.element,
                    gfx = event.gfx,
                    hit = domQuery('.djs-hit', gfx);

                updateLine(hit, element.waypoints);
            });


            // API

            this.fire = fire;

            this.triggerMouseEvent = triggerMouseEvent;

            this.mouseHandler = mouseHandler;

            this.registerEvent = registerEvent;
            this.unregisterEvent = unregisterEvent;
        }


        InteractionEvents.$inject = ['eventBus', 'elementRegistry', 'styles'];

        module.exports = InteractionEvents;


        /**
         * An event indicating that the mouse hovered over an element
         *
         * @event element.hover
         *
         * @type {Object}
         * @property {djs.model.Base} element
         * @property {SVGElement} gfx
         * @property {Event} originalEvent
         */

        /**
         * An event indicating that the mouse has left an element
         *
         * @event element.out
         *
         * @type {Object}
         * @property {djs.model.Base} element
         * @property {SVGElement} gfx
         * @property {Event} originalEvent
         */

        /**
         * An event indicating that the mouse has clicked an element
         *
         * @event element.click
         *
         * @type {Object}
         * @property {djs.model.Base} element
         * @property {SVGElement} gfx
         * @property {Event} originalEvent
         */

        /**
         * An event indicating that the mouse has double clicked an element
         *
         * @event element.dblclick
         *
         * @type {Object}
         * @property {djs.model.Base} element
         * @property {SVGElement} gfx
         * @property {Event} originalEvent
         */

        /**
         * An event indicating that the mouse has gone down on an element.
         *
         * @event element.mousedown
         *
         * @type {Object}
         * @property {djs.model.Base} element
         * @property {SVGElement} gfx
         * @property {Event} originalEvent
         */

        /**
         * An event indicating that the mouse has gone up on an element.
         *
         * @event element.mouseup
         *
         * @type {Object}
         * @property {djs.model.Base} element
         * @property {SVGElement} gfx
         * @property {Event} originalEvent
         */

    }, { "../../util/Mouse": 274, "../../util/RenderUtil": 278, "lodash/collection/forEach": 304, "min-dom/lib/delegate": 450, "min-dom/lib/query": 454, "tiny-svg/lib/append": 473, "tiny-svg/lib/attr": 475, "tiny-svg/lib/create": 479 }], 170: [function (require, module, exports) {
        module.exports = {
            __init__: ['interactionEvents'],
            interactionEvents: ['type', require('./InteractionEvents')]
        };
    }, { "./InteractionEvents": 169 }], 171: [function (require, module, exports) {
        'use strict';

        var domEvent = require('min-dom/lib/event'),
            domMatches = require('min-dom/lib/matches');

        /**
         * A keyboard abstraction that may be activated and
         * deactivated by users at will, consuming key events
         * and triggering diagram actions.
         *
         * The implementation fires the following key events that allow
         * other components to hook into key handling:
         *
         *  - keyboard.bind
         *  - keyboard.unbind
         *  - keyboard.init
         *  - keyboard.destroy
         *
         * All events contain the fields (node, listeners).
         *
         * A default binding for the keyboard may be specified via the
         * `keyboard.bindTo` configuration option.
         *
         * @param {Config} config
         * @param {EventBus} eventBus
         * @param {EditorActions} editorActions
         */
        function Keyboard(config, eventBus, editorActions) {
            var self = this;

            this._config = config || {};
            this._eventBus = eventBus;
            this._editorActions = editorActions;

            this._listeners = [];

            // our key handler is a singleton that passes
            // (keycode, modifiers) to each listener.
            //
            // listeners must indicate that they handled a key event
            // by returning true. This stops the event propagation.
            //
            this._keyHandler = function (event) {

                var i, l,
                    target = event.target,
                    listeners = self._listeners,
                    code = event.keyCode || event.charCode || -1;

                if (target && (domMatches(target, 'input, textarea') || target.contentEditable === 'true')) {
                    return;
                }

                for (i = 0; (l = listeners[i]); i++) {
                    if (l(code, event)) {
                        event.preventDefault();
                        event.stopPropagation();
                    }
                }
            };

            // properly clean dom registrations
            eventBus.on('diagram.destroy', function () {
                self._fire('destroy');

                self.unbind();
                self._listeners = null;
            });

            eventBus.on('diagram.init', function () {
                self._fire('init');

                if (config && config.bindTo) {
                    self.bind(config.bindTo);
                }
            });

            this._init();
        }

        Keyboard.$inject = [
            'config.keyboard',
            'eventBus',
            'editorActions'
        ];

        module.exports = Keyboard;


        Keyboard.prototype.bind = function (node) {
            // make sure that the keyboard is only bound once to the DOM
            this.unbind();

            this._node = node;

            // bind key events
            domEvent.bind(node, 'keydown', this._keyHandler, true);

            this._fire('bind');
        };

        Keyboard.prototype.getBinding = function () {
            return this._node;
        };

        Keyboard.prototype.unbind = function () {
            var node = this._node;

            if (node) {
                this._fire('unbind');

                // unbind key events
                domEvent.unbind(node, 'keydown', this._keyHandler, true);
            }

            this._node = null;
        };

        Keyboard.prototype._fire = function (event) {
            this._eventBus.fire('keyboard.' + event, { node: this._node, listeners: this._listeners });
        };

        Keyboard.prototype._init = function () {

            var listeners = this._listeners;

            var editorActions = this._editorActions,
                config = this._config;

            // init default listeners

            // undo
            // (CTRL|CMD) + Z
            function undo(key, modifiers) {

                if (isCmd(modifiers) && !isShift(modifiers) && key === 90) {
                    editorActions.trigger('undo');

                    return true;
                }
            }

            // redo
            // CTRL + Y
            // CMD + SHIFT + Z
            function redo(key, modifiers) {

                if (isCmd(modifiers) && (key === 89 || (key === 90 && isShift(modifiers)))) {
                    editorActions.trigger('redo');

                    return true;
                }
            }

            // copy
            // CTRL/CMD + C
            function copy(key, modifiers) {

                if (isCmd(modifiers) && (key === 67)) {
                    editorActions.trigger('copy');

                    return true;
                }
            }

            // paste
            // CTRL/CMD + V
            function paste(key, modifiers) {

                if (isCmd(modifiers) && (key === 86)) {
                    editorActions.trigger('paste');

                    return true;
                }
            }

            /**
             * zoom in one step
             * CTRL + +
             *
             * 107 = numpad plus
             * 187 = regular plus
             * 171 = regular plus in Firefox (german keyboard layout)
             *  61 = regular plus in Firefox (US keyboard layout)
             */
            function zoomIn(key, modifiers) {

                if ((key === 107 || key === 187 || key === 171 || key === 61) && isCmd(modifiers)) {
                    editorActions.trigger('stepZoom', { value: 1 });

                    return true;
                }
            }

            /**
             * zoom out one step
             * CTRL + -
             *
             * 109 = numpad minus
             * 189 = regular minus
             * 173 = regular minus in Firefox (US and german keyboard layout)
             */
            function zoomOut(key, modifiers) {

                if ((key === 109 || key === 189 || key === 173) && isCmd(modifiers)) {
                    editorActions.trigger('stepZoom', { value: -1 });

                    return true;
                }
            }

            /**
             * zoom to the default level
             * CTRL + 0
             *
             * 96 = numpad zero
             * 48 = regular zero
             */
            function zoomDefault(key, modifiers) {

                if ((key === 96 || key === 48) && isCmd(modifiers)) {
                    editorActions.trigger('zoom', { value: 1 });

                    return true;
                }
            }

            // delete selected element
            // DEL
            function removeSelection(key, modifiers) {

                if (key === 46) {
                    editorActions.trigger('removeSelection');

                    return true;
                }
            }

            // move canvas left
            // left arrow
            //
            // 37 = Left
            // 38 = Up
            // 39 = Right
            // 40 = Down
            function moveCanvas(key, modifiers) {

                if ([37, 38, 39, 40].indexOf(key) >= 0) {

                    var opts = {
                        invertY: config.invertY,
                        speed: (config.speed || 50)
                    };

                    switch (key) {
                        case 37:    // Left
                            opts.direction = 'left';
                            break;
                        case 38:    // Up
                            opts.direction = 'up';
                            break;
                        case 39:    // Right
                            opts.direction = 'right';
                            break;
                        case 40:    // Down
                            opts.direction = 'down';
                            break;
                    }

                    editorActions.trigger('moveCanvas', opts);

                    return true;
                }
            }

            listeners.push(undo);
            listeners.push(redo);
            listeners.push(copy);
            listeners.push(paste);
            listeners.push(removeSelection);
            listeners.push(zoomIn);
            listeners.push(zoomOut);
            listeners.push(zoomDefault);
            listeners.push(moveCanvas);
        };


        /**
         * Add a listener function that is notified with (key, modifiers) whenever
         * the keyboard is bound and the user presses a key.
         *
         * @param {Function} listenerFn
         */
        Keyboard.prototype.addListener = function (listenerFn) {
            this._listeners.push(listenerFn);
        };

        Keyboard.prototype.hasModifier = hasModifier;
        Keyboard.prototype.isCmd = isCmd;
        Keyboard.prototype.isShift = isShift;


        function hasModifier(modifiers) {
            return (modifiers.ctrlKey || modifiers.metaKey || modifiers.shiftKey || modifiers.altKey);
        }

        function isCmd(modifiers) {
            return modifiers.ctrlKey || modifiers.metaKey;
        }

        function isShift(modifiers) {
            return modifiers.shiftKey;
        }

    }, { "min-dom/lib/event": 452, "min-dom/lib/matches": 453 }], 172: [function (require, module, exports) {
        module.exports = {
            __init__: ['keyboard'],
            keyboard: ['type', require('./Keyboard')]
        };

    }, { "./Keyboard": 171 }], 173: [function (require, module, exports) {
        'use strict';

        var forEach = require('lodash/collection/forEach'),
            filter = require('lodash/collection/filter'),
            inherits = require('inherits');

        var LOW_PRIORITY = 250,
            HIGH_PRIORITY = 1400;

        var CommandInterceptor = require('../../command/CommandInterceptor');


        /**
         * A handler that makes sure labels are properly moved with
         * their label targets.
         */
        function LabelSupport(eventBus, modeling, movePreview) {

            CommandInterceptor.call(this, eventBus);

            // remove labels from the collection that are being
            // moved with other elements anyway
            eventBus.on('shape.move.start', HIGH_PRIORITY, function (e) {

                var context = e.context,
                    shapes = context.shapes,
                    validatedShapes = context.validatedShapes;

                context.shapes = removeLabels(shapes);
                context.validatedShapes = removeLabels(validatedShapes);
            });


            // add labels to visual's group
            eventBus.on('shape.move.start', LOW_PRIORITY, function (e) {

                var context = e.context,
                    shapes = context.shapes;

                var labels = [];

                forEach(shapes, function (element) {
                    var label = element.label;

                    if (label && !label.hidden && context.shapes.indexOf(label) === -1) {
                        labels.push(label);
                    }

                    if (element.labelTarget) {
                        labels.push(element);
                    }
                });

                forEach(labels, function (label) {
                    movePreview.makeDraggable(context, label, true);
                });

            });

            // move labels after the other shapes are done moving
            this.postExecuted(['elements.move'], function (e) {
                var context = e.context,
                    closure = context.closure,
                    enclosedElements = closure.enclosedElements;

                // ensure we move all labels with their respective elements
                // if they have not been moved already

                forEach(enclosedElements, function (e) {
                    if (e.label && !enclosedElements[e.label.id]) {
                        modeling.moveShape(e.label, context.delta, e.parent);
                    }
                });

            });

        }

        inherits(LabelSupport, CommandInterceptor);

        LabelSupport.$inject = ['eventBus', 'modeling', 'movePreview'];

        module.exports = LabelSupport;


        /**
         * Return a filtered list of elements that do not
         * contain attached elements with hosts being part
         * of the selection.
         *
         * @param  {Array<djs.model.Base>} elements
         *
         * @return {Array<djs.model.Base>} filtered
         */
        function removeLabels(elements) {

            return filter(elements, function (element) {

                // filter out labels that are move together
                // with their label targets
                return elements.indexOf(element.labelTarget) === -1;
            });
        }

    }, { "../../command/CommandInterceptor": 119, "inherits": 289, "lodash/collection/filter": 302, "lodash/collection/forEach": 304 }], 174: [function (require, module, exports) {
        module.exports = {
            __depends__: [
                require('../move')
            ],
            __init__: ['labelSupport'],
            labelSupport: ['type', require('./LabelSupport')]
        };

    }, { "../move": 206, "./LabelSupport": 173 }], 175: [function (require, module, exports) {
        'use strict';

        var values = require('lodash/object/values');

        var getEnclosedElements = require('../../util/Elements').getEnclosedElements;

        var hasSecondaryModifier = require('../../util/Mouse').hasSecondaryModifier;

        var svgAppend = require('tiny-svg/lib/append'),
            svgAttr = require('tiny-svg/lib/attr'),
            svgCreate = require('tiny-svg/lib/create'),
            svgRemove = require('tiny-svg/lib/remove');

        var LASSO_TOOL_CURSOR = 'crosshair';


        function LassoTool(eventBus, canvas, dragging, elementRegistry, selection, toolManager) {

            this._selection = selection;
            this._dragging = dragging;

            var self = this;

            // lasso visuals implementation

            /**
            * A helper that realizes the selection box visual
            */
            var visuals = {

                create: function (context) {
                    var container = canvas.getDefaultLayer(),
                        frame;

                    frame = context.frame = svgCreate('rect');
                    svgAttr(frame, {
                        class: 'djs-lasso-overlay',
                        width: 1,
                        height: 1,
                        x: 0,
                        y: 0
                    });

                    svgAppend(container, frame);
                },

                update: function (context) {
                    var frame = context.frame,
                        bbox = context.bbox;

                    svgAttr(frame, {
                        x: bbox.x,
                        y: bbox.y,
                        width: bbox.width,
                        height: bbox.height
                    });
                },

                remove: function (context) {

                    if (context.frame) {
                        svgRemove(context.frame);
                    }
                }
            };

            toolManager.registerTool('lasso', {
                tool: 'lasso.selection',
                dragging: 'lasso'
            });

            eventBus.on('lasso.selection.end', function (event) {
                var target = event.originalEvent.target;

                // only reactive on diagram click
                // on some occasions, event.hover is not set and we have to check if the target is an svg
                if (!event.hover && !(target instanceof SVGElement)) {
                    return;
                }

                eventBus.once('lasso.selection.ended', function () {
                    self.activateLasso(event.originalEvent, true);
                });
            });

            // lasso interaction implementation

            eventBus.on('lasso.end', function (event) {

                var bbox = toBBox(event);

                var elements = elementRegistry.filter(function (element) {
                    return element;
                });

                self.select(elements, bbox);
            });

            eventBus.on('lasso.start', function (event) {

                var context = event.context;

                context.bbox = toBBox(event);
                visuals.create(context);
            });

            eventBus.on('lasso.move', function (event) {

                var context = event.context;

                context.bbox = toBBox(event);
                visuals.update(context);
            });

            eventBus.on('lasso.cleanup', function (event) {

                var context = event.context;

                visuals.remove(context);
            });


            // event integration

            eventBus.on('element.mousedown', 1500, function (event) {

                if (hasSecondaryModifier(event)) {
                    self.activateLasso(event.originalEvent);

                    event.stopPropagation();
                }
            });
        }

        LassoTool.$inject = [
            'eventBus',
            'canvas',
            'dragging',
            'elementRegistry',
            'selection',
            'toolManager'
        ];

        module.exports = LassoTool;


        LassoTool.prototype.activateLasso = function (event, autoActivate) {

            this._dragging.init(event, 'lasso', {
                autoActivate: autoActivate,
                cursor: LASSO_TOOL_CURSOR,
                data: {
                    context: {}
                }
            });
        };

        LassoTool.prototype.activateSelection = function (event) {

            this._dragging.init(event, 'lasso.selection', {
                trapClick: false,
                cursor: LASSO_TOOL_CURSOR,
                data: {
                    context: {}
                }
            });
        };

        LassoTool.prototype.select = function (elements, bbox) {
            var selectedElements = getEnclosedElements(elements, bbox);

            this._selection.select(values(selectedElements));
        };

        LassoTool.prototype.toggle = function () {
            if (this.isActive()) {
                this._dragging.cancel();
            } else {
                this.activateSelection();
            }
        };

        LassoTool.prototype.isActive = function () {
            var context = this._dragging.context();

            return context && /^lasso/.test(context.prefix);
        };



        function toBBox(event) {

            var start = {

                x: event.x - event.dx,
                y: event.y - event.dy
            };

            var end = {
                x: event.x,
                y: event.y
            };

            var bbox;

            if ((start.x <= end.x && start.y < end.y) ||
                (start.x < end.x && start.y <= end.y)) {

                bbox = {
                    x: start.x,
                    y: start.y,
                    width: end.x - start.x,
                    height: end.y - start.y
                };
            } else if ((start.x >= end.x && start.y < end.y) ||
                (start.x > end.x && start.y <= end.y)) {

                bbox = {
                    x: end.x,
                    y: start.y,
                    width: start.x - end.x,
                    height: end.y - start.y
                };
            } else if ((start.x <= end.x && start.y > end.y) ||
                (start.x < end.x && start.y >= end.y)) {

                bbox = {
                    x: start.x,
                    y: end.y,
                    width: end.x - start.x,
                    height: start.y - end.y
                };
            } else if ((start.x >= end.x && start.y > end.y) ||
                (start.x > end.x && start.y >= end.y)) {

                bbox = {
                    x: end.x,
                    y: end.y,
                    width: start.x - end.x,
                    height: start.y - end.y
                };
            } else {

                bbox = {
                    x: end.x,
                    y: end.y,
                    width: 0,
                    height: 0
                };
            }
            return bbox;
        }

    }, { "../../util/Elements": 266, "../../util/Mouse": 274, "lodash/object/values": 442, "tiny-svg/lib/append": 473, "tiny-svg/lib/attr": 475, "tiny-svg/lib/create": 479, "tiny-svg/lib/remove": 482 }], 176: [function (require, module, exports) {
        'use strict';

        module.exports = {
            __depends__: [require('../tool-manager')],
            __init__: ['lassoTool'],
            lassoTool: ['type', require('./LassoTool')]
        };

    }, { "../tool-manager": 242, "./LassoTool": 175 }], 177: [function (require, module, exports) {
        'use strict';

        var forEach = require('lodash/collection/forEach');

        var model = require('../../model');


        /**
         * The basic modeling entry point.
         *
         * @param {EventBus} eventBus
         * @param {ElementFactory} elementFactory
         * @param {CommandStack} commandStack
         */
        function Modeling(eventBus, elementFactory, commandStack) {
            this._eventBus = eventBus;
            this._elementFactory = elementFactory;
            this._commandStack = commandStack;

            var self = this;

            eventBus.on('diagram.init', function () {
                // register modeling handlers
                self.registerHandlers(commandStack);
            });
        }

        Modeling.$inject = ['eventBus', 'elementFactory', 'commandStack'];

        module.exports = Modeling;


        Modeling.prototype.getHandlers = function () {
            return {
                'shape.append': require('./cmd/AppendShapeHandler'),
                'shape.create': require('./cmd/CreateShapeHandler'),
                'shape.delete': require('./cmd/DeleteShapeHandler'),
                'shape.move': require('./cmd/MoveShapeHandler'),
                'shape.resize': require('./cmd/ResizeShapeHandler'),
                'shape.replace': require('./cmd/ReplaceShapeHandler'),
                'shape.toggleCollapse': require('./cmd/ToggleShapeCollapseHandler'),

                'spaceTool': require('./cmd/SpaceToolHandler'),

                'label.create': require('./cmd/CreateLabelHandler'),

                'connection.create': require('./cmd/CreateConnectionHandler'),
                'connection.delete': require('./cmd/DeleteConnectionHandler'),
                'connection.move': require('./cmd/MoveConnectionHandler'),
                'connection.layout': require('./cmd/LayoutConnectionHandler'),

                'connection.updateWaypoints': require('./cmd/UpdateWaypointsHandler'),

                'connection.reconnectStart': require('./cmd/ReconnectConnectionHandler'),
                'connection.reconnectEnd': require('./cmd/ReconnectConnectionHandler'),

                'elements.move': require('./cmd/MoveElementsHandler'),
                'elements.delete': require('./cmd/DeleteElementsHandler'),

                'elements.distribute': require('./cmd/DistributeElementsHandler'),
                'elements.align': require('./cmd/AlignElementsHandler'),

                'element.updateAttachment': require('./cmd/UpdateAttachmentHandler'),

                'elements.paste': require('./cmd/PasteHandler')
            };
        };

        /**
         * Register handlers with the command stack
         *
         * @param {CommandStack} commandStack
         */
        Modeling.prototype.registerHandlers = function (commandStack) {
            forEach(this.getHandlers(), function (handler, id) {
                commandStack.registerHandler(id, handler);
            });
        };


        ///// modeling helpers /////////////////////////////////////////

        Modeling.prototype.moveShape = function (shape, delta, newParent, newParentIndex, hints) {

            if (typeof newParentIndex === 'object') {
                hints = newParentIndex;
                newParentIndex = null;
            }

            var context = {
                shape: shape,
                delta: delta,
                newParent: newParent,
                newParentIndex: newParentIndex,
                hints: hints || {}
            };

            this._commandStack.execute('shape.move', context);
        };


        /**
         * Update the attachment of the given shape.
         *
         * @param  {djs.mode.Base} shape
         * @param  {djs.model.Base} [newHost]
         */
        Modeling.prototype.updateAttachment = function (shape, newHost) {
            var context = {
                shape: shape,
                newHost: newHost
            };

            this._commandStack.execute('element.updateAttachment', context);
        };

        /**
         * Move a number of shapes to a new target, either setting it as
         * the new parent or attaching it.
         *
         * @param {Array<djs.mode.Base>} shapes
         * @param {Point} delta
         * @param {djs.model.Base} [target]
         * @param {Boolean} [isAttach=false]
         * @param {Object} [hints]
         */
        Modeling.prototype.moveElements = function (shapes, delta, target, isAttach, hints) {
            if (typeof isAttach === 'object') {
                hints = isAttach;
                isAttach = undefined;
            }

            var newParent = target,
                newHost;

            if (isAttach === true) {
                newHost = target;
                newParent = target.parent;
            }

            if (isAttach === false) {
                newHost = null;
            }

            var context = {
                shapes: shapes,
                delta: delta,
                newParent: newParent,
                newHost: newHost,
                hints: hints || {}
            };

            this._commandStack.execute('elements.move', context);
        };

        Modeling.prototype.moveConnection = function (connection, delta, newParent, newParentIndex, hints) {

            if (typeof newParentIndex === 'object') {
                hints = newParentIndex;
                newParentIndex = undefined;
            }

            var context = {
                connection: connection,
                delta: delta,
                newParent: newParent,
                newParentIndex: newParentIndex,
                hints: hints || {}
            };

            this._commandStack.execute('connection.move', context);
        };


        Modeling.prototype.layoutConnection = function (connection, hints) {
            var context = {
                connection: connection,
                hints: hints || {}
            };

            this._commandStack.execute('connection.layout', context);
        };

        /**
         * Create connection.
         *
         * @param {djs.model.Base} source
         * @param {djs.model.Base} target
         * @param {Number} [targetIndex]
         * @param {Object|djs.model.Connection} connection
         * @param {djs.model.Base} parent
         * @param {Object} hints
         *
         * @return {djs.model.Connection} the created connection.
         */
        Modeling.prototype.createConnection = function (source, target, targetIndex, connection, parent, hints) {

            if (typeof targetIndex === 'object') {
                hints = parent;
                parent = connection;
                connection = targetIndex;
                targetIndex = undefined;
            }

            connection = this._create('connection', connection);

            var context = {
                source: source,
                target: target,
                parent: parent,
                parentIndex: targetIndex,
                connection: connection,
                hints: hints
            };

            this._commandStack.execute('connection.create', context);

            return context.connection;
        };

        Modeling.prototype.createShape = function (shape, position, target, targetIndex, isAttach, hints) {

            if (typeof targetIndex !== 'number') {
                hints = isAttach;
                isAttach = targetIndex;
            }

            if (typeof isAttach !== 'boolean') {
                hints = isAttach;
                isAttach = false;
            }

            shape = this._create('shape', shape);

            var context = {
                position: position,
                shape: shape,
                parent: target,
                parentIndex: targetIndex,
                host: shape.host,
                hints: hints || {}
            };

            if (isAttach) {
                context.parent = target.parent;
                context.host = target;
            }

            this._commandStack.execute('shape.create', context);

            return context.shape;
        };


        Modeling.prototype.createLabel = function (labelTarget, position, label, parent) {

            label = this._create('label', label);

            var context = {
                labelTarget: labelTarget,
                position: position,
                parent: parent || labelTarget.parent,
                shape: label
            };

            this._commandStack.execute('label.create', context);

            return context.shape;
        };


        Modeling.prototype.appendShape = function (source, shape, position, parent, connection, connectionParent) {

            shape = this._create('shape', shape);

            var context = {
                source: source,
                position: position,
                parent: parent,
                shape: shape,
                connection: connection,
                connectionParent: connectionParent
            };

            this._commandStack.execute('shape.append', context);

            return context.shape;
        };


        Modeling.prototype.removeElements = function (elements) {
            var context = {
                elements: elements
            };

            this._commandStack.execute('elements.delete', context);
        };


        Modeling.prototype.distributeElements = function (groups, axis, dimension) {
            var context = {
                groups: groups,
                axis: axis,
                dimension: dimension
            };

            this._commandStack.execute('elements.distribute', context);
        };


        Modeling.prototype.removeShape = function (shape, hints) {
            var context = {
                shape: shape,
                hints: hints || {}
            };

            this._commandStack.execute('shape.delete', context);
        };


        Modeling.prototype.removeConnection = function (connection, hints) {
            var context = {
                connection: connection,
                hints: hints || {}
            };

            this._commandStack.execute('connection.delete', context);
        };

        Modeling.prototype.replaceShape = function (oldShape, newShape, hints) {
            var context = {
                oldShape: oldShape,
                newData: newShape,
                hints: hints || {}
            };

            this._commandStack.execute('shape.replace', context);

            return context.newShape;
        };

        Modeling.prototype.pasteElements = function (tree, topParent, position) {
            var context = {
                tree: tree,
                topParent: topParent,
                position: position
            };

            this._commandStack.execute('elements.paste', context);
        };

        Modeling.prototype.alignElements = function (elements, alignment) {
            var context = {
                elements: elements,
                alignment: alignment
            };

            this._commandStack.execute('elements.align', context);
        };

        Modeling.prototype.resizeShape = function (shape, newBounds, minBounds) {
            var context = {
                shape: shape,
                newBounds: newBounds,
                minBounds: minBounds
            };

            this._commandStack.execute('shape.resize', context);
        };

        Modeling.prototype.createSpace = function (movingShapes, resizingShapes, delta, direction) {
            var context = {
                movingShapes: movingShapes,
                resizingShapes: resizingShapes,
                delta: delta,
                direction: direction
            };

            this._commandStack.execute('spaceTool', context);
        };

        Modeling.prototype.updateWaypoints = function (connection, newWaypoints, hints) {
            var context = {
                connection: connection,
                newWaypoints: newWaypoints,
                hints: hints || {}
            };

            this._commandStack.execute('connection.updateWaypoints', context);
        };

        Modeling.prototype.reconnectStart = function (connection, newSource, dockingOrPoints) {
            var context = {
                connection: connection,
                newSource: newSource,
                dockingOrPoints: dockingOrPoints
            };

            this._commandStack.execute('connection.reconnectStart', context);
        };

        Modeling.prototype.reconnectEnd = function (connection, newTarget, dockingOrPoints) {
            var context = {
                connection: connection,
                newTarget: newTarget,
                dockingOrPoints: dockingOrPoints
            };

            this._commandStack.execute('connection.reconnectEnd', context);
        };

        Modeling.prototype.connect = function (source, target, attrs, hints) {
            return this.createConnection(source, target, attrs || {}, source.parent, hints);
        };

        Modeling.prototype._create = function (type, attrs) {
            if (attrs instanceof model.Base) {
                return attrs;
            } else {
                return this._elementFactory.create(type, attrs);
            }
        };

        Modeling.prototype.toggleCollapse = function (shape, hints) {
            var context = {
                shape: shape,
                hints: hints || {}
            };

            this._commandStack.execute('shape.toggleCollapse', context);
        };

    }, { "../../model": 254, "./cmd/AlignElementsHandler": 178, "./cmd/AppendShapeHandler": 179, "./cmd/CreateConnectionHandler": 180, "./cmd/CreateLabelHandler": 181, "./cmd/CreateShapeHandler": 182, "./cmd/DeleteConnectionHandler": 183, "./cmd/DeleteElementsHandler": 184, "./cmd/DeleteShapeHandler": 185, "./cmd/DistributeElementsHandler": 186, "./cmd/LayoutConnectionHandler": 187, "./cmd/MoveConnectionHandler": 188, "./cmd/MoveElementsHandler": 189, "./cmd/MoveShapeHandler": 190, "./cmd/PasteHandler": 192, "./cmd/ReconnectConnectionHandler": 193, "./cmd/ReplaceShapeHandler": 194, "./cmd/ResizeShapeHandler": 195, "./cmd/SpaceToolHandler": 196, "./cmd/ToggleShapeCollapseHandler": 197, "./cmd/UpdateAttachmentHandler": 198, "./cmd/UpdateWaypointsHandler": 199, "lodash/collection/forEach": 304 }], 178: [function (require, module, exports) {
        'use strict';

        var forEach = require('lodash/collection/forEach');

        /**
         * A handler that align elements in a certain way.
         *
         */
        function AlignElements(modeling, canvas) {
            this._modeling = modeling;
            this._canvas = canvas;
        }

        AlignElements.$inject = ['modeling', 'canvas'];

        module.exports = AlignElements;


        AlignElements.prototype.preExecute = function (context) {
            var modeling = this._modeling;

            var elements = context.elements,
                alignment = context.alignment;


            forEach(elements, function (element) {
                var delta = {
                    x: 0,
                    y: 0
                };

                if (alignment.left) {
                    delta.x = alignment.left - element.x;

                } else if (alignment.right) {
                    delta.x = (alignment.right - element.width) - element.x;

                } else if (alignment.center) {
                    delta.x = (alignment.center - Math.round(element.width / 2)) - element.x;

                } else if (alignment.top) {
                    delta.y = alignment.top - element.y;

                } else if (alignment.bottom) {
                    delta.y = (alignment.bottom - element.height) - element.y;

                } else if (alignment.middle) {
                    delta.y = (alignment.middle - Math.round(element.height / 2)) - element.y;
                }

                modeling.moveElements([element], delta, element.parent);
            });
        };

        AlignElements.prototype.postExecute = function (context) {

        };

    }, { "lodash/collection/forEach": 304 }], 179: [function (require, module, exports) {
        'use strict';

        var any = require('lodash/collection/any');

        var inherits = require('inherits');


        /**
         * A handler that implements reversible appending of shapes
         * to a source shape.
         *
         * @param {canvas} Canvas
         * @param {elementFactory} ElementFactory
         * @param {modeling} Modeling
         */
        function AppendShapeHandler(modeling) {
            this._modeling = modeling;
        }

        inherits(AppendShapeHandler, require('./NoopHandler'));


        AppendShapeHandler.$inject = ['modeling'];

        module.exports = AppendShapeHandler;


        ////// api /////////////////////////////////////////////

        /**
         * Creates a new shape
         *
         * @param {Object} context
         * @param {ElementDescriptor} context.shape the new shape
         * @param {ElementDescriptor} context.source the source object
         * @param {ElementDescriptor} context.parent the parent object
         * @param {Point} context.position position of the new element
         */
        AppendShapeHandler.prototype.preExecute = function (context) {

            if (!context.source) {
                throw new Error('source required');
            }

            var parent = context.parent || context.source.parent,
                shape = this._modeling.createShape(context.shape, context.position, parent);

            context.shape = shape;
        };

        AppendShapeHandler.prototype.postExecute = function (context) {
            var parent = context.connectionParent || context.shape.parent;

            if (!existsConnection(context.source, context.shape)) {

                // create connection
                this._modeling.connect(context.source, context.shape, context.connection, parent);
            }
        };


        function existsConnection(source, target) {
            return any(source.outgoing, function (c) {
                return c.target === target;
            });
        }
    }, { "./NoopHandler": 191, "inherits": 289, "lodash/collection/any": 300 }], 180: [function (require, module, exports) {
        'use strict';


        function CreateConnectionHandler(canvas, layouter) {
            this._canvas = canvas;
            this._layouter = layouter;
        }

        CreateConnectionHandler.$inject = ['canvas', 'layouter'];

        module.exports = CreateConnectionHandler;



        ////// api /////////////////////////////////////////

        /**
         * Appends a shape to a target shape
         *
         * @param {Object} context
         * @param {djs.element.Base} context.source the source object
         * @param {djs.element.Base} context.target the parent object
         * @param {Point} context.position position of the new element
         */
        CreateConnectionHandler.prototype.execute = function (context) {

            var connection = context.connection,
                source = context.source,
                target = context.target,
                parent = context.parent,
                hints = context.hints;

            if (!source || !target) {
                throw new Error('source and target required');
            }

            if (!parent) {
                throw new Error('parent required');
            }

            connection.source = source;
            connection.target = target;

            if (!connection.waypoints) {
                connection.waypoints = this._layouter.layoutConnection(connection, hints);
            }

            // add connection
            this._canvas.addConnection(connection, parent);

            return connection;
        };

        CreateConnectionHandler.prototype.revert = function (context) {
            var connection = context.connection;

            this._canvas.removeConnection(connection);

            connection.source = null;
            connection.target = null;
        };
    }, {}], 181: [function (require, module, exports) {
        'use strict';

        var inherits = require('inherits');

        var CreateShapeHandler = require('./CreateShapeHandler');


        /**
         * A handler that attaches a label to a given target shape.
         *
         * @param {canvas} Canvas
         */
        function CreateLabelHandler(canvas) {
            CreateShapeHandler.call(this, canvas);
        }

        inherits(CreateLabelHandler, CreateShapeHandler);

        CreateLabelHandler.$inject = ['canvas'];

        module.exports = CreateLabelHandler;



        ////// api /////////////////////////////////////////


        var originalExecute = CreateShapeHandler.prototype.execute;

        /**
         * Appends a label to a target shape.
         *
         * @method CreateLabelHandler#execute
         *
         * @param {Object} context
         * @param {ElementDescriptor} context.target the element the label is attached to
         * @param {ElementDescriptor} context.parent the parent object
         * @param {Point} context.position position of the new element
         */
        CreateLabelHandler.prototype.execute = function (context) {

            var label = context.shape;

            ensureValidDimensions(label);

            label.labelTarget = context.labelTarget;

            return originalExecute.call(this, context);
        };

        var originalRevert = CreateShapeHandler.prototype.revert;

        /**
         * Undo append by removing the shape
         */
        CreateLabelHandler.prototype.revert = function (context) {
            context.shape.labelTarget = null;

            return originalRevert.call(this, context);
        };


        ////// helpers /////////////////////////////////////////

        function ensureValidDimensions(label) {
            // make sure a label has valid { width, height } dimensions
            ['width', 'height'].forEach(function (prop) {
                if (typeof label[prop] === 'undefined') {
                    label[prop] = 0;
                }
            });
        }
    }, { "./CreateShapeHandler": 182, "inherits": 289 }], 182: [function (require, module, exports) {
        'use strict';

        var assign = require('lodash/object/assign');

        var round = Math.round;


        /**
         * A handler that implements reversible addition of shapes.
         *
         * @param {canvas} Canvas
         */
        function CreateShapeHandler(canvas) {
            this._canvas = canvas;
        }

        CreateShapeHandler.$inject = ['canvas'];

        module.exports = CreateShapeHandler;



        ////// api /////////////////////////////////////////


        /**
         * Appends a shape to a target shape
         *
         * @param {Object} context
         * @param {djs.model.Base} context.parent the parent object
         * @param {Point} context.position position of the new element
         */
        CreateShapeHandler.prototype.execute = function (context) {

            var shape = context.shape,
                positionOrBounds = context.position,
                parent = context.parent,
                parentIndex = context.parentIndex;

            if (!parent) {
                throw new Error('parent required');
            }

            if (!positionOrBounds) {
                throw new Error('position required');
            }

            // (1) add at event center position _or_ at given bounds
            if (positionOrBounds.width !== undefined) {
                assign(shape, positionOrBounds);
            } else {
                assign(shape, {
                    x: positionOrBounds.x - round(shape.width / 2),
                    y: positionOrBounds.y - round(shape.height / 2)
                });
            }

            // (2) add to canvas
            this._canvas.addShape(shape, parent, parentIndex);

            return shape;
        };


        /**
         * Undo append by removing the shape
         */
        CreateShapeHandler.prototype.revert = function (context) {

            // (3) remove form canvas
            this._canvas.removeShape(context.shape);
        };
    }, { "lodash/object/assign": 433 }], 183: [function (require, module, exports) {
        'use strict';

        var Collections = require('../../../util/Collections');


        /**
         * A handler that implements reversible deletion of Connections.
         *
         */
        function DeleteConnectionHandler(canvas, modeling) {
            this._canvas = canvas;
            this._modeling = modeling;
        }

        DeleteConnectionHandler.$inject = ['canvas', 'modeling'];

        module.exports = DeleteConnectionHandler;


        /**
         * - Remove attached label
         */
        DeleteConnectionHandler.prototype.preExecute = function (context) {

            var connection = context.connection;

            // Remove label
            if (connection.label) {
                this._modeling.removeShape(connection.label);
            }
        };

        DeleteConnectionHandler.prototype.execute = function (context) {

            var connection = context.connection,
                parent = connection.parent;

            context.parent = parent;
            context.parentIndex = Collections.indexOf(parent.children, connection);

            context.source = connection.source;
            context.target = connection.target;

            this._canvas.removeConnection(connection);

            connection.source = null;
            connection.target = null;
            connection.label = null;

            return connection;
        };

        /**
         * Command revert implementation.
         */
        DeleteConnectionHandler.prototype.revert = function (context) {

            var connection = context.connection,
                parent = context.parent,
                parentIndex = context.parentIndex;

            connection.source = context.source;
            connection.target = context.target;

            // restore previous location in old parent
            Collections.add(parent.children, connection, parentIndex);

            this._canvas.addConnection(connection, parent);

            return connection;
        };

    }, { "../../../util/Collections": 263 }], 184: [function (require, module, exports) {
        'use strict';

        var forEach = require('lodash/collection/forEach'),
            inherits = require('inherits');


        function DeleteElementsHandler(modeling, elementRegistry) {
            this._modeling = modeling;
            this._elementRegistry = elementRegistry;
        }

        inherits(DeleteElementsHandler, require('./NoopHandler'));

        DeleteElementsHandler.$inject = ['modeling', 'elementRegistry'];

        module.exports = DeleteElementsHandler;


        DeleteElementsHandler.prototype.postExecute = function (context) {

            var modeling = this._modeling,
                elementRegistry = this._elementRegistry,
                elements = context.elements;

            forEach(elements, function (element) {

                // element may have been removed with previous
                // remove operations already (e.g. in case of nesting)
                if (!elementRegistry.get(element.id)) {
                    return;
                }

                if (element.waypoints) {
                    modeling.removeConnection(element);
                } else {
                    modeling.removeShape(element);
                }
            });
        };
    }, { "./NoopHandler": 191, "inherits": 289, "lodash/collection/forEach": 304 }], 185: [function (require, module, exports) {
        'use strict';

        var Collections = require('../../../util/Collections');

        var saveClear = require('../../../util/Removal').saveClear;


        /**
         * A handler that implements reversible deletion of shapes.
         *
         */
        function DeleteShapeHandler(canvas, modeling) {
            this._canvas = canvas;
            this._modeling = modeling;
        }

        DeleteShapeHandler.$inject = ['canvas', 'modeling'];

        module.exports = DeleteShapeHandler;


        /**
         * - Remove connections
         * - Remove all direct children
         */
        DeleteShapeHandler.prototype.preExecute = function (context) {

            var modeling = this._modeling;

            var shape = context.shape,
                label = shape.label;

            // Clean up on removeShape(label)
            if (shape.labelTarget) {
                context.labelTarget = shape.labelTarget;
                shape.labelTarget = null;
            }

            // Remove label
            if (label) {
                this._modeling.removeShape(label, { nested: true });
            }

            // remove connections
            saveClear(shape.incoming, function (connection) {
                // To make sure that the connection isn't removed twice
                // For example if a container is removed
                modeling.removeConnection(connection, { nested: true });
            });

            saveClear(shape.outgoing, function (connection) {
                modeling.removeConnection(connection, { nested: true });
            });

            // remove child shapes and connections
            saveClear(shape.children, function (child) {
                if (isConnection(child)) {
                    modeling.removeConnection(child, { nested: true });
                } else {
                    modeling.removeShape(child, { nested: true });
                }
            });
        };

        /**
         * Remove shape and remember the parent
         */
        DeleteShapeHandler.prototype.execute = function (context) {
            var canvas = this._canvas;

            var shape = context.shape,
                oldParent = shape.parent;

            context.oldParent = oldParent;
            context.oldParentIndex = Collections.indexOf(oldParent.children, shape);

            shape.label = null;

            canvas.removeShape(shape);

            return shape;
        };


        /**
         * Command revert implementation
         */
        DeleteShapeHandler.prototype.revert = function (context) {

            var canvas = this._canvas;

            var shape = context.shape,
                oldParent = context.oldParent,
                oldParentIndex = context.oldParentIndex,
                labelTarget = context.labelTarget;

            // restore previous location in old oldParent
            Collections.add(oldParent.children, shape, oldParentIndex);

            if (labelTarget) {
                labelTarget.label = shape;
            }

            canvas.addShape(shape, oldParent);

            return shape;
        };

        function isConnection(element) {
            return element.waypoints;
        }

    }, { "../../../util/Collections": 263, "../../../util/Removal": 277 }], 186: [function (require, module, exports) {
        'use strict';

        var forEach = require('lodash/collection/forEach'),
            sortBy = require('lodash/collection/sortBy');

        /**
         * A handler that distributes elements evenly.
         */
        function DistributeElements(modeling) {
            this._modeling = modeling;
        }

        DistributeElements.$inject = ['modeling'];

        module.exports = DistributeElements;

        var OFF_AXIS = {
            x: 'y',
            y: 'x'
        };

        DistributeElements.prototype.preExecute = function (context) {
            var modeling = this._modeling;

            var groups = context.groups,
                axis = context.axis,
                dimension = context.dimension;

            function updateRange(group, element) {
                group.range.min = Math.min(element[axis], group.range.min);
                group.range.max = Math.max(element[axis] + element[dimension], group.range.max);
            }

            function center(element) {
                return element[axis] + element[dimension] / 2;
            }

            function lastIdx(arr) {
                return arr.length - 1;
            }

            function rangeDiff(range) {
                return range.max - range.min;
            }

            function centerElement(refCenter, element) {
                var delta = { y: 0 };

                delta[axis] = refCenter - center(element);

                if (delta[axis]) {

                    delta[OFF_AXIS[axis]] = 0;

                    modeling.moveElements([element], delta, element.parent);
                }
            }

            var firstGroup = groups[0],
                lastGroupIdx = lastIdx(groups),
                lastGroup = groups[lastGroupIdx];

            var margin,
                spaceInBetween,
                groupsSize = 0; // the size of each range

            forEach(groups, function (group, idx) {
                var sortedElements,
                    refElem,
                    refCenter;

                if (group.elements.length < 2) {
                    if (idx && idx !== groups.length - 1) {
                        updateRange(group, group.elements[0]);

                        groupsSize += rangeDiff(group.range);
                    }
                    return;
                }

                sortedElements = sortBy(group.elements, axis);

                refElem = sortedElements[0];

                if (idx === lastGroupIdx) {
                    refElem = sortedElements[lastIdx(sortedElements)];
                }

                refCenter = center(refElem);

                // wanna update the ranges after the shapes have been centered
                group.range = null;

                forEach(sortedElements, function (element) {

                    centerElement(refCenter, element);

                    if (group.range === null) {
                        group.range = {
                            min: element[axis],
                            max: element[axis] + element[dimension]
                        };

                        return;
                    }

                    // update group's range after centering the range elements
                    updateRange(group, element);
                });

                if (idx && idx !== groups.length - 1) {
                    groupsSize += rangeDiff(group.range);
                }
            });

            spaceInBetween = Math.abs(lastGroup.range.min - firstGroup.range.max);

            margin = Math.round((spaceInBetween - groupsSize) / (groups.length - 1));

            if (margin < groups.length - 1) {
                return;
            }

            forEach(groups, function (group, groupIdx) {
                var delta = {},
                    prevGroup;

                if (group === firstGroup || group === lastGroup) {
                    return;
                }

                prevGroup = groups[groupIdx - 1];

                group.range.max = 0;

                forEach(group.elements, function (element, idx) {
                    delta[OFF_AXIS[axis]] = 0;
                    delta[axis] = (prevGroup.range.max - element[axis]) + margin;

                    if (group.range.min !== element[axis]) {
                        delta[axis] += element[axis] - group.range.min;
                    }

                    if (delta[axis]) {
                        modeling.moveElements([element], delta, element.parent);
                    }

                    group.range.max = Math.max(element[axis] + element[dimension], idx ? group.range.max : 0);
                });
            });
        };

        DistributeElements.prototype.postExecute = function (context) {

        };

    }, { "lodash/collection/forEach": 304, "lodash/collection/sortBy": 311 }], 187: [function (require, module, exports) {
        'use strict';

        var assign = require('lodash/object/assign');


        /**
         * A handler that implements reversible moving of shapes.
         */
        function LayoutConnectionHandler(layouter, canvas) {
            this._layouter = layouter;
            this._canvas = canvas;
        }

        LayoutConnectionHandler.$inject = ['layouter', 'canvas'];

        module.exports = LayoutConnectionHandler;

        LayoutConnectionHandler.prototype.execute = function (context) {

            var connection = context.connection,
                parent = connection.parent,
                connectionSiblings = parent.children;

            var oldIndex = connectionSiblings.indexOf(connection);

            var oldWaypoints = connection.waypoints;

            assign(context, {
                oldWaypoints: oldWaypoints,
                oldIndex: oldIndex
            });

            sendToFront(connection);

            connection.waypoints = this._layouter.layoutConnection(connection, context.hints);

            return connection;
        };

        LayoutConnectionHandler.prototype.revert = function (context) {

            var connection = context.connection,
                parent = connection.parent,
                connectionSiblings = parent.children,
                currentIndex = connectionSiblings.indexOf(connection),
                oldIndex = context.oldIndex;

            connection.waypoints = context.oldWaypoints;

            if (oldIndex !== currentIndex) {

                // change position of connection in shape
                connectionSiblings.splice(currentIndex, 1);
                connectionSiblings.splice(oldIndex, 0, connection);
            }

            return connection;
        };


        ////////////// helpers /////////////////////////////////////


        // connections should have a higher z-order as there source and targets
        function sendToFront(connection) {

            var connectionSiblings = connection.parent.children;

            var connectionIdx = connectionSiblings.indexOf(connection),
                sourceIdx = findIndex(connectionSiblings, connection.source),
                targetIdx = findIndex(connectionSiblings, connection.target),

                // ensure we do not send the connection back
                // if it is already in front
                insertIndex = Math.max(sourceIdx + 1, targetIdx + 1, connectionIdx);

            if (connectionIdx < insertIndex) {
                connectionSiblings.splice(insertIndex, 0, connection); // add to new position
                connectionSiblings.splice(connectionIdx, 1); // remove from old position
            }

            function findIndex(array, obj) {

                var index = array.indexOf(obj);
                if (index < 0 && obj) {
                    var parent = obj.parent;
                    index = findIndex(array, parent);
                }
                return index;
            }

            return insertIndex;
        }

    }, { "lodash/object/assign": 433 }], 188: [function (require, module, exports) {
        'use strict';

        var forEach = require('lodash/collection/forEach');

        var Collections = require('../../../util/Collections');


        /**
         * A handler that implements reversible moving of connections.
         *
         * The handler differs from the layout connection handler in a sense
         * that it preserves the connection layout.
         */
        function MoveConnectionHandler() { }

        module.exports = MoveConnectionHandler;


        MoveConnectionHandler.prototype.execute = function (context) {

            var connection = context.connection,
                delta = context.delta;

            var newParent = context.newParent || connection.parent,
                newParentIndex = context.newParentIndex,
                oldParent = connection.parent;

            // save old parent in context
            context.oldParent = oldParent;
            context.oldParentIndex = Collections.remove(oldParent.children, connection);

            // add to new parent at position
            Collections.add(newParent.children, connection, newParentIndex);

            // update parent
            connection.parent = newParent;

            // update waypoint positions
            forEach(connection.waypoints, function (p) {
                p.x += delta.x;
                p.y += delta.y;

                if (p.original) {
                    p.original.x += delta.x;
                    p.original.y += delta.y;
                }
            });

            return connection;
        };

        MoveConnectionHandler.prototype.revert = function (context) {

            var connection = context.connection,
                newParent = connection.parent,
                oldParent = context.oldParent,
                oldParentIndex = context.oldParentIndex,
                delta = context.delta;

            // remove from newParent
            Collections.remove(newParent.children, connection);

            // restore previous location in old parent
            Collections.add(oldParent.children, connection, oldParentIndex);

            // restore parent
            connection.parent = oldParent;

            // revert to old waypoint positions
            forEach(connection.waypoints, function (p) {
                p.x -= delta.x;
                p.y -= delta.y;

                if (p.original) {
                    p.original.x -= delta.x;
                    p.original.y -= delta.y;
                }
            });

            return connection;
        };
    }, { "../../../util/Collections": 263, "lodash/collection/forEach": 304 }], 189: [function (require, module, exports) {
        'use strict';

        var MoveHelper = require('./helper/MoveHelper');


        /**
         * A handler that implements reversible moving of shapes.
         */
        function MoveElementsHandler(modeling) {
            this._helper = new MoveHelper(modeling);
        }

        MoveElementsHandler.$inject = ['modeling'];

        module.exports = MoveElementsHandler;

        MoveElementsHandler.prototype.preExecute = function (context) {
            context.closure = this._helper.getClosure(context.shapes);
        };

        MoveElementsHandler.prototype.postExecute = function (context) {

            var hints = context.hints,
                primaryShape;

            if (hints && hints.primaryShape) {
                primaryShape = hints.primaryShape;
                hints.oldParent = primaryShape.parent;
            }

            this._helper.moveClosure(context.closure, context.delta, context.newParent, context.newHost, primaryShape);
        };


        MoveElementsHandler.prototype.execute = function (context) { };
        MoveElementsHandler.prototype.revert = function (context) { };

    }, { "./helper/MoveHelper": 201 }], 190: [function (require, module, exports) {
        'use strict';

        var assign = require('lodash/object/assign'),
            forEach = require('lodash/collection/forEach'),
            pick = require('lodash/object/pick');

        var MoveHelper = require('./helper/MoveHelper'),
            Collections = require('../../../util/Collections');

        var getMovedSourceAnchor = require('./helper/AnchorsHelper').getMovedSourceAnchor,
            getMovedTargetAnchor = require('./helper/AnchorsHelper').getMovedTargetAnchor;


        /**
         * A handler that implements reversible moving of shapes.
         */
        function MoveShapeHandler(modeling) {
            this._modeling = modeling;

            this._helper = new MoveHelper(modeling);
        }

        MoveShapeHandler.$inject = ['modeling'];

        module.exports = MoveShapeHandler;


        MoveShapeHandler.prototype.execute = function (context) {

            var shape = context.shape,
                delta = context.delta,
                newParent = context.newParent || shape.parent,
                newParentIndex = context.newParentIndex,
                oldParent = shape.parent;

            context.oldBounds = pick(shape, ['x', 'y', 'width', 'height']);

            // save old parent in context
            context.oldParent = oldParent;
            context.oldParentIndex = Collections.remove(oldParent.children, shape);

            // add to new parent at position
            Collections.add(newParent.children, shape, newParentIndex);

            // update shape parent + position
            assign(shape, {
                parent: newParent,
                x: shape.x + delta.x,
                y: shape.y + delta.y
            });

            return shape;
        };

        MoveShapeHandler.prototype.postExecute = function (context) {

            var shape = context.shape,
                delta = context.delta,
                hints = context.hints;

            var modeling = this._modeling;

            if (hints.layout !== false) {

                forEach(shape.incoming, function (c) {
                    modeling.layoutConnection(c, {
                        connectionEnd: getMovedTargetAnchor(c, shape, delta)
                    });
                });

                forEach(shape.outgoing, function (c) {
                    modeling.layoutConnection(c, {
                        connectionStart: getMovedSourceAnchor(c, shape, delta)
                    });
                });
            }

            if (hints.recurse !== false) {
                this.moveChildren(context);
            }
        };

        MoveShapeHandler.prototype.revert = function (context) {

            var shape = context.shape,
                oldParent = context.oldParent,
                oldParentIndex = context.oldParentIndex,
                delta = context.delta;

            // restore previous location in old parent
            Collections.add(oldParent.children, shape, oldParentIndex);

            // revert to old position and parent
            assign(shape, {
                parent: oldParent,
                x: shape.x - delta.x,
                y: shape.y - delta.y
            });

            return shape;
        };

        MoveShapeHandler.prototype.moveChildren = function (context) {

            var delta = context.delta,
                shape = context.shape;

            this._helper.moveRecursive(shape.children, delta, null);
        };

        MoveShapeHandler.prototype.getNewParent = function (context) {
            return context.newParent || context.shape.parent;
        };

    }, { "../../../util/Collections": 263, "./helper/AnchorsHelper": 200, "./helper/MoveHelper": 201, "lodash/collection/forEach": 304, "lodash/object/assign": 433, "lodash/object/pick": 440 }], 191: [function (require, module, exports) {
        'use strict';

        function NoopHandler() { }

        module.exports = NoopHandler;

        NoopHandler.prototype.execute = function () { };
        NoopHandler.prototype.revert = function () { };
    }, {}], 192: [function (require, module, exports) {
        'use strict';

        var forEach = require('lodash/collection/forEach'),
            map = require('lodash/collection/map'),
            sortBy = require('lodash/collection/sortBy'),
            clone = require('lodash/lang/clone');

        var inherits = require('inherits');



        function removeProperties(element, properties) {
            forEach(properties, function (prop) {
                if (element[prop]) {
                    delete element[prop];
                }
            });
        }

        /**
         * A handler that implements pasting of elements onto the diagram.
         *
         * @param {eventBus} EventBus
         * @param {canvas} Canvas
         * @param {selection} Selection
         * @param {elementFactory} ElementFactory
         * @param {modeling} Modeling
         * @param {rules} Rules
         */
        function PasteHandler(eventBus, canvas, selection, elementFactory, modeling, rules) {
            this._eventBus = eventBus;
            this._canvas = canvas;
            this._selection = selection;
            this._elementFactory = elementFactory;
            this._modeling = modeling;
            this._rules = rules;
        }

        inherits(PasteHandler, require('./NoopHandler'));


        PasteHandler.$inject = [
            'eventBus',
            'canvas',
            'selection',
            'elementFactory',
            'modeling',
            'rules'
        ];

        module.exports = PasteHandler;


        ////// api /////////////////////////////////////////////

        /**
         * Creates a new shape
         *
         * @param {Object} context
         * @param {Object} context.tree the new shape
         * @param {Element} context.topParent the paste target
         */
        PasteHandler.prototype.preExecute = function (context) {
            var eventBus = this._eventBus;

            var tree = context.tree,
                topParent = context.topParent,
                position = context.position;

            tree.createdElements = {};

            tree.labels = [];

            forEach(tree, function (elements, depthStr) {
                var depth = parseInt(depthStr, 10);

                if (isNaN(depth)) {
                    return;
                }

                // set the parent on the top level elements
                if (!depth) {
                    elements = map(elements, function (descriptor) {
                        descriptor.parent = topParent;

                        return descriptor;
                    });
                }

                // Order by priority for element creation
                elements = sortBy(elements, 'priority');

                forEach(elements, function (descriptor) {
                    var id = descriptor.id,
                        parent = descriptor.parent,
                        isAttach = false,
                        hints,
                        newPosition;

                    var element = clone(descriptor);

                    if (depth) {
                        element.parent = this._getCreatedElement(parent, tree);
                    }

                    // this happens when shapes have not been created due to rules
                    if (!parent) {
                        return;
                    }

                    eventBus.fire('element.paste', {
                        createdElements: tree.createdElements,
                        descriptor: element
                    });

                    // in case the parent changed during 'element.paste'
                    parent = element.parent;

                    if (element.waypoints) {
                        element = this._createConnection(element, parent, position, tree);

                        if (element) {
                            tree.createdElements[id] = {
                                element: element,
                                descriptor: descriptor
                            };
                        }

                        return;
                    }

                    // supply not-root information as hint
                    if (element.parent !== topParent) {
                        hints = { root: false };
                    }

                    // set host
                    if (element.host) {
                        isAttach = true;

                        parent = this._getCreatedElement(element.host, tree);
                    }

                    // handle labels
                    if (element.labelTarget) {
                        return tree.labels.push(element);
                    }

                    newPosition = {
                        x: Math.round(position.x + element.delta.x + (element.width / 2)),
                        y: Math.round(position.y + element.delta.y + (element.height / 2))
                    };

                    removeProperties(element, ['id', 'parent', 'delta', 'host', 'priority']);

                    element = this._createShape(element, parent, newPosition, isAttach, hints);

                    if (element) {
                        tree.createdElements[id] = {
                            element: element,
                            descriptor: descriptor
                        };
                    }
                }, this);
            }, this);
        };

        // move label's to their relative position
        PasteHandler.prototype.postExecute = function (context) {
            var modeling = this._modeling,
                selection = this._selection;

            var tree = context.tree,
                labels = tree.labels,
                topLevelElements = [];

            forEach(labels, function (labelDescriptor) {
                var labelTarget = this._getCreatedElement(labelDescriptor.labelTarget, tree),
                    label, labelTargetPos, newPosition;

                if (!labelTarget) {
                    return;
                }

                label = labelTarget.label;

                if (!label) {
                    return;
                }

                labelTargetPos = {
                    x: labelTarget.x,
                    y: labelTarget.y
                };

                if (labelTarget.waypoints) {
                    labelTargetPos = labelTarget.waypoints[0];
                }

                newPosition = {
                    x: Math.round((labelTargetPos.x - label.x) + labelDescriptor.delta.x),
                    y: Math.round((labelTargetPos.y - label.y) + labelDescriptor.delta.y)
                };

                modeling.moveShape(label, newPosition, labelTarget.parent);
            }, this);

            forEach(tree[0], function (descriptor) {
                var id = descriptor.id,
                    toplevel = tree.createdElements[id];

                if (toplevel) {
                    topLevelElements.push(toplevel.element);
                }
            });

            selection.select(topLevelElements);
        };


        PasteHandler.prototype._createConnection = function (element, parent, parentCenter, tree) {
            var modeling = this._modeling,
                rules = this._rules;

            var connection, source, target, canPaste;

            element.waypoints = map(element.waypoints, function (waypoint, idx) {
                return {
                    x: Math.round(parentCenter.x + element.delta[idx].x),
                    y: Math.round(parentCenter.y + element.delta[idx].y)
                };
            });

            source = this._getCreatedElement(element.source, tree);
            target = this._getCreatedElement(element.target, tree);

            if (!source || !target) {
                return null;
            }

            canPaste = rules.allowed('element.paste', {
                source: source,
                target: target
            });

            if (!canPaste) {
                return null;
            }

            removeProperties(element, ['id', 'parent', 'delta', 'source', 'target', 'width', 'height', 'priority']);

            connection = modeling.createConnection(source, target, element, parent);

            return connection;
        };


        PasteHandler.prototype._createShape = function (element, parent, position, isAttach, hints) {
            var modeling = this._modeling,
                elementFactory = this._elementFactory,
                rules = this._rules;

            var canPaste = rules.allowed('element.paste', {
                element: element,
                position: position,
                parent: parent
            });

            if (!canPaste) {
                return null;
            }

            var shape = elementFactory.createShape(element);

            modeling.createShape(shape, position, parent, isAttach, hints);

            return shape;
        };


        PasteHandler.prototype._getCreatedElement = function (id, tree) {
            return tree.createdElements[id] && tree.createdElements[id].element;
        };

    }, { "./NoopHandler": 191, "inherits": 289, "lodash/collection/forEach": 304, "lodash/collection/map": 306, "lodash/collection/sortBy": 311, "lodash/lang/clone": 422 }], 193: [function (require, module, exports) {
        'use strict';

        var isArray = require('lodash/lang/isArray');


        /**
         * Reconnect connection handler
         */
        function ReconnectConnectionHandler() { }

        ReconnectConnectionHandler.$inject = [];

        module.exports = ReconnectConnectionHandler;

        ReconnectConnectionHandler.prototype.execute = function (context) {

            var newSource = context.newSource,
                newTarget = context.newTarget,
                connection = context.connection,
                dockingOrPoints = context.dockingOrPoints,
                oldWaypoints = connection.waypoints,
                newWaypoints;

            if (!newSource && !newTarget) {
                throw new Error('newSource or newTarget are required');
            }

            if (newSource && newTarget) {
                throw new Error('must specify either newSource or newTarget');
            }

            context.oldWaypoints = oldWaypoints;

            if (isArray(dockingOrPoints)) {
                newWaypoints = dockingOrPoints;
            } else {
                newWaypoints = oldWaypoints.slice();

                newWaypoints.splice(newSource ? 0 : -1, 1, dockingOrPoints);
            }

            if (newSource) {
                context.oldSource = connection.source;
                connection.source = newSource;
            }

            if (newTarget) {
                context.oldTarget = connection.target;
                connection.target = newTarget;
            }

            connection.waypoints = newWaypoints;

            return connection;
        };

        ReconnectConnectionHandler.prototype.revert = function (context) {

            var newSource = context.newSource,
                newTarget = context.newTarget,
                connection = context.connection;

            if (newSource) {
                connection.source = context.oldSource;
            }

            if (newTarget) {
                connection.target = context.oldTarget;
            }

            connection.waypoints = context.oldWaypoints;

            return connection;
        };
    }, { "lodash/lang/isArray": 424 }], 194: [function (require, module, exports) {
        'use strict';

        var forEach = require('lodash/collection/forEach');


        /**
         * A handler that implements reversible replacing of shapes.
         * Internally the old shape will be removed and the new shape will be added.
         *
         *
         * @class
         * @constructor
         *
         * @param {canvas} Canvas
         */
        function ReplaceShapeHandler(modeling, rules) {
            this._modeling = modeling;
            this._rules = rules;
        }

        ReplaceShapeHandler.$inject = ['modeling', 'rules'];

        module.exports = ReplaceShapeHandler;



        ////// api /////////////////////////////////////////


        /**
         * Replaces a shape with an replacement Element.
         *
         * The newData object should contain type, x, y.
         *
         * If possible also the incoming/outgoing connection
         * will be restored.
         *
         * @param {Object} context
         */
        ReplaceShapeHandler.prototype.preExecute = function (context) {

            var self = this,
                modeling = this._modeling,
                rules = this._rules;

            var oldShape = context.oldShape,
                newData = context.newData,
                hints = context.hints,
                newShape;

            function canReconnect(type, source, target, connection) {
                return rules.allowed(type, {
                    source: source,
                    target: target,
                    connection: connection
                });
            }


            // (1) place a new shape at the given position

            var position = {
                x: newData.x,
                y: newData.y
            };

            newShape = context.newShape = context.newShape || self.createShape(newData, position, oldShape.parent);


            // (2) update the host

            if (oldShape.host) {
                modeling.updateAttachment(newShape, oldShape.host);
            }


            // (3) adopt all children from the old shape

            var children;

            if (hints.moveChildren !== false) {
                children = oldShape.children.slice();

                modeling.moveElements(children, { x: 0, y: 0 }, newShape);
            }

            // (4) reconnect connections to the new shape (where allowed)

            var incoming = oldShape.incoming.slice(),
                outgoing = oldShape.outgoing.slice();

            forEach(incoming, function (connection) {
                var waypoints = connection.waypoints,
                    docking = waypoints[waypoints.length - 1],
                    source = connection.source,
                    allowed = canReconnect('connection.reconnectEnd', source, newShape, connection);

                if (allowed) {
                    self.reconnectEnd(connection, newShape, docking);
                }
            });

            forEach(outgoing, function (connection) {
                var waypoints = connection.waypoints,
                    docking = waypoints[0],
                    target = connection.target,
                    allowed = canReconnect('connection.reconnectStart', newShape, target, connection);

                if (allowed) {
                    self.reconnectStart(connection, newShape, docking);
                }

            });
        };


        ReplaceShapeHandler.prototype.postExecute = function (context) {
            var modeling = this._modeling;

            var oldShape = context.oldShape,
                newShape = context.newShape;

            // if an element gets resized on replace, layout the connection again
            forEach(newShape.incoming, function (c) {
                modeling.layoutConnection(c, { endChanged: true });
            });

            forEach(newShape.outgoing, function (c) {
                modeling.layoutConnection(c, { startChanged: true });
            });

            modeling.removeShape(oldShape);
        };


        ReplaceShapeHandler.prototype.execute = function (context) { };

        ReplaceShapeHandler.prototype.revert = function (context) { };


        ReplaceShapeHandler.prototype.createShape = function (shape, position, target) {
            var modeling = this._modeling;
            return modeling.createShape(shape, position, target);
        };


        ReplaceShapeHandler.prototype.reconnectStart = function (connection, newSource, dockingPoint) {
            var modeling = this._modeling;
            modeling.reconnectStart(connection, newSource, dockingPoint);
        };


        ReplaceShapeHandler.prototype.reconnectEnd = function (connection, newTarget, dockingPoint) {
            var modeling = this._modeling;
            modeling.reconnectEnd(connection, newTarget, dockingPoint);
        };

    }, { "lodash/collection/forEach": 304 }], 195: [function (require, module, exports) {
        'use strict';

        var assign = require('lodash/object/assign'),
            forEach = require('lodash/collection/forEach');

        var getResizedSourceAnchor = require('./helper/AnchorsHelper').getResizedSourceAnchor,
            getResizedTargetAnchor = require('./helper/AnchorsHelper').getResizedTargetAnchor;

        /**
         * A handler that implements reversible resizing of shapes.
         *
         * @param {Modeling} modeling
         */
        function ResizeShapeHandler(modeling) {
            this._modeling = modeling;
        }

        ResizeShapeHandler.$inject = ['modeling'];

        module.exports = ResizeShapeHandler;

        /**
         * {
         *   shape: {....}
         *   newBounds: {
         *     width:  20,
         *     height: 40,
         *     x:       5,
         *     y:      10
         *   }
         *
         * }
         */
        ResizeShapeHandler.prototype.execute = function (context) {
            var shape = context.shape,
                newBounds = context.newBounds,
                minBounds = context.minBounds;

            if (newBounds.x === undefined || newBounds.y === undefined ||
                newBounds.width === undefined || newBounds.height === undefined) {
                throw new Error('newBounds must have {x, y, width, height} properties');
            }

            if (minBounds && (newBounds.width < minBounds.width
                || newBounds.height < minBounds.height)) {
                throw new Error('width and height cannot be less than minimum height and width');
            } else if (!minBounds
                && newBounds.width < 10 || newBounds.height < 10) {
                throw new Error('width and height cannot be less than 10px');
            }

            // save old bbox in context
            context.oldBounds = {
                width: shape.width,
                height: shape.height,
                x: shape.x,
                y: shape.y
            };

            // update shape
            assign(shape, {
                width: newBounds.width,
                height: newBounds.height,
                x: newBounds.x,
                y: newBounds.y
            });

            return shape;
        };

        ResizeShapeHandler.prototype.postExecute = function (context) {

            var shape = context.shape,
                oldBounds = context.oldBounds;

            var modeling = this._modeling;

            forEach(shape.incoming, function (c) {
                modeling.layoutConnection(c, {
                    connectionEnd: getResizedTargetAnchor(c, shape, oldBounds)
                });
            });

            forEach(shape.outgoing, function (c) {
                modeling.layoutConnection(c, {
                    connectionStart: getResizedSourceAnchor(c, shape, oldBounds)
                });
            });

        };

        ResizeShapeHandler.prototype.revert = function (context) {

            var shape = context.shape,
                oldBounds = context.oldBounds;

            // restore previous bbox
            assign(shape, {
                width: oldBounds.width,
                height: oldBounds.height,
                x: oldBounds.x,
                y: oldBounds.y
            });

            return shape;
        };

    }, { "./helper/AnchorsHelper": 200, "lodash/collection/forEach": 304, "lodash/object/assign": 433 }], 196: [function (require, module, exports) {
        'use strict';

        var forEach = require('lodash/collection/forEach');

        var SpaceUtil = require('../../space-tool/SpaceUtil');

        /**
         * A handler that implements reversible creating and removing of space.
         *
         * It executes in two phases:
         *
         *  (1) resize all affected resizeShapes
         *  (2) move all affected moveElements
         */
        function SpaceToolHandler(modeling) {
            this._modeling = modeling;
        }

        SpaceToolHandler.$inject = ['modeling'];

        module.exports = SpaceToolHandler;


        SpaceToolHandler.prototype.preExecute = function (context) {

            // resize
            var modeling = this._modeling,
                resizingShapes = context.resizingShapes,
                delta = context.delta,
                direction = context.direction;

            forEach(resizingShapes, function (shape) {
                var newBounds = SpaceUtil.resizeBounds(shape, direction, delta);

                modeling.resizeShape(shape, newBounds);
            });
        };

        SpaceToolHandler.prototype.postExecute = function (context) {
            // move
            var modeling = this._modeling,
                movingShapes = context.movingShapes,
                delta = context.delta;

            modeling.moveElements(movingShapes, delta, undefined, false, { autoResize: false });
        };

        SpaceToolHandler.prototype.execute = function (context) { };
        SpaceToolHandler.prototype.revert = function (context) { };

    }, { "../../space-tool/SpaceUtil": 239, "lodash/collection/forEach": 304 }], 197: [function (require, module, exports) {
        'use strict';

        /**
         * A handler that toggles the collapsed state of an element
         * and the visibility of all its children.
         *
         * @param {Modeling} modeling
         */
        function ToggleShapeCollapseHandler(modeling) {
            this._modeling = modeling;
        }

        ToggleShapeCollapseHandler.$inject = ['modeling'];

        module.exports = ToggleShapeCollapseHandler;


        ToggleShapeCollapseHandler.prototype.execute = function (context) {

            var shape = context.shape,
                children = shape.children;

            // remember previous visibility of children
            context.oldChildrenVisibility = getElementsVisibility(children);

            // toggle state
            shape.collapsed = !shape.collapsed;

            // hide/show children
            setHidden(children, shape.collapsed);

            return [shape].concat(children);
        };


        ToggleShapeCollapseHandler.prototype.revert = function (context) {

            var shape = context.shape,
                oldChildrenVisibility = context.oldChildrenVisibility;

            var children = shape.children;

            // set old visability of children
            restoreVisibility(children, oldChildrenVisibility);

            // retoggle state
            shape.collapsed = !shape.collapsed;

            return [shape].concat(children);
        };


        /////// helpers ///////////////////////////////

        /**
         * Return a map { elementId -> hiddenState}.
         *
         * @param {Array<djs.model.Shape>} elements
         *
         * @return {Object}
         */
        function getElementsVisibility(elements) {

            var result = {};

            elements.forEach(function (e) {
                result[e.id] = e.hidden;
            });

            return result;
        }


        function setHidden(elements, newHidden) {
            elements.forEach(function (element) {
                element.hidden = newHidden;
            });
        }

        function restoreVisibility(elements, lastState) {
            elements.forEach(function (e) {
                e.hidden = lastState[e.id];
            });
        }

    }, {}], 198: [function (require, module, exports) {
        'use strict';

        var Collections = require('../../../util/Collections');

        /**
         * A handler that implements reversible attaching/detaching of shapes.
         */
        function UpdateAttachmentHandler(modeling) {
            this._modeling = modeling;
        }

        module.exports = UpdateAttachmentHandler;

        UpdateAttachmentHandler.$inject = ['modeling'];


        UpdateAttachmentHandler.prototype.execute = function (context) {
            var shape = context.shape,
                newHost = context.newHost,
                oldHost = shape.host;

            // (0) detach from old host
            context.oldHost = oldHost;
            context.attacherIdx = removeAttacher(oldHost, shape);

            // (1) attach to new host
            addAttacher(newHost, shape);

            // (2) update host
            shape.host = newHost;

            return shape;
        };

        UpdateAttachmentHandler.prototype.revert = function (context) {
            var shape = context.shape,
                newHost = context.newHost,
                oldHost = context.oldHost,
                attacherIdx = context.attacherIdx;

            // (2) update host
            shape.host = oldHost;

            // (1) attach to new host
            removeAttacher(newHost, shape);

            // (0) detach from old host
            addAttacher(oldHost, shape, attacherIdx);

            return shape;
        };


        function removeAttacher(host, attacher) {
            // remove attacher from host
            return Collections.remove(host && host.attachers, attacher);
        }

        function addAttacher(host, attacher, idx) {

            if (!host) {
                return;
            }

            var attachers = host.attachers;

            if (!attachers) {
                host.attachers = attachers = [];
            }

            Collections.add(attachers, attacher, idx);
        }

    }, { "../../../util/Collections": 263 }], 199: [function (require, module, exports) {
        'use strict';

        function UpdateWaypointsHandler() { }

        module.exports = UpdateWaypointsHandler;

        UpdateWaypointsHandler.prototype.execute = function (context) {

            var connection = context.connection,
                newWaypoints = context.newWaypoints;

            context.oldWaypoints = connection.waypoints;

            connection.waypoints = newWaypoints;

            return connection;
        };

        UpdateWaypointsHandler.prototype.revert = function (context) {

            var connection = context.connection,
                oldWaypoints = context.oldWaypoints;

            connection.waypoints = oldWaypoints;

            return connection;
        };
    }, {}], 200: [function (require, module, exports) {
        'use strict';

        var getNewAttachPoint = require('../../../../util/AttachUtil').getNewAttachPoint;

        function getResizedSourceAnchor(connection, shape, oldBounds) {

            var waypoints = safeGetWaypoints(connection),
                oldAnchor = waypoints[0];

            return getNewAttachPoint(oldAnchor.original || oldAnchor, oldBounds, shape);
        }

        module.exports.getResizedSourceAnchor = getResizedSourceAnchor;


        function getResizedTargetAnchor(connection, shape, oldBounds) {

            var waypoints = safeGetWaypoints(connection),
                oldAnchor = waypoints[waypoints.length - 1];

            return getNewAttachPoint(oldAnchor.original || oldAnchor, oldBounds, shape);
        }

        module.exports.getResizedTargetAnchor = getResizedTargetAnchor;


        function getMovedSourceAnchor(connection, source, moveDelta) {
            return getResizedSourceAnchor(connection, source, substractPosition(source, moveDelta));
        }

        module.exports.getMovedSourceAnchor = getMovedSourceAnchor;


        function getMovedTargetAnchor(connection, target, moveDelta) {
            return getResizedTargetAnchor(connection, target, substractPosition(target, moveDelta));
        }

        module.exports.getMovedTargetAnchor = getMovedTargetAnchor;


        //////// helpers ////////////////////////////////////

        function substractPosition(bounds, delta) {
            return {
                x: bounds.x - delta.x,
                y: bounds.y - delta.y,
                width: bounds.width,
                height: bounds.height
            };
        }


        /**
         * Return waypoints of given connection; throw if non exists (should not happen!!).
         *
         * @param {Connection} connection
         *
         * @return {Array<Point>}
         */
        function safeGetWaypoints(connection) {

            var waypoints = connection.waypoints;

            if (!waypoints.length) {
                throw new Error('connection#' + connection.id + ': no waypoints');
            }

            return waypoints;
        }

    }, { "../../../../util/AttachUtil": 261 }], 201: [function (require, module, exports) {
        'use strict';

        var forEach = require('lodash/collection/forEach');

        var Elements = require('../../../../util/Elements');

        var getMovedSourceAnchor = require('./AnchorsHelper').getMovedSourceAnchor,
            getMovedTargetAnchor = require('./AnchorsHelper').getMovedTargetAnchor;

        /**
         * A helper that is able to carry out serialized move operations on multiple elements.
         *
         * @param {Modeling} modeling
         */
        function MoveHelper(modeling) {
            this._modeling = modeling;
        }

        module.exports = MoveHelper;

        /**
         * Move the specified elements and all children by the given delta.
         *
         * This moves all enclosed connections, too and layouts all affected
         * external connections.
         *
         * @param  {Array<djs.model.Base>} elements
         * @param  {Point} delta
         * @param  {djs.model.Base} newParent applied to the first level of shapes
         *
         * @return {Array<djs.model.Base>} list of touched elements
         */
        MoveHelper.prototype.moveRecursive = function (elements, delta, newParent) {
            if (!elements) {
                return [];
            } else {
                return this.moveClosure(this.getClosure(elements), delta, newParent);
            }
        };

        /**
         * Move the given closure of elmements.
         *
         * @param {Object} closure
         * @param {Point} delta
         * @param {djs.model.Base} [newParent]
         * @param {djs.model.Base} [newHost]
         */
        MoveHelper.prototype.moveClosure = function (closure, delta, newParent, newHost, primaryShape) {
            var modeling = this._modeling;

            var allShapes = closure.allShapes,
                allConnections = closure.allConnections,
                enclosedConnections = closure.enclosedConnections,
                topLevel = closure.topLevel,
                keepParent = false;

            if (primaryShape && primaryShape.parent === newParent) {
                keepParent = true;
            }

            // move all shapes
            forEach(allShapes, function (shape) {

                // move the element according to the given delta
                modeling.moveShape(shape, delta, topLevel[shape.id] && !keepParent && newParent, {
                    recurse: false,
                    layout: false
                });
            });

            // move all child connections / layout external connections
            forEach(allConnections, function (c) {

                var sourceMoved = !!allShapes[c.source.id],
                    targetMoved = !!allShapes[c.target.id];

                if (enclosedConnections[c.id] && sourceMoved && targetMoved) {
                    modeling.moveConnection(c, delta, topLevel[c.id] && !keepParent && newParent);
                } else {
                    modeling.layoutConnection(c, {
                        connectionStart: sourceMoved && getMovedSourceAnchor(c, c.source, delta),
                        connectionEnd: targetMoved && getMovedTargetAnchor(c, c.target, delta)
                    });
                }
            });
        };

        /**
         * Returns the closure for the selected elements
         *
         * @param  {Array<djs.model.Base>} elements
         * @return {Object} closure
         */
        MoveHelper.prototype.getClosure = function (elements) {
            return Elements.getClosure(elements);
        };

    }, { "../../../../util/Elements": 266, "./AnchorsHelper": 200, "lodash/collection/forEach": 304 }], 202: [function (require, module, exports) {
        'use strict';

        var bind = require('lodash/function/bind');


        function MouseTracking(eventBus, canvas) {
            this._eventBus = eventBus;
            this._canvas = canvas;

            this._init();
        }

        MouseTracking.$inject = [
            'eventBus',
            'canvas'
        ];

        module.exports = MouseTracking;


        MouseTracking.prototype.getHoverContext = function () {
            var viewbox = this._canvas.viewbox();

            return {
                element: this._hoverElement,
                point: {
                    x: viewbox.x + Math.round(this._mouseX / viewbox.scale),
                    y: viewbox.y + Math.round(this._mouseY / viewbox.scale)
                }
            };
        };

        MouseTracking.prototype._init = function () {
            var eventBus = this._eventBus,
                canvas = this._canvas;

            var container = canvas.getContainer();

            this._setMousePosition = bind(this._setMousePosition, this);

            container.addEventListener('mousemove', this._setMousePosition);

            eventBus.on('diagram.destroy', function () {
                container.removeEventListener('mousemove', this._setMousePosition);
            }, this);

            eventBus.on('element.hover', this._setHoverElement, this);
        };


        MouseTracking.prototype._setHoverElement = function (event) {
            this._hoverElement = event.element;
        };


        MouseTracking.prototype._setMousePosition = function (event) {
            this._mouseX = event.layerX;
            this._mouseY = event.layerY;
        };

    }, { "lodash/function/bind": 313 }], 203: [function (require, module, exports) {
        'use strict';

        module.exports = {
            __init__: ['mouseTracking'],
            mouseTracking: ['type', require('./MouseTracking')]
        };

    }, { "./MouseTracking": 202 }], 204: [function (require, module, exports) {
        'use strict';

        var assign = require('lodash/object/assign'),
            filter = require('lodash/collection/filter'),
            groupBy = require('lodash/collection/groupBy');

        var LOW_PRIORITY = 500,
            MEDIUM_PRIORITY = 1250,
            HIGH_PRIORITY = 1500;

        var getOriginalEvent = require('../../util/Event').getOriginal;

        var round = Math.round;

        function mid(element) {
            return {
                x: element.x + round(element.width / 2),
                y: element.y + round(element.height / 2)
            };
        }

        /**
         * A plugin that makes shapes draggable / droppable.
         *
         * @param {EventBus} eventBus
         * @param {Dragging} dragging
         * @param {Modeling} modeling
         * @param {Selection} selection
         * @param {Rules} rules
         */
        function MoveEvents(eventBus, dragging, modeling, selection, rules) {

            // rules

            function canMove(shapes, delta, position, target) {

                return rules.allowed('elements.move', {
                    shapes: shapes,
                    delta: delta,
                    position: position,
                    target: target
                });
            }


            // move events

            // assign a high priority to this handler to setup the environment
            // others may hook up later, e.g. at default priority and modify
            // the move environment.
            //
            // This sets up the context with
            //
            // * shape: the primary shape being moved
            // * shapes: a list of shapes to be moved
            // * validatedShapes: a list of shapes that are being checked
            //                    against the rules before and during move
            //
            eventBus.on('shape.move.start', HIGH_PRIORITY, function (event) {

                var context = event.context,
                    shape = event.shape,
                    shapes = selection.get().slice();

                // move only single shape if the dragged element
                // is not part of the current selection
                if (shapes.indexOf(shape) === -1) {
                    shapes = [shape];
                }

                // ensure we remove nested elements in the collection
                // and add attachers for a proper dragger
                shapes = removeNested(shapes);

                // attach shapes to drag context
                assign(context, {
                    shapes: shapes,
                    validatedShapes: shapes,
                    shape: shape
                });
            });


            // assign a high priority to this handler to setup the environment
            // others may hook up later, e.g. at default priority and modify
            // the move environment
            //
            eventBus.on('shape.move.start', MEDIUM_PRIORITY, function (event) {

                var context = event.context,
                    validatedShapes = context.validatedShapes,
                    canExecute;

                canExecute = context.canExecute = canMove(validatedShapes);

                // check if we can move the elements
                if (!canExecute) {
                    // suppress move operation
                    event.stopPropagation();

                    return false;
                }
            });

            // assign a low priority to this handler
            // to let others modify the move event before we update
            // the context
            //
            eventBus.on('shape.move.move', LOW_PRIORITY, function (event) {

                var context = event.context,
                    validatedShapes = context.validatedShapes,
                    hover = event.hover,
                    delta = { x: event.dx, y: event.dy },
                    position = { x: event.x, y: event.y },
                    canExecute;

                // check if we can move the elements
                canExecute = canMove(validatedShapes, delta, position, hover);

                context.delta = delta;
                context.canExecute = canExecute;

                // simply ignore move over
                if (canExecute === null) {
                    context.target = null;

                    return;
                }

                context.target = hover;
            });

            eventBus.on('shape.move.end', function (event) {

                var context = event.context;

                var delta = context.delta,
                    canExecute = context.canExecute,
                    isAttach = canExecute === 'attach',
                    shapes = context.shapes;

                if (!canExecute) {
                    return false;
                }

                // ensure we have actual pixel values deltas
                // (important when zoom level was > 1 during move)
                delta.x = round(delta.x);
                delta.y = round(delta.y);

                modeling.moveElements(shapes, delta, context.target, isAttach, { primaryShape: context.shape });
            });


            // move activation

            eventBus.on('element.mousedown', function (event) {

                var originalEvent = getOriginalEvent(event);

                if (!originalEvent) {
                    throw new Error('must supply DOM mousedown event');
                }

                start(originalEvent, event.element);
            });


            function start(event, element, activate) {

                // do not move connections or the root element
                if (element.waypoints || !element.parent) {
                    return;
                }

                var referencePoint = mid(element);

                dragging.init(event, referencePoint, 'shape.move', {
                    cursor: 'grabbing',
                    autoActivate: activate,
                    data: {
                        shape: element,
                        context: {}
                    }
                });
            }

            // API

            this.start = start;
        }

        MoveEvents.$inject = ['eventBus', 'dragging', 'modeling', 'selection', 'rules'];

        module.exports = MoveEvents;


        /**
         * Return a filtered list of elements that do not contain
         * those nested into others.
         *
         * @param  {Array<djs.model.Base>} elements
         *
         * @return {Array<djs.model.Base>} filtered
         */
        function removeNested(elements) {

            var ids = groupBy(elements, 'id');

            return filter(elements, function (element) {
                while ((element = element.parent)) {

                    // parent in selection
                    if (ids[element.id]) {
                        return false;
                    }
                }

                return true;
            });
        }

    }, { "../../util/Event": 267, "lodash/collection/filter": 302, "lodash/collection/groupBy": 305, "lodash/object/assign": 433 }], 205: [function (require, module, exports) {
        'use strict';

        var flatten = require('lodash/array/flatten'),
            forEach = require('lodash/collection/forEach'),
            filter = require('lodash/collection/filter'),
            find = require('lodash/collection/find'),
            size = require('lodash/collection/size'),
            groupBy = require('lodash/collection/groupBy'),
            map = require('lodash/collection/map');

        var Elements = require('../../util/Elements');

        var svgAppend = require('tiny-svg/lib/append'),
            svgAttr = require('tiny-svg/lib/attr'),
            svgClear = require('tiny-svg/lib/clear'),
            svgCreate = require('tiny-svg/lib/create');

        var translate = require('../../util/SvgTransformUtil').translate;

        var LOW_PRIORITY = 500;

        var MARKER_DRAGGING = 'djs-dragging',
            MARKER_OK = 'drop-ok',
            MARKER_NOT_OK = 'drop-not-ok',
            MARKER_NEW_PARENT = 'new-parent',
            MARKER_ATTACH = 'attach-ok';

        /**
         * Provides previews for moving shapes when moving.
         *
         * @param {EventBus} eventBus
         * @param {ElementRegistry} elementRegistry
         * @param {Canvas} canvas
         * @param {Styles} styles
         */
        function MovePreview(eventBus, elementRegistry, canvas, styles, previewSupport) {

            function getVisualDragShapes(shapes) {
                var elements = getAllDraggedElements(shapes);

                var filteredElements = removeEdges(elements);

                return filteredElements;
            }

            function getAllDraggedElements(shapes) {
                var allShapes = Elements.selfAndAllChildren(shapes, true);

                var allConnections = map(allShapes, function (shape) {
                    return (shape.incoming || []).concat(shape.outgoing || []);
                });

                return flatten(allShapes.concat(allConnections), true);
            }

            /**
             * Sets drop marker on an element.
             */
            function setMarker(element, marker) {

                [MARKER_ATTACH, MARKER_OK, MARKER_NOT_OK, MARKER_NEW_PARENT].forEach(function (m) {

                    if (m === marker) {
                        canvas.addMarker(element, m);
                    } else {
                        canvas.removeMarker(element, m);
                    }
                });
            }

            function makeDraggable(context, element, addMarker) {

                previewSupport.addDragger(element, context.dragGroup);

                if (addMarker) {
                    canvas.addMarker(element, MARKER_DRAGGING);
                }

                if (context.allDraggedElements) {
                    context.allDraggedElements.push(element);
                } else {
                    context.allDraggedElements = [element];
                }
            }

            // expose to other components
            // that plug into the drag behavior
            this.makeDraggable = makeDraggable;

            // add previews
            eventBus.on('shape.move.start', LOW_PRIORITY, function (event) {

                var context = event.context,
                    dragShapes = context.shapes,
                    allDraggedElements = context.allDraggedElements;

                var visuallyDraggedShapes = getVisualDragShapes(dragShapes);

                if (!context.dragGroup) {
                    var dragGroup = svgCreate('g');
                    svgAttr(dragGroup, styles.cls('djs-drag-group', ['no-events']));

                    var defaultLayer = canvas.getDefaultLayer();

                    svgAppend(defaultLayer, dragGroup);

                    context.dragGroup = dragGroup;
                }

                // add previews
                visuallyDraggedShapes.forEach(function (shape) {
                    previewSupport.addDragger(shape, context.dragGroup);
                });

                // cache all dragged elements / gfx
                // so that we can quickly undo their state changes later
                if (!allDraggedElements) {
                    allDraggedElements = getAllDraggedElements(dragShapes);
                } else {
                    allDraggedElements = flatten(allDraggedElements, getAllDraggedElements(dragShapes));
                }

                // add dragging marker
                forEach(allDraggedElements, function (e) {
                    canvas.addMarker(e, MARKER_DRAGGING);
                });

                context.allDraggedElements = allDraggedElements;

                // determine, if any of the dragged elements have different parents
                context.differentParents = haveDifferentParents(dragShapes);
            });

            // update previews
            eventBus.on('shape.move.move', LOW_PRIORITY, function (event) {

                var context = event.context,
                    dragGroup = context.dragGroup,
                    target = context.target,
                    parent = context.shape.parent,
                    canExecute = context.canExecute;

                if (target) {
                    if (canExecute === 'attach') {
                        setMarker(target, MARKER_ATTACH);
                    } else if (context.canExecute && target && target.id !== parent.id) {
                        setMarker(target, MARKER_NEW_PARENT);
                    } else {
                        setMarker(target, context.canExecute ? MARKER_OK : MARKER_NOT_OK);
                    }
                }

                translate(dragGroup, event.dx, event.dy);
            });

            eventBus.on(['shape.move.out', 'shape.move.cleanup'], function (event) {
                var context = event.context,
                    target = context.target;

                if (target) {
                    setMarker(target, null);
                }
            });

            // remove previews
            eventBus.on('shape.move.cleanup', function (event) {

                var context = event.context,
                    allDraggedElements = context.allDraggedElements,
                    dragGroup = context.dragGroup;


                // remove dragging marker
                forEach(allDraggedElements, function (e) {
                    canvas.removeMarker(e, MARKER_DRAGGING);
                });

                if (dragGroup) {
                    svgClear(dragGroup);
                }
            });
        }

        MovePreview.$inject = ['eventBus', 'elementRegistry', 'canvas', 'styles', 'previewSupport'];

        module.exports = MovePreview;

        ////////// helpers //////////

        // returns elements minus all connections
        // where source or target is not elements
        function removeEdges(elements) {

            var filteredElements = filter(elements, function (element) {

                if (!isConnection(element)) {
                    return true;
                } else {
                    var srcFound = find(elements, element.source);
                    var targetFound = find(elements, element.target);

                    return srcFound && targetFound;
                }
            });

            return filteredElements;
        }

        function haveDifferentParents(elements) {
            return size(groupBy(elements, function (e) { return e.parent && e.parent.id; })) !== 1;
        }

        /**
         * Checks if an element is a connection.
         */
        function isConnection(element) {
            return element.waypoints;
        }

    }, { "../../util/Elements": 266, "../../util/SvgTransformUtil": 279, "lodash/array/flatten": 292, "lodash/collection/filter": 302, "lodash/collection/find": 303, "lodash/collection/forEach": 304, "lodash/collection/groupBy": 305, "lodash/collection/map": 306, "lodash/collection/size": 309, "tiny-svg/lib/append": 473, "tiny-svg/lib/attr": 475, "tiny-svg/lib/clear": 477, "tiny-svg/lib/create": 479 }], 206: [function (require, module, exports) {
        module.exports = {
            __depends__: [
                require('../interaction-events'),
                require('../selection'),
                require('../outline'),
                require('../rules'),
                require('../dragging'),
                require('../preview-support')
            ],
            __init__: ['move', 'movePreview'],
            move: ['type', require('./Move')],
            movePreview: ['type', require('./MovePreview')]
        };

    }, { "../dragging": 162, "../interaction-events": 170, "../outline": 209, "../preview-support": 217, "../rules": 227, "../selection": 233, "./Move": 204, "./MovePreview": 205 }], 207: [function (require, module, exports) {
        'use strict';

        var inherits = require('inherits');

        var CommandInterceptor = require('../../command/CommandInterceptor');


        /**
         * An abstract provider that allows modelers to implement a custom
         * ordering of diagram elements on the canvas.
         *
         * It makes sure that the order is always preserved during element
         * creation and move operations.
         *
         * In order to use this behavior, inherit from it and override
         * the method {@link OrderingProvider#getOrdering}.
         *
         * @example
         *
         * ```javascript
         * function CustomOrderingProvider(eventBus) {
         *   OrderingProvider.call(this, eventBus);
         *
         *   this.getOrdering = function(element, newParent) {
         *     // always insert elements at the front
         *     // when moving
         *     return {
         *       index: 0,
         *       parent: newParent
         *     };
         *   };
         * }
         * ```
         *
         * @param {EventBus} eventBus
         */
        function OrderingProvider(eventBus) {

            CommandInterceptor.call(this, eventBus);


            var self = this;

            this.preExecute(['shape.create', 'connection.create'], function (event) {

                var context = event.context,
                    element = context.shape || context.connection,
                    parent = context.parent;

                var ordering = self.getOrdering(element, parent);

                if (ordering) {

                    if (ordering.parent !== undefined) {
                        context.parent = ordering.parent;
                    }

                    context.parentIndex = ordering.index;
                }
            });

            this.preExecute(['shape.move', 'connection.move'], function (event) {

                var context = event.context,
                    element = context.shape || context.connection,
                    parent = context.newParent || element.parent;

                var ordering = self.getOrdering(element, parent);

                if (ordering) {

                    if (ordering.parent !== undefined) {
                        context.newParent = ordering.parent;
                    }

                    context.newParentIndex = ordering.index;
                }
            });
        }

        /**
         * Return a custom ordering of the element, both in terms
         * of parent element and index in the new parent.
         *
         * Implementors of this method must return an object with
         * `parent` _and_ `index` in it.
         *
         * @param {djs.model.Base} element
         * @param {djs.model.Shape} newParent
         *
         * @return {Object} ordering descriptor
         */
        OrderingProvider.prototype.getOrdering = function (element, newParent) {
            return null;
        };

        inherits(OrderingProvider, CommandInterceptor);

        module.exports = OrderingProvider;
    }, { "../../command/CommandInterceptor": 119, "inherits": 289 }], 208: [function (require, module, exports) {
        'use strict';

        var getBBox = require('../../util/Elements').getBBox;

        var LOW_PRIORITY = 500;

        var svgAppend = require('tiny-svg/lib/append'),
            svgAttr = require('tiny-svg/lib/attr'),
            svgCreate = require('tiny-svg/lib/create');

        var domQuery = require('min-dom/lib/query');

        var assign = require('lodash/object/assign');


        /**
         * @class
         *
         * A plugin that adds an outline to shapes and connections that may be activated and styled
         * via CSS classes.
         *
         * @param {EventBus} eventBus
         * @param {Styles} styles
         * @param {ElementRegistry} elementRegistry
         */
        function Outline(eventBus, styles, elementRegistry) {

            this.offset = 6;

            var OUTLINE_STYLE = styles.cls('djs-outline', ['no-fill']);

            var self = this;

            function createOutline(gfx, bounds) {
                var outline = svgCreate('rect');

                svgAttr(outline, assign({
                    x: 10,
                    y: 10,
                    width: 100,
                    height: 100
                }, OUTLINE_STYLE));

                svgAppend(gfx, outline);

                return outline;
            }

            // A low priortity is necessary, because outlines of labels have to be updated
            // after the label bounds have been updated in the renderer.
            eventBus.on(['shape.added', 'shape.changed'], LOW_PRIORITY, function (event) {
                var element = event.element,
                    gfx = event.gfx;

                var outline = domQuery('.djs-outline', gfx);

                if (!outline) {
                    outline = createOutline(gfx, element);
                }

                self.updateShapeOutline(outline, element);
            });

            eventBus.on(['connection.added', 'connection.changed'], function (event) {
                var element = event.element,
                    gfx = event.gfx;

                var outline = domQuery('.djs-outline', gfx);

                if (!outline) {
                    outline = createOutline(gfx, element);
                }

                self.updateConnectionOutline(outline, element);
            });
        }


        /**
         * Updates the outline of a shape respecting the dimension of the
         * element and an outline offset.
         *
         * @param  {SVGElement} outline
         * @param  {djs.model.Base} element
         */
        Outline.prototype.updateShapeOutline = function (outline, element) {

            svgAttr(outline, {
                x: -this.offset,
                y: -this.offset,
                width: element.width + this.offset * 2,
                height: element.height + this.offset * 2
            });

        };


        /**
         * Updates the outline of a connection respecting the bounding box of
         * the connection and an outline offset.
         *
         * @param  {SVGElement} outline
         * @param  {djs.model.Base} element
         */
        Outline.prototype.updateConnectionOutline = function (outline, connection) {

            var bbox = getBBox(connection);

            svgAttr(outline, {
                x: bbox.x - this.offset,
                y: bbox.y - this.offset,
                width: bbox.width + this.offset * 2,
                height: bbox.height + this.offset * 2
            });

        };


        Outline.$inject = ['eventBus', 'styles', 'elementRegistry'];

        module.exports = Outline;

    }, { "../../util/Elements": 266, "lodash/object/assign": 433, "min-dom/lib/query": 454, "tiny-svg/lib/append": 473, "tiny-svg/lib/attr": 475, "tiny-svg/lib/create": 479 }], 209: [function (require, module, exports) {
        'use strict';

        module.exports = {
            __init__: ['outline'],
            outline: ['type', require('./Outline')]
        };
    }, { "./Outline": 208 }], 210: [function (require, module, exports) {
        'use strict';

        var isArray = require('lodash/lang/isArray'),
            isString = require('lodash/lang/isString'),
            isObject = require('lodash/lang/isObject'),
            assign = require('lodash/object/assign'),
            forEach = require('lodash/collection/forEach'),
            find = require('lodash/collection/find'),
            filter = require('lodash/collection/filter');

        var domify = require('min-dom/lib/domify'),
            domClasses = require('min-dom/lib/classes'),
            domAttr = require('min-dom/lib/attr'),
            domRemove = require('min-dom/lib/remove'),
            domClear = require('min-dom/lib/clear');

        var getBBox = require('../../util/Elements').getBBox;

        // document wide unique overlay ids
        var ids = new (require('../../util/IdGenerator'))('ov');

        var LOW_PRIORITY = 500;


        function createRoot(parent) {
            var root = domify('<div class="djs-overlay-container" style="position: absolute; width: 0; height: 0;" />');
            parent.insertBefore(root, parent.firstChild);

            return root;
        }


        function setPosition(el, x, y) {
            assign(el.style, { left: x + 'px', top: y + 'px' });
        }

        function setVisible(el, visible) {
            el.style.display = visible === false ? 'none' : '';
        }

        /**
         * A service that allows users to attach overlays to diagram elements.
         *
         * The overlay service will take care of overlay positioning during updates.
         *
         * @example
         *
         * // add a pink badge on the top left of the shape
         * overlays.add(someShape, {
         *   position: {
         *     top: -5,
         *     left: -5
         *   },
         *   html: '<div style="width: 10px; background: fuchsia; color: white;">0</div>'
         * });
         *
         * // or add via shape id
         *
         * overlays.add('some-element-id', {
         *   position: {
         *     top: -5,
         *     left: -5
         *   }
         *   html: '<div style="width: 10px; background: fuchsia; color: white;">0</div>'
         * });
         *
         * // or add with optional type
         *
         * overlays.add(someShape, 'badge', {
         *   position: {
         *     top: -5,
         *     left: -5
         *   }
         *   html: '<div style="width: 10px; background: fuchsia; color: white;">0</div>'
         * });
         *
         *
         * // remove an overlay
         *
         * var id = overlays.add(...);
         * overlays.remove(id);
         *
         * @param {EventBus} eventBus
         * @param {Canvas} canvas
         * @param {ElementRegistry} elementRegistry
         */
        function Overlays(eventBus, canvas, elementRegistry) {

            this._eventBus = eventBus;
            this._canvas = canvas;
            this._elementRegistry = elementRegistry;

            this._ids = ids;

            this._overlayDefaults = {
                show: {
                    minZoom: 0.7,
                    maxZoom: 5.0
                }
            };

            /**
             * Mapping overlayId -> overlay
             */
            this._overlays = {};

            /**
             * Mapping elementId -> overlay container
             */
            this._overlayContainers = [];

            // root html element for all overlays
            this._overlayRoot = createRoot(canvas.getContainer());

            this._init();
        }


        Overlays.$inject = ['eventBus', 'canvas', 'elementRegistry'];

        module.exports = Overlays;


        /**
         * Returns the overlay with the specified id or a list of overlays
         * for an element with a given type.
         *
         * @example
         *
         * // return the single overlay with the given id
         * overlays.get('some-id');
         *
         * // return all overlays for the shape
         * overlays.get({ element: someShape });
         *
         * // return all overlays on shape with type 'badge'
         * overlays.get({ element: someShape, type: 'badge' });
         *
         * // shape can also be specified as id
         * overlays.get({ element: 'element-id', type: 'badge' });
         *
         *
         * @param {Object} search
         * @param {String} [search.id]
         * @param {String|djs.model.Base} [search.element]
         * @param {String} [search.type]
         *
         * @return {Object|Array<Object>} the overlay(s)
         */
        Overlays.prototype.get = function (search) {

            if (isString(search)) {
                search = { id: search };
            }

            if (isString(search.element)) {
                search.element = this._elementRegistry.get(search.element);
            }

            if (search.element) {
                var container = this._getOverlayContainer(search.element, true);

                // return a list of overlays when searching by element (+type)
                if (container) {
                    return search.type ? filter(container.overlays, { type: search.type }) : container.overlays.slice();
                } else {
                    return [];
                }
            } else
                if (search.type) {
                    return filter(this._overlays, { type: search.type });
                } else {
                    // return single element when searching by id
                    return search.id ? this._overlays[search.id] : null;
                }
        };

        /**
         * Adds a HTML overlay to an element.
         *
         * @param {String|djs.model.Base}   element   attach overlay to this shape
         * @param {String}                  [type]    optional type to assign to the overlay
         * @param {Object}                  overlay   the overlay configuration
         *
         * @param {String|DOMElement}       overlay.html                 html element to use as an overlay
         * @param {Object}                  [overlay.show]               show configuration
         * @param {Number}                  [overlay.show.minZoom]       minimal zoom level to show the overlay
         * @param {Number}                  [overlay.show.maxZoom]       maximum zoom level to show the overlay
         * @param {Object}                  overlay.position             where to attach the overlay
         * @param {Number}                  [overlay.position.left]      relative to element bbox left attachment
         * @param {Number}                  [overlay.position.top]       relative to element bbox top attachment
         * @param {Number}                  [overlay.position.bottom]    relative to element bbox bottom attachment
         * @param {Number}                  [overlay.position.right]     relative to element bbox right attachment
         *
         * @return {String}                 id that may be used to reference the overlay for update or removal
         */
        Overlays.prototype.add = function (element, type, overlay) {

            if (isObject(type)) {
                overlay = type;
                type = null;
            }

            if (!element.id) {
                element = this._elementRegistry.get(element);
            }

            if (!overlay.position) {
                throw new Error('must specifiy overlay position');
            }

            if (!overlay.html) {
                throw new Error('must specifiy overlay html');
            }

            if (!element) {
                throw new Error('invalid element specified');
            }

            var id = this._ids.next();

            overlay = assign({}, this._overlayDefaults, overlay, {
                id: id,
                type: type,
                element: element,
                html: overlay.html
            });

            this._addOverlay(overlay);

            return id;
        };


        /**
         * Remove an overlay with the given id or all overlays matching the given filter.
         *
         * @see Overlays#get for filter options.
         *
         * @param {String} [id]
         * @param {Object} [filter]
         */
        Overlays.prototype.remove = function (filter) {

            var overlays = this.get(filter) || [];

            if (!isArray(overlays)) {
                overlays = [overlays];
            }

            var self = this;

            forEach(overlays, function (overlay) {

                var container = self._getOverlayContainer(overlay.element, true);

                if (overlay) {
                    domRemove(overlay.html);
                    domRemove(overlay.htmlContainer);

                    delete overlay.htmlContainer;
                    delete overlay.element;

                    delete self._overlays[overlay.id];
                }

                if (container) {
                    var idx = container.overlays.indexOf(overlay);
                    if (idx !== -1) {
                        container.overlays.splice(idx, 1);
                    }
                }
            });

        };


        Overlays.prototype.show = function () {
            setVisible(this._overlayRoot);
        };


        Overlays.prototype.hide = function () {
            setVisible(this._overlayRoot, false);
        };

        Overlays.prototype.clear = function () {
            this._overlays = {};

            this._overlayContainers = [];

            domClear(this._overlayRoot);
        };

        Overlays.prototype._updateOverlayContainer = function (container) {
            var element = container.element,
                html = container.html;

            // update container left,top according to the elements x,y coordinates
            // this ensures we can attach child elements relative to this container

            var x = element.x,
                y = element.y;

            if (element.waypoints) {
                var bbox = getBBox(element);
                x = bbox.x;
                y = bbox.y;
            }

            setPosition(html, x, y);

            domAttr(container.html, 'data-container-id', element.id);
        };


        Overlays.prototype._updateOverlay = function (overlay) {

            var position = overlay.position,
                htmlContainer = overlay.htmlContainer,
                element = overlay.element;

            // update overlay html relative to shape because
            // it is already positioned on the element

            // update relative
            var left = position.left,
                top = position.top;

            if (position.right !== undefined) {

                var width;

                if (element.waypoints) {
                    width = getBBox(element).width;
                } else {
                    width = element.width;
                }

                left = position.right * -1 + width;
            }

            if (position.bottom !== undefined) {

                var height;

                if (element.waypoints) {
                    height = getBBox(element).height;
                } else {
                    height = element.height;
                }

                top = position.bottom * -1 + height;
            }

            setPosition(htmlContainer, left || 0, top || 0);
        };

        Overlays.prototype._createOverlayContainer = function (element) {
            var html = domify('<div class="djs-overlays" style="position: absolute" />');

            this._overlayRoot.appendChild(html);

            var container = {
                html: html,
                element: element,
                overlays: []
            };

            this._updateOverlayContainer(container);

            this._overlayContainers.push(container);

            return container;
        };


        Overlays.prototype._updateRoot = function (viewbox) {
            var a = viewbox.scale || 1;
            var d = viewbox.scale || 1;

            var matrix = 'matrix(' + a + ',0,0,' + d + ',' + (-1 * viewbox.x * a) + ',' + (-1 * viewbox.y * d) + ')';

            this._overlayRoot.style.transform = matrix;
            this._overlayRoot.style['-ms-transform'] = matrix;
            this._overlayRoot.style['-webkit-transform'] = matrix;
        };


        Overlays.prototype._getOverlayContainer = function (element, raw) {
            var container = find(this._overlayContainers, function (c) {
                return c.element === element;
            });


            if (!container && !raw) {
                return this._createOverlayContainer(element);
            }

            return container;
        };





        Overlays.prototype._addOverlay = function (overlay) {

            var id = overlay.id,
                element = overlay.element,
                html = overlay.html,
                htmlContainer,
                overlayContainer;

            // unwrap jquery (for those who need it)
            if (html.get && html.constructor.prototype.jquery) {
                html = html.get(0);
            }

            // create proper html elements from
            // overlay HTML strings
            if (isString(html)) {
                html = domify(html);
            }

            overlayContainer = this._getOverlayContainer(element);

            htmlContainer = domify('<div class="djs-overlay" data-overlay-id="' + id + '" style="position: absolute">');

            htmlContainer.appendChild(html);

            if (overlay.type) {
                domClasses(htmlContainer).add('djs-overlay-' + overlay.type);
            }

            overlay.htmlContainer = htmlContainer;

            overlayContainer.overlays.push(overlay);
            overlayContainer.html.appendChild(htmlContainer);

            this._overlays[id] = overlay;

            this._updateOverlay(overlay);
            this._updateOverlayVisibilty(overlay, this._canvas.viewbox());
        };

        Overlays.prototype._updateOverlayVisibilty = function (overlay, viewbox) {
            var show = overlay.show,
                htmlContainer = overlay.htmlContainer,
                visible = true;

            if (show) {
                if (show.minZoom > viewbox.scale ||
                    show.maxZoom < viewbox.scale) {
                    visible = false;
                }

                setVisible(htmlContainer, visible);
            }
        };

        Overlays.prototype._updateOverlaysVisibilty = function (viewbox) {

            var self = this;

            forEach(this._overlays, function (overlay) {
                self._updateOverlayVisibilty(overlay, viewbox);
            });
        };


        Overlays.prototype._init = function () {

            var eventBus = this._eventBus;

            var self = this;


            // scroll/zoom integration

            function updateViewbox(viewbox) {
                self._updateRoot(viewbox);
                self._updateOverlaysVisibilty(viewbox);

                self.show();
            }

            eventBus.on('canvas.viewbox.changing', function (event) {
                self.hide();
            });

            eventBus.on('canvas.viewbox.changed', function (event) {
                updateViewbox(event.viewbox);
            });


            // remove integration

            eventBus.on(['shape.remove', 'connection.remove'], function (e) {
                var element = e.element;
                var overlays = self.get({ element: element });

                forEach(overlays, function (o) {
                    self.remove(o.id);
                });

                var container = self._getOverlayContainer(element);

                if (container) {
                    domRemove(container.html);
                    var i = self._overlayContainers.indexOf(container);
                    if (i !== -1) {
                        self._overlayContainers.splice(i, 1);
                    }
                }
            });


            // move integration

            eventBus.on('element.changed', LOW_PRIORITY, function (e) {
                var element = e.element;

                var container = self._getOverlayContainer(element, true);

                if (container) {
                    forEach(container.overlays, function (overlay) {
                        self._updateOverlay(overlay);
                    });

                    self._updateOverlayContainer(container);
                }
            });


            // marker integration, simply add them on the overlays as classes, too.

            eventBus.on('element.marker.update', function (e) {
                var container = self._getOverlayContainer(e.element, true);
                if (container) {
                    domClasses(container.html)[e.add ? 'add' : 'remove'](e.marker);
                }
            });


            // clear overlays with diagram

            eventBus.on('diagram.clear', this.clear, this);
        };

    }, { "../../util/Elements": 266, "../../util/IdGenerator": 270, "lodash/collection/filter": 302, "lodash/collection/find": 303, "lodash/collection/forEach": 304, "lodash/lang/isArray": 424, "lodash/lang/isObject": 428, "lodash/lang/isString": 430, "lodash/object/assign": 433, "min-dom/lib/attr": 446, "min-dom/lib/classes": 447, "min-dom/lib/clear": 448, "min-dom/lib/domify": 451, "min-dom/lib/remove": 455 }], 211: [function (require, module, exports) {
        module.exports = {
            __init__: ['overlays'],
            overlays: ['type', require('./Overlays')]
        };
    }, { "./Overlays": 210 }], 212: [function (require, module, exports) {
        'use strict';

        var isFunction = require('lodash/lang/isFunction'),
            isArray = require('lodash/lang/isArray'),
            forEach = require('lodash/collection/forEach');

        var domify = require('min-dom/lib/domify'),
            domQuery = require('min-dom/lib/query'),
            domAttr = require('min-dom/lib/attr'),
            domClear = require('min-dom/lib/clear'),
            domClasses = require('min-dom/lib/classes'),
            domMatches = require('min-dom/lib/matches'),
            domDelegate = require('min-dom/lib/delegate'),
            domEvent = require('min-dom/lib/event');


        var toggleSelector = '.djs-palette-toggle',
            entrySelector = '.entry',
            elementSelector = toggleSelector + ', ' + entrySelector;


        /**
         * A palette containing modeling elements.
         */
        function Palette(eventBus, canvas, dragging) {

            this._eventBus = eventBus;
            this._canvas = canvas;
            this._dragging = dragging;

            this._providers = [];

            var self = this;

            eventBus.on('tool-manager.update', function (event) {
                var tool = event.tool;

                self.updateToolHighlight(tool);
            });

            eventBus.on('i18n.changed', function () {
                self._update();
            });
        }

        Palette.$inject = ['eventBus', 'canvas', 'dragging'];

        module.exports = Palette;


        /**
         * Register a provider with the palette
         *
         * @param  {PaletteProvider} provider
         */
        Palette.prototype.registerProvider = function (provider) {
            this._providers.push(provider);

            if (!this._container) {
                this._init();
            }

            this._update();
        };


        /**
         * Returns the palette entries for a given element
         *
         * @return {Array<PaletteEntryDescriptor>} list of entries
         */
        Palette.prototype.getEntries = function () {

            var entries = {};

            // loop through all providers and their entries.
            // group entries by id so that overriding an entry is possible
            forEach(this._providers, function (provider) {
                var e = provider.getPaletteEntries();

                forEach(e, function (entry, id) {
                    entries[id] = entry;
                });
            });

            return entries;
        };


        /**
         * Initialize
         */
        Palette.prototype._init = function () {
            var canvas = this._canvas,
                eventBus = this._eventBus;

            var parent = canvas.getContainer(),
                container = this._container = domify(Palette.HTML_MARKUP),
                self = this;

            parent.appendChild(container);

            domDelegate.bind(container, elementSelector, 'click', function (event) {

                var target = event.delegateTarget;

                if (domMatches(target, toggleSelector)) {
                    return self.toggle();
                }

                self.trigger('click', event);
            });

            // prevent drag propagation
            domEvent.bind(container, 'mousedown', function (event) {
                event.stopPropagation();
            });

            // prevent drag propagation
            domDelegate.bind(container, entrySelector, 'dragstart', function (event) {
                self.trigger('dragstart', event);
            });

            eventBus.fire('palette.create', {
                html: container
            });

            eventBus.on('canvas.resized', this.triggerTwoColumn, this);
        };


        Palette.prototype._update = function () {

            var entriesContainer = domQuery('.djs-palette-entries', this._container),
                entries = this._entries = this.getEntries();

            domClear(entriesContainer);

            forEach(entries, function (entry, id) {

                var grouping = entry.group || 'default';

                var container = domQuery('[data-group=' + grouping + ']', entriesContainer);
                if (!container) {
                    container = domify('<div class="group" data-group="' + grouping + '"></div>');
                    entriesContainer.appendChild(container);
                }

                var html = entry.html || (
                    entry.separator ?
                        '<hr class="separator" />' :
                        '<div class="entry" draggable="true"></div>');


                var control = domify(html);
                container.appendChild(control);

                if (!entry.separator) {
                    domAttr(control, 'data-action', id);

                    if (entry.title) {
                        domAttr(control, 'title', entry.title);
                    }

                    if (entry.className) {
                        addClasses(control, entry.className);
                    }

                    if (entry.imageUrl) {
                        control.appendChild(domify('<img src="' + entry.imageUrl + '">'));
                    }
                }
            });

            // open after update
            this.open(true);
        };


        /**
         * Trigger an action available on the palette
         *
         * @param  {String} action
         * @param  {Event} event
         */
        Palette.prototype.trigger = function (action, event, autoActivate) {
            var entries = this._entries,
                entry,
                handler,
                originalEvent,
                button = event.delegateTarget || event.target;

            if (!button) {
                return event.preventDefault();
            }

            entry = entries[domAttr(button, 'data-action')];

            // when user clicks on the palette and not on an action
            if (!entry) {
                return;
            }

            handler = entry.action;

            originalEvent = event.originalEvent || event;

            // simple action (via callback function)
            if (isFunction(handler)) {
                if (action === 'click') {
                    handler(originalEvent, autoActivate);
                }
            } else {
                if (handler[action]) {
                    handler[action](originalEvent, autoActivate);
                }
            }

            // silence other actions
            event.preventDefault();
        };

        Palette.prototype.triggerTwoColumn = function () {
            var canvas = this._canvas;

            var parent = canvas.getContainer();

            if (parent.clientHeight < 650) {
                domClasses(parent).add('two-column');
            } else {
                domClasses(parent).remove('two-column');
            }
        };


        /**
         * Close the palette
         */
        Palette.prototype.close = function () {
            var canvas = this._canvas;

            var parent = canvas.getContainer();

            domClasses(this._container).remove('open');

            domClasses(parent).remove('two-column');
        };


        /**
         * Open the palette
         */
        Palette.prototype.open = function () {
            domClasses(this._container).add('open');

            this.triggerTwoColumn();
        };


        Palette.prototype.toggle = function (open) {
            if (this.isOpen()) {
                this.close();
            } else {
                this.open();
            }
        };

        Palette.prototype.isActiveTool = function (tool) {
            return tool && this._activeTool === tool;
        };

        Palette.prototype.updateToolHighlight = function (name) {
            var entriesContainer,
                toolsContainer;

            if (!this._toolsContainer) {
                entriesContainer = domQuery('.djs-palette-entries', this._container);

                this._toolsContainer = domQuery('[data-group=tools]', entriesContainer);
            }

            toolsContainer = this._toolsContainer;

            forEach(toolsContainer.children, function (tool) {
                var actionName = tool.getAttribute('data-action');

                if (!actionName) {
                    return;
                }

                actionName = actionName.replace('-tool', '');

                if (tool.classList.contains('entry') && actionName === name) {
                    domClasses(tool).add('highlighted-entry');
                } else {
                    domClasses(tool).remove('highlighted-entry');
                }
            });
        };


        /**
         * Return true if the palette is opened.
         *
         * @example
         *
         * palette.open();
         *
         * if (palette.isOpen()) {
         *   // yes, we are open
         * }
         *
         * @return {boolean} true if palette is opened
         */
        Palette.prototype.isOpen = function () {
            return this._container && domClasses(this._container).has('open');
        };


        /* markup definition */

        Palette.HTML_MARKUP =
            '<div class="djs-palette">' +
            '<div class="djs-palette-entries"></div>' +
            '<div class="djs-palette-toggle"></div>' +
            '</div>';


        ////////// helpers /////////////////////////////

        function addClasses(element, classNames) {

            var classes = domClasses(element);

            var actualClassNames = isArray(classNames) ? classNames : classNames.split(/\s+/g);
            actualClassNames.forEach(function (cls) {
                classes.add(cls);
            });
        }

    }, { "lodash/collection/forEach": 304, "lodash/lang/isArray": 424, "lodash/lang/isFunction": 425, "min-dom/lib/attr": 446, "min-dom/lib/classes": 447, "min-dom/lib/clear": 448, "min-dom/lib/delegate": 450, "min-dom/lib/domify": 451, "min-dom/lib/event": 452, "min-dom/lib/matches": 453, "min-dom/lib/query": 454 }], 213: [function (require, module, exports) {
        'use strict';

        module.exports = {
            __depends__: [require('../tool-manager')],
            __init__: ['palette'],
            palette: ['type', require('./Palette')]
        };

    }, { "../tool-manager": 242, "./Palette": 212 }], 214: [function (require, module, exports) {
        'use strict';

        var forEach = require('lodash/collection/forEach'),
            assign = require('lodash/object/assign'),
            find = require('lodash/collection/find');

        var domDelegate = require('min-dom/lib/delegate'),
            domify = require('min-dom/lib/domify'),
            domClasses = require('min-dom/lib/classes'),
            domAttr = require('min-dom/lib/attr'),
            domRemove = require('min-dom/lib/remove');

        var DATA_REF = 'data-id';

        /**
         * A popup menu that can be used to display a list of actions anywhere in the canvas.
         *
         * @param {EventBus} eventBus
         * @param {Canvas} canvas
         *
         * @class
         * @constructor
         */
        function PopupMenu(eventBus, canvas) {

            this._eventBus = eventBus;
            this._canvas = canvas;
            this._providers = {};
        }

        PopupMenu.$inject = ['eventBus', 'canvas'];

        /**
         * Registers a popup menu provider
         *
         * @param  {String} id
         * @param  {Object} provider
         *
         * @example
         * popupMenu.registerProvider('myMenuID', {
         *   getEntries: function(element) {
         *     return [
         *       {
         *          id: 'entry-1',
         *          label: 'My Entry',
         *          action: 'alert("I have been clicked!")'
         *        }
         *      ];
         *    }
         *  });
         * })
         */
        PopupMenu.prototype.registerProvider = function (id, provider) {
            this._providers[id] = provider;
        };


        /**
         * Create a popup menu according to a given element. The id refers to the ID
         * of the provider that must be registered before.
         *
         * @param  {String} id provider id
         * @param  {Object} element
         *
         * @return {PopupMenu} popup menu instance
         */
        PopupMenu.prototype.create = function (id, element) {

            var provider = this._providers[id];

            if (!provider) {
                throw new Error('Provider is not registered: ' + id);
            }

            if (!element) {
                throw new Error('Element is missing');
            }

            var current = this._current = {
                provider: provider,
                className: id,
                element: element
            };

            if (provider.getHeaderEntries) {
                current.headerEntries = provider.getHeaderEntries(element);
            }

            current.entries = provider.getEntries(element);

            return this;
        };


        /**
         * Determine if the popup menu has entries.
         *
         * @return {Boolean} true if empty
         */
        PopupMenu.prototype.isEmpty = function () {

            var current = this._current;

            return current.entries.length === 0 && current.headerEntries && current.headerEntries.length === 0;
        };


        /**
         * Open popup menu at given position
         *
         * @param {Object} position
         *
         * @return {Object} popup menu instance
         */
        PopupMenu.prototype.open = function (position) {

            if (!position) {
                throw new Error('the position argument is missing');
            }

            // make sure, only one popup menu is open at a time
            if (this.isOpen()) {
                this.close();
            }

            var current = this._current,
                canvas = this._canvas,
                parent = canvas.getContainer();

            current.position = position;

            current.container = this._createContainer();

            if (current.headerEntries) {
                var headerEntriesContainer = this._createEntries(current.headerEntries, 'djs-popup-header');

                current.container.appendChild(headerEntriesContainer);
            }

            if (current.entries) {
                var entriesContainer = this._createEntries(current.entries, 'djs-popup-body');

                current.container.appendChild(entriesContainer);
            }

            this._attachContainer(current.container, parent, position.cursor);

            return this;
        };


        /**
         * Removes the popup menu and unbinds the event handlers.
         */
        PopupMenu.prototype.close = function () {

            if (!this.isOpen()) {
                return;
            }

            this._unbindHandlers();
            domRemove(this._current.container);
            this._current.container = null;
        };


        /**
         * Determine if an open popup menu exist.
         *
         * @return {Boolean} true if open
         */
        PopupMenu.prototype.isOpen = function () {
            return !!this._current.container;
        };


        /**
         * Trigger an action associated with an entry.
         *
         * @param {Object} event
         *
         * @return the result of the action callback, if any
         */
        PopupMenu.prototype.trigger = function (event) {

            // silence other actions
            event.preventDefault();

            var element = event.delegateTarget || event.target,
                entryId = domAttr(element, DATA_REF);

            var entry = this._getEntry(entryId);

            if (entry.action) {
                return entry.action.call(null, event, entry);
            }
        };

        /**
         * Gets an entry instance (either entry or headerEntry) by id.
         *
         * @param  {String} entryId
         *
         * @return {Object} entry instance
         */
        PopupMenu.prototype._getEntry = function (entryId) {

            var search = { id: entryId };

            var entry = find(this._current.entries, search) || find(this._current.headerEntries, search);

            if (!entry) {
                throw new Error('entry not found');
            }

            return entry;
        };


        /**
         * Creates the popup menu container.
         *
         * @return {Object} a DOM container
         */
        PopupMenu.prototype._createContainer = function () {
            var container = domify('<div class="djs-popup">'),
                position = this._current.position,
                className = this._current.className;

            assign(container.style, {
                position: 'absolute',
                left: position.x + 'px',
                top: position.y + 'px',
                visibility: 'hidden'
            });

            domClasses(container).add(className);

            return container;
        };


        /**
         * Attaches the container to the DOM and binds the event handlers.
         *
         * @param {Object} container
         * @param {Object} parent
         */
        PopupMenu.prototype._attachContainer = function (container, parent, cursor) {
            var self = this;

            // Event handler
            domDelegate.bind(container, '.entry', 'click', function (event) {
                self.trigger(event);
            });

            // apply canvas zoom level
            var zoom = this._canvas.zoom();

            container.style.transformOrigin = 'top left';
            container.style.transform = 'scale(' + zoom + ')';

            // Attach to DOM
            parent.appendChild(container);

            if (cursor) {
                this._assureIsInbounds(container, cursor);
            }

            // Add Handler
            this._bindHandlers();
        };


        /**
         * Make sure that the menu is always fully shown
         *
         * @method function
         *
         * @param  {Object} container
         * @param  {Position} cursor {x, y}
         */
        PopupMenu.prototype._assureIsInbounds = function (container, cursor) {
            var canvas = this._canvas,
                clientRect = canvas._container.getBoundingClientRect();

            var containerX = container.offsetLeft,
                containerY = container.offsetTop,
                containerWidth = container.scrollWidth,
                containerHeight = container.scrollHeight,
                overAxis = {},
                left, top;

            var cursorPosition = {
                x: cursor.x - clientRect.left,
                y: cursor.y - clientRect.top
            };

            if (containerX + containerWidth > clientRect.width) {
                overAxis.x = true;
            }

            if (containerY + containerHeight > clientRect.height) {
                overAxis.y = true;
            }

            if (overAxis.x && overAxis.y) {
                left = cursorPosition.x - containerWidth + 'px';
                top = cursorPosition.y - containerHeight + 'px';
            } else if (overAxis.x) {
                left = cursorPosition.x - containerWidth + 'px';
                top = cursorPosition.y + 'px';
            } else if (overAxis.y && cursorPosition.y < containerHeight) {
                left = cursorPosition.x + 'px';
                top = 10 + 'px';
            } else if (overAxis.y) {
                left = cursorPosition.x + 'px';
                top = cursorPosition.y - containerHeight + 'px';
            }

            assign(container.style, { left: left, top: top }, { visibility: 'visible', 'z-index': 1000 });
        };


        /**
         * Creates a list of entries and returns them as a DOM container.
         *
         * @param {Array<Object>} entries an array of entry objects
         * @param {String} className the class name of the entry container
         *
         * @return {Object} a DOM container
         */
        PopupMenu.prototype._createEntries = function (entries, className) {

            var entriesContainer = domify('<div>'),
                self = this;

            domClasses(entriesContainer).add(className);

            forEach(entries, function (entry) {
                var entryContainer = self._createEntry(entry, entriesContainer);
                entriesContainer.appendChild(entryContainer);
            });

            return entriesContainer;
        };


        /**
         * Creates a single entry and returns it as a DOM container.
         *
         * @param  {Object} entry
         *
         * @return {Object} a DOM container
         */
        PopupMenu.prototype._createEntry = function (entry) {

            if (!entry.id) {
                throw new Error('every entry must have the id property set');
            }

            var entryContainer = domify('<div>'),
                entryClasses = domClasses(entryContainer);

            entryClasses.add('entry');

            if (entry.className) {
                entryClasses.add(entry.className);
            }

            domAttr(entryContainer, DATA_REF, entry.id);

            if (entry.label) {
                var label = domify('<span>');
                label.textContent = entry.label;
                entryContainer.appendChild(label);
            }

            if (entry.imageUrl) {
                entryContainer.appendChild(domify('<img src="' + entry.imageUrl + '" />'));
            }

            if (entry.active === true) {
                entryClasses.add('active');
            }

            if (entry.disabled === true) {
                entryClasses.add('disabled');
            }

            if (entry.title) {
                entryContainer.title = entry.title;
            }

            return entryContainer;
        };


        /**
         * Binds the `close` method to 'contextPad.close' & 'canvas.viewbox.changed'.
         */
        PopupMenu.prototype._bindHandlers = function () {

            var eventBus = this._eventBus,
                self = this;

            function close() {
                self.close();
            }

            eventBus.once('contextPad.close', close);
            eventBus.once('canvas.viewbox.changing', close);
            eventBus.once('commandStack.changed', close);
        };


        /**
         * Unbinds the `close` method to 'contextPad.close' & 'canvas.viewbox.changing'.
         */
        PopupMenu.prototype._unbindHandlers = function () {

            var eventBus = this._eventBus,
                self = this;

            function close() {
                self.close();
            }

            eventBus.off('contextPad.close', close);
            eventBus.off('canvas.viewbox.changed', close);
            eventBus.off('commandStack.changed', close);
        };

        module.exports = PopupMenu;

    }, { "lodash/collection/find": 303, "lodash/collection/forEach": 304, "lodash/object/assign": 433, "min-dom/lib/attr": 446, "min-dom/lib/classes": 447, "min-dom/lib/delegate": 450, "min-dom/lib/domify": 451, "min-dom/lib/remove": 455 }], 215: [function (require, module, exports) {
        'use strict';

        module.exports = {
            __init__: ['popupMenu'],
            popupMenu: ['type', require('./PopupMenu')]
        };

    }, { "./PopupMenu": 214 }], 216: [function (require, module, exports) {
        'use strict';

        var forEach = require('lodash/collection/forEach');

        var svgAppend = require('tiny-svg/lib/append'),
            svgAttr = require('tiny-svg/lib/attr'),
            svgClone = require('tiny-svg/lib/clone'),
            svgCreate = require('tiny-svg/lib/create');

        /**
         * Adds support for previews of moving/resizing elements.
         */
        function PreviewSupport(elementRegistry, canvas, styles) {
            this._elementRegistry = elementRegistry;
            this._canvas = canvas;
            this._styles = styles;
        }

        module.exports = PreviewSupport;

        PreviewSupport.$inject = ['elementRegistry', 'canvas', 'styles'];


        /**
         * Returns graphics of an element.
         *
         * @param {djs.model.Base} element
         *
         * @return {SVGElement}
         */
        PreviewSupport.prototype.getGfx = function (element) {
            return this._elementRegistry.getGraphics(element);
        };

        /**
         * Adds a move preview of a given shape to a given svg group.
         *
         * @param {djs.model.Base} element
         * @param {SVGElement} group
         *
         * @return {SVGElement} dragger
         */
        PreviewSupport.prototype.addDragger = function (shape, group) {
            var gfx = this.getGfx(shape);

            // clone is not included in tsvg for some reason
            var dragger = svgClone(gfx);
            var bbox = gfx.getBoundingClientRect();

            // remove markers from connections
            if (isConnection(shape)) {
                removeMarkers(dragger);
            }

            svgAttr(dragger, this._styles.cls('djs-dragger', [], {
                x: bbox.top,
                y: bbox.left
            }));

            svgAppend(group, dragger);

            return dragger;
        };

        /**
         * Adds a resize preview of a given shape to a given svg group.
         *
         * @param {djs.model.Base} element
         * @param {SVGElement} group
         *
         * @return {SVGElement} frame
         */
        PreviewSupport.prototype.addFrame = function (shape, group) {

            var frame = svgCreate('rect', {
                class: 'djs-resize-overlay',
                width: shape.width,
                height: shape.height,
                x: shape.x,
                y: shape.y
            });

            svgAppend(group, frame);

            return frame;
        };

        ////////// helpers //////////

        /**
         * Removes all svg marker references from an SVG.
         *
         * @param {SVGElement} gfx
         */
        function removeMarkers(gfx) {

            if (gfx.children) {

                forEach(gfx.children, function (child) {

                    // recursion
                    removeMarkers(child);

                });

            }

            gfx.style.markerStart = '';
            gfx.style.markerEnd = '';

        }

        /**
         * Checks if an element is a connection.
         */
        function isConnection(element) {
            return element.waypoints;
        }

    }, { "lodash/collection/forEach": 304, "tiny-svg/lib/append": 473, "tiny-svg/lib/attr": 475, "tiny-svg/lib/clone": 478, "tiny-svg/lib/create": 479 }], 217: [function (require, module, exports) {
        'use strict';

        module.exports = {
            __init__: ['previewSupport'],
            previewSupport: ['type', require('./PreviewSupport')]
        };

    }, { "./PreviewSupport": 216 }], 218: [function (require, module, exports) {
        'use strict';


        /**
         * Service that allow replacing of elements.
         *
         *
         * @class
         * @constructor
         */
        function Replace(modeling) {

            this._modeling = modeling;
        }

        module.exports = Replace;

        Replace.$inject = ['modeling'];

        /**
         * @param {Element} oldElement - Element to be replaced
         * @param {Object}  newElementData - Containing information about the new Element, for example height, width, type.
         * @param {Object}  options - Custom options that will be attached to the context. It can be used to inject data
         *                            that is needed in the command chain. For example it could be used in
         *                            eventbus.on('commandStack.shape.replace.postExecute') to change shape attributes after
         *                            shape creation.
         */
        Replace.prototype.replaceElement = function (oldElement, newElementData, options) {

            var modeling = this._modeling;

            var newElement = null;

            if (oldElement.waypoints) {
                // TODO
                // modeling.replaceConnection
            } else {
                // set center of element for modeling API
                // if no new width / height is given use old elements size
                newElementData.x = Math.ceil(oldElement.x + (newElementData.width || oldElement.width) / 2);
                newElementData.y = Math.ceil(oldElement.y + (newElementData.height || oldElement.height) / 2);

                newElement = modeling.replaceShape(oldElement, newElementData, options);
            }

            return newElement;
        };

    }, {}], 219: [function (require, module, exports) {
        'use strict';

        module.exports = {
            __init__: ['replace'],
            replace: ['type', require('./Replace')]
        };

    }, { "./Replace": 218 }], 220: [function (require, module, exports) {
        'use strict';

        var pick = require('lodash/object/pick'),
            assign = require('lodash/object/assign');

        var ResizeUtil = require('./ResizeUtil');

        var asTRBL = require('../../layout/LayoutUtil').asTRBL,
            roundBounds = require('../../layout/LayoutUtil').roundBounds;

        var DEFAULT_MIN_WIDTH = 10;


        /**
         * A component that provides resizing of shapes on the canvas.
         *
         * The following components are part of shape resize:
         *
         *  * adding resize handles,
         *  * creating a visual during resize
         *  * checking resize rules
         *  * committing a change once finished
         *
         *
         * ## Customizing
         *
         * It's possible to customize the resizing behaviour by intercepting 'resize.start'
         * and providing the following parameters through the 'context':
         *
         *   * minDimensions ({ width, height }): minimum shape dimensions
         *
         *   * childrenBoxPadding ({ left, top, bottom, right } || number):
         *     gap between the minimum bounding box and the container
         *
         * f.ex:
         *
         * ```javascript
         * eventBus.on('resize.start', 1500, function(event) {
         *   var context = event.context,
         *
         *  context.minDimensions = { width: 140, height: 120 };
         *
         *  // Passing general padding
         *  context.childrenBoxPadding = 30;
         *
         *  // Passing padding to a specific side
         *  context.childrenBoxPadding.left = 20;
         * });
         * ```
         */
        function Resize(eventBus, rules, modeling, dragging) {

            this._dragging = dragging;
            this._rules = rules;

            var self = this;

            eventBus.on('resize.start', function (event) {

                var context = event.context,
                    resizeConstraints = context.resizeConstraints,
                    // evaluate minBounds for backwards compatibility
                    minBounds = context.minBounds;

                if (resizeConstraints === undefined) {

                    if (minBounds === undefined) {
                        minBounds = self.computeMinResizeBox(context);
                    }

                    context.resizeConstraints = {
                        min: asTRBL(minBounds)
                    };
                }
            });

            eventBus.on('resize.move', function (event) {

                var context = event.context,
                    shape = context.shape,
                    direction = context.direction,
                    resizeConstraints = context.resizeConstraints,
                    delta,
                    newBounds;

                delta = {
                    x: event.dx,
                    y: event.dy
                };

                context.delta = delta;

                newBounds = ResizeUtil.resizeBounds(shape, direction, delta);

                // ensure constraints during resize
                context.newBounds = ResizeUtil.ensureConstraints(newBounds, resizeConstraints);

                // update + cache executable state
                context.canExecute = self.canResize(context);
            });

            eventBus.on('resize.end', function (event) {
                var context = event.context,
                    shape = context.shape,
                    canExecute = context.canExecute,
                    newBounds = context.newBounds;

                if (canExecute) {
                    // ensure we have actual pixel values for new bounds
                    // (important when zoom level was > 1 during move)
                    newBounds = roundBounds(newBounds);

                    // perform the actual resize
                    modeling.resizeShape(shape, newBounds);
                }
            });
        }


        Resize.prototype.canResize = function (context) {
            var rules = this._rules;

            var ctx = pick(context, ['newBounds', 'shape', 'delta', 'direction']);

            return rules.allowed('shape.resize', ctx);
        };

        /**
         * Activate a resize operation
         *
         * You may specify additional contextual information and must specify a
         * resize direction during activation of the resize event.
         *
         * @param {MouseEvent} event
         * @param {djs.model.Shape} shape
         * @param {Object|String} contextOrDirection
         */
        Resize.prototype.activate = function (event, shape, contextOrDirection) {
            var dragging = this._dragging,
                context,
                direction;

            if (typeof contextOrDirection === 'string') {
                contextOrDirection = {
                    direction: contextOrDirection
                };
            }

            context = assign({ shape: shape }, contextOrDirection);

            direction = context.direction;

            if (!direction) {
                throw new Error('must provide a direction (nw|se|ne|sw)');
            }

            dragging.init(event, 'resize', {
                autoActivate: true,
                cursor: 'resize-' + (/nw|se/.test(direction) ? 'nwse' : 'nesw'),
                data: {
                    shape: shape,
                    context: context
                }
            });
        };

        Resize.prototype.computeMinResizeBox = function (context) {
            var shape = context.shape,
                direction = context.direction,
                minDimensions,
                childrenBounds;

            minDimensions = context.minDimensions || {
                width: DEFAULT_MIN_WIDTH,
                height: DEFAULT_MIN_WIDTH
            };

            // get children bounds
            childrenBounds = ResizeUtil.computeChildrenBBox(shape, context.childrenBoxPadding);

            // get correct minimum bounds from given resize direction
            // basically ensures that the minBounds is max(childrenBounds, minDimensions)
            return ResizeUtil.getMinResizeBounds(direction, shape, minDimensions, childrenBounds);
        };


        Resize.$inject = ['eventBus', 'rules', 'modeling', 'dragging'];

        module.exports = Resize;

    }, { "../../layout/LayoutUtil": 252, "./ResizeUtil": 223, "lodash/object/assign": 433, "lodash/object/pick": 440 }], 221: [function (require, module, exports) {
        'use strict';

        var forEach = require('lodash/collection/forEach');

        var HANDLE_OFFSET = -2,
            HANDLE_SIZE = 5,
            HANDLE_HIT_SIZE = 20;

        var CLS_RESIZER = 'djs-resizer';

        var svgAppend = require('tiny-svg/lib/append'),
            svgAttr = require('tiny-svg/lib/attr'),
            svgClasses = require('tiny-svg/lib/classes'),
            svgClear = require('tiny-svg/lib/clear'),
            svgCreate = require('tiny-svg/lib/create');

        var domEvent = require('min-dom/lib/event');

        var isPrimaryButton = require('../../util/Mouse').isPrimaryButton;

        var asTRBL = require('../../layout/LayoutUtil').asTRBL;

        var transform = require('../../util/SvgTransformUtil').transform;


        /**
         * This component is responsible for adding resize handles.
         *
         * @param {EventBus} eventBus
         * @param {Canvas} canvas
         * @param {Selection} selection
         * @param {Resize} resize
         */
        function ResizeHandles(eventBus, canvas, selection, resize) {

            this._resize = resize;
            this._canvas = canvas;

            var self = this;

            eventBus.on('selection.changed', function (e) {
                var newSelection = e.newSelection;

                // remove old selection markers
                self.removeResizers();

                // add new selection markers ONLY if single selection
                if (newSelection.length === 1) {
                    forEach(newSelection, self.addResizer, self);
                }
            });

            eventBus.on('shape.changed', function (e) {
                var shape = e.element;

                if (selection.isSelected(shape)) {
                    self.removeResizers();

                    self.addResizer(shape);
                }
            });
        }


        ResizeHandles.prototype.makeDraggable = function (element, gfx, direction) {
            var resize = this._resize;

            function startResize(event) {
                // only trigger on left mouse button
                if (isPrimaryButton(event)) {
                    resize.activate(event, element, direction);
                }
            }

            domEvent.bind(gfx, 'mousedown', startResize);
            domEvent.bind(gfx, 'touchstart', startResize);
        };


        ResizeHandles.prototype._createResizer = function (element, x, y, rotation, direction) {
            var resizersParent = this._getResizersParent();

            var group = svgCreate('g');
            svgClasses(group).add(CLS_RESIZER);
            svgClasses(group).add(CLS_RESIZER + '-' + element.id);
            svgClasses(group).add(CLS_RESIZER + '-' + direction);

            svgAppend(resizersParent, group);

            var origin = -HANDLE_SIZE + HANDLE_OFFSET;

            // Create four drag indicators on the outline
            var visual = svgCreate('rect');
            svgAttr(visual, {
                x: origin,
                y: origin,
                width: HANDLE_SIZE,
                height: HANDLE_SIZE
            });
            svgClasses(visual).add(CLS_RESIZER + '-visual');

            svgAppend(group, visual);

            var hit = svgCreate('rect');
            svgAttr(hit, {
                x: origin,
                y: origin,
                width: HANDLE_HIT_SIZE,
                height: HANDLE_HIT_SIZE
            });
            svgClasses(hit).add(CLS_RESIZER + '-hit');

            svgAppend(group, hit);

            transform(group, x, y, rotation);

            return group;
        };

        ResizeHandles.prototype.createResizer = function (element, direction) {
            var resizer;

            var trbl = asTRBL(element);

            if (direction === 'nw') {
                resizer = this._createResizer(element, trbl.left, trbl.top, 0, direction);
            } else if (direction === 'ne') {
                resizer = this._createResizer(element, trbl.right, trbl.top, 90, direction);
            } else if (direction === 'se') {
                resizer = this._createResizer(element, trbl.right, trbl.bottom, 180, direction);
            } else {
                resizer = this._createResizer(element, trbl.left, trbl.bottom, 270, direction);
            }

            this.makeDraggable(element, resizer, direction);
        };

        // resize handles implementation ///////////////////////////////

        /**
         * Add resizers for a given element.
         *
         * @param {djs.model.Shape} shape
         */
        ResizeHandles.prototype.addResizer = function (shape) {
            var resize = this._resize;

            if (!resize.canResize({ shape: shape })) {
                return;
            }

            this.createResizer(shape, 'nw');
            this.createResizer(shape, 'ne');
            this.createResizer(shape, 'se');
            this.createResizer(shape, 'sw');
        };

        /**
         * Remove all resizers
         */
        ResizeHandles.prototype.removeResizers = function () {
            var resizersParent = this._getResizersParent();

            svgClear(resizersParent);
        };

        ResizeHandles.prototype._getResizersParent = function () {
            return this._canvas.getLayer('resizers');
        };

        ResizeHandles.$inject = ['eventBus', 'canvas', 'selection', 'resize'];

        module.exports = ResizeHandles;

    }, { "../../layout/LayoutUtil": 252, "../../util/Mouse": 274, "../../util/SvgTransformUtil": 279, "lodash/collection/forEach": 304, "min-dom/lib/event": 452, "tiny-svg/lib/append": 473, "tiny-svg/lib/attr": 475, "tiny-svg/lib/classes": 476, "tiny-svg/lib/clear": 477, "tiny-svg/lib/create": 479 }], 222: [function (require, module, exports) {
        'use strict';

        var MARKER_RESIZING = 'djs-resizing',
            MARKER_RESIZE_NOT_OK = 'resize-not-ok';

        var LOW_PRIORITY = 500;

        var svgAttr = require('tiny-svg/lib/attr'),
            svgRemove = require('tiny-svg/lib/remove');

        var svgClasses = require('tiny-svg/lib/classes');


        /**
         * Provides previews for resizing shapes when resizing.
         *
         * @param {EventBus} eventBus
         * @param {ElementRegistry} elementRegistry
         * @param {Canvas} canvas
         * @param {Styles} styles
         */
        function ResizePreview(eventBus, elementRegistry, canvas, styles, previewSupport) {

            // add and update previews
            eventBus.on('resize.move', LOW_PRIORITY, function (event) {
                var context = event.context,
                    shape = context.shape,
                    bounds = context.newBounds,
                    frame = context.frame;

                if (!frame) {
                    frame = context.frame = previewSupport.addFrame(shape, canvas.getDefaultLayer());

                    canvas.addMarker(shape, MARKER_RESIZING);
                }

                if (bounds.width > 5) {
                    svgAttr(frame, { x: bounds.x, width: bounds.width });
                }

                if (bounds.height > 5) {
                    svgAttr(frame, { y: bounds.y, height: bounds.height });
                }

                if (context.canExecute) {
                    svgClasses(frame).remove(MARKER_RESIZE_NOT_OK);
                } else {
                    svgClasses(frame).add(MARKER_RESIZE_NOT_OK);
                }

            });

            // remove previews
            eventBus.on('resize.cleanup', function (event) {
                var context = event.context,
                    shape = context.shape,
                    frame = context.frame;

                if (frame) {
                    svgRemove(context.frame);
                }

                canvas.removeMarker(shape, MARKER_RESIZING);
            });
        }

        ResizePreview.$inject = ['eventBus', 'elementRegistry', 'canvas', 'styles', 'previewSupport'];

        module.exports = ResizePreview;

    }, { "tiny-svg/lib/attr": 475, "tiny-svg/lib/classes": 476, "tiny-svg/lib/remove": 482 }], 223: [function (require, module, exports) {
        'use strict';

        var filter = require('lodash/collection/filter');

        var max = Math.max,
            min = Math.min;

        var DEFAULT_CHILD_BOX_PADDING = 20;

        var getBBox = require('../../util/Elements').getBBox;


        var asTRBL = require('../../layout/LayoutUtil').asTRBL,
            asBounds = require('../../layout/LayoutUtil').asBounds;

        function isNumber(a) {
            return typeof a === 'number';
        }

        /**
         * Substract a TRBL from another
         *
         * @param  {TRBL} trblA
         * @param  {TRBL} trblB
         *
         * @return {TRBL}
         */
        module.exports.substractTRBL = function (trblA, trblB) {
            return {
                top: trblA.top - trblB.top,
                right: trblA.right - trblB.right,
                bottom: trblA.bottom - trblB.bottom,
                left: trblA.left - trblB.left
            };
        };

        /**
         * Resize the given bounds by the specified delta from a given anchor point.
         *
         * @param {Bounds} bounds the bounding box that should be resized
         * @param {String} direction in which the element is resized (nw, ne, se, sw)
         * @param {Point} delta of the resize operation
         *
         * @return {Bounds} resized bounding box
         */
        module.exports.resizeBounds = function (bounds, direction, delta) {

            var dx = delta.x,
                dy = delta.y;

            switch (direction) {

                case 'nw':
                    return {
                        x: bounds.x + dx,
                        y: bounds.y + dy,
                        width: bounds.width - dx,
                        height: bounds.height - dy
                    };

                case 'sw':
                    return {
                        x: bounds.x + dx,
                        y: bounds.y,
                        width: bounds.width - dx,
                        height: bounds.height + dy
                    };

                case 'ne':
                    return {
                        x: bounds.x,
                        y: bounds.y + dy,
                        width: bounds.width + dx,
                        height: bounds.height - dy
                    };

                case 'se':
                    return {
                        x: bounds.x,
                        y: bounds.y,
                        width: bounds.width + dx,
                        height: bounds.height + dy
                    };

                default:
                    throw new Error('unrecognized direction: ' + direction);
            }
        };


        /**
         * Resize the given bounds by applying the passed
         * { top, right, bottom, left } delta.
         *
         * @param {Bounds} bounds
         * @param {TRBL} trblResize
         *
         * @return {Bounds}
         */
        module.exports.resizeTRBL = function (bounds, resize) {
            return {
                x: bounds.x + (resize.left || 0),
                y: bounds.y + (resize.top || 0),
                width: bounds.width - (resize.left || 0) + (resize.right || 0),
                height: bounds.height - (resize.top || 0) + (resize.bottom || 0)
            };
        };


        module.exports.reattachPoint = function (bounds, newBounds, point) {

            var sx = bounds.width / newBounds.width,
                sy = bounds.height / newBounds.height;

            return {
                x: Math.round((newBounds.x + newBounds.width / 2)) - Math.floor(((bounds.x + bounds.width / 2) - point.x) / sx),
                y: Math.round((newBounds.y + newBounds.height / 2)) - Math.floor(((bounds.y + bounds.height / 2) - point.y) / sy)
            };
        };


        function applyConstraints(attr, trbl, resizeConstraints) {

            var value = trbl[attr],
                minValue = resizeConstraints.min && resizeConstraints.min[attr],
                maxValue = resizeConstraints.max && resizeConstraints.max[attr];

            if (isNumber(minValue)) {
                value = (/top|left/.test(attr) ? min : max)(value, minValue);
            }

            if (isNumber(maxValue)) {
                value = (/top|left/.test(attr) ? max : min)(value, maxValue);
            }

            return value;
        }

        module.exports.ensureConstraints = function (currentBounds, resizeConstraints) {

            if (!resizeConstraints) {
                return currentBounds;
            }

            var currentTrbl = asTRBL(currentBounds);

            return asBounds({
                top: applyConstraints('top', currentTrbl, resizeConstraints),
                right: applyConstraints('right', currentTrbl, resizeConstraints),
                bottom: applyConstraints('bottom', currentTrbl, resizeConstraints),
                left: applyConstraints('left', currentTrbl, resizeConstraints)
            });
        };


        module.exports.getMinResizeBounds = function (direction, currentBounds, minDimensions, childrenBounds) {

            var currentBox = asTRBL(currentBounds);

            var minBox = {
                top: /n/.test(direction) ? currentBox.bottom - minDimensions.height : currentBox.top,
                left: /w/.test(direction) ? currentBox.right - minDimensions.width : currentBox.left,
                bottom: /s/.test(direction) ? currentBox.top + minDimensions.height : currentBox.bottom,
                right: /e/.test(direction) ? currentBox.left + minDimensions.width : currentBox.right
            };

            var childrenBox = childrenBounds ? asTRBL(childrenBounds) : minBox;

            var combinedBox = {
                top: min(minBox.top, childrenBox.top),
                left: min(minBox.left, childrenBox.left),
                bottom: max(minBox.bottom, childrenBox.bottom),
                right: max(minBox.right, childrenBox.right)
            };

            return asBounds(combinedBox);
        };

        function asPadding(mayBePadding, defaultValue) {
            if (typeof mayBePadding !== 'undefined') {
                return mayBePadding;
            } else {
                return DEFAULT_CHILD_BOX_PADDING;
            }
        }

        function addPadding(bbox, padding) {
            var left, right, top, bottom;

            if (typeof padding === 'object') {
                left = asPadding(padding.left);
                right = asPadding(padding.right);
                top = asPadding(padding.top);
                bottom = asPadding(padding.bottom);
            } else {
                left = right = top = bottom = asPadding(padding);
            }

            return {
                x: bbox.x - left,
                y: bbox.y - top,
                width: bbox.width + left + right,
                height: bbox.height + top + bottom
            };
        }

        module.exports.addPadding = addPadding;


        /**
         * Is the given element part of the resize
         * targets min boundary box?
         *
         * This is the default implementation which excludes
         * connections and labels.
         *
         * @param {djs.model.Base} element
         */
        function isBBoxChild(element) {

            // exclude connections
            if (element.waypoints) {
                return false;
            }

            // exclude labels
            if (element.type === 'label') {
                return false;
            }

            return true;
        }

        /**
         * Return children bounding computed from a shapes children
         * or a list of prefiltered children.
         *
         * @param  {djs.model.Shape|Array<djs.model.Shape>} shapeOrChildren
         * @param  {Number|Object} padding
         *
         * @return {Bounds}
         */
        function computeChildrenBBox(shapeOrChildren, padding) {

            var elements;

            // compute based on shape
            if (shapeOrChildren.length === undefined) {
                // grab all the children that are part of the
                // parents children box
                elements = filter(shapeOrChildren.children, isBBoxChild);

            } else {
                elements = shapeOrChildren;
            }

            if (elements.length) {
                return addPadding(getBBox(elements), padding);
            }
        }

        module.exports.computeChildrenBBox = computeChildrenBBox;

    }, { "../../layout/LayoutUtil": 252, "../../util/Elements": 266, "lodash/collection/filter": 302 }], 224: [function (require, module, exports) {
        module.exports = {
            __depends__: [
                require('../rules'),
                require('../dragging'),
                require('../preview-support')
            ],
            __init__: ['resize', 'resizePreview', 'resizeHandles'],
            resize: ['type', require('./Resize')],
            resizePreview: ['type', require('./ResizePreview')],
            resizeHandles: ['type', require('./ResizeHandles')]
        };

    }, { "../dragging": 162, "../preview-support": 217, "../rules": 227, "./Resize": 220, "./ResizeHandles": 221, "./ResizePreview": 222 }], 225: [function (require, module, exports) {

        'use strict';

        var inherits = require('inherits');

        var CommandInterceptor = require('../../command/CommandInterceptor');

        /**
         * A basic provider that may be extended to implement modeling rules.
         *
         * Extensions should implement the init method to actually add their custom
         * modeling checks. Checks may be added via the #addRule(action, fn) method.
         *
         * @param {EventBus} eventBus
         */
        function RuleProvider(eventBus) {
            CommandInterceptor.call(this, eventBus);

            this.init();
        }

        RuleProvider.$inject = ['eventBus'];

        inherits(RuleProvider, CommandInterceptor);

        module.exports = RuleProvider;


        /**
         * Adds a modeling rule for the given action, implemented through
         * a callback function.
         *
         * The function will receive the modeling specific action context
         * to perform its check. It must return `false` to disallow the
         * action from happening or `true` to allow the action.
         *
         * A rule provider may pass over the evaluation to lower priority
         * rules by returning return nothing (or <code>undefined</code>).
         *
         * @example
         *
         * ResizableRules.prototype.init = function() {
         *
         *   \/**
         *    * Return `true`, `false` or nothing to denote
         *    * _allowed_, _not allowed_ and _continue evaluating_.
         *    *\/
         *   this.addRule('shape.resize', function(context) {
         *
         *     var shape = context.shape;
         *
         *     if (!context.newBounds) {
         *       // check general resizability
         *       if (!shape.resizable) {
         *         return false;
         *       }
         *
         *       // not returning anything (read: undefined)
         *       // will continue the evaluation of other rules
         *       // (with lower priority)
         *       return;
         *     } else {
         *       // element must have minimum size of 10*10 points
         *       return context.newBounds.width > 10 && context.newBounds.height > 10;
         *     }
         *   });
         * };
         *
         * @param {String|Array<String>} actions the identifier for the modeling action to check
         * @param {Number} [priority] the priority at which this rule is being applied
         * @param {Function} fn the callback function that performs the actual check
         */
        RuleProvider.prototype.addRule = function (actions, priority, fn) {

            var self = this;

            if (typeof actions === 'string') {
                actions = [actions];
            }

            actions.forEach(function (action) {

                self.canExecute(action, priority, function (context, action, event) {
                    return fn(context);
                }, true);
            });
        };

        /**
         * Implement this method to add new rules during provider initialization.
         */
        RuleProvider.prototype.init = function () { };
    }, { "../../command/CommandInterceptor": 119, "inherits": 289 }], 226: [function (require, module, exports) {
        'use strict';

        /**
         * A service that provides rules for certain diagram actions.
         *
         * The default implementation will hook into the {@link CommandStack}
         * to perform the actual rule evaluation. Make sure to provide the
         * `commandStack` service with this module if you plan to use it.
         *
         * Together with this implementation you may use the {@link RuleProvider}
         * to implement your own rule checkers.
         *
         * This module is ment to be easily replaced, thus the tiny foot print.
         *
         * @param {Injector} injector
         */
        function Rules(injector) {
            this._commandStack = injector.get('commandStack', false);
        }

        Rules.$inject = ['injector'];

        module.exports = Rules;


        /**
         * Returns whether or not a given modeling action can be executed
         * in the specified context.
         *
         * This implementation will respond with allow unless anyone
         * objects.
         *
         * @param {String} action the action to be checked
         * @param {Object} [context] the context to check the action in
         *
         * @return {Boolean} returns true, false or null depending on whether the
         *                   operation is allowed, not allowed or should be ignored.
         */
        Rules.prototype.allowed = function (action, context) {
            var allowed = true;

            var commandStack = this._commandStack;

            if (commandStack) {
                allowed = commandStack.canExecute(action, context);
            }

            // map undefined to true, i.e. no rules
            return allowed === undefined ? true : allowed;
        };
    }, {}], 227: [function (require, module, exports) {
        module.exports = {
            __init__: ['rules'],
            rules: ['type', require('./Rules')]
        };

    }, { "./Rules": 226 }], 228: [function (require, module, exports) {
        'use strict';

        var domClear = require('min-dom/lib/clear'),
            domDelegate = require('min-dom/lib/delegate'),
            domQuery = require('min-dom/lib/query'),
            domClasses = require('min-dom/lib/classes'),
            domAttr = require('min-dom/lib/attr'),
            domify = require('min-dom/lib/domify');

        var getBoundingBox = require('../../util/Elements').getBBox;


        /**
         * Provides searching infrastructure
         */
        function SearchPad(canvas, eventBus, overlays, selection) {
            this._open = false;
            this._results = [];
            this._eventMaps = [];

            this._canvas = canvas;
            this._eventBus = eventBus;
            this._overlays = overlays;
            this._selection = selection;

            // setup elements
            this._container = domify(SearchPad.BOX_HTML);
            this._searchInput = domQuery(SearchPad.INPUT_SELECTOR, this._container);
            this._resultsContainer = domQuery(SearchPad.RESULTS_CONTAINER_SELECTOR, this._container);

            // attach search pad
            this._canvas.getContainer().appendChild(this._container);

            // cleanup on destroy
            eventBus.on(['canvas.destroy', 'diagram.destroy'], this.close, this);
        }


        SearchPad.$inject = [
            'canvas',
            'eventBus',
            'overlays',
            'selection'
        ];


        /**
         * Binds and keeps track of all event listereners
         */
        SearchPad.prototype._bindEvents = function () {
            var self = this;

            function listen(el, selector, type, fn) {
                self._eventMaps.push({
                    el: el,
                    type: type,
                    listener: domDelegate.bind(el, selector, type, fn)
                });
            }

            // close search on clicking anywhere outside
            listen(document, 'html', 'click', function (e) {
                self.close();
            }, true);

            // stop event from propagating and closing search
            // focus on input
            listen(this._container, SearchPad.INPUT_SELECTOR, 'click', function (e) {
                e.stopPropagation();
                e.delegateTarget.focus();
            });

            // preselect result on hover
            listen(this._container, SearchPad.RESULT_SELECTOR, 'mouseover', function (e) {
                e.stopPropagation();
                self._scrollToNode(e.delegateTarget);
                self._preselect(e.delegateTarget);
            });

            // selects desired result on mouse click
            listen(this._container, SearchPad.RESULT_SELECTOR, 'click', function (e) {
                e.stopPropagation();
                self._select(e.delegateTarget);
            });

            // prevent cursor in input from going left and right when using up/down to
            // navigate results
            listen(this._container, SearchPad.INPUT_SELECTOR, 'keydown', function (e) {
                // up
                if (e.keyCode === 38) {
                    e.preventDefault();
                }

                // down
                if (e.keyCode === 40) {
                    e.preventDefault();
                }
            });

            // handle keyboard input
            listen(this._container, SearchPad.INPUT_SELECTOR, 'keyup', function (e) {
                // escape
                if (e.keyCode === 27) {
                    return self.close();
                }

                // enter
                if (e.keyCode === 13) {
                    var selected = self._getCurrentResult();

                    return selected ? self._select(selected) : self.close();
                }

                // up
                if (e.keyCode === 38) {
                    return self._scrollToDirection(true);
                }

                // down
                if (e.keyCode === 40) {
                    return self._scrollToDirection();
                }

                // left && right
                // do not search while navigating text input
                if (e.keyCode === 37 || e.keyCode === 39) {
                    return;
                }

                // anything else
                self._search(e.delegateTarget.value);
            });
        };


        /**
         * Unbinds all previously established listeners
         */
        SearchPad.prototype._unbindEvents = function () {
            this._eventMaps.forEach(function (m) {
                domDelegate.unbind(m.el, m.type, m.listener);
            });
        };


        /**
         * Performs a search for the given pattern.
         *
         * @param  {String} pattern
         */
        SearchPad.prototype._search = function (pattern) {
            var self = this;

            this._clearResults();

            // do not search on empty query
            if (!pattern || pattern === '') {
                return;
            }

            var searchResults = this._searchProvider.find(pattern);

            if (!searchResults.length) {
                return;
            }

            // append new results
            searchResults.forEach(function (result) {
                var id = result.element.id;
                var node = self._createResultNode(result, id);
                self._results[id] = {
                    element: result.element,
                    node: node
                };
            });

            // preselect first result
            var node = domQuery(SearchPad.RESULT_SELECTOR, this._resultsContainer);
            this._scrollToNode(node);
            this._preselect(node);
        };


        /**
         * Navigate to the previous/next result. Defaults to next result.
         * @param  {Boolean} previous
         */
        SearchPad.prototype._scrollToDirection = function (previous) {
            var selected = this._getCurrentResult();
            if (!selected) {
                return;
            }

            var node = previous ? selected.previousElementSibling : selected.nextElementSibling;
            if (node) {
                this._scrollToNode(node);
                this._preselect(node);
            }
        };


        /**
         * Scroll to the node if it is not visible.
         *
         * @param  {Element} node
         */
        SearchPad.prototype._scrollToNode = function (node) {
            if (!node || node === this._getCurrentResult()) {
                return;
            }

            var nodeOffset = node.offsetTop;
            var containerScroll = this._resultsContainer.scrollTop;

            var bottomScroll = nodeOffset - this._resultsContainer.clientHeight + node.clientHeight;

            if (nodeOffset < containerScroll) {
                this._resultsContainer.scrollTop = nodeOffset;
            } else if (containerScroll < bottomScroll) {
                this._resultsContainer.scrollTop = bottomScroll;
            }
        };


        /**
         * Clears all results data.
         */
        SearchPad.prototype._clearResults = function () {
            domClear(this._resultsContainer);

            this._results = [];

            this._resetOverlay();

            this._eventBus.fire('searchPad.cleared');
        };


        /**
         * Get currently selected result.
         *
         * @return {Element}
         */
        SearchPad.prototype._getCurrentResult = function () {
            return domQuery(SearchPad.RESULT_SELECTED_SELECTOR, this._resultsContainer);
        };


        /**
         * Create result DOM element within results container
         * that corresponds to a search result.
         *
         * 'result' : one of the elements returned by SearchProvider
         * 'id' : id attribute value to assign to the new DOM node
         * return : created DOM element
         *
         * @param  {SearchResult} result
         * @param  {String} id
         * @return {Element}
         */
        SearchPad.prototype._createResultNode = function (result, id) {
            var node = domify(SearchPad.RESULT_HTML);

            // create only if available
            if (result.primaryTokens.length > 0) {
                createInnerTextNode(node, result.primaryTokens, SearchPad.RESULT_PRIMARY_HTML);
            }

            // secondary tokens (represent element ID) are allways available
            createInnerTextNode(node, result.secondaryTokens, SearchPad.RESULT_SECONDARY_HTML);

            domAttr(node, SearchPad.RESULT_ID_ATTRIBUTE, id);

            this._resultsContainer.appendChild(node);

            return node;
        };


        /**
         * Register search element provider.
         *
         * SearchProvider.find - provides search function over own elements
         *  (pattern) => [{ text: <String>, element: <Element>}, ...]
         *
         * @param  {SearchProvider} provider
         */
        SearchPad.prototype.registerProvider = function (provider) {
            this._searchProvider = provider;
        };


        /**
         * Open search pad.
         */
        SearchPad.prototype.open = function () {
            if (!this._searchProvider) {
                throw new Error('no search provider registered');
            }

            if (this.isOpen()) {
                return;
            }

            this._bindEvents();

            this._open = true;

            domClasses(this._container).add('open');

            this._searchInput.focus();

            this._eventBus.fire('searchPad.opened');
        };


        /**
         * Close search pad.
         */
        SearchPad.prototype.close = function () {
            if (!this.isOpen()) {
                return;
            }

            this._unbindEvents();

            this._open = false;

            domClasses(this._container).remove('open');

            this._clearResults();

            this._searchInput.value = '';
            this._searchInput.blur();

            this._resetOverlay();

            this._eventBus.fire('searchPad.closed');
        };


        /**
         * Toggles search pad on/off.
         */
        SearchPad.prototype.toggle = function () {
            this.isOpen() ? this.close() : this.open();
        };


        /**
         * Report state of search pad.
         */
        SearchPad.prototype.isOpen = function () {
            return this._open;
        };


        /**
         * Preselect result entry.
         *
         * @param  {Element} element
         */
        SearchPad.prototype._preselect = function (node) {
            var selectedNode = this._getCurrentResult();

            // already selected
            if (node === selectedNode) {
                return;
            }

            // removing preselection from current node
            if (selectedNode) {
                domClasses(selectedNode).remove(SearchPad.RESULT_SELECTED_CLASS);
            }

            var id = domAttr(node, SearchPad.RESULT_ID_ATTRIBUTE);
            var element = this._results[id].element;

            domClasses(node).add(SearchPad.RESULT_SELECTED_CLASS);

            this._resetOverlay(element);

            this._centerViewbox(element);

            this._selection.select(element);

            this._eventBus.fire('searchPad.preselected', element);
        };


        /**
         * Select result node.
         *
         * @param  {Element} element
         */
        SearchPad.prototype._select = function (node) {
            var id = domAttr(node, SearchPad.RESULT_ID_ATTRIBUTE);
            var element = this._results[id].element;

            this.close();

            this._resetOverlay();

            this._centerViewbox(element);

            this._selection.select(element);

            this._eventBus.fire('searchPad.selected', element);
        };


        /**
         * Center viewbox on the element middle point.
         *
         * @param  {Element} element
         */
        SearchPad.prototype._centerViewbox = function (element) {
            var viewbox = this._canvas.viewbox();

            var box = getBoundingBox(element);

            var newViewbox = {
                x: (box.x + box.width / 2) - viewbox.outer.width / 2,
                y: (box.y + box.height / 2) - viewbox.outer.height / 2,
                width: viewbox.outer.width,
                height: viewbox.outer.height
            };

            this._canvas.viewbox(newViewbox);

            this._canvas.zoom(viewbox.scale);
        };


        /**
         * Reset overlay removes and, optionally, set
         * overlay to a new element.
         *
         * @param  {Element} element
         */
        SearchPad.prototype._resetOverlay = function (element) {
            if (this._overlayId) {
                this._overlays.remove(this._overlayId);
            }

            if (element) {
                var box = getBoundingBox(element);
                var overlay = constructOverlay(box);
                this._overlayId = this._overlays.add(element, overlay);
            }
        };


        module.exports = SearchPad;

        /**
         * Construct overlay object for the given bounding box.
         *
         * @param  {BoundingBox} box
         * @return {Object}
         */
        function constructOverlay(box) {

            var offset = 6;
            var w = box.width + offset * 2;
            var h = box.height + offset * 2;

            var styles = [
                'width: ' + w + 'px',
                'height: ' + h + 'px'
            ].join('; ');

            return {
                position: {
                    bottom: h - offset,
                    right: w - offset
                },
                show: true,
                html: '<div style="' + styles + '" class="' + SearchPad.OVERLAY_CLASS + '"></div>'
            };
        }


        /**
         * Creates and appends child node from result tokens and HTML template.
         *
         * @param  {Element} node
         * @param  {Array<Object>} tokens
         * @param  {String} template
         */
        function createInnerTextNode(parentNode, tokens, template) {
            var text = createHtmlText(tokens);
            var childNode = domify(template);
            childNode.innerHTML = text;
            parentNode.appendChild(childNode);
        }

        /**
         * Create internal HTML markup from result tokens.
         * Caters for highlighting pattern matched tokens.
         *
         * @param  {Array<Object>} tokens
         * @return {String}
         */
        function createHtmlText(tokens) {
            var htmlText = '';

            tokens.forEach(function (t) {
                if (t.matched) {
                    htmlText += '<strong class="' + SearchPad.RESULT_HIGHLIGHT_CLASS + '">' + t.matched + '</strong>';
                } else {
                    htmlText += t.normal;
                }
            });

            return htmlText !== '' ? htmlText : null;
        }


        /**
         * CONSTANTS
         */
        SearchPad.CONTAINER_SELECTOR = '.djs-search-container';
        SearchPad.INPUT_SELECTOR = '.djs-search-input input';
        SearchPad.RESULTS_CONTAINER_SELECTOR = '.djs-search-results';
        SearchPad.RESULT_SELECTOR = '.djs-search-result';
        SearchPad.RESULT_SELECTED_CLASS = 'djs-search-result-selected';
        SearchPad.RESULT_SELECTED_SELECTOR = '.' + SearchPad.RESULT_SELECTED_CLASS;
        SearchPad.RESULT_ID_ATTRIBUTE = 'data-result-id';
        SearchPad.RESULT_HIGHLIGHT_CLASS = 'djs-search-highlight';
        SearchPad.OVERLAY_CLASS = 'djs-search-overlay';

        SearchPad.BOX_HTML =
            '<div class="djs-search-container djs-draggable djs-scrollable">' +
            '<div class="djs-search-input">' +
            '<input type="text"/>' +
            '</div>' +
            '<div class="djs-search-results"></div>' +
            '</div>';

        SearchPad.RESULT_HTML =
            '<div class="djs-search-result"></div>';

        SearchPad.RESULT_PRIMARY_HTML =
            '<div class="djs-search-result-primary"></div>';

        SearchPad.RESULT_SECONDARY_HTML =
            '<p class="djs-search-result-secondary"></p>';

    }, { "../../util/Elements": 266, "min-dom/lib/attr": 446, "min-dom/lib/classes": 447, "min-dom/lib/clear": 448, "min-dom/lib/delegate": 450, "min-dom/lib/domify": 451, "min-dom/lib/query": 454 }], 229: [function (require, module, exports) {
        module.exports = {
            __depends__: [
                require('../overlays'),
                require('../selection')
            ],
            searchPad: ['type', require('./SearchPad')]
        };

    }, { "../overlays": 211, "../selection": 233, "./SearchPad": 228 }], 230: [function (require, module, exports) {
        'use strict';

        var isArray = require('lodash/lang/isArray'),
            forEach = require('lodash/collection/forEach');


        /**
         * A service that offers the current selection in a diagram.
         * Offers the api to control the selection, too.
         *
         * @class
         *
         * @param {EventBus} eventBus the event bus
         */
        function Selection(eventBus) {

            this._eventBus = eventBus;

            this._selectedElements = [];

            var self = this;

            eventBus.on(['shape.remove', 'connection.remove'], function (e) {
                var element = e.element;
                self.deselect(element);
            });

            eventBus.on(['diagram.clear'], function (e) {
                self.select(null);
            });
        }

        Selection.$inject = ['eventBus'];

        module.exports = Selection;


        Selection.prototype.deselect = function (element) {
            var selectedElements = this._selectedElements;

            var idx = selectedElements.indexOf(element);

            if (idx !== -1) {
                var oldSelection = selectedElements.slice();

                selectedElements.splice(idx, 1);

                this._eventBus.fire('selection.changed', { oldSelection: oldSelection, newSelection: selectedElements });
            }
        };


        Selection.prototype.get = function () {
            return this._selectedElements;
        };

        Selection.prototype.isSelected = function (element) {
            return this._selectedElements.indexOf(element) !== -1;
        };


        /**
         * This method selects one or more elements on the diagram.
         *
         * By passing an additional add parameter you can decide whether or not the element(s)
         * should be added to the already existing selection or not.
         *
         * @method Selection#select
         *
         * @param  {Object|Object[]} elements element or array of elements to be selected
         * @param  {boolean} [add] whether the element(s) should be appended to the current selection, defaults to false
         */
        Selection.prototype.select = function (elements, add) {
            var selectedElements = this._selectedElements,
                oldSelection = selectedElements.slice();

            if (!isArray(elements)) {
                elements = elements ? [elements] : [];
            }

            // selection may be cleared by passing an empty array or null
            // to the method
            if (add) {
                forEach(elements, function (element) {
                    if (selectedElements.indexOf(element) !== -1) {
                        // already selected
                        return;
                    } else {
                        selectedElements.push(element);
                    }
                });
            } else {
                this._selectedElements = selectedElements = elements.slice();
            }

            this._eventBus.fire('selection.changed', { oldSelection: oldSelection, newSelection: selectedElements });
        };

    }, { "lodash/collection/forEach": 304, "lodash/lang/isArray": 424 }], 231: [function (require, module, exports) {
        'use strict';

        var hasPrimaryModifier = require('../../util/Mouse').hasPrimaryModifier;

        var find = require('lodash/collection/find');


        function SelectionBehavior(eventBus, selection, canvas, elementRegistry) {

            eventBus.on('create.end', 500, function (e) {

                // select the created shape after a
                // successful create operation
                if (e.context.canExecute) {
                    selection.select(e.context.shape);
                }
            });

            eventBus.on('connect.end', 500, function (e) {

                // select the connect end target
                // after a connect operation
                if (e.context.canExecute && e.context.target) {
                    selection.select(e.context.target);
                }
            });

            eventBus.on('shape.move.end', 500, function (e) {
                var previousSelection = e.previousSelection || [];

                var shape = elementRegistry.get(e.context.shape.id);

                // make sure at least the main moved element is being
                // selected after a move operation
                var inSelection = find(previousSelection, function (selectedShape) {
                    return shape.id === selectedShape.id;
                });

                if (!inSelection) {
                    selection.select(shape);
                }
            });

            // Shift + click selection
            eventBus.on('element.click', function (event) {

                var element = event.element;

                // do not select the root element
                // or connections
                if (element === canvas.getRootElement()) {
                    element = null;
                }

                var isSelected = selection.isSelected(element),
                    isMultiSelect = selection.get().length > 1;

                // mouse-event: SELECTION_KEY
                var add = hasPrimaryModifier(event);

                // select OR deselect element in multi selection
                if (isSelected && isMultiSelect) {
                    if (add) {
                        return selection.deselect(element);
                    } else {
                        return selection.select(element);
                    }
                } else
                    if (!isSelected) {
                        selection.select(element, add);
                    } else {
                        selection.deselect(element);
                    }
            });
        }

        SelectionBehavior.$inject = ['eventBus', 'selection', 'canvas', 'elementRegistry'];
        module.exports = SelectionBehavior;

    }, { "../../util/Mouse": 274, "lodash/collection/find": 303 }], 232: [function (require, module, exports) {
        'use strict';

        var forEach = require('lodash/collection/forEach');

        var MARKER_HOVER = 'hover',
            MARKER_SELECTED = 'selected';


        /**
         * A plugin that adds a visible selection UI to shapes and connections
         * by appending the <code>hover</code> and <code>selected</code> classes to them.
         *
         * @class
         *
         * Makes elements selectable, too.
         *
         * @param {EventBus} events
         * @param {SelectionService} selection
         * @param {Canvas} canvas
         */
        function SelectionVisuals(events, canvas, selection, styles) {

            this._multiSelectionBox = null;

            function addMarker(e, cls) {
                canvas.addMarker(e, cls);
            }

            function removeMarker(e, cls) {
                canvas.removeMarker(e, cls);
            }

            events.on('element.hover', function (event) {
                addMarker(event.element, MARKER_HOVER);
            });

            events.on('element.out', function (event) {
                removeMarker(event.element, MARKER_HOVER);
            });

            events.on('selection.changed', function (event) {

                function deselect(s) {
                    removeMarker(s, MARKER_SELECTED);
                }

                function select(s) {
                    addMarker(s, MARKER_SELECTED);
                }

                var oldSelection = event.oldSelection,
                    newSelection = event.newSelection;

                forEach(oldSelection, function (e) {
                    if (newSelection.indexOf(e) === -1) {
                        deselect(e);
                    }
                });

                forEach(newSelection, function (e) {
                    if (oldSelection.indexOf(e) === -1) {
                        select(e);
                    }
                });
            });
        }

        SelectionVisuals.$inject = [
            'eventBus',
            'canvas',
            'selection',
            'styles'
        ];

        module.exports = SelectionVisuals;

    }, { "lodash/collection/forEach": 304 }], 233: [function (require, module, exports) {
        module.exports = {
            __init__: ['selectionVisuals', 'selectionBehavior'],
            __depends__: [
                require('../interaction-events'),
                require('../outline')
            ],
            selection: ['type', require('./Selection')],
            selectionVisuals: ['type', require('./SelectionVisuals')],
            selectionBehavior: ['type', require('./SelectionBehavior')]
        };

    }, { "../interaction-events": 170, "../outline": 209, "./Selection": 230, "./SelectionBehavior": 231, "./SelectionVisuals": 232 }], 234: [function (require, module, exports) {
        'use strict';

        var forEach = require('lodash/collection/forEach');

        var snapTo = require('./SnapUtil').snapTo;


        /**
         * A snap context, containing the (possibly incomplete)
         * mappings of drop targets (to identify the snapping)
         * to computed snap points.
         */
        function SnapContext() {

            /**
             * Map<String, SnapPoints> mapping drop targets to
             * a list of possible snappings.
             *
             * @type {Object}
             */
            this._targets = {};

            /**
             * Map<String, Point> initial positioning of element
             * regarding various snap directions.
             *
             * @type {Object}
             */
            this._snapOrigins = {};

            /**
             * List of snap locations
             *
             * @type {Array<String>}
             */
            this._snapLocations = [];

            /**
             * Map<String, Array<Point>> of default snapping locations
             *
             * @type {Object}
             */
            this._defaultSnaps = {};
        }


        SnapContext.prototype.getSnapOrigin = function (snapLocation) {
            return this._snapOrigins[snapLocation];
        };


        SnapContext.prototype.setSnapOrigin = function (snapLocation, initialValue) {
            this._snapOrigins[snapLocation] = initialValue;

            if (this._snapLocations.indexOf(snapLocation) === -1) {
                this._snapLocations.push(snapLocation);
            }
        };


        SnapContext.prototype.addDefaultSnap = function (type, point) {

            var snapValues = this._defaultSnaps[type];

            if (!snapValues) {
                snapValues = this._defaultSnaps[type] = [];
            }

            snapValues.push(point);
        };

        /**
         * Return a number of initialized snaps, i.e. snap locations such as
         * top-left, mid, bottom-right and so forth.
         *
         * @return {Array<String>} snapLocations
         */
        SnapContext.prototype.getSnapLocations = function () {
            return this._snapLocations;
        };

        /**
         * Set the snap locations for this context.
         *
         * The order of locations determines precedence.
         *
         * @param {Array<String>} snapLocations
         */
        SnapContext.prototype.setSnapLocations = function (snapLocations) {
            this._snapLocations = snapLocations;
        };

        /**
         * Get snap points for a given target
         *
         * @param {Element|String} target
         */
        SnapContext.prototype.pointsForTarget = function (target) {

            var targetId = target.id || target;

            var snapPoints = this._targets[targetId];

            if (!snapPoints) {
                snapPoints = this._targets[targetId] = new SnapPoints();
                snapPoints.initDefaults(this._defaultSnaps);
            }

            return snapPoints;
        };

        module.exports = SnapContext;


        /**
         * Creates the snap points and initializes them with the
         * given default values.
         *
         * @param {Object<String, Array<Point>>} [defaultPoints]
         */
        function SnapPoints(defaultSnaps) {

            /**
             * Map<String, Map<(x|y), Array<Number>>> mapping snap locations,
             * i.e. top-left, bottom-right, center to actual snap values.
             *
             * @type {Object}
             */
            this._snapValues = {};
        }

        SnapPoints.prototype.add = function (snapLocation, point) {

            var snapValues = this._snapValues[snapLocation];

            if (!snapValues) {
                snapValues = this._snapValues[snapLocation] = { x: [], y: [] };
            }

            if (snapValues.x.indexOf(point.x) === -1) {
                snapValues.x.push(point.x);
            }

            if (snapValues.y.indexOf(point.y) === -1) {
                snapValues.y.push(point.y);
            }
        };


        SnapPoints.prototype.snap = function (point, snapLocation, axis, tolerance) {
            var snappingValues = this._snapValues[snapLocation];

            return snappingValues && snapTo(point[axis], snappingValues[axis], tolerance);
        };

        /**
         * Initialize a number of default snapping points.
         *
         * @param  {Object} defaultSnaps
         */
        SnapPoints.prototype.initDefaults = function (defaultSnaps) {

            var self = this;

            forEach(defaultSnaps || {}, function (snapPoints, snapLocation) {
                forEach(snapPoints, function (point) {
                    self.add(snapLocation, point);
                });
            });
        };
    }, { "./SnapUtil": 235, "lodash/collection/forEach": 304 }], 235: [function (require, module, exports) {
        'use strict';

        var abs = Math.abs,
            round = Math.round;


        /**
         * Snap value to a collection of reference values.
         *
         * @param  {Number} value
         * @param  {Array<Number>} values
         * @param  {Number} [tolerance=10]
         *
         * @return {Number} the value we snapped to or null, if none snapped
         */
        function snapTo(value, values, tolerance) {
            tolerance = tolerance === undefined ? 10 : tolerance;

            var idx, snapValue;

            for (idx = 0; idx < values.length; idx++) {
                snapValue = values[idx];

                if (abs(snapValue - value) <= tolerance) {
                    return snapValue;
                }
            }
        }

        module.exports.snapTo = snapTo;


        function topLeft(bounds) {
            return {
                x: bounds.x,
                y: bounds.y
            };
        }

        module.exports.topLeft = topLeft;


        function mid(bounds, defaultValue) {

            if (!bounds || isNaN(bounds.x) || isNaN(bounds.y)) {
                return defaultValue;
            }

            return {
                x: round(bounds.x + bounds.width / 2),
                y: round(bounds.y + bounds.height / 2)
            };
        }

        module.exports.mid = mid;


        function bottomRight(bounds) {
            return {
                x: bounds.x + bounds.width,
                y: bounds.y + bounds.height
            };
        }

        module.exports.bottomRight = bottomRight;


        /**
         * Retrieve the snap state of the given event.
         *
         * @param  {Event} event
         * @param  {String} axis
         *
         * @return {Boolean} the snapped state
         *
         */
        module.exports.isSnapped = function (event, axis) {
            var snapped = event.snapped;

            if (!snapped) {
                return false;
            }

            if (typeof axis === 'string') {
                return snapped[axis];
            }

            return snapped.x && snapped.y;
        };

        /**
         * Set the given event as snapped.
         *
         * This method may change the x and/or y position of the shape
         * from the given event!
         *
         * @param {Event} event
         * @param {String} axis
         * @param {Number|Boolean} value
         *
         * @return {Number} old value
         */
        module.exports.setSnapped = function (event, axis, value) {
            if (typeof axis !== 'string') {
                throw new Error('axis must be in [x, y]');
            }

            if (typeof value !== 'number' && value !== false) {
                throw new Error('value must be Number or false');
            }

            var delta,
                previousValue = event[axis];

            var snapped = event.snapped = (event.snapped || {});


            if (value === false) {
                snapped[axis] = false;
            } else {
                snapped[axis] = true;

                delta = value - previousValue;

                event[axis] += delta;
                event['d' + axis] += delta;
            }

            return previousValue;
        };
    }, {}], 236: [function (require, module, exports) {
        'use strict';

        var filter = require('lodash/collection/filter'),
            forEach = require('lodash/collection/forEach'),
            debounce = require('lodash/function/debounce');

        var mid = require('./SnapUtil').mid;

        var SnapContext = require('./SnapContext');

        var SnapUtil = require('./SnapUtil');

        var HIGHER_PRIORITY = 1250;

        var isSnapped = SnapUtil.isSnapped,
            setSnapped = SnapUtil.setSnapped;

        var svgAppend = require('tiny-svg/lib/append'),
            svgAttr = require('tiny-svg/lib/attr'),
            svgClasses = require('tiny-svg/lib/classes'),
            svgCreate = require('tiny-svg/lib/create');


        /**
         * A general purpose snapping component for diagram elements.
         *
         * @param {EventBus} eventBus
         * @param {Canvas} canvas
         */
        function Snapping(eventBus, canvas) {

            this._canvas = canvas;

            var self = this;

            eventBus.on(['shape.move.start', 'create.start'], function (event) {
                self.initSnap(event);
            });

            eventBus.on(['shape.move.move', 'shape.move.end', 'create.move', 'create.end'], HIGHER_PRIORITY, function (event) {

                if (event.originalEvent && event.originalEvent.ctrlKey) {
                    return;
                }

                if (isSnapped(event)) {
                    return;
                }

                self.snap(event);
            });

            eventBus.on(['shape.move.cleanup', 'create.cleanup'], function (event) {
                self.hide();
            });

            // delay hide by 1000 seconds since last match
            this._asyncHide = debounce(this.hide, 1000);
        }

        Snapping.$inject = ['eventBus', 'canvas'];

        module.exports = Snapping;


        Snapping.prototype.initSnap = function (event) {

            var context = event.context,
                shape = context.shape,
                snapContext = context.snapContext;

            if (!snapContext) {
                snapContext = context.snapContext = new SnapContext();
            }

            var snapMid = mid(shape, event);

            snapContext.setSnapOrigin('mid', {
                x: snapMid.x - event.x,
                y: snapMid.y - event.y
            });

            return snapContext;
        };


        Snapping.prototype.snap = function (event) {

            var context = event.context,
                snapContext = context.snapContext,
                shape = context.shape,
                target = context.target,
                snapLocations = snapContext.getSnapLocations();

            if (!target) {
                return;
            }

            var snapPoints = snapContext.pointsForTarget(target);

            if (!snapPoints.initialized) {
                this.addTargetSnaps(snapPoints, shape, target);

                snapPoints.initialized = true;
            }


            var snapping = {
                x: isSnapped(event, 'x'),
                y: isSnapped(event, 'y')
            };


            forEach(snapLocations, function (location) {

                var snapOrigin = snapContext.getSnapOrigin(location);

                var snapCurrent = {
                    x: event.x + snapOrigin.x,
                    y: event.y + snapOrigin.y
                };

                // snap on both axis, if not snapped already
                forEach(['x', 'y'], function (axis) {
                    var locationSnapping;

                    if (!snapping[axis]) {
                        locationSnapping = snapPoints.snap(snapCurrent, location, axis, 7);

                        if (locationSnapping !== undefined) {
                            snapping[axis] = {
                                value: locationSnapping,
                                originValue: locationSnapping - snapOrigin[axis]
                            };
                        }
                    }
                });

                // no more need to snap, drop out of interation
                if (snapping.x && snapping.y) {
                    return false;
                }
            });


            // show snap visuals

            this.showSnapLine('vertical', snapping.x && snapping.x.value);
            this.showSnapLine('horizontal', snapping.y && snapping.y.value);


            // adjust event { x, y, dx, dy } and mark as snapping
            forEach(['x', 'y'], function (axis) {

                var axisSnapping = snapping[axis];

                if (typeof axisSnapping === 'object') {
                    // set as snapped and adjust the x and/or y position of the event
                    setSnapped(event, axis, axisSnapping.originValue);
                }
            });
        };


        Snapping.prototype._createLine = function (orientation) {

            var root = this._canvas.getLayer('snap');

            // var line = root.path('M0,0 L0,0').addClass('djs-snap-line');

            var line = svgCreate('path');
            svgAttr(line, { d: 'M0,0 L0,0' });
            svgClasses(line).add('djs-snap-line');

            svgAppend(root, line);

            return {
                update: function (position) {

                    if (typeof position !== 'number') {
                        svgAttr(line, { display: 'none' });
                    } else {
                        if (orientation === 'horizontal') {
                            svgAttr(line, {
                                d: 'M-100000,' + position + ' L+100000,' + position,
                                display: ''
                            });
                        } else {
                            svgAttr(line, {
                                d: 'M ' + position + ',-100000 L ' + position + ', +100000',
                                display: ''
                            });
                        }
                    }
                }
            };
        };


        Snapping.prototype._createSnapLines = function () {

            this._snapLines = {
                horizontal: this._createLine('horizontal'),
                vertical: this._createLine('vertical')
            };
        };

        Snapping.prototype.showSnapLine = function (orientation, position) {

            var line = this.getSnapLine(orientation);

            if (line) {
                line.update(position);
            }

            this._asyncHide();
        };

        Snapping.prototype.getSnapLine = function (orientation) {
            if (!this._snapLines) {
                this._createSnapLines();
            }

            return this._snapLines[orientation];
        };

        Snapping.prototype.hide = function () {
            forEach(this._snapLines, function (l) {
                l.update();
            });
        };

        Snapping.prototype.addTargetSnaps = function (snapPoints, shape, target) {

            var siblings = this.getSiblings(shape, target);

            forEach(siblings, function (s) {
                snapPoints.add('mid', mid(s));
            });

        };

        Snapping.prototype.getSiblings = function (element, target) {

            // snap to all non connection siblings
            return target && filter(target.children, function (e) {
                return !e.hidden && !e.labelTarget && !e.waypoints && e.host !== element && e !== element;
            });
        };

    }, { "./SnapContext": 234, "./SnapUtil": 235, "lodash/collection/filter": 302, "lodash/collection/forEach": 304, "lodash/function/debounce": 314, "tiny-svg/lib/append": 473, "tiny-svg/lib/attr": 475, "tiny-svg/lib/classes": 476, "tiny-svg/lib/create": 479 }], 237: [function (require, module, exports) {
        'use strict';

        var SpaceUtil = require('./SpaceUtil');

        var Cursor = require('../../util/Cursor');

        var hasPrimaryModifier = require('../../util/Mouse').hasPrimaryModifier;

        var abs = Math.abs,
            round = Math.round;

        var HIGH_PRIORITY = 1500,
            SPACE_TOOL_CURSOR = 'crosshair';

        var AXIS_TO_DIMENSION = { x: 'width', y: 'height' },
            AXIS_INVERTED = { x: 'y', y: 'x' };

        var getAllChildren = require('../../util/Elements').selfAndAllChildren;

        var assign = require('lodash/object/assign'),
            forEach = require('lodash/collection/forEach');


        /**
         * A tool that allows users to create and remove space in a diagram.
         *
         * The tool needs to be activated manually via {@link SpaceTool#activate(MouseEvent)}.
         */
        function SpaceTool(eventBus, dragging, canvas, modeling, rules, toolManager) {

            this._canvas = canvas;
            this._dragging = dragging;
            this._modeling = modeling;
            this._rules = rules;
            this._toolManager = toolManager;

            var self = this;

            toolManager.registerTool('space', {
                tool: 'spaceTool.selection',
                dragging: 'spaceTool'
            });

            eventBus.on('spaceTool.selection.end', function (event) {
                var target = event.originalEvent.target;

                // only reactive on diagram click
                // on some occasions, event.hover is not set and we have to check if the target is an svg
                if (!event.hover && !(target instanceof SVGElement)) {
                    return;
                }

                eventBus.once('spaceTool.selection.ended', function () {
                    self.activateMakeSpace(event.originalEvent);
                });
            });


            eventBus.on('spaceTool.move', HIGH_PRIORITY, function (event) {

                var context = event.context;

                if (!context.initialized) {
                    context.initialized = self.initializeMakeSpace(event, context);
                }
            });


            eventBus.on('spaceTool.end', function (event) {

                var context = event.context,
                    axis = context.axis,
                    direction = context.direction,
                    movingShapes = context.movingShapes,
                    resizingShapes = context.resizingShapes;

                // skip if create space has not been initialized yet
                if (!context.initialized) {
                    return;
                }

                var delta = { x: round(event.dx), y: round(event.dy) };
                delta[AXIS_INVERTED[axis]] = 0;

                var insideBounds = true;

                // check if the space tool cursor is inside of bounds of
                // any of the shapes that would be resized.
                forEach(resizingShapes, function (shape) {

                    if ((direction === 'w' && event.x > shape.x + shape.width) ||
                        (direction === 'e' && event.x < shape.x) ||
                        (direction === 'n' && event.y > shape.y + shape.height) ||
                        (direction === 's' && event.y < shape.y)) {

                        insideBounds = false;
                        return;
                    }
                });

                if (insideBounds) {
                    // make space only if the cursor is inside bounds
                    self.makeSpace(movingShapes, resizingShapes, delta, direction);
                }

                eventBus.once('spaceTool.ended', function (event) {
                    // reactivate space tool after usage
                    self.activateSelection(event.originalEvent, true, true);
                });

            });
        }

        SpaceTool.$inject = ['eventBus', 'dragging', 'canvas', 'modeling', 'rules', 'toolManager'];

        module.exports = SpaceTool;


        /**
         * Activate space tool selection
         *
         * @param  {MouseEvent} event
         * @param  {Boolean} autoActivate
         */
        SpaceTool.prototype.activateSelection = function (event, autoActivate, reactivate) {
            this._dragging.init(event, 'spaceTool.selection', {
                trapClick: false,
                cursor: SPACE_TOOL_CURSOR,
                autoActivate: autoActivate,
                data: {
                    context: {
                        reactivate: reactivate
                    }
                }
            });
        };

        /**
         * Activate make space
         *
         * @param  {MouseEvent} event
         */
        SpaceTool.prototype.activateMakeSpace = function (event) {
            this._dragging.init(event, 'spaceTool', {
                autoActivate: true,
                cursor: SPACE_TOOL_CURSOR,
                data: {
                    context: {}
                }
            });
        };

        /**
         * Actually make space on the diagram
         *
         * @param  {Array<djs.model.Shape>} movingShapes
         * @param  {Array<djs.model.Shape>} resizingShapes
         * @param  {Point} delta
         * @param  {String} direction
         */
        SpaceTool.prototype.makeSpace = function (movingShapes, resizingShapes, delta, direction) {
            return this._modeling.createSpace(movingShapes, resizingShapes, delta, direction);
        };

        /**
         * Initialize make space and return true if that was successful.
         *
         * @param {Event} event
         * @param {Object} context
         *
         * @return {Boolean} true, if successful
         */
        SpaceTool.prototype.initializeMakeSpace = function (event, context) {

            var axis = abs(event.dx) > abs(event.dy) ? 'x' : 'y',
                offset = event['d' + axis],
                // start point of create space operation
                spacePos = event[axis] - offset;

            if (abs(offset) < 5) {
                return false;
            }

            // invert the offset in order to remove space when moving left
            if (offset < 0) {
                offset *= -1;
            }

            // inverts the offset to choose the shapes
            // on the opposite side of the resizer if
            // a key modifier is pressed
            if (hasPrimaryModifier(event)) {
                offset *= -1;
            }

            var rootShape = this._canvas.getRootElement();

            var allShapes = getAllChildren(rootShape, true);

            var adjustments = this.calculateAdjustments(allShapes, axis, offset, spacePos);

            // store data in context
            assign(context, adjustments, {
                axis: axis,
                direction: SpaceUtil.getDirection(axis, offset)
            });

            Cursor.set('resize-' + (axis === 'x' ? 'ew' : 'ns'));

            return true;
        };

        /**
         * Calculate adjustments needed when making space
         *
         * @param  {Array<djs.model.Shape>} elements
         * @param  {String} axis
         * @param  {Number} offset
         * @param  {Number} spacePos
         *
         * @return {Object}
         */
        SpaceTool.prototype.calculateAdjustments = function (elements, axis, offset, spacePos) {

            var movingShapes = [],
                resizingShapes = [];

            var rules = this._rules;

            // collect all elements that need to be moved _AND_
            // resized given on the initial create space position
            elements.forEach(function (shape) {

                var shapeStart = shape[axis],
                    shapeEnd = shapeStart + shape[AXIS_TO_DIMENSION[axis]];

                // checking if it's root
                if (!shape.parent) {
                    return;
                }

                // checking if it's a shape
                if (shape.waypoints) {
                    return;
                }

                // shape after spacePos
                if (offset > 0 && shapeStart > spacePos) {
                    return movingShapes.push(shape);
                }

                // shape before spacePos
                if (offset < 0 && shapeEnd < spacePos) {
                    return movingShapes.push(shape);
                }

                // shape on top of spacePos, resize only if allowed
                if (shapeStart < spacePos &&
                    shapeEnd > spacePos &&
                    rules.allowed('shape.resize', { shape: shape })) {

                    return resizingShapes.push(shape);
                }
            });

            return {
                movingShapes: movingShapes,
                resizingShapes: resizingShapes
            };
        };

        SpaceTool.prototype.toggle = function () {
            if (this.isActive()) {
                this._dragging.cancel();
            } else {
                this.activateSelection();
            }
        };

        SpaceTool.prototype.isActive = function () {
            var context = this._dragging.context();

            return context && /^spaceTool/.test(context.prefix);
        };

    }, { "../../util/Cursor": 265, "../../util/Elements": 266, "../../util/Mouse": 274, "./SpaceUtil": 239, "lodash/collection/forEach": 304, "lodash/object/assign": 433 }], 238: [function (require, module, exports) {
        'use strict';

        var forEach = require('lodash/collection/forEach');

        var MARKER_DRAGGING = 'djs-dragging',
            MARKER_RESIZING = 'djs-resizing';

        var LOW_PRIORITY = 250;

        var svgAppend = require('tiny-svg/lib/append'),
            svgAttr = require('tiny-svg/lib/attr'),
            svgClasses = require('tiny-svg/lib/classes'),
            svgCreate = require('tiny-svg/lib/create'),
            svgRemove = require('tiny-svg/lib/remove');

        var translate = require('../../util/SvgTransformUtil').translate;


        /**
         * Provides previews for selecting/moving/resizing shapes when creating/removing space.
         *
         * @param {EventBus} eventBus
         * @param {ElementRegistry} elementRegistry
         * @param {Canvas} canvas
         * @param {Styles} styles
         */

        function SpaceToolPreview(eventBus, elementRegistry, canvas, styles, previewSupport) {

            function addPreviewGfx(collection, dragGroup) {
                forEach(collection, function (element) {
                    previewSupport.addDragger(element, dragGroup);

                    canvas.addMarker(element, MARKER_DRAGGING);
                });
            }

            // add crosshair
            eventBus.on('spaceTool.selection.start', function (event) {
                var space = canvas.getLayer('space'),
                    context = event.context;

                var orientation = {
                    x: 'M 0,-10000 L 0,10000',
                    y: 'M -10000,0 L 10000,0'
                };

                var crosshairGroup = svgCreate('g');
                svgAttr(crosshairGroup, styles.cls('djs-crosshair-group', ['no-events']));

                svgAppend(space, crosshairGroup);

                // horizontal path
                var pathX = svgCreate('path');
                svgAttr(pathX, 'd', orientation.x);
                svgClasses(pathX).add('djs-crosshair');

                svgAppend(crosshairGroup, pathX);

                // vertical path
                var pathY = svgCreate('path');
                svgAttr(pathY, 'd', orientation.y);
                svgClasses(pathY).add('djs-crosshair');

                svgAppend(crosshairGroup, pathY);

                context.crosshairGroup = crosshairGroup;
            });

            // update crosshair
            eventBus.on('spaceTool.selection.move', function (event) {
                var crosshairGroup = event.context.crosshairGroup;

                translate(crosshairGroup, event.x, event.y);
            });

            // remove crosshair
            eventBus.on('spaceTool.selection.cleanup', function (event) {
                var context = event.context,
                    crosshairGroup = context.crosshairGroup;

                if (crosshairGroup) {
                    svgRemove(crosshairGroup);
                }
            });

            // add and update move/resize previews
            eventBus.on('spaceTool.move', LOW_PRIORITY, function (event) {

                var context = event.context,
                    line = context.line,
                    axis = context.axis,
                    movingShapes = context.movingShapes,
                    resizingShapes = context.resizingShapes;

                if (!context.initialized) {
                    return;
                }

                if (!context.dragGroup) {
                    var spaceLayer = canvas.getLayer('space');

                    line = svgCreate('path');
                    svgAttr(line, 'd', 'M0,0 L0,0');
                    svgClasses(line).add('djs-crosshair');

                    svgAppend(spaceLayer, line);

                    context.line = line;

                    var dragGroup = svgCreate('g');
                    svgAttr(dragGroup, styles.cls('djs-drag-group', ['no-events']));

                    svgAppend(canvas.getDefaultLayer(), dragGroup);

                    // shapes
                    addPreviewGfx(movingShapes, dragGroup);

                    // connections
                    var movingConnections = context.movingConnections = elementRegistry.filter(function (element) {
                        var sourceIsMoving = false;

                        forEach(movingShapes, function (shape) {
                            forEach(shape.outgoing, function (connection) {
                                if (element === connection) {
                                    sourceIsMoving = true;
                                }
                            });
                        });

                        var targetIsMoving = false;

                        forEach(movingShapes, function (shape) {
                            forEach(shape.incoming, function (connection) {
                                if (element === connection) {
                                    targetIsMoving = true;
                                }
                            });
                        });

                        var sourceIsResizing = false;

                        forEach(resizingShapes, function (shape) {
                            forEach(shape.outgoing, function (connection) {
                                if (element === connection) {
                                    sourceIsResizing = true;
                                }
                            });
                        });

                        var targetIsResizing = false;

                        forEach(resizingShapes, function (shape) {
                            forEach(shape.incoming, function (connection) {
                                if (element === connection) {
                                    targetIsResizing = true;
                                }
                            });
                        });

                        return isConnection(element)
                            && (sourceIsMoving || sourceIsResizing)
                            && (targetIsMoving || targetIsResizing);
                    });


                    addPreviewGfx(movingConnections, dragGroup);

                    context.dragGroup = dragGroup;
                }

                if (!context.frameGroup) {
                    var frameGroup = svgCreate('g');
                    svgAttr(frameGroup, styles.cls('djs-frame-group', ['no-events']));

                    svgAppend(canvas.getDefaultLayer(), frameGroup);

                    var frames = [];

                    forEach(resizingShapes, function (shape) {
                        var frame = previewSupport.addFrame(shape, frameGroup);

                        frames.push({
                            element: frame,
                            initialWidth: frame.getBBox().width,
                            initialHeight: frame.getBBox().height
                        });

                        canvas.addMarker(shape, MARKER_RESIZING);
                    });

                    context.frameGroup = frameGroup;
                    context.frames = frames;
                }

                var orientation = {
                    x: 'M' + event.x + ', -10000 L' + event.x + ', 10000',
                    y: 'M -10000, ' + event.y + ' L 10000, ' + event.y
                };

                svgAttr(line, { path: orientation[axis], display: '' });

                var opposite = { x: 'y', y: 'x' };
                var delta = { x: event.dx, y: event.dy };
                delta[opposite[context.axis]] = 0;

                // update move previews
                translate(context.dragGroup, delta.x, delta.y);

                // update resize previews
                forEach(context.frames, function (frame) {
                    if (frame.initialWidth + delta.x > 5) {
                        svgAttr(frame.element, { width: frame.initialWidth + delta.x });
                    }

                    if (frame.initialHeight + delta.y > 5) {
                        svgAttr(frame.element, { height: frame.initialHeight + delta.y });
                    }
                });

            });

            // remove move/resize previews
            eventBus.on('spaceTool.cleanup', function (event) {

                var context = event.context,
                    movingShapes = context.movingShapes,
                    movingConnections = context.movingConnections,
                    resizingShapes = context.resizingShapes,
                    line = context.line,
                    dragGroup = context.dragGroup,
                    frameGroup = context.frameGroup;

                // moving shapes
                forEach(movingShapes, function (shape) {
                    canvas.removeMarker(shape, MARKER_DRAGGING);
                });

                // moving connections
                forEach(movingConnections, function (connection) {
                    canvas.removeMarker(connection, MARKER_DRAGGING);
                });

                if (dragGroup) {
                    svgRemove(line);
                    svgRemove(dragGroup);
                }

                forEach(resizingShapes, function (shape) {
                    canvas.removeMarker(shape, MARKER_RESIZING);
                });

                if (frameGroup) {
                    svgRemove(frameGroup);
                }
            });
        }

        SpaceToolPreview.$inject = ['eventBus', 'elementRegistry', 'canvas', 'styles', 'previewSupport'];

        module.exports = SpaceToolPreview;

        ////////// helpers //////////

        /**
         * Checks if an element is a connection.
         */
        function isConnection(element) {
            return element.waypoints;
        }

    }, { "../../util/SvgTransformUtil": 279, "lodash/collection/forEach": 304, "tiny-svg/lib/append": 473, "tiny-svg/lib/attr": 475, "tiny-svg/lib/classes": 476, "tiny-svg/lib/create": 479, "tiny-svg/lib/remove": 482 }], 239: [function (require, module, exports) {
        'use strict';

        /**
         * Get Resize direction given axis + offset
         *
         * @param {String} axis (x|y)
         * @param {Number} offset
         *
         * @return {String} (e|w|n|s)
         */
        function getDirection(axis, offset) {

            if (axis === 'x') {
                if (offset > 0) {
                    return 'e';
                }

                if (offset < 0) {
                    return 'w';
                }
            }

            if (axis === 'y') {
                if (offset > 0) {
                    return 's';
                }

                if (offset < 0) {
                    return 'n';
                }
            }

            return null;
        }

        module.exports.getDirection = getDirection;

        /**
         * Resize the given bounds by the specified delta from a given anchor point.
         *
         * @param {Bounds} bounds the bounding box that should be resized
         * @param {String} direction in which the element is resized (n, s, e, w)
         * @param {Point} delta of the resize operation
         *
         * @return {Bounds} resized bounding box
         */
        module.exports.resizeBounds = function (bounds, direction, delta) {

            var dx = delta.x,
                dy = delta.y;

            switch (direction) {

                case 'n':
                    return {
                        x: bounds.x,
                        y: bounds.y + dy,
                        width: bounds.width,
                        height: bounds.height - dy
                    };

                case 's':
                    return {
                        x: bounds.x,
                        y: bounds.y,
                        width: bounds.width,
                        height: bounds.height + dy
                    };

                case 'w':
                    return {
                        x: bounds.x + dx,
                        y: bounds.y,
                        width: bounds.width - dx,
                        height: bounds.height
                    };

                case 'e':
                    return {
                        x: bounds.x,
                        y: bounds.y,
                        width: bounds.width + dx,
                        height: bounds.height
                    };

                default:
                    throw new Error('unrecognized direction: ' + direction);
            }
        };
    }, {}], 240: [function (require, module, exports) {
        'use strict';

        module.exports = {
            __init__: ['spaceToolPreview'],
            __depends__: [
                require('../dragging'),
                require('../rules'),
                require('../tool-manager'),
                require('../preview-support')
            ],
            spaceTool: ['type', require('./SpaceTool')],
            spaceToolPreview: ['type', require('./SpaceToolPreview')]
        };

    }, { "../dragging": 162, "../preview-support": 217, "../rules": 227, "../tool-manager": 242, "./SpaceTool": 237, "./SpaceToolPreview": 238 }], 241: [function (require, module, exports) {
        'use strict';

        var forEach = require('lodash/collection/forEach');

        var LOW_PRIORITY = 250;

        /**
         * The tool manager acts as middle-man between the available tool's and the Palette,
         * it takes care of making sure that the correct active state is set.
         *
         * @param  {Object}    eventBus
         * @param  {Object}    dragging
         */
        function ToolManager(eventBus, dragging) {
            this._eventBus = eventBus;
            this._dragging = dragging;

            this._tools = [];
            this._active = null;
        }

        ToolManager.$inject = ['eventBus', 'dragging'];

        module.exports = ToolManager;

        ToolManager.prototype.registerTool = function (name, events) {
            var tools = this._tools;

            if (!events) {
                throw new Error('A tool has to be registered with it\'s "events"');
            }

            tools.push(name);

            this.bindEvents(name, events);
        };

        ToolManager.prototype.isActive = function (tool) {
            return tool && this._active === tool;
        };

        ToolManager.prototype.length = function (tool) {
            return this._tools.length;
        };

        ToolManager.prototype.setActive = function (tool) {
            var eventBus = this._eventBus;

            if (this._active !== tool) {
                this._active = tool;

                eventBus.fire('tool-manager.update', { tool: tool });
            }
        };

        ToolManager.prototype.bindEvents = function (name, events) {
            var eventBus = this._eventBus,
                dragging = this._dragging;

            var eventsToRegister = [];

            eventBus.on(events.tool + '.init', function (event) {
                var context = event.context;

                // Active tools that want to reactivate themselves must do this explicitly
                if (!context.reactivate && this.isActive(name)) {
                    this.setActive(null);

                    dragging.cancel();
                    return;
                }

                this.setActive(name);

            }, this);

            // Todo[ricardo]: add test cases
            forEach(events, function (event) {
                eventsToRegister.push(event + '.ended');
                eventsToRegister.push(event + '.canceled');
            });

            eventBus.on(eventsToRegister, LOW_PRIORITY, function (event) {
                var originalEvent = event.originalEvent;

                // We defer the de-activation of the tool to the .activate phase,
                // so we're able to check if we want to toggle off the current active tool or switch to a new one
                if (!this._active ||
                    (originalEvent && originalEvent.target.parentNode.getAttribute('data-group') === 'tools')) {
                    return;
                }

                this.setActive(null);
            }, this);
        };

    }, { "lodash/collection/forEach": 304 }], 242: [function (require, module, exports) {
        'use strict';

        module.exports = {
            __depends__: [require('../dragging')],
            __init__: ['toolManager'],
            toolManager: ['type', require('./ToolManager')]
        };

    }, { "../dragging": 162, "./ToolManager": 241 }], 243: [function (require, module, exports) {
        'use strict';

        var isString = require('lodash/lang/isString'),
            assign = require('lodash/object/assign'),
            forEach = require('lodash/collection/forEach');

        var domify = require('min-dom/lib/domify'),
            domAttr = require('min-dom/lib/attr'),
            domClasses = require('min-dom/lib/classes'),
            domRemove = require('min-dom/lib/remove'),
            domDelegate = require('min-dom/lib/delegate');


        // document wide unique tooltip ids
        var ids = new (require('../../util/IdGenerator'))('tt');


        function createRoot(parent) {
            var root = domify('<div class="djs-tooltip-container" style="position: absolute; width: 0; height: 0;" />');
            parent.insertBefore(root, parent.firstChild);

            return root;
        }


        function setPosition(el, x, y) {
            assign(el.style, { left: x + 'px', top: y + 'px' });
        }

        function setVisible(el, visible) {
            el.style.display = visible === false ? 'none' : '';
        }


        var tooltipClass = 'djs-tooltip',
            tooltipSelector = '.' + tooltipClass;

        /**
         * A service that allows users to render tool tips on the diagram.
         *
         * The tooltip service will take care of updating the tooltip positioning
         * during navigation + zooming.
         *
         * @example
         *
         * ```javascript
         *
         * // add a pink badge on the top left of the shape
         * tooltips.add({
         *   position: {
         *     x: 50,
         *     y: 100
         *   },
         *   html: '<div style="width: 10px; background: fuchsia; color: white;">0</div>'
         * });
         *
         * // or with optional life span
         * tooltips.add({
         *   position: {
         *     top: -5,
         *     left: -5
         *   },
         *   html: '<div style="width: 10px; background: fuchsia; color: white;">0</div>',
         *   ttl: 2000
         * });
         *
         * // remove a tool tip
         * var id = tooltips.add(...);
         * tooltips.remove(id);
         * ```
         *
         * @param {EventBus} eventBus
         * @param {Canvas} canvas
         */
        function Tooltips(eventBus, canvas) {

            this._eventBus = eventBus;
            this._canvas = canvas;

            this._ids = ids;

            this._tooltipDefaults = {
                show: {
                    minZoom: 0.7,
                    maxZoom: 5.0
                }
            };

            /**
             * Mapping tooltipId -> tooltip
             */
            this._tooltips = {};

            // root html element for all tooltips
            this._tooltipRoot = createRoot(canvas.getContainer());


            var self = this;

            domDelegate.bind(this._tooltipRoot, tooltipSelector, 'mousedown', function (event) {
                event.stopPropagation();
            });

            domDelegate.bind(this._tooltipRoot, tooltipSelector, 'mouseover', function (event) {
                self.trigger('mouseover', event);
            });

            domDelegate.bind(this._tooltipRoot, tooltipSelector, 'mouseout', function (event) {
                self.trigger('mouseout', event);
            });

            this._init();
        }


        Tooltips.$inject = ['eventBus', 'canvas'];

        module.exports = Tooltips;


        /**
         * Adds a HTML tooltip to the diagram
         *
         * @param {Object}               tooltip   the tooltip configuration
         *
         * @param {String|DOMElement}    tooltip.html                 html element to use as an tooltip
         * @param {Object}               [tooltip.show]               show configuration
         * @param {Number}               [tooltip.show.minZoom]       minimal zoom level to show the tooltip
         * @param {Number}               [tooltip.show.maxZoom]       maximum zoom level to show the tooltip
         * @param {Object}               tooltip.position             where to attach the tooltip
         * @param {Number}               [tooltip.position.left]      relative to element bbox left attachment
         * @param {Number}               [tooltip.position.top]       relative to element bbox top attachment
         * @param {Number}               [tooltip.position.bottom]    relative to element bbox bottom attachment
         * @param {Number}               [tooltip.position.right]     relative to element bbox right attachment
         * @param {Number}               [tooltip.timeout=-1]
         *
         * @return {String}              id that may be used to reference the tooltip for update or removal
         */
        Tooltips.prototype.add = function (tooltip) {

            if (!tooltip.position) {
                throw new Error('must specifiy tooltip position');
            }

            if (!tooltip.html) {
                throw new Error('must specifiy tooltip html');
            }

            var id = this._ids.next();

            tooltip = assign({}, this._tooltipDefaults, tooltip, {
                id: id
            });

            this._addTooltip(tooltip);

            if (tooltip.timeout) {
                this.setTimeout(tooltip);
            }

            return id;
        };

        Tooltips.prototype.trigger = function (action, event) {

            var node = event.delegateTarget || event.target;

            var tooltip = this.get(domAttr(node, 'data-tooltip-id'));

            if (!tooltip) {
                return;
            }

            if (action === 'mouseover' && tooltip.timeout) {
                this.clearTimeout(tooltip);
            }

            if (action === 'mouseout' && tooltip.timeout) {
                // cut timeout after mouse out
                tooltip.timeout = 1000;

                this.setTimeout(tooltip);
            }
        };

        /**
         * Get a tooltip with the given id
         *
         * @param {String} id
         */
        Tooltips.prototype.get = function (id) {

            if (typeof id !== 'string') {
                id = id.id;
            }

            return this._tooltips[id];
        };

        Tooltips.prototype.clearTimeout = function (tooltip) {

            tooltip = this.get(tooltip);

            if (!tooltip) {
                return;
            }

            var removeTimer = tooltip.removeTimer;

            if (removeTimer) {
                clearTimeout(removeTimer);
                tooltip.removeTimer = null;
            }
        };

        Tooltips.prototype.setTimeout = function (tooltip) {

            tooltip = this.get(tooltip);

            if (!tooltip) {
                return;
            }

            this.clearTimeout(tooltip);

            var self = this;

            tooltip.removeTimer = setTimeout(function () {
                self.remove(tooltip);
            }, tooltip.timeout);
        };

        /**
         * Remove an tooltip with the given id
         *
         * @param {String} id
         */
        Tooltips.prototype.remove = function (id) {

            var tooltip = this.get(id);

            if (tooltip) {
                domRemove(tooltip.html);
                domRemove(tooltip.htmlContainer);

                delete tooltip.htmlContainer;

                delete this._tooltips[tooltip.id];
            }
        };


        Tooltips.prototype.show = function () {
            setVisible(this._tooltipRoot);
        };


        Tooltips.prototype.hide = function () {
            setVisible(this._tooltipRoot, false);
        };


        Tooltips.prototype._updateRoot = function (viewbox) {
            var a = viewbox.scale || 1;
            var d = viewbox.scale || 1;

            var matrix = 'matrix(' + a + ',0,0,' + d + ',' + (-1 * viewbox.x * a) + ',' + (-1 * viewbox.y * d) + ')';

            this._tooltipRoot.style.transform = matrix;
            this._tooltipRoot.style['-ms-transform'] = matrix;
        };


        Tooltips.prototype._addTooltip = function (tooltip) {

            var id = tooltip.id,
                html = tooltip.html,
                htmlContainer,
                tooltipRoot = this._tooltipRoot;

            // unwrap jquery (for those who need it)
            if (html.get && html.constructor.prototype.jquery) {
                html = html.get(0);
            }

            // create proper html elements from
            // tooltip HTML strings
            if (isString(html)) {
                html = domify(html);
            }

            htmlContainer = domify('<div data-tooltip-id="' + id + '" class="' + tooltipClass + '" style="position: absolute">');

            htmlContainer.appendChild(html);

            if (tooltip.type) {
                domClasses(htmlContainer).add('djs-tooltip-' + tooltip.type);
            }

            if (tooltip.className) {
                domClasses(htmlContainer).add(tooltip.className);
            }

            tooltip.htmlContainer = htmlContainer;

            tooltipRoot.appendChild(htmlContainer);

            this._tooltips[id] = tooltip;

            this._updateTooltip(tooltip);
        };


        Tooltips.prototype._updateTooltip = function (tooltip) {

            var position = tooltip.position,
                htmlContainer = tooltip.htmlContainer;

            // update overlay html based on tooltip x, y

            setPosition(htmlContainer, position.x, position.y);
        };


        Tooltips.prototype._updateTooltipVisibilty = function (viewbox) {

            forEach(this._tooltips, function (tooltip) {
                var show = tooltip.show,
                    htmlContainer = tooltip.htmlContainer,
                    visible = true;

                if (show) {
                    if (show.minZoom > viewbox.scale ||
                        show.maxZoom < viewbox.scale) {
                        visible = false;
                    }

                    setVisible(htmlContainer, visible);
                }
            });
        };

        Tooltips.prototype._init = function () {

            var self = this;

            // scroll/zoom integration

            function updateViewbox(viewbox) {
                self._updateRoot(viewbox);
                self._updateTooltipVisibilty(viewbox);

                self.show();
            }

            this._eventBus.on('canvas.viewbox.changing', function (event) {
                self.hide();
            });

            this._eventBus.on('canvas.viewbox.changed', function (event) {
                updateViewbox(event.viewbox);
            });
        };

    }, { "../../util/IdGenerator": 270, "lodash/collection/forEach": 304, "lodash/lang/isString": 430, "lodash/object/assign": 433, "min-dom/lib/attr": 446, "min-dom/lib/classes": 447, "min-dom/lib/delegate": 450, "min-dom/lib/domify": 451, "min-dom/lib/remove": 455 }], 244: [function (require, module, exports) {
        module.exports = {
            __init__: ['tooltips'],
            tooltips: ['type', require('./Tooltips')]
        };
    }, { "./Tooltips": 243 }], 245: [function (require, module, exports) {
        'use strict';

        var svgAppend = require('tiny-svg/lib/append'),
            svgAttr = require('tiny-svg/lib/attr'),
            svgCreate = require('tiny-svg/lib/create');


        function TouchFix(canvas, eventBus) {

            var self = this;

            eventBus.on('canvas.init', function (e) {
                self.addBBoxMarker(e.svg);
            });
        }

        TouchFix.$inject = ['canvas', 'eventBus'];

        module.exports = TouchFix;


        /**
         * Safari mobile (iOS 7) does not fire touchstart event in <SVG> element
         * if there is no shape between 0,0 and viewport elements origin.
         *
         * So touchstart event is only fired when the <g class="viewport"> element was hit.
         * Putting an element over and below the 'viewport' fixes that behavior.
         */
        TouchFix.prototype.addBBoxMarker = function (svg) {

            var markerStyle = {
                fill: 'none',
                class: 'outer-bound-marker'
            };

            var rect1 = svgCreate('rect');
            svgAttr(rect1, {
                x: -10000,
                y: 10000,
                width: 10,
                height: 10
            });
            svgAttr(rect1, markerStyle);

            svgAppend(svg, rect1);

            var rect2 = svgCreate('rect');
            svgAttr(rect2, {
                x: 10000,
                y: 10000,
                width: 10,
                height: 10
            });
            svgAttr(rect2, markerStyle);

            svgAppend(svg, rect2);
        };

    }, { "tiny-svg/lib/append": 473, "tiny-svg/lib/attr": 475, "tiny-svg/lib/create": 479 }], 246: [function (require, module, exports) {
        'use strict';

        var forEach = require('lodash/collection/forEach'),
            domEvent = require('min-dom/lib/event'),
            domClosest = require('min-dom/lib/closest'),
            Hammer = require('hammerjs'),
            Event = require('../../util/Event');

        var MIN_ZOOM = 0.2,
            MAX_ZOOM = 4;

        var mouseEvents = [
            'mousedown',
            'mouseup',
            'mouseover',
            'mouseout',
            'click',
            'dblclick'
        ];

        function log() {
            // console.log.apply(console, arguments);
        }

        function get(service, injector) {
            return injector.get(service, false);
        }

        function createTouchRecognizer(node) {

            function stopEvent(event) {
                Event.stopEvent(event, true);
            }

            function stopMouse(event) {

                forEach(mouseEvents, function (e) {
                    domEvent.bind(node, e, stopEvent, true);
                });
            }

            function allowMouse(event) {
                setTimeout(function () {
                    forEach(mouseEvents, function (e) {
                        domEvent.unbind(node, e, stopEvent, true);
                    });
                }, 500);
            }

            domEvent.bind(node, 'touchstart', stopMouse, true);
            domEvent.bind(node, 'touchend', allowMouse, true);
            domEvent.bind(node, 'touchcancel', allowMouse, true);

            // A touch event recognizer that handles
            // touch events only (we know, we can already handle
            // mouse events out of the box)

            var recognizer = new Hammer.Manager(node, {
                inputClass: Hammer.TouchInput,
                recognizers: []
            });


            var tap = new Hammer.Tap();
            var pan = new Hammer.Pan({ threshold: 10 });
            var press = new Hammer.Press();
            var pinch = new Hammer.Pinch();

            var doubleTap = new Hammer.Tap({ event: 'doubletap', taps: 2 });

            pinch.requireFailure(pan);
            pinch.requireFailure(press);

            recognizer.add([pan, press, pinch, doubleTap, tap]);

            recognizer.reset = function (force) {
                var recognizers = this.recognizers,
                    session = this.session;

                if (session.stopped) {
                    return;
                }

                log('recognizer', 'stop');

                recognizer.stop(force);

                setTimeout(function () {
                    var i, r;

                    log('recognizer', 'reset');
                    for (i = 0; (r = recognizers[i]); i++) {
                        r.reset();
                        r.state = 8; // FAILED STATE
                    }

                    session.curRecognizer = null;
                }, 0);
            };

            recognizer.on('hammer.input', function (event) {
                if (event.srcEvent.defaultPrevented) {
                    recognizer.reset(true);
                }
            });

            return recognizer;
        }

        /**
         * A plugin that provides touch events for elements.
         *
         * @param {EventBus} eventBus
         * @param {InteractionEvents} interactionEvents
         */
        function TouchInteractionEvents(injector, canvas, eventBus, elementRegistry, interactionEvents) {

            // optional integrations
            var dragging = get('dragging', injector),
                move = get('move', injector),
                contextPad = get('contextPad', injector),
                palette = get('palette', injector);

            // the touch recognizer
            var recognizer;

            function handler(type) {

                return function (event) {
                    log('element', type, event);

                    interactionEvents.fire(type, event);
                };
            }

            function getGfx(target) {
                var node = domClosest(target, 'svg, .djs-element', true);
                return node;
            }

            function initEvents(svg) {

                // touch recognizer
                recognizer = createTouchRecognizer(svg);

                recognizer.on('doubletap', handler('element.dblclick'));

                recognizer.on('tap', handler('element.click'));

                function startGrabCanvas(event) {

                    log('canvas', 'grab start');

                    var lx = 0, ly = 0;

                    function update(e) {

                        var dx = e.deltaX - lx,
                            dy = e.deltaY - ly;

                        canvas.scroll({ dx: dx, dy: dy });

                        lx = e.deltaX;
                        ly = e.deltaY;
                    }

                    function end(e) {
                        recognizer.off('panmove', update);
                        recognizer.off('panend', end);
                        recognizer.off('pancancel', end);

                        log('canvas', 'grab end');
                    }

                    recognizer.on('panmove', update);
                    recognizer.on('panend', end);
                    recognizer.on('pancancel', end);
                }

                function startGrab(event) {

                    var gfx = getGfx(event.target),
                        element = gfx && elementRegistry.get(gfx);

                    // recognizer
                    if (move && canvas.getRootElement() !== element) {
                        log('element', 'move start', element, event, true);
                        return move.start(event, element, true);
                    } else {
                        startGrabCanvas(event);
                    }
                }

                function startZoom(e) {

                    log('canvas', 'zoom start');

                    var zoom = canvas.zoom(),
                        mid = e.center;

                    function update(e) {

                        var ratio = 1 - (1 - e.scale) / 1.50,
                            newZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, ratio * zoom));

                        canvas.zoom(newZoom, mid);

                        Event.stopEvent(e, true);
                    }

                    function end(e) {
                        recognizer.off('pinchmove', update);
                        recognizer.off('pinchend', end);
                        recognizer.off('pinchcancel', end);

                        recognizer.reset(true);

                        log('canvas', 'zoom end');
                    }

                    recognizer.on('pinchmove', update);
                    recognizer.on('pinchend', end);
                    recognizer.on('pinchcancel', end);
                }

                recognizer.on('panstart', startGrab);
                recognizer.on('press', startGrab);

                recognizer.on('pinchstart', startZoom);
            }

            if (dragging) {

                // simulate hover during dragging
                eventBus.on('drag.move', function (event) {

                    var originalEvent = event.originalEvent;

                    if (!originalEvent || originalEvent instanceof MouseEvent) {
                        return;
                    }

                    var position = Event.toPoint(originalEvent);

                    // this gets really expensive ...
                    var node = document.elementFromPoint(position.x, position.y),
                        gfx = getGfx(node),
                        element = gfx && elementRegistry.get(gfx);

                    if (element !== event.hover) {
                        if (event.hover) {
                            dragging.out(event);
                        }

                        if (element) {
                            dragging.hover({ element: element, gfx: gfx });

                            event.hover = element;
                            event.hoverGfx = gfx;
                        }
                    }
                });
            }

            if (contextPad) {

                eventBus.on('contextPad.create', function (event) {
                    var node = event.pad.html;

                    // touch recognizer
                    var padRecognizer = createTouchRecognizer(node);

                    padRecognizer.on('panstart', function (event) {
                        log('context-pad', 'panstart', event);
                        contextPad.trigger('dragstart', event, true);
                    });

                    padRecognizer.on('press', function (event) {
                        log('context-pad', 'press', event);
                        contextPad.trigger('dragstart', event, true);
                    });

                    padRecognizer.on('tap', function (event) {
                        log('context-pad', 'tap', event);
                        contextPad.trigger('click', event);
                    });
                });
            }

            if (palette) {
                eventBus.on('palette.create', function (event) {
                    var node = event.html;

                    // touch recognizer
                    var padRecognizer = createTouchRecognizer(node);

                    padRecognizer.on('panstart', function (event) {
                        log('palette', 'panstart', event);
                        palette.trigger('dragstart', event, true);
                    });

                    padRecognizer.on('press', function (event) {
                        log('palette', 'press', event);
                        palette.trigger('dragstart', event, true);
                    });

                    padRecognizer.on('tap', function (event) {
                        log('palette', 'tap', event);
                        palette.trigger('click', event);
                    });
                });
            }

            eventBus.on('canvas.init', function (event) {
                initEvents(event.svg);
            });
        }


        TouchInteractionEvents.$inject = [
            'injector',
            'canvas',
            'eventBus',
            'elementRegistry',
            'interactionEvents',
            'touchFix'
        ];

        module.exports = TouchInteractionEvents;

    }, { "../../util/Event": 267, "hammerjs": 286, "lodash/collection/forEach": 304, "min-dom/lib/closest": 449, "min-dom/lib/event": 452 }], 247: [function (require, module, exports) {
        module.exports = {
            __depends__: [require('../interaction-events')],
            __init__: ['touchInteractionEvents'],
            touchInteractionEvents: ['type', require('./TouchInteractionEvents')],
            touchFix: ['type', require('./TouchFix')]
        };
    }, { "../interaction-events": 170, "./TouchFix": 245, "./TouchInteractionEvents": 246 }], 248: [function (require, module, exports) {
        module.exports = {
            translate: ['value', require('./translate')]
        };
    }, { "./translate": 249 }], 249: [function (require, module, exports) {
        'use strict';

        /**
         * A simple translation stub to be used for multi-language support
         * in diagrams. Can be easily replaced with a more sophisticated
         * solution.
         *
         * @example
         *
         * // use it inside any diagram component by injecting `translate`.
         *
         * function MyService(translate) {
         *   alert(translate('HELLO {you}', { you: 'You!' }));
         * }
         *
         * @param {String} template to interpolate
         * @param {Object} [replacements] a map with substitutes
         *
         * @return {String} the translated string
         */
        module.exports = function translate(template, replacements) {

            replacements = replacements || {};

            return template.replace(/{([^}]+)}/g, function (_, key) {
                return replacements[key] || '{' + key + '}';
            });
        };
    }, {}], 250: [function (require, module, exports) {
        'use strict';

        var getMid = require('./LayoutUtil').getMid;


        /**
         * A base connection layouter implementation
         * that layouts the connection by directly connecting
         * mid(source) + mid(target).
         */
        function BaseLayouter() { }

        module.exports = BaseLayouter;


        /**
         * Return the new layouted waypoints for the given connection.
         *
         * The connection passed is still unchanged; you may figure out about
         * the new connection start / end via the layout hints provided.
         *
         * @param {djs.model.Connection} connection
         * @param {Object} [hints]
         * @param {Point} [hints.connectionStart]
         * @param {Point} [hints.connectionEnd]
         *
         * @return {Array<Point>} the layouted connection waypoints
         */
        BaseLayouter.prototype.layoutConnection = function (connection, hints) {

            hints = hints || {};

            return [
                hints.connectionStart || getMid(connection.source),
                hints.connectionEnd || getMid(connection.target)
            ];
        };

    }, { "./LayoutUtil": 252 }], 251: [function (require, module, exports) {
        'use strict';

        var assign = require('lodash/object/assign');

        var LayoutUtil = require('./LayoutUtil');


        function dockingToPoint(docking) {
            // use the dockings actual point and
            // retain the original docking
            return assign({ original: docking.point.original || docking.point }, docking.actual);
        }


        /**
         * A {@link ConnectionDocking} that crops connection waypoints based on
         * the path(s) of the connection source and target.
         *
         * @param {djs.core.ElementRegistry} elementRegistry
         */
        function CroppingConnectionDocking(elementRegistry, graphicsFactory) {
            this._elementRegistry = elementRegistry;
            this._graphicsFactory = graphicsFactory;
        }

        CroppingConnectionDocking.$inject = ['elementRegistry', 'graphicsFactory'];

        module.exports = CroppingConnectionDocking;


        /**
         * @inheritDoc ConnectionDocking#getCroppedWaypoints
         */
        CroppingConnectionDocking.prototype.getCroppedWaypoints = function (connection, source, target) {

            source = source || connection.source;
            target = target || connection.target;

            var sourceDocking = this.getDockingPoint(connection, source, true),
                targetDocking = this.getDockingPoint(connection, target);

            var croppedWaypoints = connection.waypoints.slice(sourceDocking.idx + 1, targetDocking.idx);

            croppedWaypoints.unshift(dockingToPoint(sourceDocking));
            croppedWaypoints.push(dockingToPoint(targetDocking));

            return croppedWaypoints;
        };

        /**
         * Return the connection docking point on the specified shape
         *
         * @inheritDoc ConnectionDocking#getDockingPoint
         */
        CroppingConnectionDocking.prototype.getDockingPoint = function (connection, shape, dockStart) {

            var waypoints = connection.waypoints,
                dockingIdx,
                dockingPoint,
                croppedPoint;

            dockingIdx = dockStart ? 0 : waypoints.length - 1;
            dockingPoint = waypoints[dockingIdx];

            croppedPoint = this._getIntersection(shape, connection, dockStart);

            return {
                point: dockingPoint,
                actual: croppedPoint || dockingPoint,
                idx: dockingIdx
            };
        };


        ////// helper methods ///////////////////////////////////////////////////

        CroppingConnectionDocking.prototype._getIntersection = function (shape, connection, takeFirst) {

            var shapePath = this._getShapePath(shape),
                connectionPath = this._getConnectionPath(connection);

            return LayoutUtil.getElementLineIntersection(shapePath, connectionPath, takeFirst);
        };

        CroppingConnectionDocking.prototype._getConnectionPath = function (connection) {
            return this._graphicsFactory.getConnectionPath(connection);
        };

        CroppingConnectionDocking.prototype._getShapePath = function (shape) {
            return this._graphicsFactory.getShapePath(shape);
        };

        CroppingConnectionDocking.prototype._getGfx = function (element) {
            return this._elementRegistry.getGraphics(element);
        };

    }, { "./LayoutUtil": 252, "lodash/object/assign": 433 }], 252: [function (require, module, exports) {
        'use strict';

        var isObject = require('lodash/lang/isObject'),
            sortBy = require('lodash/collection/sortBy'),
            pointDistance = require('../util/Geometry').pointDistance;

        var intersection = require('../util/Intersection').intersection;


        function roundBounds(bounds) {
            return {
                x: Math.round(bounds.x),
                y: Math.round(bounds.y),
                width: Math.round(bounds.width),
                height: Math.round(bounds.height)
            };
        }

        module.exports.roundBounds = roundBounds;


        function roundPoint(point) {

            return {
                x: Math.round(point.x),
                y: Math.round(point.y)
            };
        }

        module.exports.roundPoint = roundPoint;


        /**
         * Convert the given bounds to a { top, left, bottom, right } descriptor.
         *
         * @param {Bounds|Point} bounds
         *
         * @return {Object}
         */
        function asTRBL(bounds) {
            return {
                top: bounds.y,
                right: bounds.x + (bounds.width || 0),
                bottom: bounds.y + (bounds.height || 0),
                left: bounds.x
            };
        }

        module.exports.asTRBL = asTRBL;

        /**
         * Convert a { top, left, bottom, right } to an objects bounds.
         *
         * @param {Object} trbl
         *
         * @return {Bounds}
         */
        function asBounds(trbl) {
            return {
                x: trbl.left,
                y: trbl.top,
                width: trbl.right - trbl.left,
                height: trbl.bottom - trbl.top
            };
        }

        module.exports.asBounds = asBounds;


        /**
         * Get the mid of the given bounds or point.
         *
         * @param {Bounds|Point} bounds
         *
         * @return {Point}
         */
        function getMid(bounds) {
            return roundPoint({
                x: bounds.x + (bounds.width || 0) / 2,
                y: bounds.y + (bounds.height || 0) / 2
            });
        }

        module.exports.getMid = getMid;


        ////// orientation utils //////////////////////////////

        /**
         * Get orientation of the given rectangle with respect to
         * the reference rectangle.
         *
         * A padding (positive or negative) may be passed to influence
         * horizontal / vertical orientation and intersection.
         *
         * @param {Bounds} rect
         * @param {Bounds} reference
         * @param {Point|Number} padding
         *
         * @return {String} the orientation; one of top, top-left, left, ..., bottom, right or intersect.
         */
        function getOrientation(rect, reference, padding) {

            padding = padding || 0;

            // make sure we can use an object, too
            // for individual { x, y } padding
            if (!isObject(padding)) {
                padding = { x: padding, y: padding };
            }


            var rectOrientation = asTRBL(rect),
                referenceOrientation = asTRBL(reference);

            var top = rectOrientation.bottom + padding.y <= referenceOrientation.top,
                right = rectOrientation.left - padding.x >= referenceOrientation.right,
                bottom = rectOrientation.top - padding.y >= referenceOrientation.bottom,
                left = rectOrientation.right + padding.x <= referenceOrientation.left;

            var vertical = top ? 'top' : (bottom ? 'bottom' : null),
                horizontal = left ? 'left' : (right ? 'right' : null);

            if (horizontal && vertical) {
                return vertical + '-' + horizontal;
            } else {
                return horizontal || vertical || 'intersect';
            }
        }

        module.exports.getOrientation = getOrientation;


        ////// intersection utils //////////////////////////////

        /**
         * Get intersection between an element and a line path.
         *
         * @param {PathDef} elementPath
         * @param {PathDef} linePath
         * @param {Boolean} cropStart crop from start or end
         *
         * @return {Point}
         */
        function getElementLineIntersection(elementPath, linePath, cropStart) {

            var intersections = getIntersections(elementPath, linePath);

            // recognize intersections
            // only one -> choose
            // two close together -> choose first
            // two or more distinct -> pull out appropriate one
            // none -> ok (fallback to point itself)
            if (intersections.length === 1) {
                return roundPoint(intersections[0]);
            } else if (intersections.length === 2 && pointDistance(intersections[0], intersections[1]) < 1) {
                return roundPoint(intersections[0]);
            } else if (intersections.length > 1) {

                // sort by intersections based on connection segment +
                // distance from start
                intersections = sortBy(intersections, function (i) {
                    var distance = Math.floor(i.t2 * 100) || 1;

                    distance = 100 - distance;

                    distance = (distance < 10 ? '0' : '') + distance;

                    // create a sort string that makes sure we sort
                    // line segment ASC + line segment position DESC (for cropStart)
                    // line segment ASC + line segment position ASC (for cropEnd)
                    return i.segment2 + '#' + distance;
                });

                return roundPoint(intersections[cropStart ? 0 : intersections.length - 1]);
            }

            return null;
        }

        module.exports.getElementLineIntersection = getElementLineIntersection;


        function getIntersections(a, b) {
            return intersection(a, b);
        }

        module.exports.getIntersections = getIntersections;

    }, { "../util/Geometry": 268, "../util/Intersection": 271, "lodash/collection/sortBy": 311, "lodash/lang/isObject": 428 }], 253: [function (require, module, exports) {
        'use strict';

        var isArray = require('lodash/lang/isArray'),
            find = require('lodash/collection/find'),
            without = require('lodash/array/without'),
            assign = require('lodash/object/assign');

        var LayoutUtil = require('./LayoutUtil'),
            Geometry = require('../util/Geometry');

        var getOrientation = LayoutUtil.getOrientation,
            getMid = LayoutUtil.getMid,
            pointsAligned = Geometry.pointsAligned;

        var pointInRect = Geometry.pointInRect,
            pointDistance = Geometry.pointDistance;

        var INTERSECTION_THRESHOLD = 20,
            ORIENTATION_THRESHOLD = {
                'h:h': 20,
                'v:v': 20,
                'h:v': -10,
                'v:h': -10
            };


        /**
         * Returns the mid points for a manhattan connection between two points.
         *
         * @example
         *
         * [a]----[x]
         *         |
         *        [x]----[b]
         *
         * @example
         *
         * [a]----[x]
         *         |
         *        [b]
         *
         * @param  {Point} a
         * @param  {Point} b
         * @param  {String} directions
         *
         * @return {Array<Point>}
         */
        module.exports.getBendpoints = function (a, b, directions) {

            directions = directions || 'h:h';

            var xmid, ymid;

            // one point, next to a
            if (directions === 'h:v') {
                return [{ x: b.x, y: a.y }];
            } else
                // one point, above a
                if (directions === 'v:h') {
                    return [{ x: a.x, y: b.y }];
                } else
                    // vertical edge xmid
                    if (directions === 'h:h') {
                        xmid = Math.round((b.x - a.x) / 2 + a.x);

                        return [
                            { x: xmid, y: a.y },
                            { x: xmid, y: b.y }
                        ];
                    } else
                        // horizontal edge ymid
                        if (directions === 'v:v') {
                            ymid = Math.round((b.y - a.y) / 2 + a.y);

                            return [
                                { x: a.x, y: ymid },
                                { x: b.x, y: ymid }
                            ];
                        } else {
                            throw new Error(
                                'unknown directions: <' + directions + '>: ' +
                                'directions must be specified as {a direction}:{b direction} (direction in h|v)');
                        }
        };


        /**
         * Create a connection between the two points according
         * to the manhattan layout (only horizontal and vertical) edges.
         *
         * @param {Point} a
         * @param {Point} b
         *
         * @param {String} [directions='h:h'] specifies manhattan directions for each point as {adirection}:{bdirection}.
                           A directionfor a point is either `h` (horizontal) or `v` (vertical)
         *
         * @return {Array<Point>}
         */
        module.exports.connectPoints = function (a, b, directions) {

            var points = [];

            if (!pointsAligned(a, b)) {
                points = this.getBendpoints(a, b, directions);
            }

            points.unshift(a);
            points.push(b);

            return points;
        };


        /**
         * Connect two rectangles using a manhattan layouted connection.
         *
         * @param {Bounds} source source rectangle
         * @param {Bounds} target target rectangle
         * @param {Point} [start] source docking
         * @param {Point} [end] target docking
         *
         * @param {Object} [hints]
         * @param {String} [hints.preserveDocking=source] preserve docking on selected side
         * @param {Array<String>} [hints.preferredLayouts]
         * @param {Point|Boolean} [hints.connectionStart] whether the start changed
         * @param {Point|Boolean} [hints.connectionEnd] whether the end changed
         *
         * @return {Array<Point>} connection points
         */
        module.exports.connectRectangles = function (source, target, start, end, hints) {

            var preferredLayouts = hints && hints.preferredLayouts || [];

            var preferredLayout = without(preferredLayouts, 'straight')[0] || 'h:h';

            var threshold = ORIENTATION_THRESHOLD[preferredLayout] || 0;

            var orientation = getOrientation(source, target, threshold);

            var directions = getDirections(orientation, preferredLayout);

            start = start || getMid(source);
            end = end || getMid(target);

            // overlapping elements
            if (!directions) {
                return;
            }

            if (directions === 'h:h') {

                switch (orientation) {
                    case 'top-right':
                    case 'right':
                    case 'bottom-right':
                        start = { original: start, x: source.x, y: start.y };
                        end = { original: end, x: target.x + target.width, y: end.y };
                        break;
                    case 'top-left':
                    case 'left':
                    case 'bottom-left':
                        start = { original: start, x: source.x + source.width, y: start.y };
                        end = { original: end, x: target.x, y: end.y };
                        break;
                }
            }

            if (directions === 'v:v') {

                switch (orientation) {
                    case 'top-left':
                    case 'top':
                    case 'top-right':
                        start = { original: start, x: start.x, y: source.y + source.height };
                        end = { original: end, x: end.x, y: target.y };
                        break;
                    case 'bottom-left':
                    case 'bottom':
                    case 'bottom-right':
                        start = { original: start, x: start.x, y: source.y };
                        end = { original: end, x: end.x, y: target.y + target.height };
                        break;
                }
            }

            return this.connectPoints(start, end, directions);
        };

        /**
         * Repair the connection between two rectangles, of which one has been updated.
         *
         * @param {Bounds} source
         * @param {Bounds} target
         * @param {Point} [start]
         * @param {Point} [end]
         * @param {Array<Point>} waypoints
         * @param {Object} [hints]
         * @param {Array<String>} [hints.preferredLayouts] list of preferred layouts
         * @param {Boolean} [hints.connectionStart]
         * @param {Boolean} [hints.connectionEnd]
         *
         * @return {Array<Point>} repaired waypoints
         */
        module.exports.repairConnection = function (source, target, start, end, waypoints, hints) {

            if (isArray(start)) {
                waypoints = start;
                hints = end;

                start = getMid(source);
                end = getMid(target);
            }

            hints = assign({ preferredLayouts: [] }, hints);
            waypoints = waypoints || [];

            var preferredLayouts = hints.preferredLayouts,
                layoutStraight = preferredLayouts.indexOf('straight') !== -1,
                repairedWaypoints;

            // just layout non-existing or simple connections
            // attempt to render straight lines, if required

            if (layoutStraight) {
                // attempt to layout a straight line
                repairedWaypoints = this.layoutStraight(source, target, start, end, hints);
            }

            if (!repairedWaypoints) {
                // check if we layout from start or end
                if (hints.connectionEnd) {
                    repairedWaypoints = this._repairConnectionSide(target, source, end, waypoints.slice().reverse());
                    repairedWaypoints = repairedWaypoints && repairedWaypoints.reverse();
                } else
                    if (hints.connectionStart) {
                        repairedWaypoints = this._repairConnectionSide(source, target, start, waypoints);
                    } else
                        // or whether nothing seems to have changed
                        if (waypoints && waypoints.length) {
                            repairedWaypoints = waypoints;
                        }
            }

            // simply reconnect if nothing else worked
            if (!repairedWaypoints) {
                repairedWaypoints = this.connectRectangles(source, target, start, end, hints);
            }

            return repairedWaypoints;
        };


        function inRange(a, start, end) {
            return a >= start && a <= end;
        }

        function isInRange(axis, a, b) {
            var size = {
                x: 'width',
                y: 'height'
            };

            return inRange(a[axis], b[axis], b[axis] + b[size[axis]]);
        }

        /**
         * Layout a straight connection
         *
         * @param {Bounds} source
         * @param {Bounds} target
         * @param {Point} start
         * @param {Point} end
         * @param {Object} [hints]
         *
         * @return {Array<Point>} waypoints if straight layout worked
         */
        module.exports.layoutStraight = function (source, target, start, end, hints) {
            var axis = {},
                primaryAxis,
                orientation;

            orientation = getOrientation(source, target);

            // We're only interested in layouting a straight connection
            // if the shapes are horizontally or vertically aligned
            if (!/^(top|bottom|left|right)$/.test(orientation)) {
                return null;
            }

            if (/top|bottom/.test(orientation)) {
                primaryAxis = 'x';
            }

            if (/left|right/.test(orientation)) {
                primaryAxis = 'y';
            }

            if (hints.preserveDocking === 'target') {

                if (!isInRange(primaryAxis, end, source)) {
                    return null;
                }

                axis[primaryAxis] = end[primaryAxis];

                return [
                    {
                        x: axis.x !== undefined ? axis.x : start.x,
                        y: axis.y !== undefined ? axis.y : start.y,
                        original: {
                            x: axis.x !== undefined ? axis.x : start.x,
                            y: axis.y !== undefined ? axis.y : start.y
                        }
                    },
                    {
                        x: end.x,
                        y: end.y
                    }
                ];

            } else {

                if (!isInRange(primaryAxis, start, target)) {
                    return null;
                }

                axis[primaryAxis] = start[primaryAxis];

                return [
                    {
                        x: start.x,
                        y: start.y
                    },
                    {
                        x: axis.x !== undefined ? axis.x : end.x,
                        y: axis.y !== undefined ? axis.y : end.y,
                        original: {
                            x: axis.x !== undefined ? axis.x : end.x,
                            y: axis.y !== undefined ? axis.y : end.y
                        }
                    }
                ];
            }

        };

        /**
         * Repair a connection from one side that moved.
         *
         * @param {Bounds} moved
         * @param {Bounds} other
         * @param {Point} newDocking
         * @param {Array<Point>} points originalPoints from moved to other
         *
         * @return {Array<Point>} the repaired points between the two rectangles
         */
        module.exports._repairConnectionSide = function (moved, other, newDocking, points) {

            function needsRelayout(moved, other, points) {

                if (points.length < 3) {
                    return true;
                }

                if (points.length > 4) {
                    return false;
                }

                // relayout if two points overlap
                // this is most likely due to
                return !!find(points, function (p, idx) {
                    var q = points[idx - 1];

                    return q && pointDistance(p, q) < 3;
                });
            }

            function repairBendpoint(candidate, oldPeer, newPeer) {

                var alignment = pointsAligned(oldPeer, candidate);

                switch (alignment) {
                    case 'v':
                        // repair vertical alignment
                        return { x: candidate.x, y: newPeer.y };
                    case 'h':
                        // repair horizontal alignment
                        return { x: newPeer.x, y: candidate.y };
                }

                return { x: candidate.x, y: candidate.y };
            }

            function removeOverlapping(points, a, b) {
                var i;

                for (i = points.length - 2; i !== 0; i--) {

                    // intersects (?) break, remove all bendpoints up to this one and relayout
                    if (pointInRect(points[i], a, INTERSECTION_THRESHOLD) ||
                        pointInRect(points[i], b, INTERSECTION_THRESHOLD)) {

                        // return sliced old connection
                        return points.slice(i);
                    }
                }

                return points;
            }


            // (0) only repair what has layoutable bendpoints

            // (1) if only one bendpoint and on shape moved onto other shapes axis
            //     (horizontally / vertically), relayout

            if (needsRelayout(moved, other, points)) {
                return null;
            }

            var oldDocking = points[0],
                newPoints = points.slice(),
                slicedPoints;

            // (2) repair only last line segment and only if it was layouted before

            newPoints[0] = newDocking;
            newPoints[1] = repairBendpoint(newPoints[1], oldDocking, newDocking);


            // (3) if shape intersects with any bendpoint after repair,
            //     remove all segments up to this bendpoint and repair from there

            slicedPoints = removeOverlapping(newPoints, moved, other);

            if (slicedPoints !== newPoints) {
                return this._repairConnectionSide(moved, other, newDocking, slicedPoints);
            }

            return newPoints;
        };

        /**
         * Returns the manhattan directions connecting two rectangles
         * with the given orientation.
         *
         * @example
         *
         * getDirections('top'); // -> 'v:v'
         *
         * getDirections('top-right', 'v:h'); // -> 'v:h'
         * getDirections('top-right', 'h:h'); // -> 'h:h'
         *
         *
         * @param {String} orientation
         * @param {String} defaultLayout
         *
         * @return {String}
         */
        function getDirections(orientation, defaultLayout) {

            switch (orientation) {
                case 'intersect':
                    return null;

                case 'top':
                case 'bottom':
                    return 'v:v';

                case 'left':
                case 'right':
                    return 'h:h';

                // 'top-left'
                // 'top-right'
                // 'bottom-left'
                // 'bottom-right'
                default:
                    return defaultLayout;
            }
        }

    }, { "../util/Geometry": 268, "./LayoutUtil": 252, "lodash/array/without": 298, "lodash/collection/find": 303, "lodash/lang/isArray": 424, "lodash/object/assign": 433 }], 254: [function (require, module, exports) {
        'use strict';

        var assign = require('lodash/object/assign'),
            inherits = require('inherits');

        var Refs = require('object-refs');

        var parentRefs = new Refs({ name: 'children', enumerable: true, collection: true }, { name: 'parent' }),
            labelRefs = new Refs({ name: 'label', enumerable: true }, { name: 'labelTarget' }),
            attacherRefs = new Refs({ name: 'attachers', collection: true }, { name: 'host' }),
            outgoingRefs = new Refs({ name: 'outgoing', collection: true }, { name: 'source' }),
            incomingRefs = new Refs({ name: 'incoming', collection: true }, { name: 'target' });

        /**
         * @namespace djs.model
         */

        /**
         * @memberOf djs.model
         */

        /**
         * The basic graphical representation
         *
         * @class
         *
         * @abstract
         */
        function Base() {

            /**
             * The object that backs up the shape
             *
             * @name Base#businessObject
             * @type Object
             */
            Object.defineProperty(this, 'businessObject', {
                writable: true
            });

            /**
             * The parent shape
             *
             * @name Base#parent
             * @type Shape
             */
            parentRefs.bind(this, 'parent');

            /**
             * @name Base#label
             * @type Label
             */
            labelRefs.bind(this, 'label');

            /**
             * The list of outgoing connections
             *
             * @name Base#outgoing
             * @type Array<Connection>
             */
            outgoingRefs.bind(this, 'outgoing');

            /**
             * The list of incoming connections
             *
             * @name Base#incoming
             * @type Array<Connection>
             */
            incomingRefs.bind(this, 'incoming');
        }


        /**
         * A graphical object
         *
         * @class
         * @constructor
         *
         * @extends Base
         */
        function Shape() {
            Base.call(this);

            /**
             * The list of children
             *
             * @name Shape#children
             * @type Array<Base>
             */
            parentRefs.bind(this, 'children');

            /**
             * @name Shape#host
             * @type Shape
             */
            attacherRefs.bind(this, 'host');

            /**
             * @name Shape#attachers
             * @type Shape
             */
            attacherRefs.bind(this, 'attachers');
        }

        inherits(Shape, Base);


        /**
         * A root graphical object
         *
         * @class
         * @constructor
         *
         * @extends Shape
         */
        function Root() {
            Shape.call(this);
        }

        inherits(Root, Shape);


        /**
         * A label for an element
         *
         * @class
         * @constructor
         *
         * @extends Shape
         */
        function Label() {
            Shape.call(this);

            /**
             * The labeled element
             *
             * @name Label#labelTarget
             * @type Base
             */
            labelRefs.bind(this, 'labelTarget');
        }

        inherits(Label, Shape);


        /**
         * A connection between two elements
         *
         * @class
         * @constructor
         *
         * @extends Base
         */
        function Connection() {
            Base.call(this);

            /**
             * The element this connection originates from
             *
             * @name Connection#source
             * @type Base
             */
            outgoingRefs.bind(this, 'source');

            /**
             * The element this connection points to
             *
             * @name Connection#target
             * @type Base
             */
            incomingRefs.bind(this, 'target');
        }

        inherits(Connection, Base);


        var types = {
            connection: Connection,
            shape: Shape,
            label: Label,
            root: Root
        };

        /**
         * Creates a new model element of the specified type
         *
         * @method create
         *
         * @example
         *
         * var shape1 = Model.create('shape', { x: 10, y: 10, width: 100, height: 100 });
         * var shape2 = Model.create('shape', { x: 210, y: 210, width: 100, height: 100 });
         *
         * var connection = Model.create('connection', { waypoints: [ { x: 110, y: 55 }, {x: 210, y: 55 } ] });
         *
         * @param  {String} type lower-cased model name
         * @param  {Object} attrs attributes to initialize the new model instance with
         *
         * @return {Base} the new model instance
         */
        module.exports.create = function (type, attrs) {
            var Type = types[type];
            if (!Type) {
                throw new Error('unknown type: <' + type + '>');
            }
            return assign(new Type(), attrs);
        };


        module.exports.Base = Base;
        module.exports.Root = Root;
        module.exports.Shape = Shape;
        module.exports.Connection = Connection;
        module.exports.Label = Label;

    }, { "inherits": 289, "lodash/object/assign": 433, "object-refs": 468 }], 255: [function (require, module, exports) {
        'use strict';

        var Cursor = require('../../util/Cursor'),
            ClickTrap = require('../../util/ClickTrap'),
            substract = require('../../util/Math').substract,
            domEvent = require('min-dom/lib/event'),
            domClosest = require('min-dom/lib/closest'),
            EventUtil = require('../../util/Event');


        function length(point) {
            return Math.sqrt(Math.pow(point.x, 2) + Math.pow(point.y, 2));
        }


        var THRESHOLD = 15;


        function MoveCanvas(eventBus, canvas) {

            var container = canvas._container,
                context;


            function handleMove(event) {

                var start = context.start,
                    position = EventUtil.toPoint(event),
                    delta = substract(position, start);

                if (!context.dragging && length(delta) > THRESHOLD) {
                    context.dragging = true;

                    // prevent mouse click in this
                    // interaction sequence
                    ClickTrap.install();

                    Cursor.set('grab');
                }

                if (context.dragging) {

                    var lastPosition = context.last || context.start;

                    delta = substract(position, lastPosition);

                    canvas.scroll({
                        dx: delta.x,
                        dy: delta.y
                    });

                    context.last = position;
                }

                // prevent select
                event.preventDefault();
            }


            function handleEnd(event) {
                domEvent.unbind(document, 'mousemove', handleMove);
                domEvent.unbind(document, 'mouseup', handleEnd);

                context = null;

                Cursor.unset();
            }

            function handleStart(event) {
                // event is already handled by '.djs-draggable'
                if (domClosest(event.target, '.djs-draggable')) {
                    return;
                }


                // reject non-left left mouse button or modifier key
                if (event.button || event.ctrlKey || event.shiftKey || event.altKey) {
                    return;
                }

                context = {
                    start: EventUtil.toPoint(event)
                };

                domEvent.bind(document, 'mousemove', handleMove);
                domEvent.bind(document, 'mouseup', handleEnd);
            }

            domEvent.bind(container, 'mousedown', handleStart);
        }


        MoveCanvas.$inject = ['eventBus', 'canvas'];

        module.exports = MoveCanvas;

    }, { "../../util/ClickTrap": 262, "../../util/Cursor": 265, "../../util/Event": 267, "../../util/Math": 273, "min-dom/lib/closest": 449, "min-dom/lib/event": 452 }], 256: [function (require, module, exports) {
        module.exports = {
            __init__: ['moveCanvas'],
            moveCanvas: ['type', require('./MoveCanvas')]
        };
    }, { "./MoveCanvas": 255 }], 257: [function (require, module, exports) {
        module.exports = {
            __depends__: [require('../../features/touch')]
        };
    }, { "../../features/touch": 247 }], 258: [function (require, module, exports) {
        'use strict';

        var domEvent = require('min-dom/lib/event'),
            domClosest = require('min-dom/lib/closest');

        var hasPrimaryModifier = require('../../util/Mouse').hasPrimaryModifier,
            hasSecondaryModifier = require('../../util/Mouse').hasSecondaryModifier;

        var isMac = require('../../util/Platform').isMac;

        var getStepRange = require('./ZoomUtil').getStepRange,
            cap = require('./ZoomUtil').cap;

        var log10 = require('../../util/Math').log10;

        var bind = require('lodash/function/bind');

        var RANGE = { min: 0.2, max: 4 },
            NUM_STEPS = 10;


        /**
         * An implementation of zooming and scrolling within the
         * {@link Canvas} via the mouse wheel.
         *
         * Mouse wheel zooming / scrolling may be disabled using
         * the {@link toggle(enabled)} method.
         *
         * Additionally users can define the initial enabled state
         * by passing `{ zoomScroll: { enabled: false } }` at diagram
         * initialization.
         *
         * @param {EventBus} eventBus
         * @param {Canvas} canvas
         * @param {Object} config
         */
        function ZoomScroll(eventBus, canvas, config) {

            this._enabled = false;

            this._canvas = canvas;
            this._container = canvas._container;

            this._handleWheel = bind(this._handleWheel, this);

            var newEnabled = !config || config.enabled !== false;

            var self = this;

            eventBus.on('canvas.init', function (e) {
                self._init(newEnabled);
            });
        }

        ZoomScroll.$inject = ['eventBus', 'canvas', 'config.zoomScroll'];

        module.exports = ZoomScroll;

        ZoomScroll.prototype.scroll = function scroll(delta) {
            this._canvas.scroll(delta);
        };


        ZoomScroll.prototype.reset = function reset() {
            this._canvas.zoom('fit-viewport');
        };


        ZoomScroll.prototype.zoom = function zoom(direction, position) {
            var canvas = this._canvas;
            var currentZoom = canvas.zoom(false);

            var factor = Math.pow(1 + Math.abs(direction), direction > 0 ? 1 : -1);

            canvas.zoom(cap(RANGE, currentZoom * factor), position);
        };


        ZoomScroll.prototype._handleWheel = function handleWheel(event) {
            // event is already handled by '.djs-scrollable'
            if (domClosest(event.target, '.djs-scrollable', true)) {
                return;
            }

            var element = this._container;

            event.preventDefault();

            // mouse-event: SELECTION_KEY
            // mouse-event: AND_KEY
            var isVerticalScroll = hasPrimaryModifier(event),
                isHorizontalScroll = hasSecondaryModifier(event);

            var factor;

            if (isVerticalScroll || isHorizontalScroll) {

                if (isMac) {
                    factor = event.deltaMode === 0 ? 1.25 : 50;
                } else {
                    factor = event.deltaMode === 0 ? 1 / 40 : 1 / 2;
                }

                var delta = {};

                if (isHorizontalScroll) {
                    delta.dx = (factor * (event.deltaX || event.deltaY));
                } else {
                    delta.dy = (factor * event.deltaY);
                }
                this.scroll(delta);
            } else {
                factor = (event.deltaMode === 0 ? 1 / 40 : 1 / 2);

                var elementRect = element.getBoundingClientRect();

                var offset = {
                    x: event.clientX - elementRect.left,
                    y: event.clientY - elementRect.top
                };

                // zoom in relative to diagram {x,y} coordinates
                this.zoom(event.deltaY * factor / (-5), offset);
            }
        };

        /**
         * Zoom along fixed zoom steps
         *
         * @param {Integer} direction zoom direction (1 for zooming in, -1 for out)
         */
        ZoomScroll.prototype.stepZoom = function stepZoom(direction, position) {

            var canvas = this._canvas,
                stepRange = getStepRange(RANGE, NUM_STEPS);

            direction = direction > 0 ? 1 : -1;

            var currentLinearZoomLevel = log10(canvas.zoom());

            // snap to a proximate zoom step
            var newLinearZoomLevel = Math.round(currentLinearZoomLevel / stepRange) * stepRange;

            // increase or decrease one zoom step in the given direction
            newLinearZoomLevel += stepRange * direction;

            // calculate the absolute logarithmic zoom level based on the linear zoom level
            // (e.g. 2 for an absolute x2 zoom)
            var newLogZoomLevel = Math.pow(10, newLinearZoomLevel);

            canvas.zoom(cap(RANGE, newLogZoomLevel), position);
        };


        /**
         * Toggle the zoom scroll ability via mouse wheel.
         *
         * @param  {Boolean} [newEnabled] new enabled state
         */
        ZoomScroll.prototype.toggle = function toggle(newEnabled) {

            var element = this._container;
            var handleWheel = this._handleWheel;

            var oldEnabled = this._enabled;

            if (typeof newEnabled === 'undefined') {
                newEnabled = !oldEnabled;
            }

            // only react on actual changes
            if (oldEnabled !== newEnabled) {

                // add or remove wheel listener based on
                // changed enabled state
                domEvent[newEnabled ? 'bind' : 'unbind'](element, 'wheel', handleWheel, false);
            }

            this._enabled = newEnabled;

            return newEnabled;
        };


        ZoomScroll.prototype._init = function (newEnabled) {
            this.toggle(newEnabled);
        };

    }, { "../../util/Math": 273, "../../util/Mouse": 274, "../../util/Platform": 275, "./ZoomUtil": 259, "lodash/function/bind": 313, "min-dom/lib/closest": 449, "min-dom/lib/event": 452 }], 259: [function (require, module, exports) {
        'use strict';


        var log10 = require('../../util/Math').log10;

        /**
         * Get the linear range between two zoom steps based on the
         * total number of zoom steps (defined as NUM_STEPS)
         */
        module.exports.getStepRange = function (range, steps) {

            var minLinearRange = log10(range.min),
                maxLinearRange = log10(range.max);

            var absoluteLinearRange = Math.abs(minLinearRange) + Math.abs(maxLinearRange);

            return absoluteLinearRange / steps;
        };

        module.exports.cap = function (range, scale) {
            return Math.max(range.min, Math.min(range.max, scale));
        };

    }, { "../../util/Math": 273 }], 260: [function (require, module, exports) {
        module.exports = {
            __init__: ['zoomScroll'],
            zoomScroll: ['type', require('./ZoomScroll')]
        };
    }, { "./ZoomScroll": 258 }], 261: [function (require, module, exports) {
        'use strict';

        var roundPoint = require('../layout/LayoutUtil').roundPoint;

        var center = require('./PositionUtil').center,
            delta = require('./PositionUtil').delta;


        /**
         * Calculates the absolute point relative to the new element's position
         *
         * @param {point} point [absolute]
         * @param {bounds} oldBounds
         * @param {bounds} newBounds
         *
         * @return {point} point [absolute]
         */
        function getNewAttachPoint(point, oldBounds, newBounds) {
            var oldCenter = center(oldBounds),
                newCenter = center(newBounds),
                oldDelta = delta(point, oldCenter);

            var newDelta = {
                x: oldDelta.x * (newBounds.width / oldBounds.width),
                y: oldDelta.y * (newBounds.height / oldBounds.height)
            };

            return roundPoint({
                x: newCenter.x + newDelta.x,
                y: newCenter.y + newDelta.y
            });
        }

        module.exports.getNewAttachPoint = getNewAttachPoint;


        /**
         * Calculates the shape's delta relative to a new position
         * of a certain element's bounds
         *
         * @param {djs.model.Shape} point [absolute]
         * @param {bounds} oldBounds
         * @param {bounds} newBounds
         *
         * @return {delta} delta
         */
        function getNewAttachShapeDelta(shape, oldBounds, newBounds) {
            var shapeCenter = center(shape),
                oldCenter = center(oldBounds),
                newCenter = center(newBounds),
                shapeDelta = delta(shape, shapeCenter),
                oldCenterDelta = delta(shapeCenter, oldCenter);

            var newCenterDelta = {
                x: oldCenterDelta.x * (newBounds.width / oldBounds.width),
                y: oldCenterDelta.y * (newBounds.height / oldBounds.height)
            };

            var newShapeCenter = {
                x: newCenter.x + newCenterDelta.x,
                y: newCenter.y + newCenterDelta.y
            };

            return roundPoint({
                x: newShapeCenter.x + shapeDelta.x - shape.x,
                y: newShapeCenter.y + shapeDelta.y - shape.y
            });
        }

        module.exports.getNewAttachShapeDelta = getNewAttachShapeDelta;

    }, { "../layout/LayoutUtil": 252, "./PositionUtil": 276 }], 262: [function (require, module, exports) {
        'use strict';

        var domEvent = require('min-dom/lib/event'),
            stopEvent = require('./Event').stopEvent;

        function trap(event) {
            stopEvent(event);

            toggle(false);
        }

        function toggle(active) {
            domEvent[active ? 'bind' : 'unbind'](document.body, 'click', trap, true);
        }

        /**
         * Installs a click trap that prevents a ghost click following a dragging operation.
         *
         * @return {Function} a function to immediately remove the installed trap.
         */
        function install() {

            toggle(true);

            return function () {
                toggle(false);
            };
        }

        module.exports.install = install;
    }, { "./Event": 267, "min-dom/lib/event": 452 }], 263: [function (require, module, exports) {
        'use strict';

        /**
         * Failsafe remove an element from a collection
         *
         * @param  {Array<Object>} [collection]
         * @param  {Object} [element]
         *
         * @return {Number} the previous index of the element
         */
        module.exports.remove = function (collection, element) {

            if (!collection || !element) {
                return -1;
            }

            var idx = collection.indexOf(element);

            if (idx !== -1) {
                collection.splice(idx, 1);
            }

            return idx;
        };

        /**
         * Fail save add an element to the given connection, ensuring
         * it does not yet exist.
         *
         * @param {Array<Object>} collection
         * @param {Object} element
         * @param {Number} idx
         */
        module.exports.add = function (collection, element, idx) {

            if (!collection || !element) {
                return;
            }

            if (typeof idx !== 'number') {
                idx = -1;
            }

            var currentIdx = collection.indexOf(element);

            if (currentIdx !== -1) {

                if (currentIdx === idx) {
                    // nothing to do, position has not changed
                    return;
                } else {

                    if (idx !== -1) {
                        // remove from current position
                        collection.splice(currentIdx, 1);
                    } else {
                        // already exists in collection
                        return;
                    }
                }
            }

            if (idx !== -1) {
                // insert at specified position
                collection.splice(idx, 0, element);
            } else {
                // push to end
                collection.push(element);
            }
        };


        /**
         * Fail save get the index of an element in a collection.
         *
         * @param {Array<Object>} collection
         * @param {Object} element
         *
         * @return {Number} the index or -1 if collection or element do
         *                  not exist or the element is not contained.
         */
        module.exports.indexOf = function (collection, element) {

            if (!collection || !element) {
                return -1;
            }

            return collection.indexOf(element);
        };

    }, {}], 264: [function (require, module, exports) {
        'use strict';

        var forEach = require('lodash/collection/forEach');

        function getTopLevel(elements) {
            var topLevel = {},
                parents = [],
                result = [],
                clearedParents = [];

            forEach(elements, function (element) {
                var parent = element.parent;

                if (!topLevel[parent.id]) {
                    topLevel[parent.id] = [];
                }

                if (parents.indexOf(parent.id) === -1) {
                    parents.push(parent.id);
                }

                topLevel[parent.id].push(element);
            });

            forEach(parents, function (parent) {
                forEach(topLevel[parent], function (element) {
                    if (topLevel[element.id]) {
                        clearedParents.push(element.id);
                    }
                });
            });

            forEach(parents, function (parent) {
                var idx = clearedParents.indexOf(parent);

                if (idx === -1) {
                    result = result.concat(topLevel[parent]);
                }
            });

            return result;
        }

        module.exports.getTopLevel = getTopLevel;

    }, { "lodash/collection/forEach": 304 }], 265: [function (require, module, exports) {
        'use strict';

        var domClasses = require('min-dom/lib/classes');

        var CURSOR_CLS_PATTERN = /^djs-cursor-.*$/;


        module.exports.set = function (mode) {
            var classes = domClasses(document.body);

            classes.removeMatching(CURSOR_CLS_PATTERN);

            if (mode) {
                classes.add('djs-cursor-' + mode);
            }
        };

        module.exports.unset = function () {
            this.set(null);
        };

        module.exports.has = function (mode) {
            var classes = domClasses(document.body);

            return classes.has('djs-cursor-' + mode);
        };

    }, { "min-dom/lib/classes": 447 }], 266: [function (require, module, exports) {
        'use strict';

        var isArray = require('lodash/lang/isArray'),
            isNumber = require('lodash/lang/isNumber'),
            groupBy = require('lodash/collection/groupBy'),
            forEach = require('lodash/collection/forEach');

        /**
         * Adds an element to a collection and returns true if the
         * element was added.
         *
         * @param {Array<Object>} elements
         * @param {Object} e
         * @param {Boolean} unique
         */
        function add(elements, e, unique) {
            var canAdd = !unique || elements.indexOf(e) === -1;

            if (canAdd) {
                elements.push(e);
            }

            return canAdd;
        }

        /**
         * Iterate over each element in a collection, calling the iterator function `fn`
         * with (element, index, recursionDepth).
         *
         * Recurse into all elements that are returned by `fn`.
         *
         * @param  {Object|Array<Object>} elements
         * @param  {Function} fn iterator function called with (element, index, recursionDepth)
         * @param  {Number} [depth] maximum recursion depth
         */
        function eachElement(elements, fn, depth) {

            depth = depth || 0;

            if (!isArray(elements)) {
                elements = [elements];
            }

            forEach(elements, function (s, i) {
                var filter = fn(s, i, depth);

                if (isArray(filter) && filter.length) {
                    eachElement(filter, fn, depth + 1);
                }
            });
        }

        /**
         * Collects self + child elements up to a given depth from a list of elements.
         *
         * @param  {djs.model.Base|Array<djs.model.Base>} elements the elements to select the children from
         * @param  {Boolean} unique whether to return a unique result set (no duplicates)
         * @param  {Number} maxDepth the depth to search through or -1 for infinite
         *
         * @return {Array<djs.model.Base>} found elements
         */
        function selfAndChildren(elements, unique, maxDepth) {
            var result = [],
                processedChildren = [];

            eachElement(elements, function (element, i, depth) {
                add(result, element, unique);

                var children = element.children;

                // max traversal depth not reached yet
                if (maxDepth === -1 || depth < maxDepth) {

                    // children exist && children not yet processed
                    if (children && add(processedChildren, children, unique)) {
                        return children;
                    }
                }
            });

            return result;
        }

        /**
         * Return self + direct children for a number of elements
         *
         * @param  {Array<djs.model.Base>} elements to query
         * @param  {Boolean} allowDuplicates to allow duplicates in the result set
         *
         * @return {Array<djs.model.Base>} the collected elements
         */
        function selfAndDirectChildren(elements, allowDuplicates) {
            return selfAndChildren(elements, !allowDuplicates, 1);
        }

        /**
         * Return self + ALL children for a number of elements
         *
         * @param  {Array<djs.model.Base>} elements to query
         * @param  {Boolean} allowDuplicates to allow duplicates in the result set
         *
         * @return {Array<djs.model.Base>} the collected elements
         */
        function selfAndAllChildren(elements, allowDuplicates) {
            return selfAndChildren(elements, !allowDuplicates, -1);
        }

        /**
         * Gets the the closure for all selected elements,
         * their connections and their attachment's connections
         *
         * @param {Array<djs.model.Base>} elements
         * @return {Object} enclosure
         */
        function getClosure(elements) {

            // original elements passed to this function
            var topLevel = groupBy(elements, function (e) { return e.id; });

            var allShapes = {},
                allConnections = {},
                enclosedElements = {},
                enclosedConnections = {};

            function handleConnection(c) {
                if (topLevel[c.source.id] && topLevel[c.target.id]) {
                    topLevel[c.id] = c;
                }

                // not enclosed as a child, but maybe logically
                // (connecting two moved elements?)
                if (allShapes[c.source.id] && allShapes[c.target.id]) {
                    enclosedConnections[c.id] = enclosedElements[c.id] = c;
                }

                allConnections[c.id] = c;
            }

            function handleElement(element) {

                enclosedElements[element.id] = element;

                if (element.waypoints) {
                    // remember connection
                    enclosedConnections[element.id] = allConnections[element.id] = element;
                } else {
                    // remember shape
                    allShapes[element.id] = element;

                    // remember all connections
                    forEach(element.incoming, handleConnection);

                    forEach(element.outgoing, handleConnection);

                    // recurse into children
                    return element.children;
                }
            }

            eachElement(elements, handleElement);

            return {
                allShapes: allShapes,
                allConnections: allConnections,
                topLevel: topLevel,
                enclosedConnections: enclosedConnections,
                enclosedElements: enclosedElements
            };
        }

        /**
         * Returns the surrounding bbox for all elements in
         * the array or the element primitive.
         *
         * @param {Array<djs.model.Shape>|djs.model.Shape} elements
         * @param {Boolean} stopRecursion
         */
        function getBBox(elements, stopRecursion) {

            stopRecursion = !!stopRecursion;
            if (!isArray(elements)) {
                elements = [elements];
            }

            var minX,
                minY,
                maxX,
                maxY;

            forEach(elements, function (element) {

                // If element is a connection the bbox must be computed first
                var bbox = element;
                if (element.waypoints && !stopRecursion) {
                    bbox = getBBox(element.waypoints, true);
                }

                var x = bbox.x,
                    y = bbox.y,
                    height = bbox.height || 0,
                    width = bbox.width || 0;

                if (x < minX || minX === undefined) {
                    minX = x;
                }
                if (y < minY || minY === undefined) {
                    minY = y;
                }

                if ((x + width) > maxX || maxX === undefined) {
                    maxX = x + width;
                }
                if ((y + height) > maxY || maxY === undefined) {
                    maxY = y + height;
                }
            });

            return {
                x: minX,
                y: minY,
                height: maxY - minY,
                width: maxX - minX
            };
        }


        /**
         * Returns all elements that are enclosed from the bounding box.
         *
         *   * If bbox.(width|height) is not specified the method returns
         *     all elements with element.x/y > bbox.x/y
         *   * If only bbox.x or bbox.y is specified, method return all elements with
         *     e.x > bbox.x or e.y > bbox.y
         *
         * @param {Array<djs.model.Shape>} elements List of Elements to search through
         * @param {djs.model.Shape} bbox the enclosing bbox.
         *
         * @return {Array<djs.model.Shape>} enclosed elements
         */
        function getEnclosedElements(elements, bbox) {

            var filteredElements = {};

            forEach(elements, function (element) {

                var e = element;

                if (e.waypoints) {
                    e = getBBox(e);
                }

                if (!isNumber(bbox.y) && (e.x > bbox.x)) {
                    filteredElements[element.id] = element;
                }
                if (!isNumber(bbox.x) && (e.y > bbox.y)) {
                    filteredElements[element.id] = element;
                }
                if (e.x > bbox.x && e.y > bbox.y) {
                    if (isNumber(bbox.width) && isNumber(bbox.height) &&
                        e.width + e.x < bbox.width + bbox.x &&
                        e.height + e.y < bbox.height + bbox.y) {

                        filteredElements[element.id] = element;
                    } else if (!isNumber(bbox.width) || !isNumber(bbox.height)) {
                        filteredElements[element.id] = element;
                    }
                }
            });

            return filteredElements;
        }


        module.exports.add = add;
        module.exports.eachElement = eachElement;
        module.exports.selfAndDirectChildren = selfAndDirectChildren;
        module.exports.selfAndAllChildren = selfAndAllChildren;
        module.exports.getBBox = getBBox;
        module.exports.getEnclosedElements = getEnclosedElements;

        module.exports.getClosure = getClosure;


        function getElementType(element) {

            if ('waypoints' in element) {
                return 'connection';
            }

            if ('x' in element) {
                return 'shape';
            }

            return 'root';
        }

        module.exports.getType = getElementType;
    }, { "lodash/collection/forEach": 304, "lodash/collection/groupBy": 305, "lodash/lang/isArray": 424, "lodash/lang/isNumber": 427 }], 267: [function (require, module, exports) {
        'use strict';

        function __preventDefault(event) {
            return event && event.preventDefault();
        }

        function __stopPropagation(event, immediate) {
            if (!event) {
                return;
            }

            if (event.stopPropagation) {
                event.stopPropagation();
            }

            if (immediate && event.stopImmediatePropagation) {
                event.stopImmediatePropagation();
            }
        }


        function getOriginal(event) {
            return event.originalEvent || event.srcEvent;
        }

        module.exports.getOriginal = getOriginal;


        function stopEvent(event, immediate) {
            stopPropagation(event, immediate);
            preventDefault(event);
        }

        module.exports.stopEvent = stopEvent;


        function preventDefault(event) {
            __preventDefault(event);
            __preventDefault(getOriginal(event));
        }

        module.exports.preventDefault = preventDefault;


        function stopPropagation(event, immediate) {
            __stopPropagation(event, immediate);
            __stopPropagation(getOriginal(event), immediate);
        }

        module.exports.stopPropagation = stopPropagation;


        function toPoint(event) {

            if (event.pointers && event.pointers.length) {
                event = event.pointers[0];
            }

            if (event.touches && event.touches.length) {
                event = event.touches[0];
            }

            return event ? {
                x: event.clientX,
                y: event.clientY
            } : null;
        }

        module.exports.toPoint = toPoint;

    }, {}], 268: [function (require, module, exports) {
        'use strict';

        /**
         * Computes the distance between two points
         *
         * @param  {Point}  p
         * @param  {Point}  q
         *
         * @return {Number}  distance
         */
        function pointDistance(a, b) {
            if (!a || !b) {
                return -1;
            }

            return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));
        }

        module.exports.pointDistance = pointDistance;


        /**
         * Returns true if the point r is on the line between p and y
         *
         * @param  {Point}  p
         * @param  {Point}  q
         * @param  {Point}  r
         *
         * @return {Boolean}
         */
        module.exports.pointsOnLine = function (p, q, r) {

            if (!p || !q || !r) {
                return false;
            }

            var val = (q.x - p.x) * (r.y - p.y) - (q.y - p.y) * (r.x - p.x),
                dist = pointDistance(p, q);

            // @see http://stackoverflow.com/a/907491/412190
            return Math.abs(val / dist) < 5;
        };


        var ALIGNED_THRESHOLD = 2;

        /**
         * Returns whether two points are in a horizontal or vertical line.
         *
         * @param {Point} a
         * @param {Point} b
         *
         * @return {String|Boolean} returns false if the points are not
         *                          aligned or 'h|v' if they are aligned
         *                          horizontally / vertically.
         */
        function pointsAligned(a, b) {
            if (Math.abs(a.x - b.x) <= ALIGNED_THRESHOLD) {
                return 'h';
            }

            if (Math.abs(a.y - b.y) <= ALIGNED_THRESHOLD) {
                return 'v';
            }

            return false;
        }

        module.exports.pointsAligned = pointsAligned;


        /**
         * Returns true if the point p is inside the rectangle rect
         *
         * @param  {Point}  p
         * @param  {Rect}   rect
         * @param  {Number} tolerance
         *
         * @return {Boolean}
         */
        module.exports.pointInRect = function (p, rect, tolerance) {
            tolerance = tolerance || 0;

            return p.x > rect.x - tolerance &&
                p.y > rect.y - tolerance &&
                p.x < rect.x + rect.width + tolerance &&
                p.y < rect.y + rect.height + tolerance;
        };

        /**
         * Returns a point in the middle of points p and q
         *
         * @param  {Point}  p
         * @param  {Point}  q
         *
         * @return {Point} middle point
         */
        module.exports.getMidPoint = function (p, q) {
            return {
                x: Math.round(p.x + ((q.x - p.x) / 2.0)),
                y: Math.round(p.y + ((q.y - p.y) / 2.0))
            };
        };

    }, {}], 269: [function (require, module, exports) {
        'use strict';

        var domQuery = require('min-dom/lib/query');

        /**
         * SVGs for elements are generated by the {@link GraphicsFactory}.
         *
         * This utility gives quick access to the important semantic
         * parts of an element.
         */

        /**
         * Returns the visual part of a diagram element
         *
         * @param {Snap<SVGElement>} gfx
         *
         * @return {Snap<SVGElement>}
         */
        function getVisual(gfx) {
            return domQuery('.djs-visual', gfx);
        }

        /**
         * Returns the children for a given diagram element.
         *
         * @param {Snap<SVGElement>} gfx
         * @return {Snap<SVGElement>}
         */
        function getChildren(gfx) {
            return gfx.parentNode.childNodes[1];
        }

        module.exports.getVisual = getVisual;
        module.exports.getChildren = getChildren;

    }, { "min-dom/lib/query": 454 }], 270: [function (require, module, exports) {
        'use strict';

        /**
         * Util that provides unique IDs.
         *
         * @class djs.util.IdGenerator
         * @constructor
         * @memberOf djs.util
         *
         * The ids can be customized via a given prefix and contain a random value to avoid collisions.
         *
         * @param {String} prefix a prefix to prepend to generated ids (for better readability)
         */
        function IdGenerator(prefix) {

            this._counter = 0;
            this._prefix = (prefix ? prefix + '-' : '') + Math.floor(Math.random() * 1000000000) + '-';
        }

        module.exports = IdGenerator;

        /**
         * Returns a next unique ID.
         *
         * @method djs.util.IdGenerator#next
         *
         * @returns {String} the id
         */
        IdGenerator.prototype.next = function () {
            return this._prefix + (++this._counter);
        };

    }, {}], 271: [function (require, module, exports) {
        /* eslint no-fallthrough: "off" */

        'use strict';

        var has = 'hasOwnProperty',
            p2s = /,?([a-z]),?/gi,
            toFloat = parseFloat,
            math = Math,
            PI = math.PI,
            mmin = math.min,
            mmax = math.max,
            pow = math.pow,
            abs = math.abs,
            pathCommand = /([a-z])[\s,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\s]*,?[\s]*)+)/ig,
            pathValues = /(-?\d*\.?\d*(?:e[\-+]?\\d+)?)[\s]*,?[\s]*/ig;

        function is(o, type) {
            type = String.prototype.toLowerCase.call(type);

            if (type == 'finite') {
                return isFinite(o);
            }

            if (type == 'array' && (o instanceof Array || Array.isArray && Array.isArray(o))) {
                return true;
            }

            return (type == 'null' && o === null) ||
                (type == typeof o && o !== null) ||
                (type == 'object' && o === Object(o)) ||
                Object.prototype.toString.call(o).slice(8, -1).toLowerCase() == type;
        }

        function clone(obj) {

            if (typeof obj == 'function' || Object(obj) !== obj) {
                return obj;
            }

            var res = new obj.constructor;

            for (var key in obj) if (obj[has](key)) {
                res[key] = clone(obj[key]);
            }

            return res;
        }

        function repush(array, item) {
            for (var i = 0, ii = array.length; i < ii; i++) if (array[i] === item) {
                return array.push(array.splice(i, 1)[0]);
            }
        }

        function cacher(f, scope, postprocessor) {

            function newf() {

                var arg = Array.prototype.slice.call(arguments, 0),
                    args = arg.join('\u2400'),
                    cache = newf.cache = newf.cache || {},
                    count = newf.count = newf.count || [];

                if (cache[has](args)) {
                    repush(count, args);
                    return postprocessor ? postprocessor(cache[args]) : cache[args];
                }

                count.length >= 1e3 && delete cache[count.shift()];
                count.push(args);
                cache[args] = f.apply(scope, arg);

                return postprocessor ? postprocessor(cache[args]) : cache[args];
            }
            return newf;
        }

        function parsePathString(pathString) {

            if (!pathString) {
                return null;
            }

            var pth = paths(pathString);

            if (pth.arr) {
                return clone(pth.arr);
            }

            var paramCounts = { a: 7, c: 6, o: 2, h: 1, l: 2, m: 2, r: 4, q: 4, s: 4, t: 2, v: 1, u: 3, z: 0 },
                data = [];

            if (is(pathString, 'array') && is(pathString[0], 'array')) { // rough assumption
                data = clone(pathString);
            }

            if (!data.length) {

                String(pathString).replace(pathCommand, function (a, b, c) {
                    var params = [],
                        name = b.toLowerCase();

                    c.replace(pathValues, function (a, b) {
                        b && params.push(+b);
                    });

                    if (name == 'm' && params.length > 2) {
                        data.push([b].concat(params.splice(0, 2)));
                        name = 'l';
                        b = b == 'm' ? 'l' : 'L';
                    }

                    if (name == 'o' && params.length == 1) {
                        data.push([b, params[0]]);
                    }

                    if (name == 'r') {
                        data.push([b].concat(params));
                    } else while (params.length >= paramCounts[name]) {
                        data.push([b].concat(params.splice(0, paramCounts[name])));
                        if (!paramCounts[name]) {
                            break;
                        }
                    }
                });
            }

            data.toString = paths.toString;
            pth.arr = clone(data);

            return data;
        }

        function paths(ps) {
            var p = paths.ps = paths.ps || {};

            if (p[ps]) {
                p[ps].sleep = 100;
            } else {
                p[ps] = {
                    sleep: 100
                };
            }

            setTimeout(function () {
                for (var key in p) if (p[has](key) && key != ps) {
                    p[key].sleep--;
                    !p[key].sleep && delete p[key];
                }
            });

            return p[ps];
        }

        function box(x, y, width, height) {
            if (x == null) {
                x = y = width = height = 0;
            }

            if (y == null) {
                y = x.y;
                width = x.width;
                height = x.height;
                x = x.x;
            }

            return {
                x: x,
                y: y,
                width: width,
                w: width,
                height: height,
                h: height,
                x2: x + width,
                y2: y + height,
                cx: x + width / 2,
                cy: y + height / 2,
                r1: math.min(width, height) / 2,
                r2: math.max(width, height) / 2,
                r0: math.sqrt(width * width + height * height) / 2,
                path: rectPath(x, y, width, height),
                vb: [x, y, width, height].join(' ')
            };
        }

        function toString() {
            return this.join(',').replace(p2s, '$1');
        }

        function pathClone(pathArray) {
            var res = clone(pathArray);
            res.toString = toString;
            return res;
        }

        function getPointAtSegmentLength(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length) {
            if (length == null) {
                return bezlen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y);
            } else {
                return findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y,
                    getTotLen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length));
            }
        }

        function getLengthFactory(istotal, subpath) {
            function O(val) {
                return +(+val).toFixed(3);
            }

            return cacher(function (path, length, onlystart) {

                if (path instanceof Element) {
                    path = path.attr('d');
                }

                path = path2curve(path);

                var x, y, p, l, sp = '', subpaths = {}, point,
                    len = 0;

                for (var i = 0, ii = path.length; i < ii; i++) {
                    p = path[i];

                    if (p[0] == 'M') {
                        x = +p[1];
                        y = +p[2];
                    } else {
                        l = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);

                        if (len + l > length) {

                            if (subpath && !subpaths.start) {
                                point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);

                                sp += [
                                    'C' + O(point.start.x),
                                    O(point.start.y),
                                    O(point.m.x),
                                    O(point.m.y),
                                    O(point.x),
                                    O(point.y)
                                ];

                                if (onlystart) {
                                    return sp;
                                }

                                subpaths.start = sp;
                                sp = [
                                    'M' + O(point.x),
                                    O(point.y) + 'C' + O(point.n.x),
                                    O(point.n.y),
                                    O(point.end.x),
                                    O(point.end.y),
                                    O(p[5]),
                                    O(p[6])
                                ].join();
                                len += l;
                                x = +p[5];
                                y = +p[6];
                                continue;
                            }

                            if (!istotal && !subpath) {
                                point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
                                return point;
                            }
                        }

                        len += l;
                        x = +p[5];
                        y = +p[6];
                    }

                    sp += p.shift() + p;
                }

                subpaths.end = sp;
                point = istotal ? len : subpath ? subpaths : findDotsAtSegment(x, y, p[0], p[1], p[2], p[3], p[4], p[5], 1);
                return point;
            }, null, clone);
        }

        var getTotalLength = getLengthFactory(1),
            getPointAtLength = getLengthFactory();

        function findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
            var t1 = 1 - t,
                t13 = pow(t1, 3),
                t12 = pow(t1, 2),
                t2 = t * t,
                t3 = t2 * t,
                x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x,
                y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y,
                mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x),
                my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y),
                nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x),
                ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y),
                ax = t1 * p1x + t * c1x,
                ay = t1 * p1y + t * c1y,
                cx = t1 * c2x + t * p2x,
                cy = t1 * c2y + t * p2y,
                alpha = (90 - math.atan2(mx - nx, my - ny) * 180 / PI);

            // (mx > nx || my < ny) && (alpha += 180);

            return {
                x: x,
                y: y,
                m: { x: mx, y: my },
                n: { x: nx, y: ny },
                start: { x: ax, y: ay },
                end: { x: cx, y: cy },
                alpha: alpha
            };
        }

        function bezierBBox(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {

            if (!is(p1x, 'array')) {
                p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];
            }

            var bbox = curveDim.apply(null, p1x);

            return box(
                bbox.min.x,
                bbox.min.y,
                bbox.max.x - bbox.min.x,
                bbox.max.y - bbox.min.y
            );
        }

        function isPointInsideBBox(bbox, x, y) {
            return x >= bbox.x &&
                x <= bbox.x + bbox.width &&
                y >= bbox.y &&
                y <= bbox.y + bbox.height;
        }

        function isBBoxIntersect(bbox1, bbox2) {
            bbox1 = box(bbox1);
            bbox2 = box(bbox2);
            return isPointInsideBBox(bbox2, bbox1.x, bbox1.y)
                || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y)
                || isPointInsideBBox(bbox2, bbox1.x, bbox1.y2)
                || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y2)
                || isPointInsideBBox(bbox1, bbox2.x, bbox2.y)
                || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y)
                || isPointInsideBBox(bbox1, bbox2.x, bbox2.y2)
                || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y2)
                || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x
                    || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x)
                && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y
                    || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);
        }

        function base3(t, p1, p2, p3, p4) {
            var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4,
                t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;
            return t * t2 - 3 * p1 + 3 * p2;
        }

        function bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z) {

            if (z == null) {
                z = 1;
            }

            z = z > 1 ? 1 : z < 0 ? 0 : z;

            var z2 = z / 2,
                n = 12,
                Tvalues = [-.1252, .1252, -.3678, .3678, -.5873, .5873, -.7699, .7699, -.9041, .9041, -.9816, .9816],
                Cvalues = [0.2491, 0.2491, 0.2335, 0.2335, 0.2032, 0.2032, 0.1601, 0.1601, 0.1069, 0.1069, 0.0472, 0.0472],
                sum = 0;

            for (var i = 0; i < n; i++) {
                var ct = z2 * Tvalues[i] + z2,
                    xbase = base3(ct, x1, x2, x3, x4),
                    ybase = base3(ct, y1, y2, y3, y4),
                    comb = xbase * xbase + ybase * ybase;

                sum += Cvalues[i] * math.sqrt(comb);
            }

            return z2 * sum;
        }

        function getTotLen(x1, y1, x2, y2, x3, y3, x4, y4, ll) {

            if (ll < 0 || bezlen(x1, y1, x2, y2, x3, y3, x4, y4) < ll) {
                return;
            }

            var t = 1,
                step = t / 2,
                t2 = t - step,
                l,
                e = .01;

            l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);

            while (abs(l - ll) > e) {
                step /= 2;
                t2 += (l < ll ? 1 : -1) * step;
                l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);
            }

            return t2;
        }

        function intersect(x1, y1, x2, y2, x3, y3, x4, y4) {

            if (
                mmax(x1, x2) < mmin(x3, x4) ||
                mmin(x1, x2) > mmax(x3, x4) ||
                mmax(y1, y2) < mmin(y3, y4) ||
                mmin(y1, y2) > mmax(y3, y4)
            ) {
                return;
            }

            var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),
                ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),
                denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);

            if (!denominator) {
                return;
            }

            var px = nx / denominator,
                py = ny / denominator,
                px2 = +px.toFixed(2),
                py2 = +py.toFixed(2);

            if (
                px2 < +mmin(x1, x2).toFixed(2) ||
                px2 > +mmax(x1, x2).toFixed(2) ||
                px2 < +mmin(x3, x4).toFixed(2) ||
                px2 > +mmax(x3, x4).toFixed(2) ||
                py2 < +mmin(y1, y2).toFixed(2) ||
                py2 > +mmax(y1, y2).toFixed(2) ||
                py2 < +mmin(y3, y4).toFixed(2) ||
                py2 > +mmax(y3, y4).toFixed(2)
            ) {
                return;
            }

            return { x: px, y: py };
        }

        function interHelper(bez1, bez2, justCount) {
            var bbox1 = bezierBBox(bez1),
                bbox2 = bezierBBox(bez2);

            if (!isBBoxIntersect(bbox1, bbox2)) {
                return justCount ? 0 : [];
            }

            var l1 = bezlen.apply(0, bez1),
                l2 = bezlen.apply(0, bez2),
                n1 = ~~(l1 / 8),
                n2 = ~~(l2 / 8),
                dots1 = [],
                dots2 = [],
                xy = {},
                res = justCount ? 0 : [];

            for (var i = 0; i < n1 + 1; i++) {
                var p = findDotsAtSegment.apply(0, bez1.concat(i / n1));
                dots1.push({ x: p.x, y: p.y, t: i / n1 });
            }

            for (i = 0; i < n2 + 1; i++) {
                p = findDotsAtSegment.apply(0, bez2.concat(i / n2));
                dots2.push({ x: p.x, y: p.y, t: i / n2 });
            }

            for (i = 0; i < n1; i++) {

                for (var j = 0; j < n2; j++) {
                    var di = dots1[i],
                        di1 = dots1[i + 1],
                        dj = dots2[j],
                        dj1 = dots2[j + 1],
                        ci = abs(di1.x - di.x) < .001 ? 'y' : 'x',
                        cj = abs(dj1.x - dj.x) < .001 ? 'y' : 'x',
                        is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);

                    if (is) {

                        if (xy[is.x.toFixed(4)] == is.y.toFixed(4)) {
                            continue;
                        }

                        xy[is.x.toFixed(4)] = is.y.toFixed(4);

                        var t1 = di.t + abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t),
                            t2 = dj.t + abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);

                        if (t1 >= 0 && t1 <= 1 && t2 >= 0 && t2 <= 1) {

                            if (justCount) {
                                res++;
                            } else {
                                res.push({
                                    x: is.x,
                                    y: is.y,
                                    t1: t1,
                                    t2: t2
                                });
                            }
                        }
                    }
                }
            }

            return res;
        }

        function pathIntersection(path1, path2) {
            return interPathHelper(path1, path2);
        }

        function pathIntersectionNumber(path1, path2) {
            return interPathHelper(path1, path2, 1);
        }

        function interPathHelper(path1, path2, justCount) {
            path1 = path2curve(path1);
            path2 = path2curve(path2);

            var x1, y1, x2, y2, x1m, y1m, x2m, y2m, bez1, bez2,
                res = justCount ? 0 : [];

            for (var i = 0, ii = path1.length; i < ii; i++) {
                var pi = path1[i];

                if (pi[0] == 'M') {
                    x1 = x1m = pi[1];
                    y1 = y1m = pi[2];
                } else {

                    if (pi[0] == 'C') {
                        bez1 = [x1, y1].concat(pi.slice(1));
                        x1 = bez1[6];
                        y1 = bez1[7];
                    } else {
                        bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];
                        x1 = x1m;
                        y1 = y1m;
                    }

                    for (var j = 0, jj = path2.length; j < jj; j++) {
                        var pj = path2[j];

                        if (pj[0] == 'M') {
                            x2 = x2m = pj[1];
                            y2 = y2m = pj[2];
                        } else {

                            if (pj[0] == 'C') {
                                bez2 = [x2, y2].concat(pj.slice(1));
                                x2 = bez2[6];
                                y2 = bez2[7];
                            } else {
                                bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];
                                x2 = x2m;
                                y2 = y2m;
                            }

                            var intr = interHelper(bez1, bez2, justCount);

                            if (justCount) {
                                res += intr;
                            } else {

                                for (var k = 0, kk = intr.length; k < kk; k++) {
                                    intr[k].segment1 = i;
                                    intr[k].segment2 = j;
                                    intr[k].bez1 = bez1;
                                    intr[k].bez2 = bez2;
                                }

                                res = res.concat(intr);
                            }
                        }
                    }
                }
            }

            return res;
        }

        function isPointInsidePath(path, x, y) {
            var bbox = pathBBox(path);

            return isPointInsideBBox(bbox, x, y) &&
                interPathHelper(path, [['M', x, y], ['H', bbox.x2 + 10]], 1) % 2 == 1;
        }

        function pathBBox(path) {
            var pth = paths(path);

            if (pth.bbox) {
                return clone(pth.bbox);
            }

            if (!path) {
                return box();
            }

            path = path2curve(path);

            var x = 0,
                y = 0,
                X = [],
                Y = [],
                p;

            for (var i = 0, ii = path.length; i < ii; i++) {
                p = path[i];

                if (p[0] == 'M') {
                    x = p[1];
                    y = p[2];
                    X.push(x);
                    Y.push(y);
                } else {
                    var dim = curveDim(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
                    X = X.concat(dim.min.x, dim.max.x);
                    Y = Y.concat(dim.min.y, dim.max.y);
                    x = p[5];
                    y = p[6];
                }
            }

            var xmin = mmin.apply(0, X),
                ymin = mmin.apply(0, Y),
                xmax = mmax.apply(0, X),
                ymax = mmax.apply(0, Y),
                bb = box(xmin, ymin, xmax - xmin, ymax - ymin);

            pth.bbox = clone(bb);

            return bb;
        }

        function rectPath(x, y, w, h, r) {
            if (r) {
                return [
                    ['M', +x + (+r), y],
                    ['l', w - r * 2, 0],
                    ['a', r, r, 0, 0, 1, r, r],
                    ['l', 0, h - r * 2],
                    ['a', r, r, 0, 0, 1, -r, r],
                    ['l', r * 2 - w, 0],
                    ['a', r, r, 0, 0, 1, -r, -r],
                    ['l', 0, r * 2 - h],
                    ['a', r, r, 0, 0, 1, r, -r],
                    ['z']
                ];
            }

            var res = [['M', x, y], ['l', w, 0], ['l', 0, h], ['l', -w, 0], ['z']];
            res.toString = toString;

            return res;
        }

        function ellipsePath(x, y, rx, ry, a) {
            if (a == null && ry == null) {
                ry = rx;
            }

            x = +x;
            y = +y;
            rx = +rx;
            ry = +ry;

            if (a != null) {
                var rad = Math.PI / 180,
                    x1 = x + rx * Math.cos(-ry * rad),
                    x2 = x + rx * Math.cos(-a * rad),
                    y1 = y + rx * Math.sin(-ry * rad),
                    y2 = y + rx * Math.sin(-a * rad),
                    res = [['M', x1, y1], ['A', rx, rx, 0, +(a - ry > 180), 0, x2, y2]];
            } else {
                res = [
                    ['M', x, y],
                    ['m', 0, -ry],
                    ['a', rx, ry, 0, 1, 1, 0, 2 * ry],
                    ['a', rx, ry, 0, 1, 1, 0, -2 * ry],
                    ['z']
                ];
            }

            res.toString = toString;

            return res;
        }

        function pathToRelative(pathArray) {
            var pth = paths(pathArray),
                lowerCase = String.prototype.toLowerCase;

            if (pth.rel) {
                return pathClone(pth.rel);
            }

            if (!is(pathArray, 'array') || !is(pathArray && pathArray[0], 'array')) {
                pathArray = parsePathString(pathArray);
            }

            var res = [],
                x = 0,
                y = 0,
                mx = 0,
                my = 0,
                start = 0;

            if (pathArray[0][0] == 'M') {
                x = pathArray[0][1];
                y = pathArray[0][2];
                mx = x;
                my = y;
                start++;
                res.push(['M', x, y]);
            }

            for (var i = start, ii = pathArray.length; i < ii; i++) {
                var r = res[i] = [],
                    pa = pathArray[i];

                if (pa[0] != lowerCase.call(pa[0])) {
                    r[0] = lowerCase.call(pa[0]);

                    switch (r[0]) {
                        case 'a':
                            r[1] = pa[1];
                            r[2] = pa[2];
                            r[3] = pa[3];
                            r[4] = pa[4];
                            r[5] = pa[5];
                            r[6] = +(pa[6] - x).toFixed(3);
                            r[7] = +(pa[7] - y).toFixed(3);
                            break;
                        case 'v':
                            r[1] = +(pa[1] - y).toFixed(3);
                            break;
                        case 'm':
                            mx = pa[1];
                            my = pa[2];
                        default:
                            for (var j = 1, jj = pa.length; j < jj; j++) {
                                r[j] = +(pa[j] - ((j % 2) ? x : y)).toFixed(3);
                            }
                    }
                } else {
                    r = res[i] = [];

                    if (pa[0] == 'm') {
                        mx = pa[1] + x;
                        my = pa[2] + y;
                    }

                    for (var k = 0, kk = pa.length; k < kk; k++) {
                        res[i][k] = pa[k];
                    }
                }

                var len = res[i].length;

                switch (res[i][0]) {
                    case 'z':
                        x = mx;
                        y = my;
                        break;
                    case 'h':
                        x += +res[i][len - 1];
                        break;
                    case 'v':
                        y += +res[i][len - 1];
                        break;
                    default:
                        x += +res[i][len - 2];
                        y += +res[i][len - 1];
                }
            }

            res.toString = toString;
            pth.rel = pathClone(res);

            return res;
        }

        function pathToAbsolute(pathArray) {
            var pth = paths(pathArray);

            if (pth.abs) {
                return pathClone(pth.abs);
            }

            if (!is(pathArray, 'array') || !is(pathArray && pathArray[0], 'array')) { // rough assumption
                pathArray = parsePathString(pathArray);
            }

            if (!pathArray || !pathArray.length) {
                return [['M', 0, 0]];
            }

            var res = [],
                x = 0,
                y = 0,
                mx = 0,
                my = 0,
                start = 0,
                pa0;

            if (pathArray[0][0] == 'M') {
                x = +pathArray[0][1];
                y = +pathArray[0][2];
                mx = x;
                my = y;
                start++;
                res[0] = ['M', x, y];
            }

            var crz = pathArray.length == 3 &&
                pathArray[0][0] == 'M' &&
                pathArray[1][0].toUpperCase() == 'R' &&
                pathArray[2][0].toUpperCase() == 'Z';

            for (var r, pa, i = start, ii = pathArray.length; i < ii; i++) {
                res.push(r = []);
                pa = pathArray[i];
                pa0 = pa[0];

                if (pa0 != pa0.toUpperCase()) {
                    r[0] = pa0.toUpperCase();

                    switch (r[0]) {
                        case 'A':
                            r[1] = pa[1];
                            r[2] = pa[2];
                            r[3] = pa[3];
                            r[4] = pa[4];
                            r[5] = pa[5];
                            r[6] = +pa[6] + x;
                            r[7] = +pa[7] + y;
                            break;
                        case 'V':
                            r[1] = +pa[1] + y;
                            break;
                        case 'H':
                            r[1] = +pa[1] + x;
                            break;
                        case 'R':
                            var dots = [x, y].concat(pa.slice(1));

                            for (var j = 2, jj = dots.length; j < jj; j++) {
                                dots[j] = +dots[j] + x;
                                dots[++j] = +dots[j] + y;
                            }

                            res.pop();
                            res = res.concat(catmullRom2bezier(dots, crz));
                            break;
                        case 'O':
                            res.pop();
                            dots = ellipsePath(x, y, pa[1], pa[2]);
                            dots.push(dots[0]);
                            res = res.concat(dots);
                            break;
                        case 'U':
                            res.pop();
                            res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));
                            r = ['U'].concat(res[res.length - 1].slice(-2));
                            break;
                        case 'M':
                            mx = +pa[1] + x;
                            my = +pa[2] + y;
                        default:

                            for (j = 1, jj = pa.length; j < jj; j++) {
                                r[j] = +pa[j] + ((j % 2) ? x : y);
                            }
                    }
                } else if (pa0 == 'R') {
                    dots = [x, y].concat(pa.slice(1));
                    res.pop();
                    res = res.concat(catmullRom2bezier(dots, crz));
                    r = ['R'].concat(pa.slice(-2));
                } else if (pa0 == 'O') {
                    res.pop();
                    dots = ellipsePath(x, y, pa[1], pa[2]);
                    dots.push(dots[0]);
                    res = res.concat(dots);
                } else if (pa0 == 'U') {
                    res.pop();
                    res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));
                    r = ['U'].concat(res[res.length - 1].slice(-2));
                } else {

                    for (var k = 0, kk = pa.length; k < kk; k++) {
                        r[k] = pa[k];
                    }
                }
                pa0 = pa0.toUpperCase();

                if (pa0 != 'O') {
                    switch (r[0]) {
                        case 'Z':
                            x = +mx;
                            y = +my;
                            break;
                        case 'H':
                            x = r[1];
                            break;
                        case 'V':
                            y = r[1];
                            break;
                        case 'M':
                            mx = r[r.length - 2];
                            my = r[r.length - 1];
                        default:
                            x = r[r.length - 2];
                            y = r[r.length - 1];
                    }
                }
            }

            res.toString = toString;
            pth.abs = pathClone(res);

            return res;
        }

        function l2c(x1, y1, x2, y2) {
            return [x1, y1, x2, y2, x2, y2];
        }

        function q2c(x1, y1, ax, ay, x2, y2) {
            var _13 = 1 / 3,
                _23 = 2 / 3;

            return [
                _13 * x1 + _23 * ax,
                _13 * y1 + _23 * ay,
                _13 * x2 + _23 * ax,
                _13 * y2 + _23 * ay,
                x2,
                y2
            ];
        }

        function a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {

            // for more information of where this math came from visit:
            // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
            var _120 = PI * 120 / 180,
                rad = PI / 180 * (+angle || 0),
                res = [],
                xy,
                rotate = cacher(function (x, y, rad) {
                    var X = x * math.cos(rad) - y * math.sin(rad),
                        Y = x * math.sin(rad) + y * math.cos(rad);

                    return { x: X, y: Y };
                });

            if (!recursive) {
                xy = rotate(x1, y1, -rad);
                x1 = xy.x;
                y1 = xy.y;
                xy = rotate(x2, y2, -rad);
                x2 = xy.x;
                y2 = xy.y;

                var x = (x1 - x2) / 2,
                    y = (y1 - y2) / 2;

                var h = (x * x) / (rx * rx) + (y * y) / (ry * ry);

                if (h > 1) {
                    h = math.sqrt(h);
                    rx = h * rx;
                    ry = h * ry;
                }

                var rx2 = rx * rx,
                    ry2 = ry * ry,
                    k = (large_arc_flag == sweep_flag ? -1 : 1) *
                        math.sqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),
                    cx = k * rx * y / ry + (x1 + x2) / 2,
                    cy = k * -ry * x / rx + (y1 + y2) / 2,
                    f1 = math.asin(((y1 - cy) / ry).toFixed(9)),
                    f2 = math.asin(((y2 - cy) / ry).toFixed(9));

                f1 = x1 < cx ? PI - f1 : f1;
                f2 = x2 < cx ? PI - f2 : f2;
                f1 < 0 && (f1 = PI * 2 + f1);
                f2 < 0 && (f2 = PI * 2 + f2);

                if (sweep_flag && f1 > f2) {
                    f1 = f1 - PI * 2;
                }
                if (!sweep_flag && f2 > f1) {
                    f2 = f2 - PI * 2;
                }
            } else {
                f1 = recursive[0];
                f2 = recursive[1];
                cx = recursive[2];
                cy = recursive[3];
            }

            var df = f2 - f1;

            if (abs(df) > _120) {
                var f2old = f2,
                    x2old = x2,
                    y2old = y2;

                f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
                x2 = cx + rx * math.cos(f2);
                y2 = cy + ry * math.sin(f2);
                res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
            }

            df = f2 - f1;

            var c1 = math.cos(f1),
                s1 = math.sin(f1),
                c2 = math.cos(f2),
                s2 = math.sin(f2),
                t = math.tan(df / 4),
                hx = 4 / 3 * rx * t,
                hy = 4 / 3 * ry * t,
                m1 = [x1, y1],
                m2 = [x1 + hx * s1, y1 - hy * c1],
                m3 = [x2 + hx * s2, y2 - hy * c2],
                m4 = [x2, y2];

            m2[0] = 2 * m1[0] - m2[0];
            m2[1] = 2 * m1[1] - m2[1];

            if (recursive) {
                return [m2, m3, m4].concat(res);
            } else {
                res = [m2, m3, m4].concat(res).join().split(',');
                var newres = [];

                for (var i = 0, ii = res.length; i < ii; i++) {
                    newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;
                }

                return newres;
            }
        }

        // Returns bounding box of cubic bezier curve.
        // Source: http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html
        // Original version: NISHIO Hirokazu
        // Modifications: https://github.com/timo22345
        function curveDim(x0, y0, x1, y1, x2, y2, x3, y3) {
            var tvalues = [],
                bounds = [[], []],
                a, b, c, t, t1, t2, b2ac, sqrtb2ac;

            for (var i = 0; i < 2; ++i) {

                if (i == 0) {
                    b = 6 * x0 - 12 * x1 + 6 * x2;
                    a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
                    c = 3 * x1 - 3 * x0;
                } else {
                    b = 6 * y0 - 12 * y1 + 6 * y2;
                    a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
                    c = 3 * y1 - 3 * y0;
                }

                if (abs(a) < 1e-12) {

                    if (abs(b) < 1e-12) {
                        continue;
                    }

                    t = -c / b;

                    if (0 < t && t < 1) {
                        tvalues.push(t);
                    }

                    continue;
                }

                b2ac = b * b - 4 * c * a;
                sqrtb2ac = math.sqrt(b2ac);

                if (b2ac < 0) {
                    continue;
                }

                t1 = (-b + sqrtb2ac) / (2 * a);

                if (0 < t1 && t1 < 1) {
                    tvalues.push(t1);
                }

                t2 = (-b - sqrtb2ac) / (2 * a);

                if (0 < t2 && t2 < 1) {
                    tvalues.push(t2);
                }
            }

            var j = tvalues.length,
                jlen = j,
                mt;

            while (j--) {
                t = tvalues[j];
                mt = 1 - t;
                bounds[0][j] = (mt * mt * mt * x0) + (3 * mt * mt * t * x1) + (3 * mt * t * t * x2) + (t * t * t * x3);
                bounds[1][j] = (mt * mt * mt * y0) + (3 * mt * mt * t * y1) + (3 * mt * t * t * y2) + (t * t * t * y3);
            }

            bounds[0][jlen] = x0;
            bounds[1][jlen] = y0;
            bounds[0][jlen + 1] = x3;
            bounds[1][jlen + 1] = y3;
            bounds[0].length = bounds[1].length = jlen + 2;

            return {
                min: { x: mmin.apply(0, bounds[0]), y: mmin.apply(0, bounds[1]) },
                max: { x: mmax.apply(0, bounds[0]), y: mmax.apply(0, bounds[1]) }
            };
        }

        function path2curve(path, path2) {
            var pth = !path2 && paths(path);

            if (!path2 && pth.curve) {
                return pathClone(pth.curve);
            }

            var p = pathToAbsolute(path),
                p2 = path2 && pathToAbsolute(path2),
                attrs = { x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null },
                attrs2 = { x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null },
                processPath = function (path, d, pcom) {
                    var nx, ny;

                    if (!path) {
                        return ['C', d.x, d.y, d.x, d.y, d.x, d.y];
                    }

                    !(path[0] in { T: 1, Q: 1 }) && (d.qx = d.qy = null);

                    switch (path[0]) {
                        case 'M':
                            d.X = path[1];
                            d.Y = path[2];
                            break;
                        case 'A':
                            path = ['C'].concat(a2c.apply(0, [d.x, d.y].concat(path.slice(1))));
                            break;
                        case 'S':
                            if (pcom == 'C' || pcom == 'S') { // In 'S' case we have to take into account, if the previous command is C/S.
                                nx = d.x * 2 - d.bx;          // And reflect the previous
                                ny = d.y * 2 - d.by;          // command's control point relative to the current point.
                            }
                            else {                            // or some else or nothing
                                nx = d.x;
                                ny = d.y;
                            }
                            path = ['C', nx, ny].concat(path.slice(1));
                            break;
                        case 'T':
                            if (pcom == 'Q' || pcom == 'T') { // In 'T' case we have to take into account, if the previous command is Q/T.
                                d.qx = d.x * 2 - d.qx;        // And make a reflection similar
                                d.qy = d.y * 2 - d.qy;        // to case 'S'.
                            }
                            else {                            // or something else or nothing
                                d.qx = d.x;
                                d.qy = d.y;
                            }
                            path = ['C'].concat(q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));
                            break;
                        case 'Q':
                            d.qx = path[1];
                            d.qy = path[2];
                            path = ['C'].concat(q2c(d.x, d.y, path[1], path[2], path[3], path[4]));
                            break;
                        case 'L':
                            path = ['C'].concat(l2c(d.x, d.y, path[1], path[2]));
                            break;
                        case 'H':
                            path = ['C'].concat(l2c(d.x, d.y, path[1], d.y));
                            break;
                        case 'V':
                            path = ['C'].concat(l2c(d.x, d.y, d.x, path[1]));
                            break;
                        case 'Z':
                            path = ['C'].concat(l2c(d.x, d.y, d.X, d.Y));
                            break;
                    }

                    return path;
                },

                fixArc = function (pp, i) {

                    if (pp[i].length > 7) {
                        pp[i].shift();
                        var pi = pp[i];

                        while (pi.length) {
                            pcoms1[i] = 'A'; // if created multiple C:s, their original seg is saved
                            p2 && (pcoms2[i] = 'A'); // the same as above
                            pp.splice(i++, 0, ['C'].concat(pi.splice(0, 6)));
                        }

                        pp.splice(i, 1);
                        ii = mmax(p.length, p2 && p2.length || 0);
                    }
                },

                fixM = function (path1, path2, a1, a2, i) {

                    if (path1 && path2 && path1[i][0] == 'M' && path2[i][0] != 'M') {
                        path2.splice(i, 0, ['M', a2.x, a2.y]);
                        a1.bx = 0;
                        a1.by = 0;
                        a1.x = path1[i][1];
                        a1.y = path1[i][2];
                        ii = mmax(p.length, p2 && p2.length || 0);
                    }
                },

                pcoms1 = [], // path commands of original path p
                pcoms2 = [], // path commands of original path p2
                pfirst = '', // temporary holder for original path command
                pcom = ''; // holder for previous path command of original path

            for (var i = 0, ii = mmax(p.length, p2 && p2.length || 0); i < ii; i++) {
                p[i] && (pfirst = p[i][0]); // save current path command

                if (pfirst != 'C') // C is not saved yet, because it may be result of conversion
                {
                    pcoms1[i] = pfirst; // Save current path command
                    i && (pcom = pcoms1[i - 1]); // Get previous path command pcom
                }
                p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath

                if (pcoms1[i] != 'A' && pfirst == 'C') pcoms1[i] = 'C'; // A is the only command
                // which may produce multiple C:s
                // so we have to make sure that C is also C in original path

                fixArc(p, i); // fixArc adds also the right amount of A:s to pcoms1

                if (p2) { // the same procedures is done to p2
                    p2[i] && (pfirst = p2[i][0]);

                    if (pfirst != 'C') {
                        pcoms2[i] = pfirst;
                        i && (pcom = pcoms2[i - 1]);
                    }

                    p2[i] = processPath(p2[i], attrs2, pcom);

                    if (pcoms2[i] != 'A' && pfirst == 'C') {
                        pcoms2[i] = 'C';
                    }

                    fixArc(p2, i);
                }

                fixM(p, p2, attrs, attrs2, i);
                fixM(p2, p, attrs2, attrs, i);

                var seg = p[i],
                    seg2 = p2 && p2[i],
                    seglen = seg.length,
                    seg2len = p2 && seg2.length;

                attrs.x = seg[seglen - 2];
                attrs.y = seg[seglen - 1];
                attrs.bx = toFloat(seg[seglen - 4]) || attrs.x;
                attrs.by = toFloat(seg[seglen - 3]) || attrs.y;
                attrs2.bx = p2 && (toFloat(seg2[seg2len - 4]) || attrs2.x);
                attrs2.by = p2 && (toFloat(seg2[seg2len - 3]) || attrs2.y);
                attrs2.x = p2 && seg2[seg2len - 2];
                attrs2.y = p2 && seg2[seg2len - 1];
            }

            if (!p2) {
                pth.curve = pathClone(p);
            }

            return p2 ? [p, p2] : p;
        }

        function mapPath(path, matrix) {

            if (!matrix) {
                return path;
            }

            var x, y, i, j, ii, jj, pathi;
            path = path2curve(path);

            for (i = 0, ii = path.length; i < ii; i++) {
                pathi = path[i];

                for (j = 1, jj = pathi.length; j < jj; j += 2) {
                    x = matrix.x(pathi[j], pathi[j + 1]);
                    y = matrix.y(pathi[j], pathi[j + 1]);
                    pathi[j] = x;
                    pathi[j + 1] = y;
                }
            }

            return path;
        }

        // http://schepers.cc/getting-to-the-point
        function catmullRom2bezier(crp, z) {
            var d = [];

            for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {
                var p = [
                    { x: +crp[i - 2], y: +crp[i - 1] },
                    { x: +crp[i], y: +crp[i + 1] },
                    { x: +crp[i + 2], y: +crp[i + 3] },
                    { x: +crp[i + 4], y: +crp[i + 5] }
                ];

                if (z) {

                    if (!i) {
                        p[0] = { x: +crp[iLen - 2], y: +crp[iLen - 1] };
                    } else if (iLen - 4 == i) {
                        p[3] = { x: +crp[0], y: +crp[1] };
                    } else if (iLen - 2 == i) {
                        p[2] = { x: +crp[0], y: +crp[1] };
                        p[3] = { x: +crp[2], y: +crp[3] };
                    }

                } else {

                    if (iLen - 4 == i) {
                        p[3] = p[2];
                    } else if (!i) {
                        p[0] = { x: +crp[i], y: +crp[i + 1] };
                    }

                }

                d.push(['C',
                    (-p[0].x + 6 * p[1].x + p[2].x) / 6,
                    (-p[0].y + 6 * p[1].y + p[2].y) / 6,
                    (p[1].x + 6 * p[2].x - p[3].x) / 6,
                    (p[1].y + 6 * p[2].y - p[3].y) / 6,
                    p[2].x,
                    p[2].y
                ]);
            }

            return d;
        }

        paths.getTotalLength = getTotalLength;
        paths.getPointAtLength = getPointAtLength;
        paths.findDotsAtSegment = findDotsAtSegment;
        paths.bezierBBox = bezierBBox;
        paths.isPointInsideBBox = isPointInsideBBox;
        paths.isBBoxIntersect = isBBoxIntersect;
        paths.intersection = pathIntersection;
        paths.intersectionNumber = pathIntersectionNumber;
        paths.isPointInside = isPointInsidePath;
        paths.getBBox = pathBBox;
        paths.toRelative = pathToRelative;
        paths.toAbsolute = pathToAbsolute;
        paths.toCubic = path2curve;
        paths.map = mapPath;
        paths.toString = toString;
        paths.clone = pathClone;

        module.exports.intersection = pathIntersection;

    }, {}], 272: [function (require, module, exports) {
        'use strict';

        var pointDistance = require('./Geometry').pointDistance;

        var intersection = require('./Intersection').intersection;

        var round = Math.round,
            max = Math.max;


        function circlePath(center, r) {
            var x = center.x,
                y = center.y;

            return [
                ['M', x, y],
                ['m', 0, -r],
                ['a', r, r, 0, 1, 1, 0, 2 * r],
                ['a', r, r, 0, 1, 1, 0, -2 * r],
                ['z']
            ];
        }

        function linePath(points) {
            var segments = [];

            points.forEach(function (p, idx) {
                segments.push([idx === 0 ? 'M' : 'L', p.x, p.y]);
            });

            return segments;
        }


        var INTERSECTION_THRESHOLD = 10;

        function getBendpointIntersection(waypoints, reference) {

            var i, w;

            for (i = 0; (w = waypoints[i]); i++) {

                if (pointDistance(w, reference) <= INTERSECTION_THRESHOLD) {
                    return {
                        point: waypoints[i],
                        bendpoint: true,
                        index: i
                    };
                }
            }

            return null;
        }

        function getPathIntersection(waypoints, reference) {

            var intersections = intersection(circlePath(reference, INTERSECTION_THRESHOLD), linePath(waypoints));

            var a = intersections[0],
                b = intersections[intersections.length - 1],
                idx;

            if (!a) {
                // no intersection
                return null;
            }

            if (a !== b) {

                if (a.segment2 !== b.segment2) {
                    // we use the bendpoint in between both segments
                    // as the intersection point

                    idx = max(a.segment2, b.segment2) - 1;

                    return {
                        point: waypoints[idx],
                        bendpoint: true,
                        index: idx
                    };
                }

                return {
                    point: {
                        x: (round(a.x + b.x) / 2),
                        y: (round(a.y + b.y) / 2)
                    },
                    index: a.segment2
                };
            }

            return {
                point: {
                    x: round(a.x),
                    y: round(a.y)
                },
                index: a.segment2
            };
        }

        /**
         * Returns the closest point on the connection towards a given reference point.
         *
         * @param  {Array<Point>} waypoints
         * @param  {Point} reference
         *
         * @return {Object} intersection data (segment, point)
         */
        module.exports.getApproxIntersection = function (waypoints, reference) {
            return getBendpointIntersection(waypoints, reference) || getPathIntersection(waypoints, reference);
        };

    }, { "./Geometry": 268, "./Intersection": 271 }], 273: [function (require, module, exports) {
        'use strict';

        /**
         * Get the logarithm of x with base 10
         * @param  {Integer} value
         */
        function log10(x) {
            return Math.log(x) / Math.log(10);
        }

        module.exports.log10 = log10;


        function substract(p1, p2) {
            return {
                x: p1.x - p2.x,
                y: p1.y - p2.y
            };
        }

        module.exports.substract = substract;

    }, {}], 274: [function (require, module, exports) {
        'use strict';

        var getOriginalEvent = require('./Event').getOriginal;

        var isMac = require('./Platform').isMac;


        function isPrimaryButton(event) {
            // button === 0 -> left ka primary mouse button
            return !(getOriginalEvent(event) || event).button;
        }

        module.exports.isPrimaryButton = isPrimaryButton;

        module.exports.isMac = isMac;

        module.exports.hasPrimaryModifier = function (event) {
            var originalEvent = getOriginalEvent(event) || event;

            if (!isPrimaryButton(event)) {
                return false;
            }

            // Use alt as primary modifier key for mac OS
            if (isMac()) {
                return originalEvent.metaKey;
            } else {
                return originalEvent.ctrlKey;
            }
        };


        module.exports.hasSecondaryModifier = function (event) {
            var originalEvent = getOriginalEvent(event) || event;

            return isPrimaryButton(event) && originalEvent.shiftKey;
        };

    }, { "./Event": 267, "./Platform": 275 }], 275: [function (require, module, exports) {
        'use strict';

        module.exports.isMac = function isMac() {
            return (/mac/i).test(navigator.platform);
        };
    }, {}], 276: [function (require, module, exports) {
        'use strict';

        function center(bounds) {
            return {
                x: bounds.x + (bounds.width / 2),
                y: bounds.y + (bounds.height / 2)
            };
        }

        module.exports.center = center;


        function delta(a, b) {
            return {
                x: a.x - b.x,
                y: a.y - b.y
            };
        }

        module.exports.delta = delta;

    }, {}], 277: [function (require, module, exports) {
        'use strict';


        /**
         * Remove from the beginning of a collection until it is empty.
         *
         * This is a null-safe operation that ensures elements
         * are being removed from the given collection until the
         * collection is empty.
         *
         * The implementation deals with the fact that a remove operation
         * may touch, i.e. remove multiple elements in the collection
         * at a time.
         *
         * @param {Array<Object>} [collection]
         * @param {Function} removeFn
         *
         * @return {Array<Object>} the cleared collection
         */
        module.exports.saveClear = function (collection, removeFn) {

            if (typeof removeFn !== 'function') {
                throw new Error('removeFn iterator must be a function');
            }

            if (!collection) {
                return;
            }

            var e;

            while ((e = collection[0])) {
                removeFn(e);
            }

            return collection;
        };

    }, {}], 278: [function (require, module, exports) {
        'use strict';

        var svgAttr = require('tiny-svg/lib/attr'),
            svgCreate = require('tiny-svg/lib/create');


        module.exports.componentsToPath = function (elements) {
            return elements.join(',').replace(/,?([A-z]),?/g, '$1');
        };

        function toSVGPoints(points) {
            var result = '';

            for (var i = 0, p; (p = points[i]); i++) {
                result += p.x + ',' + p.y + ' ';
            }

            return result;
        }

        module.exports.toSVGPoints = toSVGPoints;

        module.exports.createLine = function (points, attrs) {

            var line = svgCreate('polyline');
            svgAttr(line, { points: toSVGPoints(points) });

            if (attrs) {
                svgAttr(line, attrs);
            }

            return line;
        };

        module.exports.updateLine = function (gfx, points) {
            svgAttr(gfx, { points: toSVGPoints(points) });

            return gfx;
        };

    }, { "tiny-svg/lib/attr": 475, "tiny-svg/lib/create": 479 }], 279: [function (require, module, exports) {
        'use strict';

        var svgTransform = require('tiny-svg/lib/transform');

        var createTransform = require('tiny-svg/lib/geometry').createTransform;


        /**
         * @param {<SVGElement>} element
         * @param {Number} x
         * @param {Number} y
         * @param {Number} angle
         * @param {Number} amount
         */
        module.exports.transform = function (gfx, x, y, angle, amount) {
            var translate = createTransform();
            translate.setTranslate(x, y);

            var rotate = createTransform();
            rotate.setRotate(angle, 0, 0);

            var scale = createTransform();
            scale.setScale(amount || 1, amount || 1);

            svgTransform(gfx, [translate, rotate, scale]);
        };


        /**
         * @param {SVGElement} element
         * @param {Number} x
         * @param {Number} y
         */
        module.exports.translate = function (gfx, x, y) {
            var translate = createTransform();
            translate.setTranslate(x, y);

            svgTransform(gfx, translate);
        };


        /**
         * @param {SVGElement} element
         * @param {Number} angle
         */
        module.exports.rotate = function (gfx, angle) {
            var rotate = createTransform();
            rotate.setRotate(angle, 0, 0);

            svgTransform(gfx, rotate);
        };


        /**
         * @param {SVGElement} element
         * @param {Number} amount
         */
        module.exports.scale = function (gfx, amount) {
            var scale = createTransform();
            scale.setScale(amount, amount);

            svgTransform(gfx, scale);
        };

    }, { "tiny-svg/lib/geometry": 480, "tiny-svg/lib/transform": 483 }], 280: [function (require, module, exports) {
        'use strict';

        var isObject = require('lodash/lang/isObject'),
            assign = require('lodash/object/assign'),
            pick = require('lodash/object/pick'),
            forEach = require('lodash/collection/forEach'),
            reduce = require('lodash/collection/reduce'),
            merge = require('lodash/object/merge');

        var svgAppend = require('tiny-svg/lib/append'),
            svgAttr = require('tiny-svg/lib/attr'),
            svgCreate = require('tiny-svg/lib/create'),
            svgRemove = require('tiny-svg/lib/remove');

        var DEFAULT_BOX_PADDING = 0;

        var DEFAULT_LABEL_SIZE = {
            width: 150,
            height: 50
        };


        function parseAlign(align) {

            var parts = align.split('-');

            return {
                horizontal: parts[0] || 'center',
                vertical: parts[1] || 'top'
            };
        }

        function parsePadding(padding) {

            if (isObject(padding)) {
                return assign({ top: 0, left: 0, right: 0, bottom: 0 }, padding);
            } else {
                return {
                    top: padding,
                    left: padding,
                    right: padding,
                    bottom: padding
                };
            }
        }

        function getTextBBox(text, fakeText) {

            fakeText.textContent = text;

            try {
                var bbox,
                    emptyLine = text === '';

                // add dummy text, when line is empty to determine correct height
                fakeText.textContent = emptyLine ? 'dummy' : text;

                bbox = pick(fakeText.getBBox(), ['width', 'height']);

                if (emptyLine) {
                    // correct width
                    bbox.width = 0;
                }

                return bbox;
            } catch (e) {
                return { width: 0, height: 0 };
            }
        }


        /**
         * Layout the next line and return the layouted element.
         *
         * Alters the lines passed.
         *
         * @param  {Array<String>} lines
         * @return {Object} the line descriptor, an object { width, height, text }
         */
        function layoutNext(lines, maxWidth, fakeText) {

            var originalLine = lines.shift(),
                fitLine = originalLine;

            var textBBox;

            for (; ;) {
                textBBox = getTextBBox(fitLine, fakeText);

                textBBox.width = fitLine ? textBBox.width : 0;

                // try to fit
                if (fitLine === ' ' || fitLine === '' || textBBox.width < Math.round(maxWidth) || fitLine.length < 4) {
                    return fit(lines, fitLine, originalLine, textBBox);
                }

                fitLine = shortenLine(fitLine, textBBox.width, maxWidth);
            }
        }

        function fit(lines, fitLine, originalLine, textBBox) {
            if (fitLine.length < originalLine.length) {
                var nextLine = lines[0] || '',
                    remainder = originalLine.slice(fitLine.length).trim();

                if (/-\s*$/.test(remainder)) {
                    nextLine = remainder + nextLine.replace(/^\s+/, '');
                } else {
                    nextLine = remainder + ' ' + nextLine;
                }

                lines[0] = nextLine;
            }
            return { width: textBBox.width, height: textBBox.height, text: fitLine };
        }


        /**
         * Shortens a line based on spacing and hyphens.
         * Returns the shortened result on success.
         *
         * @param  {String} line
         * @param  {Number} maxLength the maximum characters of the string
         * @return {String} the shortened string
         */
        function semanticShorten(line, maxLength) {
            var parts = line.split(/(\s|-)/g),
                part,
                shortenedParts = [],
                length = 0;

            // try to shorten via spaces + hyphens
            if (parts.length > 1) {
                while ((part = parts.shift())) {
                    if (part.length + length < maxLength) {
                        shortenedParts.push(part);
                        length += part.length;
                    } else {
                        // remove previous part, too if hyphen does not fit anymore
                        if (part === '-') {
                            shortenedParts.pop();
                        }

                        break;
                    }
                }
            }

            return shortenedParts.join('');
        }


        function shortenLine(line, width, maxWidth) {
            var length = Math.max(line.length * (maxWidth / width), 1);

            // try to shorten semantically (i.e. based on spaces and hyphens)
            var shortenedLine = semanticShorten(line, length);

            if (!shortenedLine) {

                // force shorten by cutting the long word
                shortenedLine = line.slice(0, Math.max(Math.round(length - 1), 1));
            }

            return shortenedLine;
        }


        function getHelperSvg() {
            var helperSvg = document.getElementById('helper-svg');

            if (!helperSvg) {
                helperSvg = svgCreate('svg');

                svgAttr(helperSvg, {
                    id: 'helper-svg',
                    width: 0,
                    height: 0,
                    style: 'visibility: hidden; position: fixed'
                });

                document.body.appendChild(helperSvg);
            }

            return helperSvg;
        }


        /**
         * Creates a new label utility
         *
         * @param {Object} config
         * @param {Dimensions} config.size
         * @param {Number} config.padding
         * @param {Object} config.style
         * @param {String} config.align
         */
        function Text(config) {

            this._config = assign({}, {
                size: DEFAULT_LABEL_SIZE,
                padding: DEFAULT_BOX_PADDING,
                style: {},
                align: 'center-top'
            }, config || {});
        }

        /**
         * Returns the layouted text as an SVG element.
         *
         * @param {String} text
         * @param {Object} options
         *
         * @return {SVGText}
         */
        Text.prototype.createText = function (text, options) {
            return this.layoutText(text, options).element;
        };

        /**
         * Returns a labels layouted dimensions.
         *
         * @param {String} text to layout
         * @param {Object} options
         *
         * @return {Dimensions}
         */
        Text.prototype.getDimensions = function (text, options) {
            return this.layoutText(text, options).dimensions;
        };

        /**
         * Creates and returns a label and its bounding box.
         *
         * @method Text#createText
         *
         * @param {String} text the text to render on the label
         * @param {Object} options
         * @param {String} options.align how to align in the bounding box.
         *                               Any of { 'center-middle', 'center-top' },
         *                               defaults to 'center-top'.
         * @param {String} options.style style to be applied to the text
         * @param {boolean} options.fitBox indicates if box will be recalculated to
         *                                 fit text
         *
         * @return {Object} { element, dimensions }
         */
        Text.prototype.layoutText = function (text, options) {
            var box = merge({}, this._config.size, options.box || {}),
                style = merge({}, this._config.style, options.style || {}),
                align = parseAlign(options.align || this._config.align),
                padding = parsePadding(options.padding !== undefined ? options.padding : this._config.padding),
                fitBox = options.fitBox || false;

            var lines = text.split(/\r?\n/g),
                layouted = [];

            var maxWidth = box.width - padding.left - padding.right;

            // ensure correct rendering by attaching helper text node to invisible SVG
            var helperText = svgCreate('text');
            svgAttr(helperText, { x: 0, y: 0 });
            svgAttr(helperText, style);

            var helperSvg = getHelperSvg();

            svgAppend(helperSvg, helperText);

            while (lines.length) {
                layouted.push(layoutNext(lines, maxWidth, helperText));
            }

            var totalHeight = reduce(layouted, function (sum, line, idx) {
                return sum + line.height;
            }, 0);

            var maxLineWidth = reduce(layouted, function (sum, line, idx) {
                return line.width > sum ? line.width : sum;
            }, 0);

            // the y position of the next line
            var y, x;

            switch (align.vertical) {
                case 'middle':
                    y = (box.height - totalHeight) / 2 - layouted[0].height / 4;
                    break;

                default:
                    y = padding.top;
            }

            var textElement = svgCreate('text');

            svgAttr(textElement, style);

            // layout each line taking into account that parent
            // shape might resize to fit text size
            forEach(layouted, function (line) {
                y += line.height;

                switch (align.horizontal) {
                    case 'left':
                        x = padding.left;
                        break;

                    case 'right':
                        x = ((fitBox ? maxLineWidth : maxWidth)
                            - padding.right - line.width);
                        break;

                    default:
                        // aka center
                        x = Math.max((((fitBox ? maxLineWidth : maxWidth)
                            - line.width) / 2 + padding.left), 0);
                }

                var tspan = svgCreate('tspan');
                svgAttr(tspan, { x: x, y: y });

                tspan.textContent = line.text;

                svgAppend(textElement, tspan);
            });

            svgRemove(helperText);

            var dimensions = {
                width: maxLineWidth,
                height: totalHeight
            };

            return {
                dimensions: dimensions,
                element: textElement
            };
        };

        module.exports = Text;

    }, { "lodash/collection/forEach": 304, "lodash/collection/reduce": 307, "lodash/lang/isObject": 428, "lodash/object/assign": 433, "lodash/object/merge": 437, "lodash/object/pick": 440, "tiny-svg/lib/append": 473, "tiny-svg/lib/attr": 475, "tiny-svg/lib/create": 479, "tiny-svg/lib/remove": 482 }], 281: [function (require, module, exports) {

        var isArray = function (obj) {
            return Object.prototype.toString.call(obj) === '[object Array]';
        };

        var annotate = function () {
            var args = Array.prototype.slice.call(arguments);

            if (args.length === 1 && isArray(args[0])) {
                args = args[0];
            }

            var fn = args.pop();

            fn.$inject = args;

            return fn;
        };


        // Current limitations:
        // - can't put into "function arg" comments
        // function /* (no parenthesis like this) */ (){}
        // function abc( /* xx (no parenthesis like this) */ a, b) {}
        //
        // Just put the comment before function or inside:
        // /* (((this is fine))) */ function(a, b) {}
        // function abc(a) { /* (((this is fine))) */}

        var FN_ARGS = /^function\s*[^\(]*\(\s*([^\)]*)\)/m;
        var FN_ARG = /\/\*([^\*]*)\*\//m;

        var parse = function (fn) {
            if (typeof fn !== 'function') {
                throw new Error('Cannot annotate "' + fn + '". Expected a function!');
            }

            var match = fn.toString().match(FN_ARGS);
            return match[1] && match[1].split(',').map(function (arg) {
                match = arg.match(FN_ARG);
                return match ? match[1].trim() : arg.trim();
            }) || [];
        };


        exports.annotate = annotate;
        exports.parse = parse;
        exports.isArray = isArray;

    }, {}], 282: [function (require, module, exports) {
        module.exports = {
            annotate: require('./annotation').annotate,
            Module: require('./module'),
            Injector: require('./injector')
        };

    }, { "./annotation": 281, "./injector": 283, "./module": 284 }], 283: [function (require, module, exports) {
        var Module = require('./module');
        var autoAnnotate = require('./annotation').parse;
        var annotate = require('./annotation').annotate;
        var isArray = require('./annotation').isArray;


        var Injector = function (modules, parent) {
            parent = parent || {
                get: function (name, strict) {
                    currentlyResolving.push(name);

                    if (strict === false) {
                        return null;
                    } else {
                        throw error('No provider for "' + name + '"!');
                    }
                }
            };

            var currentlyResolving = [];
            var providers = this._providers = Object.create(parent._providers || null);
            var instances = this._instances = Object.create(null);

            var self = instances.injector = this;

            var error = function (msg) {
                var stack = currentlyResolving.join(' -> ');
                currentlyResolving.length = 0;
                return new Error(stack ? msg + ' (Resolving: ' + stack + ')' : msg);
            };

            /**
             * Return a named service.
             *
             * @param {String} name
             * @param {Boolean} [strict=true] if false, resolve missing services to null
             *
             * @return {Object}
             */
            var get = function (name, strict) {
                if (!providers[name] && name.indexOf('.') !== -1) {
                    var parts = name.split('.');
                    var pivot = get(parts.shift());

                    while (parts.length) {
                        pivot = pivot[parts.shift()];
                    }

                    return pivot;
                }

                if (Object.hasOwnProperty.call(instances, name)) {
                    return instances[name];
                }

                if (Object.hasOwnProperty.call(providers, name)) {
                    if (currentlyResolving.indexOf(name) !== -1) {
                        currentlyResolving.push(name);
                        throw error('Cannot resolve circular dependency!');
                    }

                    currentlyResolving.push(name);
                    instances[name] = providers[name][0](providers[name][1]);
                    currentlyResolving.pop();

                    return instances[name];
                }

                return parent.get(name, strict);
            };

            var instantiate = function (Type) {
                var instance = Object.create(Type.prototype);
                var returned = invoke(Type, instance);

                return typeof returned === 'object' ? returned : instance;
            };

            var invoke = function (fn, context) {
                if (typeof fn !== 'function') {
                    if (isArray(fn)) {
                        fn = annotate(fn.slice());
                    } else {
                        throw new Error('Cannot invoke "' + fn + '". Expected a function!');
                    }
                }

                var inject = fn.$inject && fn.$inject || autoAnnotate(fn);
                var dependencies = inject.map(function (dep) {
                    return get(dep);
                });

                // TODO(vojta): optimize without apply
                return fn.apply(context, dependencies);
            };


            var createPrivateInjectorFactory = function (privateChildInjector) {
                return annotate(function (key) {
                    return privateChildInjector.get(key);
                });
            };

            var createChild = function (modules, forceNewInstances) {
                if (forceNewInstances && forceNewInstances.length) {
                    var fromParentModule = Object.create(null);
                    var matchedScopes = Object.create(null);

                    var privateInjectorsCache = [];
                    var privateChildInjectors = [];
                    var privateChildFactories = [];

                    var provider;
                    var cacheIdx;
                    var privateChildInjector;
                    var privateChildInjectorFactory;
                    for (var name in providers) {
                        provider = providers[name];

                        if (forceNewInstances.indexOf(name) !== -1) {
                            if (provider[2] === 'private') {
                                cacheIdx = privateInjectorsCache.indexOf(provider[3]);
                                if (cacheIdx === -1) {
                                    privateChildInjector = provider[3].createChild([], forceNewInstances);
                                    privateChildInjectorFactory = createPrivateInjectorFactory(privateChildInjector);
                                    privateInjectorsCache.push(provider[3]);
                                    privateChildInjectors.push(privateChildInjector);
                                    privateChildFactories.push(privateChildInjectorFactory);
                                    fromParentModule[name] = [privateChildInjectorFactory, name, 'private', privateChildInjector];
                                } else {
                                    fromParentModule[name] = [privateChildFactories[cacheIdx], name, 'private', privateChildInjectors[cacheIdx]];
                                }
                            } else {
                                fromParentModule[name] = [provider[2], provider[1]];
                            }
                            matchedScopes[name] = true;
                        }

                        if ((provider[2] === 'factory' || provider[2] === 'type') && provider[1].$scope) {
                            /*jshint -W083 */
                            forceNewInstances.forEach(function (scope) {
                                if (provider[1].$scope.indexOf(scope) !== -1) {
                                    fromParentModule[name] = [provider[2], provider[1]];
                                    matchedScopes[scope] = true;
                                }
                            });
                        }
                    }

                    forceNewInstances.forEach(function (scope) {
                        if (!matchedScopes[scope]) {
                            throw new Error('No provider for "' + scope + '". Cannot use provider from the parent!');
                        }
                    });

                    modules.unshift(fromParentModule);
                }

                return new Injector(modules, self);
            };

            var factoryMap = {
                factory: invoke,
                type: instantiate,
                value: function (value) {
                    return value;
                }
            };

            modules.forEach(function (module) {

                function arrayUnwrap(type, value) {
                    if (type !== 'value' && isArray(value)) {
                        value = annotate(value.slice());
                    }

                    return value;
                }

                // TODO(vojta): handle wrong inputs (modules)
                if (module instanceof Module) {
                    module.forEach(function (provider) {
                        var name = provider[0];
                        var type = provider[1];
                        var value = provider[2];

                        providers[name] = [factoryMap[type], arrayUnwrap(type, value), type];
                    });
                } else if (typeof module === 'object') {
                    if (module.__exports__) {
                        var clonedModule = Object.keys(module).reduce(function (m, key) {
                            if (key.substring(0, 2) !== '__') {
                                m[key] = module[key];
                            }
                            return m;
                        }, Object.create(null));

                        var privateInjector = new Injector((module.__modules__ || []).concat([clonedModule]), self);
                        var getFromPrivateInjector = annotate(function (key) {
                            return privateInjector.get(key);
                        });
                        module.__exports__.forEach(function (key) {
                            providers[key] = [getFromPrivateInjector, key, 'private', privateInjector];
                        });
                    } else {
                        Object.keys(module).forEach(function (name) {
                            if (module[name][2] === 'private') {
                                providers[name] = module[name];
                                return;
                            }

                            var type = module[name][0];
                            var value = module[name][1];

                            providers[name] = [factoryMap[type], arrayUnwrap(type, value), type];
                        });
                    }
                }
            });

            // public API
            this.get = get;
            this.invoke = invoke;
            this.instantiate = instantiate;
            this.createChild = createChild;
        };

        module.exports = Injector;

    }, { "./annotation": 281, "./module": 284 }], 284: [function (require, module, exports) {
        var Module = function () {
            var providers = [];

            this.factory = function (name, factory) {
                providers.push([name, 'factory', factory]);
                return this;
            };

            this.value = function (name, value) {
                providers.push([name, 'value', value]);
                return this;
            };

            this.type = function (name, type) {
                providers.push([name, 'type', type]);
                return this;
            };

            this.forEach = function (iterator) {
                providers.forEach(iterator);
            };
        };

        module.exports = Module;

    }, {}], 285: [function (require, module, exports) {

        /**
         * Expose `parse`.
         */

        module.exports = parse;

        /**
         * Tests for browser support.
         */

        var innerHTMLBug = false;
        var bugTestDiv;
        if (typeof document !== 'undefined') {
            bugTestDiv = document.createElement('div');
            // Setup
            bugTestDiv.innerHTML = '  <link/><table></table><a href="/a">a</a><input type="checkbox"/>';
            // Make sure that link elements get serialized correctly by innerHTML
            // This requires a wrapper element in IE
            innerHTMLBug = !bugTestDiv.getElementsByTagName('link').length;
            bugTestDiv = undefined;
        }

        /**
         * Wrap map from jquery.
         */

        var map = {
            legend: [1, '<fieldset>', '</fieldset>'],
            tr: [2, '<table><tbody>', '</tbody></table>'],
            col: [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
            // for script/link/style tags to work in IE6-8, you have to wrap
            // in a div with a non-whitespace character in front, ha!
            _default: innerHTMLBug ? [1, 'X<div>', '</div>'] : [0, '', '']
        };

        map.td =
            map.th = [3, '<table><tbody><tr>', '</tr></tbody></table>'];

        map.option =
            map.optgroup = [1, '<select multiple="multiple">', '</select>'];

        map.thead =
            map.tbody =
            map.colgroup =
            map.caption =
            map.tfoot = [1, '<table>', '</table>'];

        map.polyline =
            map.ellipse =
            map.polygon =
            map.circle =
            map.text =
            map.line =
            map.path =
            map.rect =
            map.g = [1, '<svg xmlns="http://www.w3.org/2000/svg" version="1.1">', '</svg>'];

        /**
         * Parse `html` and return a DOM Node instance, which could be a TextNode,
         * HTML DOM Node of some kind (<div> for example), or a DocumentFragment
         * instance, depending on the contents of the `html` string.
         *
         * @param {String} html - HTML string to "domify"
         * @param {Document} doc - The `document` instance to create the Node for
         * @return {DOMNode} the TextNode, DOM Node, or DocumentFragment instance
         * @api private
         */

        function parse(html, doc) {
            if ('string' != typeof html) throw new TypeError('String expected');

            // default to the global `document` object
            if (!doc) doc = document;

            // tag name
            var m = /<([\w:]+)/.exec(html);
            if (!m) return doc.createTextNode(html);

            html = html.replace(/^\s+|\s+$/g, ''); // Remove leading/trailing whitespace

            var tag = m[1];

            // body support
            if (tag == 'body') {
                var el = doc.createElement('html');
                el.innerHTML = html;
                return el.removeChild(el.lastChild);
            }

            // wrap map
            var wrap = map[tag] || map._default;
            var depth = wrap[0];
            var prefix = wrap[1];
            var suffix = wrap[2];
            var el = doc.createElement('div');
            el.innerHTML = prefix + html + suffix;
            while (depth--) el = el.lastChild;

            // one element
            if (el.firstChild == el.lastChild) {
                return el.removeChild(el.firstChild);
            }

            // several elements
            var fragment = doc.createDocumentFragment();
            while (el.firstChild) {
                fragment.appendChild(el.removeChild(el.firstChild));
            }

            return fragment;
        }

    }, {}], 286: [function (require, module, exports) {
        /*! Hammer.JS - v2.0.7 - 2016-04-22
         * http://hammerjs.github.io/
         *
         * Copyright (c) 2016 Jorik Tangelder;
         * Licensed under the MIT license */
        (function (window, document, exportName, undefined) {
            'use strict';

            var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];
            var TEST_ELEMENT = document.createElement('div');

            var TYPE_FUNCTION = 'function';

            var round = Math.round;
            var abs = Math.abs;
            var now = Date.now;

            /**
             * set a timeout with a given scope
             * @param {Function} fn
             * @param {Number} timeout
             * @param {Object} context
             * @returns {number}
             */
            function setTimeoutContext(fn, timeout, context) {
                return setTimeout(bindFn(fn, context), timeout);
            }

            /**
             * if the argument is an array, we want to execute the fn on each entry
             * if it aint an array we don't want to do a thing.
             * this is used by all the methods that accept a single and array argument.
             * @param {*|Array} arg
             * @param {String} fn
             * @param {Object} [context]
             * @returns {Boolean}
             */
            function invokeArrayArg(arg, fn, context) {
                if (Array.isArray(arg)) {
                    each(arg, context[fn], context);
                    return true;
                }
                return false;
            }

            /**
             * walk objects and arrays
             * @param {Object} obj
             * @param {Function} iterator
             * @param {Object} context
             */
            function each(obj, iterator, context) {
                var i;

                if (!obj) {
                    return;
                }

                if (obj.forEach) {
                    obj.forEach(iterator, context);
                } else if (obj.length !== undefined) {
                    i = 0;
                    while (i < obj.length) {
                        iterator.call(context, obj[i], i, obj);
                        i++;
                    }
                } else {
                    for (i in obj) {
                        obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
                    }
                }
            }

            /**
             * wrap a method with a deprecation warning and stack trace
             * @param {Function} method
             * @param {String} name
             * @param {String} message
             * @returns {Function} A new function wrapping the supplied method.
             */
            function deprecate(method, name, message) {
                var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\n' + message + ' AT \n';
                return function () {
                    var e = new Error('get-stack-trace');
                    var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, '')
                        .replace(/^\s+at\s+/gm, '')
                        .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';

                    var log = window.console && (window.console.warn || window.console.log);
                    if (log) {
                        log.call(window.console, deprecationMessage, stack);
                    }
                    return method.apply(this, arguments);
                };
            }

            /**
             * extend object.
             * means that properties in dest will be overwritten by the ones in src.
             * @param {Object} target
             * @param {...Object} objects_to_assign
             * @returns {Object} target
             */
            var assign;
            if (typeof Object.assign !== 'function') {
                assign = function assign(target) {
                    if (target === undefined || target === null) {
                        throw new TypeError('Cannot convert undefined or null to object');
                    }

                    var output = Object(target);
                    for (var index = 1; index < arguments.length; index++) {
                        var source = arguments[index];
                        if (source !== undefined && source !== null) {
                            for (var nextKey in source) {
                                if (source.hasOwnProperty(nextKey)) {
                                    output[nextKey] = source[nextKey];
                                }
                            }
                        }
                    }
                    return output;
                };
            } else {
                assign = Object.assign;
            }

            /**
             * extend object.
             * means that properties in dest will be overwritten by the ones in src.
             * @param {Object} dest
             * @param {Object} src
             * @param {Boolean} [merge=false]
             * @returns {Object} dest
             */
            var extend = deprecate(function extend(dest, src, merge) {
                var keys = Object.keys(src);
                var i = 0;
                while (i < keys.length) {
                    if (!merge || (merge && dest[keys[i]] === undefined)) {
                        dest[keys[i]] = src[keys[i]];
                    }
                    i++;
                }
                return dest;
            }, 'extend', 'Use `assign`.');

            /**
             * merge the values from src in the dest.
             * means that properties that exist in dest will not be overwritten by src
             * @param {Object} dest
             * @param {Object} src
             * @returns {Object} dest
             */
            var merge = deprecate(function merge(dest, src) {
                return extend(dest, src, true);
            }, 'merge', 'Use `assign`.');

            /**
             * simple class inheritance
             * @param {Function} child
             * @param {Function} base
             * @param {Object} [properties]
             */
            function inherit(child, base, properties) {
                var baseP = base.prototype,
                    childP;

                childP = child.prototype = Object.create(baseP);
                childP.constructor = child;
                childP._super = baseP;

                if (properties) {
                    assign(childP, properties);
                }
            }

            /**
             * simple function bind
             * @param {Function} fn
             * @param {Object} context
             * @returns {Function}
             */
            function bindFn(fn, context) {
                return function boundFn() {
                    return fn.apply(context, arguments);
                };
            }

            /**
             * let a boolean value also be a function that must return a boolean
             * this first item in args will be used as the context
             * @param {Boolean|Function} val
             * @param {Array} [args]
             * @returns {Boolean}
             */
            function boolOrFn(val, args) {
                if (typeof val == TYPE_FUNCTION) {
                    return val.apply(args ? args[0] || undefined : undefined, args);
                }
                return val;
            }

            /**
             * use the val2 when val1 is undefined
             * @param {*} val1
             * @param {*} val2
             * @returns {*}
             */
            function ifUndefined(val1, val2) {
                return (val1 === undefined) ? val2 : val1;
            }

            /**
             * addEventListener with multiple events at once
             * @param {EventTarget} target
             * @param {String} types
             * @param {Function} handler
             */
            function addEventListeners(target, types, handler) {
                each(splitStr(types), function (type) {
                    target.addEventListener(type, handler, false);
                });
            }

            /**
             * removeEventListener with multiple events at once
             * @param {EventTarget} target
             * @param {String} types
             * @param {Function} handler
             */
            function removeEventListeners(target, types, handler) {
                each(splitStr(types), function (type) {
                    target.removeEventListener(type, handler, false);
                });
            }

            /**
             * find if a node is in the given parent
             * @method hasParent
             * @param {HTMLElement} node
             * @param {HTMLElement} parent
             * @return {Boolean} found
             */
            function hasParent(node, parent) {
                while (node) {
                    if (node == parent) {
                        return true;
                    }
                    node = node.parentNode;
                }
                return false;
            }

            /**
             * small indexOf wrapper
             * @param {String} str
             * @param {String} find
             * @returns {Boolean} found
             */
            function inStr(str, find) {
                return str.indexOf(find) > -1;
            }

            /**
             * split string on whitespace
             * @param {String} str
             * @returns {Array} words
             */
            function splitStr(str) {
                return str.trim().split(/\s+/g);
            }

            /**
             * find if a array contains the object using indexOf or a simple polyFill
             * @param {Array} src
             * @param {String} find
             * @param {String} [findByKey]
             * @return {Boolean|Number} false when not found, or the index
             */
            function inArray(src, find, findByKey) {
                if (src.indexOf && !findByKey) {
                    return src.indexOf(find);
                } else {
                    var i = 0;
                    while (i < src.length) {
                        if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {
                            return i;
                        }
                        i++;
                    }
                    return -1;
                }
            }

            /**
             * convert array-like objects to real arrays
             * @param {Object} obj
             * @returns {Array}
             */
            function toArray(obj) {
                return Array.prototype.slice.call(obj, 0);
            }

            /**
             * unique array with objects based on a key (like 'id') or just by the array's value
             * @param {Array} src [{id:1},{id:2},{id:1}]
             * @param {String} [key]
             * @param {Boolean} [sort=False]
             * @returns {Array} [{id:1},{id:2}]
             */
            function uniqueArray(src, key, sort) {
                var results = [];
                var values = [];
                var i = 0;

                while (i < src.length) {
                    var val = key ? src[i][key] : src[i];
                    if (inArray(values, val) < 0) {
                        results.push(src[i]);
                    }
                    values[i] = val;
                    i++;
                }

                if (sort) {
                    if (!key) {
                        results = results.sort();
                    } else {
                        results = results.sort(function sortUniqueArray(a, b) {
                            return a[key] > b[key];
                        });
                    }
                }

                return results;
            }

            /**
             * get the prefixed property
             * @param {Object} obj
             * @param {String} property
             * @returns {String|Undefined} prefixed
             */
            function prefixed(obj, property) {
                var prefix, prop;
                var camelProp = property[0].toUpperCase() + property.slice(1);

                var i = 0;
                while (i < VENDOR_PREFIXES.length) {
                    prefix = VENDOR_PREFIXES[i];
                    prop = (prefix) ? prefix + camelProp : property;

                    if (prop in obj) {
                        return prop;
                    }
                    i++;
                }
                return undefined;
            }

            /**
             * get a unique id
             * @returns {number} uniqueId
             */
            var _uniqueId = 1;
            function uniqueId() {
                return _uniqueId++;
            }

            /**
             * get the window object of an element
             * @param {HTMLElement} element
             * @returns {DocumentView|Window}
             */
            function getWindowForElement(element) {
                var doc = element.ownerDocument || element;
                return (doc.defaultView || doc.parentWindow || window);
            }

            var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;

            var SUPPORT_TOUCH = ('ontouchstart' in window);
            var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
            var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);

            var INPUT_TYPE_TOUCH = 'touch';
            var INPUT_TYPE_PEN = 'pen';
            var INPUT_TYPE_MOUSE = 'mouse';
            var INPUT_TYPE_KINECT = 'kinect';

            var COMPUTE_INTERVAL = 25;

            var INPUT_START = 1;
            var INPUT_MOVE = 2;
            var INPUT_END = 4;
            var INPUT_CANCEL = 8;

            var DIRECTION_NONE = 1;
            var DIRECTION_LEFT = 2;
            var DIRECTION_RIGHT = 4;
            var DIRECTION_UP = 8;
            var DIRECTION_DOWN = 16;

            var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
            var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
            var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;

            var PROPS_XY = ['x', 'y'];
            var PROPS_CLIENT_XY = ['clientX', 'clientY'];

            /**
             * create new input type manager
             * @param {Manager} manager
             * @param {Function} callback
             * @returns {Input}
             * @constructor
             */
            function Input(manager, callback) {
                var self = this;
                this.manager = manager;
                this.callback = callback;
                this.element = manager.element;
                this.target = manager.options.inputTarget;

                // smaller wrapper around the handler, for the scope and the enabled state of the manager,
                // so when disabled the input events are completely bypassed.
                this.domHandler = function (ev) {
                    if (boolOrFn(manager.options.enable, [manager])) {
                        self.handler(ev);
                    }
                };

                this.init();

            }

            Input.prototype = {
                /**
                 * should handle the inputEvent data and trigger the callback
                 * @virtual
                 */
                handler: function () { },

                /**
                 * bind the events
                 */
                init: function () {
                    this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
                    this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
                    this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
                },

                /**
                 * unbind the events
                 */
                destroy: function () {
                    this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
                    this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
                    this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
                }
            };

            /**
             * create new input type manager
             * called by the Manager constructor
             * @param {Hammer} manager
             * @returns {Input}
             */
            function createInputInstance(manager) {
                var Type;
                var inputClass = manager.options.inputClass;

                if (inputClass) {
                    Type = inputClass;
                } else if (SUPPORT_POINTER_EVENTS) {
                    Type = PointerEventInput;
                } else if (SUPPORT_ONLY_TOUCH) {
                    Type = TouchInput;
                } else if (!SUPPORT_TOUCH) {
                    Type = MouseInput;
                } else {
                    Type = TouchMouseInput;
                }
                return new (Type)(manager, inputHandler);
            }

            /**
             * handle input events
             * @param {Manager} manager
             * @param {String} eventType
             * @param {Object} input
             */
            function inputHandler(manager, eventType, input) {
                var pointersLen = input.pointers.length;
                var changedPointersLen = input.changedPointers.length;
                var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));
                var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));

                input.isFirst = !!isFirst;
                input.isFinal = !!isFinal;

                if (isFirst) {
                    manager.session = {};
                }

                // source event is the normalized value of the domEvents
                // like 'touchstart, mouseup, pointerdown'
                input.eventType = eventType;

                // compute scale, rotation etc
                computeInputData(manager, input);

                // emit secret event
                manager.emit('hammer.input', input);

                manager.recognize(input);
                manager.session.prevInput = input;
            }

            /**
             * extend the data with some usable properties like scale, rotate, velocity etc
             * @param {Object} manager
             * @param {Object} input
             */
            function computeInputData(manager, input) {
                var session = manager.session;
                var pointers = input.pointers;
                var pointersLength = pointers.length;

                // store the first input to calculate the distance and direction
                if (!session.firstInput) {
                    session.firstInput = simpleCloneInputData(input);
                }

                // to compute scale and rotation we need to store the multiple touches
                if (pointersLength > 1 && !session.firstMultiple) {
                    session.firstMultiple = simpleCloneInputData(input);
                } else if (pointersLength === 1) {
                    session.firstMultiple = false;
                }

                var firstInput = session.firstInput;
                var firstMultiple = session.firstMultiple;
                var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;

                var center = input.center = getCenter(pointers);
                input.timeStamp = now();
                input.deltaTime = input.timeStamp - firstInput.timeStamp;

                input.angle = getAngle(offsetCenter, center);
                input.distance = getDistance(offsetCenter, center);

                computeDeltaXY(session, input);
                input.offsetDirection = getDirection(input.deltaX, input.deltaY);

                var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
                input.overallVelocityX = overallVelocity.x;
                input.overallVelocityY = overallVelocity.y;
                input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;

                input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
                input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;

                input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >
                    session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);

                computeIntervalInputData(session, input);

                // find the correct target
                var target = manager.element;
                if (hasParent(input.srcEvent.target, target)) {
                    target = input.srcEvent.target;
                }
                input.target = target;
            }

            function computeDeltaXY(session, input) {
                var center = input.center;
                var offset = session.offsetDelta || {};
                var prevDelta = session.prevDelta || {};
                var prevInput = session.prevInput || {};

                if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
                    prevDelta = session.prevDelta = {
                        x: prevInput.deltaX || 0,
                        y: prevInput.deltaY || 0
                    };

                    offset = session.offsetDelta = {
                        x: center.x,
                        y: center.y
                    };
                }

                input.deltaX = prevDelta.x + (center.x - offset.x);
                input.deltaY = prevDelta.y + (center.y - offset.y);
            }

            /**
             * velocity is calculated every x ms
             * @param {Object} session
             * @param {Object} input
             */
            function computeIntervalInputData(session, input) {
                var last = session.lastInterval || input,
                    deltaTime = input.timeStamp - last.timeStamp,
                    velocity, velocityX, velocityY, direction;

                if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
                    var deltaX = input.deltaX - last.deltaX;
                    var deltaY = input.deltaY - last.deltaY;

                    var v = getVelocity(deltaTime, deltaX, deltaY);
                    velocityX = v.x;
                    velocityY = v.y;
                    velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;
                    direction = getDirection(deltaX, deltaY);

                    session.lastInterval = input;
                } else {
                    // use latest velocity info if it doesn't overtake a minimum period
                    velocity = last.velocity;
                    velocityX = last.velocityX;
                    velocityY = last.velocityY;
                    direction = last.direction;
                }

                input.velocity = velocity;
                input.velocityX = velocityX;
                input.velocityY = velocityY;
                input.direction = direction;
            }

            /**
             * create a simple clone from the input used for storage of firstInput and firstMultiple
             * @param {Object} input
             * @returns {Object} clonedInputData
             */
            function simpleCloneInputData(input) {
                // make a simple copy of the pointers because we will get a reference if we don't
                // we only need clientXY for the calculations
                var pointers = [];
                var i = 0;
                while (i < input.pointers.length) {
                    pointers[i] = {
                        clientX: round(input.pointers[i].clientX),
                        clientY: round(input.pointers[i].clientY)
                    };
                    i++;
                }

                return {
                    timeStamp: now(),
                    pointers: pointers,
                    center: getCenter(pointers),
                    deltaX: input.deltaX,
                    deltaY: input.deltaY
                };
            }

            /**
             * get the center of all the pointers
             * @param {Array} pointers
             * @return {Object} center contains `x` and `y` properties
             */
            function getCenter(pointers) {
                var pointersLength = pointers.length;

                // no need to loop when only one touch
                if (pointersLength === 1) {
                    return {
                        x: round(pointers[0].clientX),
                        y: round(pointers[0].clientY)
                    };
                }

                var x = 0, y = 0, i = 0;
                while (i < pointersLength) {
                    x += pointers[i].clientX;
                    y += pointers[i].clientY;
                    i++;
                }

                return {
                    x: round(x / pointersLength),
                    y: round(y / pointersLength)
                };
            }

            /**
             * calculate the velocity between two points. unit is in px per ms.
             * @param {Number} deltaTime
             * @param {Number} x
             * @param {Number} y
             * @return {Object} velocity `x` and `y`
             */
            function getVelocity(deltaTime, x, y) {
                return {
                    x: x / deltaTime || 0,
                    y: y / deltaTime || 0
                };
            }

            /**
             * get the direction between two points
             * @param {Number} x
             * @param {Number} y
             * @return {Number} direction
             */
            function getDirection(x, y) {
                if (x === y) {
                    return DIRECTION_NONE;
                }

                if (abs(x) >= abs(y)) {
                    return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
                }
                return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
            }

            /**
             * calculate the absolute distance between two points
             * @param {Object} p1 {x, y}
             * @param {Object} p2 {x, y}
             * @param {Array} [props] containing x and y keys
             * @return {Number} distance
             */
            function getDistance(p1, p2, props) {
                if (!props) {
                    props = PROPS_XY;
                }
                var x = p2[props[0]] - p1[props[0]],
                    y = p2[props[1]] - p1[props[1]];

                return Math.sqrt((x * x) + (y * y));
            }

            /**
             * calculate the angle between two coordinates
             * @param {Object} p1
             * @param {Object} p2
             * @param {Array} [props] containing x and y keys
             * @return {Number} angle
             */
            function getAngle(p1, p2, props) {
                if (!props) {
                    props = PROPS_XY;
                }
                var x = p2[props[0]] - p1[props[0]],
                    y = p2[props[1]] - p1[props[1]];
                return Math.atan2(y, x) * 180 / Math.PI;
            }

            /**
             * calculate the rotation degrees between two pointersets
             * @param {Array} start array of pointers
             * @param {Array} end array of pointers
             * @return {Number} rotation
             */
            function getRotation(start, end) {
                return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
            }

            /**
             * calculate the scale factor between two pointersets
             * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
             * @param {Array} start array of pointers
             * @param {Array} end array of pointers
             * @return {Number} scale
             */
            function getScale(start, end) {
                return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
            }

            var MOUSE_INPUT_MAP = {
                mousedown: INPUT_START,
                mousemove: INPUT_MOVE,
                mouseup: INPUT_END
            };

            var MOUSE_ELEMENT_EVENTS = 'mousedown';
            var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';

            /**
             * Mouse events input
             * @constructor
             * @extends Input
             */
            function MouseInput() {
                this.evEl = MOUSE_ELEMENT_EVENTS;
                this.evWin = MOUSE_WINDOW_EVENTS;

                this.pressed = false; // mousedown state

                Input.apply(this, arguments);
            }

            inherit(MouseInput, Input, {
                /**
                 * handle mouse events
                 * @param {Object} ev
                 */
                handler: function MEhandler(ev) {
                    var eventType = MOUSE_INPUT_MAP[ev.type];

                    // on start we want to have the left mouse button down
                    if (eventType & INPUT_START && ev.button === 0) {
                        this.pressed = true;
                    }

                    if (eventType & INPUT_MOVE && ev.which !== 1) {
                        eventType = INPUT_END;
                    }

                    // mouse must be down
                    if (!this.pressed) {
                        return;
                    }

                    if (eventType & INPUT_END) {
                        this.pressed = false;
                    }

                    this.callback(this.manager, eventType, {
                        pointers: [ev],
                        changedPointers: [ev],
                        pointerType: INPUT_TYPE_MOUSE,
                        srcEvent: ev
                    });
                }
            });

            var POINTER_INPUT_MAP = {
                pointerdown: INPUT_START,
                pointermove: INPUT_MOVE,
                pointerup: INPUT_END,
                pointercancel: INPUT_CANCEL,
                pointerout: INPUT_CANCEL
            };

            // in IE10 the pointer types is defined as an enum
            var IE10_POINTER_TYPE_ENUM = {
                2: INPUT_TYPE_TOUCH,
                3: INPUT_TYPE_PEN,
                4: INPUT_TYPE_MOUSE,
                5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
            };

            var POINTER_ELEMENT_EVENTS = 'pointerdown';
            var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

            // IE10 has prefixed support, and case-sensitive
            if (window.MSPointerEvent && !window.PointerEvent) {
                POINTER_ELEMENT_EVENTS = 'MSPointerDown';
                POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
            }

            /**
             * Pointer events input
             * @constructor
             * @extends Input
             */
            function PointerEventInput() {
                this.evEl = POINTER_ELEMENT_EVENTS;
                this.evWin = POINTER_WINDOW_EVENTS;

                Input.apply(this, arguments);

                this.store = (this.manager.session.pointerEvents = []);
            }

            inherit(PointerEventInput, Input, {
                /**
                 * handle mouse events
                 * @param {Object} ev
                 */
                handler: function PEhandler(ev) {
                    var store = this.store;
                    var removePointer = false;

                    var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
                    var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
                    var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;

                    var isTouch = (pointerType == INPUT_TYPE_TOUCH);

                    // get index of the event in the store
                    var storeIndex = inArray(store, ev.pointerId, 'pointerId');

                    // start and mouse must be down
                    if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
                        if (storeIndex < 0) {
                            store.push(ev);
                            storeIndex = store.length - 1;
                        }
                    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
                        removePointer = true;
                    }

                    // it not found, so the pointer hasn't been down (so it's probably a hover)
                    if (storeIndex < 0) {
                        return;
                    }

                    // update the event in the store
                    store[storeIndex] = ev;

                    this.callback(this.manager, eventType, {
                        pointers: store,
                        changedPointers: [ev],
                        pointerType: pointerType,
                        srcEvent: ev
                    });

                    if (removePointer) {
                        // remove from the store
                        store.splice(storeIndex, 1);
                    }
                }
            });

            var SINGLE_TOUCH_INPUT_MAP = {
                touchstart: INPUT_START,
                touchmove: INPUT_MOVE,
                touchend: INPUT_END,
                touchcancel: INPUT_CANCEL
            };

            var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
            var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';

            /**
             * Touch events input
             * @constructor
             * @extends Input
             */
            function SingleTouchInput() {
                this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
                this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
                this.started = false;

                Input.apply(this, arguments);
            }

            inherit(SingleTouchInput, Input, {
                handler: function TEhandler(ev) {
                    var type = SINGLE_TOUCH_INPUT_MAP[ev.type];

                    // should we handle the touch events?
                    if (type === INPUT_START) {
                        this.started = true;
                    }

                    if (!this.started) {
                        return;
                    }

                    var touches = normalizeSingleTouches.call(this, ev, type);

                    // when done, reset the started state
                    if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
                        this.started = false;
                    }

                    this.callback(this.manager, type, {
                        pointers: touches[0],
                        changedPointers: touches[1],
                        pointerType: INPUT_TYPE_TOUCH,
                        srcEvent: ev
                    });
                }
            });

            /**
             * @this {TouchInput}
             * @param {Object} ev
             * @param {Number} type flag
             * @returns {undefined|Array} [all, changed]
             */
            function normalizeSingleTouches(ev, type) {
                var all = toArray(ev.touches);
                var changed = toArray(ev.changedTouches);

                if (type & (INPUT_END | INPUT_CANCEL)) {
                    all = uniqueArray(all.concat(changed), 'identifier', true);
                }

                return [all, changed];
            }

            var TOUCH_INPUT_MAP = {
                touchstart: INPUT_START,
                touchmove: INPUT_MOVE,
                touchend: INPUT_END,
                touchcancel: INPUT_CANCEL
            };

            var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';

            /**
             * Multi-user touch events input
             * @constructor
             * @extends Input
             */
            function TouchInput() {
                this.evTarget = TOUCH_TARGET_EVENTS;
                this.targetIds = {};

                Input.apply(this, arguments);
            }

            inherit(TouchInput, Input, {
                handler: function MTEhandler(ev) {
                    var type = TOUCH_INPUT_MAP[ev.type];
                    var touches = getTouches.call(this, ev, type);
                    if (!touches) {
                        return;
                    }

                    this.callback(this.manager, type, {
                        pointers: touches[0],
                        changedPointers: touches[1],
                        pointerType: INPUT_TYPE_TOUCH,
                        srcEvent: ev
                    });
                }
            });

            /**
             * @this {TouchInput}
             * @param {Object} ev
             * @param {Number} type flag
             * @returns {undefined|Array} [all, changed]
             */
            function getTouches(ev, type) {
                var allTouches = toArray(ev.touches);
                var targetIds = this.targetIds;

                // when there is only one touch, the process can be simplified
                if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
                    targetIds[allTouches[0].identifier] = true;
                    return [allTouches, allTouches];
                }

                var i,
                    targetTouches,
                    changedTouches = toArray(ev.changedTouches),
                    changedTargetTouches = [],
                    target = this.target;

                // get target touches from touches
                targetTouches = allTouches.filter(function (touch) {
                    return hasParent(touch.target, target);
                });

                // collect touches
                if (type === INPUT_START) {
                    i = 0;
                    while (i < targetTouches.length) {
                        targetIds[targetTouches[i].identifier] = true;
                        i++;
                    }
                }

                // filter changed touches to only contain touches that exist in the collected target ids
                i = 0;
                while (i < changedTouches.length) {
                    if (targetIds[changedTouches[i].identifier]) {
                        changedTargetTouches.push(changedTouches[i]);
                    }

                    // cleanup removed touches
                    if (type & (INPUT_END | INPUT_CANCEL)) {
                        delete targetIds[changedTouches[i].identifier];
                    }
                    i++;
                }

                if (!changedTargetTouches.length) {
                    return;
                }

                return [
                    // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
                    uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),
                    changedTargetTouches
                ];
            }

            /**
             * Combined touch and mouse input
             *
             * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
             * This because touch devices also emit mouse events while doing a touch.
             *
             * @constructor
             * @extends Input
             */

            var DEDUP_TIMEOUT = 2500;
            var DEDUP_DISTANCE = 25;

            function TouchMouseInput() {
                Input.apply(this, arguments);

                var handler = bindFn(this.handler, this);
                this.touch = new TouchInput(this.manager, handler);
                this.mouse = new MouseInput(this.manager, handler);

                this.primaryTouch = null;
                this.lastTouches = [];
            }

            inherit(TouchMouseInput, Input, {
                /**
                 * handle mouse and touch events
                 * @param {Hammer} manager
                 * @param {String} inputEvent
                 * @param {Object} inputData
                 */
                handler: function TMEhandler(manager, inputEvent, inputData) {
                    var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),
                        isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);

                    if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
                        return;
                    }

                    // when we're in a touch event, record touches to  de-dupe synthetic mouse event
                    if (isTouch) {
                        recordTouches.call(this, inputEvent, inputData);
                    } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
                        return;
                    }

                    this.callback(manager, inputEvent, inputData);
                },

                /**
                 * remove the event listeners
                 */
                destroy: function destroy() {
                    this.touch.destroy();
                    this.mouse.destroy();
                }
            });

            function recordTouches(eventType, eventData) {
                if (eventType & INPUT_START) {
                    this.primaryTouch = eventData.changedPointers[0].identifier;
                    setLastTouch.call(this, eventData);
                } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
                    setLastTouch.call(this, eventData);
                }
            }

            function setLastTouch(eventData) {
                var touch = eventData.changedPointers[0];

                if (touch.identifier === this.primaryTouch) {
                    var lastTouch = { x: touch.clientX, y: touch.clientY };
                    this.lastTouches.push(lastTouch);
                    var lts = this.lastTouches;
                    var removeLastTouch = function () {
                        var i = lts.indexOf(lastTouch);
                        if (i > -1) {
                            lts.splice(i, 1);
                        }
                    };
                    setTimeout(removeLastTouch, DEDUP_TIMEOUT);
                }
            }

            function isSyntheticEvent(eventData) {
                var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;
                for (var i = 0; i < this.lastTouches.length; i++) {
                    var t = this.lastTouches[i];
                    var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);
                    if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
                        return true;
                    }
                }
                return false;
            }

            var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
            var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

            // magical touchAction value
            var TOUCH_ACTION_COMPUTE = 'compute';
            var TOUCH_ACTION_AUTO = 'auto';
            var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
            var TOUCH_ACTION_NONE = 'none';
            var TOUCH_ACTION_PAN_X = 'pan-x';
            var TOUCH_ACTION_PAN_Y = 'pan-y';
            var TOUCH_ACTION_MAP = getTouchActionProps();

            /**
             * Touch Action
             * sets the touchAction property or uses the js alternative
             * @param {Manager} manager
             * @param {String} value
             * @constructor
             */
            function TouchAction(manager, value) {
                this.manager = manager;
                this.set(value);
            }

            TouchAction.prototype = {
                /**
                 * set the touchAction value on the element or enable the polyfill
                 * @param {String} value
                 */
                set: function (value) {
                    // find out the touch-action by the event handlers
                    if (value == TOUCH_ACTION_COMPUTE) {
                        value = this.compute();
                    }

                    if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
                        this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
                    }
                    this.actions = value.toLowerCase().trim();
                },

                /**
                 * just re-set the touchAction value
                 */
                update: function () {
                    this.set(this.manager.options.touchAction);
                },

                /**
                 * compute the value for the touchAction property based on the recognizer's settings
                 * @returns {String} value
                 */
                compute: function () {
                    var actions = [];
                    each(this.manager.recognizers, function (recognizer) {
                        if (boolOrFn(recognizer.options.enable, [recognizer])) {
                            actions = actions.concat(recognizer.getTouchAction());
                        }
                    });
                    return cleanTouchActions(actions.join(' '));
                },

                /**
                 * this method is called on each input cycle and provides the preventing of the browser behavior
                 * @param {Object} input
                 */
                preventDefaults: function (input) {
                    var srcEvent = input.srcEvent;
                    var direction = input.offsetDirection;

                    // if the touch action did prevented once this session
                    if (this.manager.session.prevented) {
                        srcEvent.preventDefault();
                        return;
                    }

                    var actions = this.actions;
                    var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
                    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
                    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];

                    if (hasNone) {
                        //do not prevent defaults if this is a tap gesture

                        var isTapPointer = input.pointers.length === 1;
                        var isTapMovement = input.distance < 2;
                        var isTapTouchTime = input.deltaTime < 250;

                        if (isTapPointer && isTapMovement && isTapTouchTime) {
                            return;
                        }
                    }

                    if (hasPanX && hasPanY) {
                        // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
                        return;
                    }

                    if (hasNone ||
                        (hasPanY && direction & DIRECTION_HORIZONTAL) ||
                        (hasPanX && direction & DIRECTION_VERTICAL)) {
                        return this.preventSrc(srcEvent);
                    }
                },

                /**
                 * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
                 * @param {Object} srcEvent
                 */
                preventSrc: function (srcEvent) {
                    this.manager.session.prevented = true;
                    srcEvent.preventDefault();
                }
            };

            /**
             * when the touchActions are collected they are not a valid value, so we need to clean things up. *
             * @param {String} actions
             * @returns {*}
             */
            function cleanTouchActions(actions) {
                // none
                if (inStr(actions, TOUCH_ACTION_NONE)) {
                    return TOUCH_ACTION_NONE;
                }

                var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
                var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);

                // if both pan-x and pan-y are set (different recognizers
                // for different directions, e.g. horizontal pan but vertical swipe?)
                // we need none (as otherwise with pan-x pan-y combined none of these
                // recognizers will work, since the browser would handle all panning
                if (hasPanX && hasPanY) {
                    return TOUCH_ACTION_NONE;
                }

                // pan-x OR pan-y
                if (hasPanX || hasPanY) {
                    return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
                }

                // manipulation
                if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
                    return TOUCH_ACTION_MANIPULATION;
                }

                return TOUCH_ACTION_AUTO;
            }

            function getTouchActionProps() {
                if (!NATIVE_TOUCH_ACTION) {
                    return false;
                }
                var touchMap = {};
                var cssSupports = window.CSS && window.CSS.supports;
                ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function (val) {

                    // If css.supports is not supported but there is native touch-action assume it supports
                    // all values. This is the case for IE 10 and 11.
                    touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;
                });
                return touchMap;
            }

            /**
             * Recognizer flow explained; *
             * All recognizers have the initial state of POSSIBLE when a input session starts.
             * The definition of a input session is from the first input until the last input, with all it's movement in it. *
             * Example session for mouse-input: mousedown -> mousemove -> mouseup
             *
             * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
             * which determines with state it should be.
             *
             * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
             * POSSIBLE to give it another change on the next cycle.
             *
             *               Possible
             *                  |
             *            +-----+---------------+
             *            |                     |
             *      +-----+-----+               |
             *      |           |               |
             *   Failed      Cancelled          |
             *                          +-------+------+
             *                          |              |
             *                      Recognized       Began
             *                                         |
             *                                      Changed
             *                                         |
             *                                  Ended/Recognized
             */
            var STATE_POSSIBLE = 1;
            var STATE_BEGAN = 2;
            var STATE_CHANGED = 4;
            var STATE_ENDED = 8;
            var STATE_RECOGNIZED = STATE_ENDED;
            var STATE_CANCELLED = 16;
            var STATE_FAILED = 32;

            /**
             * Recognizer
             * Every recognizer needs to extend from this class.
             * @constructor
             * @param {Object} options
             */
            function Recognizer(options) {
                this.options = assign({}, this.defaults, options || {});

                this.id = uniqueId();

                this.manager = null;

                // default is enable true
                this.options.enable = ifUndefined(this.options.enable, true);

                this.state = STATE_POSSIBLE;

                this.simultaneous = {};
                this.requireFail = [];
            }

            Recognizer.prototype = {
                /**
                 * @virtual
                 * @type {Object}
                 */
                defaults: {},

                /**
                 * set options
                 * @param {Object} options
                 * @return {Recognizer}
                 */
                set: function (options) {
                    assign(this.options, options);

                    // also update the touchAction, in case something changed about the directions/enabled state
                    this.manager && this.manager.touchAction.update();
                    return this;
                },

                /**
                 * recognize simultaneous with an other recognizer.
                 * @param {Recognizer} otherRecognizer
                 * @returns {Recognizer} this
                 */
                recognizeWith: function (otherRecognizer) {
                    if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
                        return this;
                    }

                    var simultaneous = this.simultaneous;
                    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
                    if (!simultaneous[otherRecognizer.id]) {
                        simultaneous[otherRecognizer.id] = otherRecognizer;
                        otherRecognizer.recognizeWith(this);
                    }
                    return this;
                },

                /**
                 * drop the simultaneous link. it doesnt remove the link on the other recognizer.
                 * @param {Recognizer} otherRecognizer
                 * @returns {Recognizer} this
                 */
                dropRecognizeWith: function (otherRecognizer) {
                    if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
                        return this;
                    }

                    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
                    delete this.simultaneous[otherRecognizer.id];
                    return this;
                },

                /**
                 * recognizer can only run when an other is failing
                 * @param {Recognizer} otherRecognizer
                 * @returns {Recognizer} this
                 */
                requireFailure: function (otherRecognizer) {
                    if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
                        return this;
                    }

                    var requireFail = this.requireFail;
                    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
                    if (inArray(requireFail, otherRecognizer) === -1) {
                        requireFail.push(otherRecognizer);
                        otherRecognizer.requireFailure(this);
                    }
                    return this;
                },

                /**
                 * drop the requireFailure link. it does not remove the link on the other recognizer.
                 * @param {Recognizer} otherRecognizer
                 * @returns {Recognizer} this
                 */
                dropRequireFailure: function (otherRecognizer) {
                    if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
                        return this;
                    }

                    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
                    var index = inArray(this.requireFail, otherRecognizer);
                    if (index > -1) {
                        this.requireFail.splice(index, 1);
                    }
                    return this;
                },

                /**
                 * has require failures boolean
                 * @returns {boolean}
                 */
                hasRequireFailures: function () {
                    return this.requireFail.length > 0;
                },

                /**
                 * if the recognizer can recognize simultaneous with an other recognizer
                 * @param {Recognizer} otherRecognizer
                 * @returns {Boolean}
                 */
                canRecognizeWith: function (otherRecognizer) {
                    return !!this.simultaneous[otherRecognizer.id];
                },

                /**
                 * You should use `tryEmit` instead of `emit` directly to check
                 * that all the needed recognizers has failed before emitting.
                 * @param {Object} input
                 */
                emit: function (input) {
                    var self = this;
                    var state = this.state;

                    function emit(event) {
                        self.manager.emit(event, input);
                    }

                    // 'panstart' and 'panmove'
                    if (state < STATE_ENDED) {
                        emit(self.options.event + stateStr(state));
                    }

                    emit(self.options.event); // simple 'eventName' events

                    if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)
                        emit(input.additionalEvent);
                    }

                    // panend and pancancel
                    if (state >= STATE_ENDED) {
                        emit(self.options.event + stateStr(state));
                    }
                },

                /**
                 * Check that all the require failure recognizers has failed,
                 * if true, it emits a gesture event,
                 * otherwise, setup the state to FAILED.
                 * @param {Object} input
                 */
                tryEmit: function (input) {
                    if (this.canEmit()) {
                        return this.emit(input);
                    }
                    // it's failing anyway
                    this.state = STATE_FAILED;
                },

                /**
                 * can we emit?
                 * @returns {boolean}
                 */
                canEmit: function () {
                    var i = 0;
                    while (i < this.requireFail.length) {
                        if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                            return false;
                        }
                        i++;
                    }
                    return true;
                },

                /**
                 * update the recognizer
                 * @param {Object} inputData
                 */
                recognize: function (inputData) {
                    // make a new copy of the inputData
                    // so we can change the inputData without messing up the other recognizers
                    var inputDataClone = assign({}, inputData);

                    // is is enabled and allow recognizing?
                    if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
                        this.reset();
                        this.state = STATE_FAILED;
                        return;
                    }

                    // reset when we've reached the end
                    if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
                        this.state = STATE_POSSIBLE;
                    }

                    this.state = this.process(inputDataClone);

                    // the recognizer has recognized a gesture
                    // so trigger an event
                    if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
                        this.tryEmit(inputDataClone);
                    }
                },

                /**
                 * return the state of the recognizer
                 * the actual recognizing happens in this method
                 * @virtual
                 * @param {Object} inputData
                 * @returns {Const} STATE
                 */
                process: function (inputData) { }, // jshint ignore:line

                /**
                 * return the preferred touch-action
                 * @virtual
                 * @returns {Array}
                 */
                getTouchAction: function () { },

                /**
                 * called when the gesture isn't allowed to recognize
                 * like when another is being recognized or it is disabled
                 * @virtual
                 */
                reset: function () { }
            };

            /**
             * get a usable string, used as event postfix
             * @param {Const} state
             * @returns {String} state
             */
            function stateStr(state) {
                if (state & STATE_CANCELLED) {
                    return 'cancel';
                } else if (state & STATE_ENDED) {
                    return 'end';
                } else if (state & STATE_CHANGED) {
                    return 'move';
                } else if (state & STATE_BEGAN) {
                    return 'start';
                }
                return '';
            }

            /**
             * direction cons to string
             * @param {Const} direction
             * @returns {String}
             */
            function directionStr(direction) {
                if (direction == DIRECTION_DOWN) {
                    return 'down';
                } else if (direction == DIRECTION_UP) {
                    return 'up';
                } else if (direction == DIRECTION_LEFT) {
                    return 'left';
                } else if (direction == DIRECTION_RIGHT) {
                    return 'right';
                }
                return '';
            }

            /**
             * get a recognizer by name if it is bound to a manager
             * @param {Recognizer|String} otherRecognizer
             * @param {Recognizer} recognizer
             * @returns {Recognizer}
             */
            function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
                var manager = recognizer.manager;
                if (manager) {
                    return manager.get(otherRecognizer);
                }
                return otherRecognizer;
            }

            /**
             * This recognizer is just used as a base for the simple attribute recognizers.
             * @constructor
             * @extends Recognizer
             */
            function AttrRecognizer() {
                Recognizer.apply(this, arguments);
            }

            inherit(AttrRecognizer, Recognizer, {
                /**
                 * @namespace
                 * @memberof AttrRecognizer
                 */
                defaults: {
                    /**
                     * @type {Number}
                     * @default 1
                     */
                    pointers: 1
                },

                /**
                 * Used to check if it the recognizer receives valid input, like input.distance > 10.
                 * @memberof AttrRecognizer
                 * @param {Object} input
                 * @returns {Boolean} recognized
                 */
                attrTest: function (input) {
                    var optionPointers = this.options.pointers;
                    return optionPointers === 0 || input.pointers.length === optionPointers;
                },

                /**
                 * Process the input and return the state for the recognizer
                 * @memberof AttrRecognizer
                 * @param {Object} input
                 * @returns {*} State
                 */
                process: function (input) {
                    var state = this.state;
                    var eventType = input.eventType;

                    var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
                    var isValid = this.attrTest(input);

                    // on cancel input and we've recognized before, return STATE_CANCELLED
                    if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
                        return state | STATE_CANCELLED;
                    } else if (isRecognized || isValid) {
                        if (eventType & INPUT_END) {
                            return state | STATE_ENDED;
                        } else if (!(state & STATE_BEGAN)) {
                            return STATE_BEGAN;
                        }
                        return state | STATE_CHANGED;
                    }
                    return STATE_FAILED;
                }
            });

            /**
             * Pan
             * Recognized when the pointer is down and moved in the allowed direction.
             * @constructor
             * @extends AttrRecognizer
             */
            function PanRecognizer() {
                AttrRecognizer.apply(this, arguments);

                this.pX = null;
                this.pY = null;
            }

            inherit(PanRecognizer, AttrRecognizer, {
                /**
                 * @namespace
                 * @memberof PanRecognizer
                 */
                defaults: {
                    event: 'pan',
                    threshold: 10,
                    pointers: 1,
                    direction: DIRECTION_ALL
                },

                getTouchAction: function () {
                    var direction = this.options.direction;
                    var actions = [];
                    if (direction & DIRECTION_HORIZONTAL) {
                        actions.push(TOUCH_ACTION_PAN_Y);
                    }
                    if (direction & DIRECTION_VERTICAL) {
                        actions.push(TOUCH_ACTION_PAN_X);
                    }
                    return actions;
                },

                directionTest: function (input) {
                    var options = this.options;
                    var hasMoved = true;
                    var distance = input.distance;
                    var direction = input.direction;
                    var x = input.deltaX;
                    var y = input.deltaY;

                    // lock to axis?
                    if (!(direction & options.direction)) {
                        if (options.direction & DIRECTION_HORIZONTAL) {
                            direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;
                            hasMoved = x != this.pX;
                            distance = Math.abs(input.deltaX);
                        } else {
                            direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;
                            hasMoved = y != this.pY;
                            distance = Math.abs(input.deltaY);
                        }
                    }
                    input.direction = direction;
                    return hasMoved && distance > options.threshold && direction & options.direction;
                },

                attrTest: function (input) {
                    return AttrRecognizer.prototype.attrTest.call(this, input) &&
                        (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));
                },

                emit: function (input) {

                    this.pX = input.deltaX;
                    this.pY = input.deltaY;

                    var direction = directionStr(input.direction);

                    if (direction) {
                        input.additionalEvent = this.options.event + direction;
                    }
                    this._super.emit.call(this, input);
                }
            });

            /**
             * Pinch
             * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
             * @constructor
             * @extends AttrRecognizer
             */
            function PinchRecognizer() {
                AttrRecognizer.apply(this, arguments);
            }

            inherit(PinchRecognizer, AttrRecognizer, {
                /**
                 * @namespace
                 * @memberof PinchRecognizer
                 */
                defaults: {
                    event: 'pinch',
                    threshold: 0,
                    pointers: 2
                },

                getTouchAction: function () {
                    return [TOUCH_ACTION_NONE];
                },

                attrTest: function (input) {
                    return this._super.attrTest.call(this, input) &&
                        (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
                },

                emit: function (input) {
                    if (input.scale !== 1) {
                        var inOut = input.scale < 1 ? 'in' : 'out';
                        input.additionalEvent = this.options.event + inOut;
                    }
                    this._super.emit.call(this, input);
                }
            });

            /**
             * Press
             * Recognized when the pointer is down for x ms without any movement.
             * @constructor
             * @extends Recognizer
             */
            function PressRecognizer() {
                Recognizer.apply(this, arguments);

                this._timer = null;
                this._input = null;
            }

            inherit(PressRecognizer, Recognizer, {
                /**
                 * @namespace
                 * @memberof PressRecognizer
                 */
                defaults: {
                    event: 'press',
                    pointers: 1,
                    time: 251, // minimal time of the pointer to be pressed
                    threshold: 9 // a minimal movement is ok, but keep it low
                },

                getTouchAction: function () {
                    return [TOUCH_ACTION_AUTO];
                },

                process: function (input) {
                    var options = this.options;
                    var validPointers = input.pointers.length === options.pointers;
                    var validMovement = input.distance < options.threshold;
                    var validTime = input.deltaTime > options.time;

                    this._input = input;

                    // we only allow little movement
                    // and we've reached an end event, so a tap is possible
                    if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {
                        this.reset();
                    } else if (input.eventType & INPUT_START) {
                        this.reset();
                        this._timer = setTimeoutContext(function () {
                            this.state = STATE_RECOGNIZED;
                            this.tryEmit();
                        }, options.time, this);
                    } else if (input.eventType & INPUT_END) {
                        return STATE_RECOGNIZED;
                    }
                    return STATE_FAILED;
                },

                reset: function () {
                    clearTimeout(this._timer);
                },

                emit: function (input) {
                    if (this.state !== STATE_RECOGNIZED) {
                        return;
                    }

                    if (input && (input.eventType & INPUT_END)) {
                        this.manager.emit(this.options.event + 'up', input);
                    } else {
                        this._input.timeStamp = now();
                        this.manager.emit(this.options.event, this._input);
                    }
                }
            });

            /**
             * Rotate
             * Recognized when two or more pointer are moving in a circular motion.
             * @constructor
             * @extends AttrRecognizer
             */
            function RotateRecognizer() {
                AttrRecognizer.apply(this, arguments);
            }

            inherit(RotateRecognizer, AttrRecognizer, {
                /**
                 * @namespace
                 * @memberof RotateRecognizer
                 */
                defaults: {
                    event: 'rotate',
                    threshold: 0,
                    pointers: 2
                },

                getTouchAction: function () {
                    return [TOUCH_ACTION_NONE];
                },

                attrTest: function (input) {
                    return this._super.attrTest.call(this, input) &&
                        (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
                }
            });

            /**
             * Swipe
             * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
             * @constructor
             * @extends AttrRecognizer
             */
            function SwipeRecognizer() {
                AttrRecognizer.apply(this, arguments);
            }

            inherit(SwipeRecognizer, AttrRecognizer, {
                /**
                 * @namespace
                 * @memberof SwipeRecognizer
                 */
                defaults: {
                    event: 'swipe',
                    threshold: 10,
                    velocity: 0.3,
                    direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
                    pointers: 1
                },

                getTouchAction: function () {
                    return PanRecognizer.prototype.getTouchAction.call(this);
                },

                attrTest: function (input) {
                    var direction = this.options.direction;
                    var velocity;

                    if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
                        velocity = input.overallVelocity;
                    } else if (direction & DIRECTION_HORIZONTAL) {
                        velocity = input.overallVelocityX;
                    } else if (direction & DIRECTION_VERTICAL) {
                        velocity = input.overallVelocityY;
                    }

                    return this._super.attrTest.call(this, input) &&
                        direction & input.offsetDirection &&
                        input.distance > this.options.threshold &&
                        input.maxPointers == this.options.pointers &&
                        abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
                },

                emit: function (input) {
                    var direction = directionStr(input.offsetDirection);
                    if (direction) {
                        this.manager.emit(this.options.event + direction, input);
                    }

                    this.manager.emit(this.options.event, input);
                }
            });

            /**
             * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
             * between the given interval and position. The delay option can be used to recognize multi-taps without firing
             * a single tap.
             *
             * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
             * multi-taps being recognized.
             * @constructor
             * @extends Recognizer
             */
            function TapRecognizer() {
                Recognizer.apply(this, arguments);

                // previous time and center,
                // used for tap counting
                this.pTime = false;
                this.pCenter = false;

                this._timer = null;
                this._input = null;
                this.count = 0;
            }

            inherit(TapRecognizer, Recognizer, {
                /**
                 * @namespace
                 * @memberof PinchRecognizer
                 */
                defaults: {
                    event: 'tap',
                    pointers: 1,
                    taps: 1,
                    interval: 300, // max time between the multi-tap taps
                    time: 250, // max time of the pointer to be down (like finger on the screen)
                    threshold: 9, // a minimal movement is ok, but keep it low
                    posThreshold: 10 // a multi-tap can be a bit off the initial position
                },

                getTouchAction: function () {
                    return [TOUCH_ACTION_MANIPULATION];
                },

                process: function (input) {
                    var options = this.options;

                    var validPointers = input.pointers.length === options.pointers;
                    var validMovement = input.distance < options.threshold;
                    var validTouchTime = input.deltaTime < options.time;

                    this.reset();

                    if ((input.eventType & INPUT_START) && (this.count === 0)) {
                        return this.failTimeout();
                    }

                    // we only allow little movement
                    // and we've reached an end event, so a tap is possible
                    if (validMovement && validTouchTime && validPointers) {
                        if (input.eventType != INPUT_END) {
                            return this.failTimeout();
                        }

                        var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;
                        var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;

                        this.pTime = input.timeStamp;
                        this.pCenter = input.center;

                        if (!validMultiTap || !validInterval) {
                            this.count = 1;
                        } else {
                            this.count += 1;
                        }

                        this._input = input;

                        // if tap count matches we have recognized it,
                        // else it has began recognizing...
                        var tapCount = this.count % options.taps;
                        if (tapCount === 0) {
                            // no failing requirements, immediately trigger the tap event
                            // or wait as long as the multitap interval to trigger
                            if (!this.hasRequireFailures()) {
                                return STATE_RECOGNIZED;
                            } else {
                                this._timer = setTimeoutContext(function () {
                                    this.state = STATE_RECOGNIZED;
                                    this.tryEmit();
                                }, options.interval, this);
                                return STATE_BEGAN;
                            }
                        }
                    }
                    return STATE_FAILED;
                },

                failTimeout: function () {
                    this._timer = setTimeoutContext(function () {
                        this.state = STATE_FAILED;
                    }, this.options.interval, this);
                    return STATE_FAILED;
                },

                reset: function () {
                    clearTimeout(this._timer);
                },

                emit: function () {
                    if (this.state == STATE_RECOGNIZED) {
                        this._input.tapCount = this.count;
                        this.manager.emit(this.options.event, this._input);
                    }
                }
            });

            /**
             * Simple way to create a manager with a default set of recognizers.
             * @param {HTMLElement} element
             * @param {Object} [options]
             * @constructor
             */
            function Hammer(element, options) {
                options = options || {};
                options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
                return new Manager(element, options);
            }

            /**
             * @const {string}
             */
            Hammer.VERSION = '2.0.7';

            /**
             * default settings
             * @namespace
             */
            Hammer.defaults = {
                /**
                 * set if DOM events are being triggered.
                 * But this is slower and unused by simple implementations, so disabled by default.
                 * @type {Boolean}
                 * @default false
                 */
                domEvents: false,

                /**
                 * The value for the touchAction property/fallback.
                 * When set to `compute` it will magically set the correct value based on the added recognizers.
                 * @type {String}
                 * @default compute
                 */
                touchAction: TOUCH_ACTION_COMPUTE,

                /**
                 * @type {Boolean}
                 * @default true
                 */
                enable: true,

                /**
                 * EXPERIMENTAL FEATURE -- can be removed/changed
                 * Change the parent input target element.
                 * If Null, then it is being set the to main element.
                 * @type {Null|EventTarget}
                 * @default null
                 */
                inputTarget: null,

                /**
                 * force an input class
                 * @type {Null|Function}
                 * @default null
                 */
                inputClass: null,

                /**
                 * Default recognizer setup when calling `Hammer()`
                 * When creating a new Manager these will be skipped.
                 * @type {Array}
                 */
                preset: [
                    // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
                    [RotateRecognizer, { enable: false }],
                    [PinchRecognizer, { enable: false }, ['rotate']],
                    [SwipeRecognizer, { direction: DIRECTION_HORIZONTAL }],
                    [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ['swipe']],
                    [TapRecognizer],
                    [TapRecognizer, { event: 'doubletap', taps: 2 }, ['tap']],
                    [PressRecognizer]
                ],

                /**
                 * Some CSS properties can be used to improve the working of Hammer.
                 * Add them to this method and they will be set when creating a new Manager.
                 * @namespace
                 */
                cssProps: {
                    /**
                     * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
                     * @type {String}
                     * @default 'none'
                     */
                    userSelect: 'none',

                    /**
                     * Disable the Windows Phone grippers when pressing an element.
                     * @type {String}
                     * @default 'none'
                     */
                    touchSelect: 'none',

                    /**
                     * Disables the default callout shown when you touch and hold a touch target.
                     * On iOS, when you touch and hold a touch target such as a link, Safari displays
                     * a callout containing information about the link. This property allows you to disable that callout.
                     * @type {String}
                     * @default 'none'
                     */
                    touchCallout: 'none',

                    /**
                     * Specifies whether zooming is enabled. Used by IE10>
                     * @type {String}
                     * @default 'none'
                     */
                    contentZooming: 'none',

                    /**
                     * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
                     * @type {String}
                     * @default 'none'
                     */
                    userDrag: 'none',

                    /**
                     * Overrides the highlight color shown when the user taps a link or a JavaScript
                     * clickable element in iOS. This property obeys the alpha value, if specified.
                     * @type {String}
                     * @default 'rgba(0,0,0,0)'
                     */
                    tapHighlightColor: 'rgba(0,0,0,0)'
                }
            };

            var STOP = 1;
            var FORCED_STOP = 2;

            /**
             * Manager
             * @param {HTMLElement} element
             * @param {Object} [options]
             * @constructor
             */
            function Manager(element, options) {
                this.options = assign({}, Hammer.defaults, options || {});

                this.options.inputTarget = this.options.inputTarget || element;

                this.handlers = {};
                this.session = {};
                this.recognizers = [];
                this.oldCssProps = {};

                this.element = element;
                this.input = createInputInstance(this);
                this.touchAction = new TouchAction(this, this.options.touchAction);

                toggleCssProps(this, true);

                each(this.options.recognizers, function (item) {
                    var recognizer = this.add(new (item[0])(item[1]));
                    item[2] && recognizer.recognizeWith(item[2]);
                    item[3] && recognizer.requireFailure(item[3]);
                }, this);
            }

            Manager.prototype = {
                /**
                 * set options
                 * @param {Object} options
                 * @returns {Manager}
                 */
                set: function (options) {
                    assign(this.options, options);

                    // Options that need a little more setup
                    if (options.touchAction) {
                        this.touchAction.update();
                    }
                    if (options.inputTarget) {
                        // Clean up existing event listeners and reinitialize
                        this.input.destroy();
                        this.input.target = options.inputTarget;
                        this.input.init();
                    }
                    return this;
                },

                /**
                 * stop recognizing for this session.
                 * This session will be discarded, when a new [input]start event is fired.
                 * When forced, the recognizer cycle is stopped immediately.
                 * @param {Boolean} [force]
                 */
                stop: function (force) {
                    this.session.stopped = force ? FORCED_STOP : STOP;
                },

                /**
                 * run the recognizers!
                 * called by the inputHandler function on every movement of the pointers (touches)
                 * it walks through all the recognizers and tries to detect the gesture that is being made
                 * @param {Object} inputData
                 */
                recognize: function (inputData) {
                    var session = this.session;
                    if (session.stopped) {
                        return;
                    }

                    // run the touch-action polyfill
                    this.touchAction.preventDefaults(inputData);

                    var recognizer;
                    var recognizers = this.recognizers;

                    // this holds the recognizer that is being recognized.
                    // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
                    // if no recognizer is detecting a thing, it is set to `null`
                    var curRecognizer = session.curRecognizer;

                    // reset when the last recognizer is recognized
                    // or when we're in a new session
                    if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {
                        curRecognizer = session.curRecognizer = null;
                    }

                    var i = 0;
                    while (i < recognizers.length) {
                        recognizer = recognizers[i];

                        // find out if we are allowed try to recognize the input for this one.
                        // 1.   allow if the session is NOT forced stopped (see the .stop() method)
                        // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
                        //      that is being recognized.
                        // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
                        //      this can be setup with the `recognizeWith()` method on the recognizer.
                        if (session.stopped !== FORCED_STOP && ( // 1
                            !curRecognizer || recognizer == curRecognizer || // 2
                            recognizer.canRecognizeWith(curRecognizer))) { // 3
                            recognizer.recognize(inputData);
                        } else {
                            recognizer.reset();
                        }

                        // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
                        // current active recognizer. but only if we don't already have an active recognizer
                        if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                            curRecognizer = session.curRecognizer = recognizer;
                        }
                        i++;
                    }
                },

                /**
                 * get a recognizer by its event name.
                 * @param {Recognizer|String} recognizer
                 * @returns {Recognizer|Null}
                 */
                get: function (recognizer) {
                    if (recognizer instanceof Recognizer) {
                        return recognizer;
                    }

                    var recognizers = this.recognizers;
                    for (var i = 0; i < recognizers.length; i++) {
                        if (recognizers[i].options.event == recognizer) {
                            return recognizers[i];
                        }
                    }
                    return null;
                },

                /**
                 * add a recognizer to the manager
                 * existing recognizers with the same event name will be removed
                 * @param {Recognizer} recognizer
                 * @returns {Recognizer|Manager}
                 */
                add: function (recognizer) {
                    if (invokeArrayArg(recognizer, 'add', this)) {
                        return this;
                    }

                    // remove existing
                    var existing = this.get(recognizer.options.event);
                    if (existing) {
                        this.remove(existing);
                    }

                    this.recognizers.push(recognizer);
                    recognizer.manager = this;

                    this.touchAction.update();
                    return recognizer;
                },

                /**
                 * remove a recognizer by name or instance
                 * @param {Recognizer|String} recognizer
                 * @returns {Manager}
                 */
                remove: function (recognizer) {
                    if (invokeArrayArg(recognizer, 'remove', this)) {
                        return this;
                    }

                    recognizer = this.get(recognizer);

                    // let's make sure this recognizer exists
                    if (recognizer) {
                        var recognizers = this.recognizers;
                        var index = inArray(recognizers, recognizer);

                        if (index !== -1) {
                            recognizers.splice(index, 1);
                            this.touchAction.update();
                        }
                    }

                    return this;
                },

                /**
                 * bind event
                 * @param {String} events
                 * @param {Function} handler
                 * @returns {EventEmitter} this
                 */
                on: function (events, handler) {
                    if (events === undefined) {
                        return;
                    }
                    if (handler === undefined) {
                        return;
                    }

                    var handlers = this.handlers;
                    each(splitStr(events), function (event) {
                        handlers[event] = handlers[event] || [];
                        handlers[event].push(handler);
                    });
                    return this;
                },

                /**
                 * unbind event, leave emit blank to remove all handlers
                 * @param {String} events
                 * @param {Function} [handler]
                 * @returns {EventEmitter} this
                 */
                off: function (events, handler) {
                    if (events === undefined) {
                        return;
                    }

                    var handlers = this.handlers;
                    each(splitStr(events), function (event) {
                        if (!handler) {
                            delete handlers[event];
                        } else {
                            handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
                        }
                    });
                    return this;
                },

                /**
                 * emit event to the listeners
                 * @param {String} event
                 * @param {Object} data
                 */
                emit: function (event, data) {
                    // we also want to trigger dom events
                    if (this.options.domEvents) {
                        triggerDomEvent(event, data);
                    }

                    // no handlers, so skip it all
                    var handlers = this.handlers[event] && this.handlers[event].slice();
                    if (!handlers || !handlers.length) {
                        return;
                    }

                    data.type = event;
                    data.preventDefault = function () {
                        data.srcEvent.preventDefault();
                    };

                    var i = 0;
                    while (i < handlers.length) {
                        handlers[i](data);
                        i++;
                    }
                },

                /**
                 * destroy the manager and unbinds all events
                 * it doesn't unbind dom events, that is the user own responsibility
                 */
                destroy: function () {
                    this.element && toggleCssProps(this, false);

                    this.handlers = {};
                    this.session = {};
                    this.input.destroy();
                    this.element = null;
                }
            };

            /**
             * add/remove the css properties as defined in manager.options.cssProps
             * @param {Manager} manager
             * @param {Boolean} add
             */
            function toggleCssProps(manager, add) {
                var element = manager.element;
                if (!element.style) {
                    return;
                }
                var prop;
                each(manager.options.cssProps, function (value, name) {
                    prop = prefixed(element.style, name);
                    if (add) {
                        manager.oldCssProps[prop] = element.style[prop];
                        element.style[prop] = value;
                    } else {
                        element.style[prop] = manager.oldCssProps[prop] || '';
                    }
                });
                if (!add) {
                    manager.oldCssProps = {};
                }
            }

            /**
             * trigger dom event
             * @param {String} event
             * @param {Object} data
             */
            function triggerDomEvent(event, data) {
                var gestureEvent = document.createEvent('Event');
                gestureEvent.initEvent(event, true, true);
                gestureEvent.gesture = data;
                data.target.dispatchEvent(gestureEvent);
            }

            assign(Hammer, {
                INPUT_START: INPUT_START,
                INPUT_MOVE: INPUT_MOVE,
                INPUT_END: INPUT_END,
                INPUT_CANCEL: INPUT_CANCEL,

                STATE_POSSIBLE: STATE_POSSIBLE,
                STATE_BEGAN: STATE_BEGAN,
                STATE_CHANGED: STATE_CHANGED,
                STATE_ENDED: STATE_ENDED,
                STATE_RECOGNIZED: STATE_RECOGNIZED,
                STATE_CANCELLED: STATE_CANCELLED,
                STATE_FAILED: STATE_FAILED,

                DIRECTION_NONE: DIRECTION_NONE,
                DIRECTION_LEFT: DIRECTION_LEFT,
                DIRECTION_RIGHT: DIRECTION_RIGHT,
                DIRECTION_UP: DIRECTION_UP,
                DIRECTION_DOWN: DIRECTION_DOWN,
                DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
                DIRECTION_VERTICAL: DIRECTION_VERTICAL,
                DIRECTION_ALL: DIRECTION_ALL,

                Manager: Manager,
                Input: Input,
                TouchAction: TouchAction,

                TouchInput: TouchInput,
                MouseInput: MouseInput,
                PointerEventInput: PointerEventInput,
                TouchMouseInput: TouchMouseInput,
                SingleTouchInput: SingleTouchInput,

                Recognizer: Recognizer,
                AttrRecognizer: AttrRecognizer,
                Tap: TapRecognizer,
                Pan: PanRecognizer,
                Swipe: SwipeRecognizer,
                Pinch: PinchRecognizer,
                Rotate: RotateRecognizer,
                Press: PressRecognizer,

                on: addEventListeners,
                off: removeEventListeners,
                each: each,
                merge: merge,
                extend: extend,
                assign: assign,
                inherit: inherit,
                bindFn: bindFn,
                prefixed: prefixed
            });

            // this prevents errors when Hammer is loaded in the presence of an AMD
            //  style loader but by script tag, not by the loader.
            var freeGlobal = (typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : {})); // jshint ignore:line
            freeGlobal.Hammer = Hammer;

            if (typeof define === 'function' && define.amd) {
                define(function () {
                    return Hammer;
                });
            } else if (typeof module != 'undefined' && module.exports) {
                module.exports = Hammer;
            } else {
                window[exportName] = Hammer;
            }

        })(window, document, 'Hammer');

    }, {}], 287: [function (require, module, exports) {
        var hat = module.exports = function (bits, base) {
            if (!base) base = 16;
            if (bits === undefined) bits = 128;
            if (bits <= 0) return '0';

            var digits = Math.log(Math.pow(2, bits)) / Math.log(base);
            for (var i = 2; digits === Infinity; i *= 2) {
                digits = Math.log(Math.pow(2, bits / i)) / Math.log(base) * i;
            }

            var rem = digits - Math.floor(digits);

            var res = '';

            for (var i = 0; i < Math.floor(digits); i++) {
                var x = Math.floor(Math.random() * base).toString(base);
                res = x + res;
            }

            if (rem) {
                var b = Math.pow(base, rem);
                var x = Math.floor(Math.random() * b).toString(base);
                res = x + res;
            }

            var parsed = parseInt(res, base);
            if (parsed !== Infinity && parsed >= Math.pow(2, bits)) {
                return hat(bits, base)
            }
            else return res;
        };

        hat.rack = function (bits, base, expandBy) {
            var fn = function (data) {
                var iters = 0;
                do {
                    if (iters++ > 10) {
                        if (expandBy) bits += expandBy;
                        else throw new Error('too many ID collisions, use more bits')
                    }

                    var id = hat(bits, base);
                } while (Object.hasOwnProperty.call(hats, id));

                hats[id] = data;
                return id;
            };
            var hats = fn.hats = {};

            fn.get = function (id) {
                return fn.hats[id];
            };

            fn.set = function (id, value) {
                fn.hats[id] = value;
                return fn;
            };

            fn.bits = bits || 128;
            fn.base = base || 16;
            return fn;
        };

    }, {}], 288: [function (require, module, exports) {
        'use strict';

        var hat = require('hat');


        /**
         * Create a new id generator / cache instance.
         *
         * You may optionally provide a seed that is used internally.
         *
         * @param {Seed} seed
         */
        function Ids(seed) {

            if (!(this instanceof Ids)) {
                return new Ids(seed);
            }

            seed = seed || [128, 36, 1];
            this._seed = seed.length ? hat.rack(seed[0], seed[1], seed[2]) : seed;
        }

        module.exports = Ids;

        /**
         * Generate a next id.
         *
         * @param {Object} [element] element to bind the id to
         *
         * @return {String} id
         */
        Ids.prototype.next = function (element) {
            return this._seed(element || true);
        };

        /**
         * Generate a next id with a given prefix.
         *
         * @param {Object} [element] element to bind the id to
         *
         * @return {String} id
         */
        Ids.prototype.nextPrefixed = function (prefix, element) {
            var id;

            do {
                id = prefix + this.next(true);
            } while (this.assigned(id));

            // claim {prefix}{random}
            this.claim(id, element);

            // return
            return id;
        };

        /**
         * Manually claim an existing id.
         *
         * @param {String} id
         * @param {String} [element] element the id is claimed by
         */
        Ids.prototype.claim = function (id, element) {
            this._seed.set(id, element || true);
        };

        /**
         * Returns true if the given id has already been assigned.
         *
         * @param  {String} id
         * @return {Boolean}
         */
        Ids.prototype.assigned = function (id) {
            return this._seed.get(id) || false;
        };

        /**
         * Unclaim an id.
         *
         * @param  {String} id the id to unclaim
         */
        Ids.prototype.unclaim = function (id) {
            delete this._seed.hats[id];
        };


        /**
         * Clear all claimed ids.
         */
        Ids.prototype.clear = function () {

            var hats = this._seed.hats,
                id;

            for (id in hats) {
                this.unclaim(id);
            }
        };
    }, { "hat": 287 }], 289: [function (require, module, exports) {
        if (typeof Object.create === 'function') {
            // implementation from standard node.js 'util' module
            module.exports = function inherits(ctor, superCtor) {
                ctor.super_ = superCtor
                ctor.prototype = Object.create(superCtor.prototype, {
                    constructor: {
                        value: ctor,
                        enumerable: false,
                        writable: true,
                        configurable: true
                    }
                });
            };
        } else {
            // old school shim for old browsers
            module.exports = function inherits(ctor, superCtor) {
                ctor.super_ = superCtor
                var TempCtor = function () { }
                TempCtor.prototype = superCtor.prototype
                ctor.prototype = new TempCtor()
                ctor.prototype.constructor = ctor
            }
        }

    }, {}], 290: [function (require, module, exports) {
        /*!
         * jQuery JavaScript Library v2.2.4
         * http://jquery.com/
         *
         * Includes Sizzle.js
         * http://sizzlejs.com/
         *
         * Copyright jQuery Foundation and other contributors
         * Released under the MIT license
         * http://jquery.org/license
         *
         * Date: 2016-05-20T17:23Z
         */

        (function (global, factory) {

            if (typeof module === "object" && typeof module.exports === "object") {
                // For CommonJS and CommonJS-like environments where a proper `window`
                // is present, execute the factory and get jQuery.
                // For environments that do not have a `window` with a `document`
                // (such as Node.js), expose a factory as module.exports.
                // This accentuates the need for the creation of a real `window`.
                // e.g. var jQuery = require("jquery")(window);
                // See ticket #14549 for more info.
                module.exports = global.document ?
                    factory(global, true) :
                    function (w) {
                        if (!w.document) {
                            throw new Error("jQuery requires a window with a document");
                        }
                        return factory(w);
                    };
            } else {
                factory(global);
            }

            // Pass this if window is not defined yet
        }(typeof window !== "undefined" ? window : this, function (window, noGlobal) {

            // Support: Firefox 18+
            // Can't be in strict mode, several libs including ASP.NET trace
            // the stack via arguments.caller.callee and Firefox dies if
            // you try to trace through "use strict" call chains. (#13335)
            //"use strict";
            var arr = [];

            var document = window.document;

            var slice = arr.slice;

            var concat = arr.concat;

            var push = arr.push;

            var indexOf = arr.indexOf;

            var class2type = {};

            var toString = class2type.toString;

            var hasOwn = class2type.hasOwnProperty;

            var support = {};



            var
                version = "2.2.4",

                // Define a local copy of jQuery
                jQuery = function (selector, context) {

                    // The jQuery object is actually just the init constructor 'enhanced'
                    // Need init if jQuery is called (just allow error to be thrown if not included)
                    return new jQuery.fn.init(selector, context);
                },

                // Support: Android<4.1
                // Make sure we trim BOM and NBSP
                rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

                // Matches dashed string for camelizing
                rmsPrefix = /^-ms-/,
                rdashAlpha = /-([\da-z])/gi,

                // Used by jQuery.camelCase as callback to replace()
                fcamelCase = function (all, letter) {
                    return letter.toUpperCase();
                };

            jQuery.fn = jQuery.prototype = {

                // The current version of jQuery being used
                jquery: version,

                constructor: jQuery,

                // Start with an empty selector
                selector: "",

                // The default length of a jQuery object is 0
                length: 0,

                toArray: function () {
                    return slice.call(this);
                },

                // Get the Nth element in the matched element set OR
                // Get the whole matched element set as a clean array
                get: function (num) {
                    return num != null ?

                        // Return just the one element from the set
                        (num < 0 ? this[num + this.length] : this[num]) :

                        // Return all the elements in a clean array
                        slice.call(this);
                },

                // Take an array of elements and push it onto the stack
                // (returning the new matched element set)
                pushStack: function (elems) {

                    // Build a new jQuery matched element set
                    var ret = jQuery.merge(this.constructor(), elems);

                    // Add the old object onto the stack (as a reference)
                    ret.prevObject = this;
                    ret.context = this.context;

                    // Return the newly-formed element set
                    return ret;
                },

                // Execute a callback for every element in the matched set.
                each: function (callback) {
                    return jQuery.each(this, callback);
                },

                map: function (callback) {
                    return this.pushStack(jQuery.map(this, function (elem, i) {
                        return callback.call(elem, i, elem);
                    }));
                },

                slice: function () {
                    return this.pushStack(slice.apply(this, arguments));
                },

                first: function () {
                    return this.eq(0);
                },

                last: function () {
                    return this.eq(-1);
                },

                eq: function (i) {
                    var len = this.length,
                        j = +i + (i < 0 ? len : 0);
                    return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
                },

                end: function () {
                    return this.prevObject || this.constructor();
                },

                // For internal use only.
                // Behaves like an Array's method, not like a jQuery method.
                push: push,
                sort: arr.sort,
                splice: arr.splice
            };

            jQuery.extend = jQuery.fn.extend = function () {
                var options, name, src, copy, copyIsArray, clone,
                    target = arguments[0] || {},
                    i = 1,
                    length = arguments.length,
                    deep = false;

                // Handle a deep copy situation
                if (typeof target === "boolean") {
                    deep = target;

                    // Skip the boolean and the target
                    target = arguments[i] || {};
                    i++;
                }

                // Handle case when target is a string or something (possible in deep copy)
                if (typeof target !== "object" && !jQuery.isFunction(target)) {
                    target = {};
                }

                // Extend jQuery itself if only one argument is passed
                if (i === length) {
                    target = this;
                    i--;
                }

                for (; i < length; i++) {

                    // Only deal with non-null/undefined values
                    if ((options = arguments[i]) != null) {

                        // Extend the base object
                        for (name in options) {
                            src = target[name];
                            copy = options[name];

                            // Prevent never-ending loop
                            if (target === copy) {
                                continue;
                            }

                            // Recurse if we're merging plain objects or arrays
                            if (deep && copy && (jQuery.isPlainObject(copy) ||
                                (copyIsArray = jQuery.isArray(copy)))) {

                                if (copyIsArray) {
                                    copyIsArray = false;
                                    clone = src && jQuery.isArray(src) ? src : [];

                                } else {
                                    clone = src && jQuery.isPlainObject(src) ? src : {};
                                }

                                // Never move original objects, clone them
                                target[name] = jQuery.extend(deep, clone, copy);

                                // Don't bring in undefined values
                            } else if (copy !== undefined) {
                                target[name] = copy;
                            }
                        }
                    }
                }

                // Return the modified object
                return target;
            };

            jQuery.extend({

                // Unique for each copy of jQuery on the page
                expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),

                // Assume jQuery is ready without the ready module
                isReady: true,

                error: function (msg) {
                    throw new Error(msg);
                },

                noop: function () { },

                isFunction: function (obj) {
                    return jQuery.type(obj) === "function";
                },

                isArray: Array.isArray,

                isWindow: function (obj) {
                    return obj != null && obj === obj.window;
                },

                isNumeric: function (obj) {

                    // parseFloat NaNs numeric-cast false positives (null|true|false|"")
                    // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
                    // subtraction forces infinities to NaN
                    // adding 1 corrects loss of precision from parseFloat (#15100)
                    var realStringObj = obj && obj.toString();
                    return !jQuery.isArray(obj) && (realStringObj - parseFloat(realStringObj) + 1) >= 0;
                },

                isPlainObject: function (obj) {
                    var key;

                    // Not plain objects:
                    // - Any object or value whose internal [[Class]] property is not "[object Object]"
                    // - DOM nodes
                    // - window
                    if (jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow(obj)) {
                        return false;
                    }

                    // Not own constructor property must be Object
                    if (obj.constructor &&
                        !hasOwn.call(obj, "constructor") &&
                        !hasOwn.call(obj.constructor.prototype || {}, "isPrototypeOf")) {
                        return false;
                    }

                    // Own properties are enumerated firstly, so to speed up,
                    // if last one is own, then all properties are own
                    for (key in obj) { }

                    return key === undefined || hasOwn.call(obj, key);
                },

                isEmptyObject: function (obj) {
                    var name;
                    for (name in obj) {
                        return false;
                    }
                    return true;
                },

                type: function (obj) {
                    if (obj == null) {
                        return obj + "";
                    }

                    // Support: Android<4.0, iOS<6 (functionish RegExp)
                    return typeof obj === "object" || typeof obj === "function" ?
                        class2type[toString.call(obj)] || "object" :
                        typeof obj;
                },

                // Evaluates a script in a global context
                globalEval: function (code) {
                    var script,
                        indirect = eval;

                    code = jQuery.trim(code);

                    if (code) {

                        // If the code includes a valid, prologue position
                        // strict mode pragma, execute code by injecting a
                        // script tag into the document.
                        if (code.indexOf("use strict") === 1) {
                            script = document.createElement("script");
                            script.text = code;
                            document.head.appendChild(script).parentNode.removeChild(script);
                        } else {

                            // Otherwise, avoid the DOM node creation, insertion
                            // and removal by using an indirect global eval

                            indirect(code);
                        }
                    }
                },

                // Convert dashed to camelCase; used by the css and data modules
                // Support: IE9-11+
                // Microsoft forgot to hump their vendor prefix (#9572)
                camelCase: function (string) {
                    return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
                },

                nodeName: function (elem, name) {
                    return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
                },

                each: function (obj, callback) {
                    var length, i = 0;

                    if (isArrayLike(obj)) {
                        length = obj.length;
                        for (; i < length; i++) {
                            if (callback.call(obj[i], i, obj[i]) === false) {
                                break;
                            }
                        }
                    } else {
                        for (i in obj) {
                            if (callback.call(obj[i], i, obj[i]) === false) {
                                break;
                            }
                        }
                    }

                    return obj;
                },

                // Support: Android<4.1
                trim: function (text) {
                    return text == null ?
                        "" :
                        (text + "").replace(rtrim, "");
                },

                // results is for internal usage only
                makeArray: function (arr, results) {
                    var ret = results || [];

                    if (arr != null) {
                        if (isArrayLike(Object(arr))) {
                            jQuery.merge(ret,
                                typeof arr === "string" ?
                                    [arr] : arr
                            );
                        } else {
                            push.call(ret, arr);
                        }
                    }

                    return ret;
                },

                inArray: function (elem, arr, i) {
                    return arr == null ? -1 : indexOf.call(arr, elem, i);
                },

                merge: function (first, second) {
                    var len = +second.length,
                        j = 0,
                        i = first.length;

                    for (; j < len; j++) {
                        first[i++] = second[j];
                    }

                    first.length = i;

                    return first;
                },

                grep: function (elems, callback, invert) {
                    var callbackInverse,
                        matches = [],
                        i = 0,
                        length = elems.length,
                        callbackExpect = !invert;

                    // Go through the array, only saving the items
                    // that pass the validator function
                    for (; i < length; i++) {
                        callbackInverse = !callback(elems[i], i);
                        if (callbackInverse !== callbackExpect) {
                            matches.push(elems[i]);
                        }
                    }

                    return matches;
                },

                // arg is for internal usage only
                map: function (elems, callback, arg) {
                    var length, value,
                        i = 0,
                        ret = [];

                    // Go through the array, translating each of the items to their new values
                    if (isArrayLike(elems)) {
                        length = elems.length;
                        for (; i < length; i++) {
                            value = callback(elems[i], i, arg);

                            if (value != null) {
                                ret.push(value);
                            }
                        }

                        // Go through every key on the object,
                    } else {
                        for (i in elems) {
                            value = callback(elems[i], i, arg);

                            if (value != null) {
                                ret.push(value);
                            }
                        }
                    }

                    // Flatten any nested arrays
                    return concat.apply([], ret);
                },

                // A global GUID counter for objects
                guid: 1,

                // Bind a function to a context, optionally partially applying any
                // arguments.
                proxy: function (fn, context) {
                    var tmp, args, proxy;

                    if (typeof context === "string") {
                        tmp = fn[context];
                        context = fn;
                        fn = tmp;
                    }

                    // Quick check to determine if target is callable, in the spec
                    // this throws a TypeError, but we will just return undefined.
                    if (!jQuery.isFunction(fn)) {
                        return undefined;
                    }

                    // Simulated bind
                    args = slice.call(arguments, 2);
                    proxy = function () {
                        return fn.apply(context || this, args.concat(slice.call(arguments)));
                    };

                    // Set the guid of unique handler to the same of original handler, so it can be removed
                    proxy.guid = fn.guid = fn.guid || jQuery.guid++;

                    return proxy;
                },

                now: Date.now,

                // jQuery.support is not used in Core but other projects attach their
                // properties to it so it needs to exist.
                support: support
            });

            // JSHint would error on this code due to the Symbol not being defined in ES5.
            // Defining this global in .jshintrc would create a danger of using the global
            // unguarded in another place, it seems safer to just disable JSHint for these
            // three lines.
            /* jshint ignore: start */
            if (typeof Symbol === "function") {
                jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
            }
            /* jshint ignore: end */

            // Populate the class2type map
            jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),
                function (i, name) {
                    class2type["[object " + name + "]"] = name.toLowerCase();
                });

            function isArrayLike(obj) {

                // Support: iOS 8.2 (not reproducible in simulator)
                // `in` check used to prevent JIT error (gh-2145)
                // hasOwn isn't used here due to false negatives
                // regarding Nodelist length in IE
                var length = !!obj && "length" in obj && obj.length,
                    type = jQuery.type(obj);

                if (type === "function" || jQuery.isWindow(obj)) {
                    return false;
                }

                return type === "array" || length === 0 ||
                    typeof length === "number" && length > 0 && (length - 1) in obj;
            }
            var Sizzle =
                /*!
                 * Sizzle CSS Selector Engine v2.2.1
                 * http://sizzlejs.com/
                 *
                 * Copyright jQuery Foundation and other contributors
                 * Released under the MIT license
                 * http://jquery.org/license
                 *
                 * Date: 2015-10-17
                 */
                (function (window) {

                    var i,
                        support,
                        Expr,
                        getText,
                        isXML,
                        tokenize,
                        compile,
                        select,
                        outermostContext,
                        sortInput,
                        hasDuplicate,

                        // Local document vars
                        setDocument,
                        document,
                        docElem,
                        documentIsHTML,
                        rbuggyQSA,
                        rbuggyMatches,
                        matches,
                        contains,

                        // Instance-specific data
                        expando = "sizzle" + 1 * new Date(),
                        preferredDoc = window.document,
                        dirruns = 0,
                        done = 0,
                        classCache = createCache(),
                        tokenCache = createCache(),
                        compilerCache = createCache(),
                        sortOrder = function (a, b) {
                            if (a === b) {
                                hasDuplicate = true;
                            }
                            return 0;
                        },

                        // General-purpose constants
                        MAX_NEGATIVE = 1 << 31,

                        // Instance methods
                        hasOwn = ({}).hasOwnProperty,
                        arr = [],
                        pop = arr.pop,
                        push_native = arr.push,
                        push = arr.push,
                        slice = arr.slice,
                        // Use a stripped-down indexOf as it's faster than native
                        // http://jsperf.com/thor-indexof-vs-for/5
                        indexOf = function (list, elem) {
                            var i = 0,
                                len = list.length;
                            for (; i < len; i++) {
                                if (list[i] === elem) {
                                    return i;
                                }
                            }
                            return -1;
                        },

                        booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

                        // Regular expressions

                        // http://www.w3.org/TR/css3-selectors/#whitespace
                        whitespace = "[\\x20\\t\\r\\n\\f]",

                        // http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
                        identifier = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

                        // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
                        attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
                            // Operator (capture 2)
                            "*([*^$|!~]?=)" + whitespace +
                            // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
                            "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
                            "*\\]",

                        pseudos = ":(" + identifier + ")(?:\\((" +
                            // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
                            // 1. quoted (capture 3; capture 4 or capture 5)
                            "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
                            // 2. simple (capture 6)
                            "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
                            // 3. anything else (capture 2)
                            ".*" +
                            ")\\)|)",

                        // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
                        rwhitespace = new RegExp(whitespace + "+", "g"),
                        rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),

                        rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
                        rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),

                        rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"),

                        rpseudo = new RegExp(pseudos),
                        ridentifier = new RegExp("^" + identifier + "$"),

                        matchExpr = {
                            "ID": new RegExp("^#(" + identifier + ")"),
                            "CLASS": new RegExp("^\\.(" + identifier + ")"),
                            "TAG": new RegExp("^(" + identifier + "|[*])"),
                            "ATTR": new RegExp("^" + attributes),
                            "PSEUDO": new RegExp("^" + pseudos),
                            "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
                                "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
                                "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
                            "bool": new RegExp("^(?:" + booleans + ")$", "i"),
                            // For use in libraries implementing .is()
                            // We use this for POS matching in `select`
                            "needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
                                whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
                        },

                        rinputs = /^(?:input|select|textarea|button)$/i,
                        rheader = /^h\d$/i,

                        rnative = /^[^{]+\{\s*\[native \w/,

                        // Easily-parseable/retrievable ID or TAG or CLASS selectors
                        rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

                        rsibling = /[+~]/,
                        rescape = /'|\\/g,

                        // CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
                        runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"),
                        funescape = function (_, escaped, escapedWhitespace) {
                            var high = "0x" + escaped - 0x10000;
                            // NaN means non-codepoint
                            // Support: Firefox<24
                            // Workaround erroneous numeric interpretation of +"0x"
                            return high !== high || escapedWhitespace ?
                                escaped :
                                high < 0 ?
                                    // BMP codepoint
                                    String.fromCharCode(high + 0x10000) :
                                    // Supplemental Plane codepoint (surrogate pair)
                                    String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
                        },

                        // Used for iframes
                        // See setDocument()
                        // Removing the function wrapper causes a "Permission Denied"
                        // error in IE
                        unloadHandler = function () {
                            setDocument();
                        };

                    // Optimize for push.apply( _, NodeList )
                    try {
                        push.apply(
                            (arr = slice.call(preferredDoc.childNodes)),
                            preferredDoc.childNodes
                        );
                        // Support: Android<4.0
                        // Detect silently failing push.apply
                        arr[preferredDoc.childNodes.length].nodeType;
                    } catch (e) {
                        push = {
                            apply: arr.length ?

                                // Leverage slice if possible
                                function (target, els) {
                                    push_native.apply(target, slice.call(els));
                                } :

                                // Support: IE<9
                                // Otherwise append directly
                                function (target, els) {
                                    var j = target.length,
                                        i = 0;
                                    // Can't trust NodeList.length
                                    while ((target[j++] = els[i++])) { }
                                    target.length = j - 1;
                                }
                        };
                    }

                    function Sizzle(selector, context, results, seed) {
                        var m, i, elem, nid, nidselect, match, groups, newSelector,
                            newContext = context && context.ownerDocument,

                            // nodeType defaults to 9, since context defaults to document
                            nodeType = context ? context.nodeType : 9;

                        results = results || [];

                        // Return early from calls with invalid selector or context
                        if (typeof selector !== "string" || !selector ||
                            nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {

                            return results;
                        }

                        // Try to shortcut find operations (as opposed to filters) in HTML documents
                        if (!seed) {

                            if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
                                setDocument(context);
                            }
                            context = context || document;

                            if (documentIsHTML) {

                                // If the selector is sufficiently simple, try using a "get*By*" DOM method
                                // (excepting DocumentFragment context, where the methods don't exist)
                                if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {

                                    // ID selector
                                    if ((m = match[1])) {

                                        // Document context
                                        if (nodeType === 9) {
                                            if ((elem = context.getElementById(m))) {

                                                // Support: IE, Opera, Webkit
                                                // TODO: identify versions
                                                // getElementById can match elements by name instead of ID
                                                if (elem.id === m) {
                                                    results.push(elem);
                                                    return results;
                                                }
                                            } else {
                                                return results;
                                            }

                                            // Element context
                                        } else {

                                            // Support: IE, Opera, Webkit
                                            // TODO: identify versions
                                            // getElementById can match elements by name instead of ID
                                            if (newContext && (elem = newContext.getElementById(m)) &&
                                                contains(context, elem) &&
                                                elem.id === m) {

                                                results.push(elem);
                                                return results;
                                            }
                                        }

                                        // Type selector
                                    } else if (match[2]) {
                                        push.apply(results, context.getElementsByTagName(selector));
                                        return results;

                                        // Class selector
                                    } else if ((m = match[3]) && support.getElementsByClassName &&
                                        context.getElementsByClassName) {

                                        push.apply(results, context.getElementsByClassName(m));
                                        return results;
                                    }
                                }

                                // Take advantage of querySelectorAll
                                if (support.qsa &&
                                    !compilerCache[selector + " "] &&
                                    (!rbuggyQSA || !rbuggyQSA.test(selector))) {

                                    if (nodeType !== 1) {
                                        newContext = context;
                                        newSelector = selector;

                                        // qSA looks outside Element context, which is not what we want
                                        // Thanks to Andrew Dupont for this workaround technique
                                        // Support: IE <=8
                                        // Exclude object elements
                                    } else if (context.nodeName.toLowerCase() !== "object") {

                                        // Capture the context ID, setting it first if necessary
                                        if ((nid = context.getAttribute("id"))) {
                                            nid = nid.replace(rescape, "\\$&");
                                        } else {
                                            context.setAttribute("id", (nid = expando));
                                        }

                                        // Prefix every selector in the list
                                        groups = tokenize(selector);
                                        i = groups.length;
                                        nidselect = ridentifier.test(nid) ? "#" + nid : "[id='" + nid + "']";
                                        while (i--) {
                                            groups[i] = nidselect + " " + toSelector(groups[i]);
                                        }
                                        newSelector = groups.join(",");

                                        // Expand context for sibling selectors
                                        newContext = rsibling.test(selector) && testContext(context.parentNode) ||
                                            context;
                                    }

                                    if (newSelector) {
                                        try {
                                            push.apply(results,
                                                newContext.querySelectorAll(newSelector)
                                            );
                                            return results;
                                        } catch (qsaError) {
                                        } finally {
                                            if (nid === expando) {
                                                context.removeAttribute("id");
                                            }
                                        }
                                    }
                                }
                            }
                        }

                        // All others
                        return select(selector.replace(rtrim, "$1"), context, results, seed);
                    }

                    /**
                     * Create key-value caches of limited size
                     * @returns {function(string, object)} Returns the Object data after storing it on itself with
                     *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
                     *	deleting the oldest entry
                     */
                    function createCache() {
                        var keys = [];

                        function cache(key, value) {
                            // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
                            if (keys.push(key + " ") > Expr.cacheLength) {
                                // Only keep the most recent entries
                                delete cache[keys.shift()];
                            }
                            return (cache[key + " "] = value);
                        }
                        return cache;
                    }

                    /**
                     * Mark a function for special use by Sizzle
                     * @param {Function} fn The function to mark
                     */
                    function markFunction(fn) {
                        fn[expando] = true;
                        return fn;
                    }

                    /**
                     * Support testing using an element
                     * @param {Function} fn Passed the created div and expects a boolean result
                     */
                    function assert(fn) {
                        var div = document.createElement("div");

                        try {
                            return !!fn(div);
                        } catch (e) {
                            return false;
                        } finally {
                            // Remove from its parent by default
                            if (div.parentNode) {
                                div.parentNode.removeChild(div);
                            }
                            // release memory in IE
                            div = null;
                        }
                    }

                    /**
                     * Adds the same handler for all of the specified attrs
                     * @param {String} attrs Pipe-separated list of attributes
                     * @param {Function} handler The method that will be applied
                     */
                    function addHandle(attrs, handler) {
                        var arr = attrs.split("|"),
                            i = arr.length;

                        while (i--) {
                            Expr.attrHandle[arr[i]] = handler;
                        }
                    }

                    /**
                     * Checks document order of two siblings
                     * @param {Element} a
                     * @param {Element} b
                     * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
                     */
                    function siblingCheck(a, b) {
                        var cur = b && a,
                            diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
                                (~b.sourceIndex || MAX_NEGATIVE) -
                                (~a.sourceIndex || MAX_NEGATIVE);

                        // Use IE sourceIndex if available on both nodes
                        if (diff) {
                            return diff;
                        }

                        // Check if b follows a
                        if (cur) {
                            while ((cur = cur.nextSibling)) {
                                if (cur === b) {
                                    return -1;
                                }
                            }
                        }

                        return a ? 1 : -1;
                    }

                    /**
                     * Returns a function to use in pseudos for input types
                     * @param {String} type
                     */
                    function createInputPseudo(type) {
                        return function (elem) {
                            var name = elem.nodeName.toLowerCase();
                            return name === "input" && elem.type === type;
                        };
                    }

                    /**
                     * Returns a function to use in pseudos for buttons
                     * @param {String} type
                     */
                    function createButtonPseudo(type) {
                        return function (elem) {
                            var name = elem.nodeName.toLowerCase();
                            return (name === "input" || name === "button") && elem.type === type;
                        };
                    }

                    /**
                     * Returns a function to use in pseudos for positionals
                     * @param {Function} fn
                     */
                    function createPositionalPseudo(fn) {
                        return markFunction(function (argument) {
                            argument = +argument;
                            return markFunction(function (seed, matches) {
                                var j,
                                    matchIndexes = fn([], seed.length, argument),
                                    i = matchIndexes.length;

                                // Match elements found at the specified indexes
                                while (i--) {
                                    if (seed[(j = matchIndexes[i])]) {
                                        seed[j] = !(matches[j] = seed[j]);
                                    }
                                }
                            });
                        });
                    }

                    /**
                     * Checks a node for validity as a Sizzle context
                     * @param {Element|Object=} context
                     * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
                     */
                    function testContext(context) {
                        return context && typeof context.getElementsByTagName !== "undefined" && context;
                    }

                    // Expose support vars for convenience
                    support = Sizzle.support = {};

                    /**
                     * Detects XML nodes
                     * @param {Element|Object} elem An element or a document
                     * @returns {Boolean} True iff elem is a non-HTML XML node
                     */
                    isXML = Sizzle.isXML = function (elem) {
                        // documentElement is verified for cases where it doesn't yet exist
                        // (such as loading iframes in IE - #4833)
                        var documentElement = elem && (elem.ownerDocument || elem).documentElement;
                        return documentElement ? documentElement.nodeName !== "HTML" : false;
                    };

                    /**
                     * Sets document-related variables once based on the current document
                     * @param {Element|Object} [doc] An element or document object to use to set the document
                     * @returns {Object} Returns the current document
                     */
                    setDocument = Sizzle.setDocument = function (node) {
                        var hasCompare, parent,
                            doc = node ? node.ownerDocument || node : preferredDoc;

                        // Return early if doc is invalid or already selected
                        if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
                            return document;
                        }

                        // Update global variables
                        document = doc;
                        docElem = document.documentElement;
                        documentIsHTML = !isXML(document);

                        // Support: IE 9-11, Edge
                        // Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
                        if ((parent = document.defaultView) && parent.top !== parent) {
                            // Support: IE 11
                            if (parent.addEventListener) {
                                parent.addEventListener("unload", unloadHandler, false);

                                // Support: IE 9 - 10 only
                            } else if (parent.attachEvent) {
                                parent.attachEvent("onunload", unloadHandler);
                            }
                        }

                        /* Attributes
                        ---------------------------------------------------------------------- */

                        // Support: IE<8
                        // Verify that getAttribute really returns attributes and not properties
                        // (excepting IE8 booleans)
                        support.attributes = assert(function (div) {
                            div.className = "i";
                            return !div.getAttribute("className");
                        });

                        /* getElement(s)By*
                        ---------------------------------------------------------------------- */

                        // Check if getElementsByTagName("*") returns only elements
                        support.getElementsByTagName = assert(function (div) {
                            div.appendChild(document.createComment(""));
                            return !div.getElementsByTagName("*").length;
                        });

                        // Support: IE<9
                        support.getElementsByClassName = rnative.test(document.getElementsByClassName);

                        // Support: IE<10
                        // Check if getElementById returns elements by name
                        // The broken getElementById methods don't pick up programatically-set names,
                        // so use a roundabout getElementsByName test
                        support.getById = assert(function (div) {
                            docElem.appendChild(div).id = expando;
                            return !document.getElementsByName || !document.getElementsByName(expando).length;
                        });

                        // ID find and filter
                        if (support.getById) {
                            Expr.find["ID"] = function (id, context) {
                                if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                                    var m = context.getElementById(id);
                                    return m ? [m] : [];
                                }
                            };
                            Expr.filter["ID"] = function (id) {
                                var attrId = id.replace(runescape, funescape);
                                return function (elem) {
                                    return elem.getAttribute("id") === attrId;
                                };
                            };
                        } else {
                            // Support: IE6/7
                            // getElementById is not reliable as a find shortcut
                            delete Expr.find["ID"];

                            Expr.filter["ID"] = function (id) {
                                var attrId = id.replace(runescape, funescape);
                                return function (elem) {
                                    var node = typeof elem.getAttributeNode !== "undefined" &&
                                        elem.getAttributeNode("id");
                                    return node && node.value === attrId;
                                };
                            };
                        }

                        // Tag
                        Expr.find["TAG"] = support.getElementsByTagName ?
                            function (tag, context) {
                                if (typeof context.getElementsByTagName !== "undefined") {
                                    return context.getElementsByTagName(tag);

                                    // DocumentFragment nodes don't have gEBTN
                                } else if (support.qsa) {
                                    return context.querySelectorAll(tag);
                                }
                            } :

                            function (tag, context) {
                                var elem,
                                    tmp = [],
                                    i = 0,
                                    // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
                                    results = context.getElementsByTagName(tag);

                                // Filter out possible comments
                                if (tag === "*") {
                                    while ((elem = results[i++])) {
                                        if (elem.nodeType === 1) {
                                            tmp.push(elem);
                                        }
                                    }

                                    return tmp;
                                }
                                return results;
                            };

                        // Class
                        Expr.find["CLASS"] = support.getElementsByClassName && function (className, context) {
                            if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
                                return context.getElementsByClassName(className);
                            }
                        };

                        /* QSA/matchesSelector
                        ---------------------------------------------------------------------- */

                        // QSA and matchesSelector support

                        // matchesSelector(:active) reports false when true (IE9/Opera 11.5)
                        rbuggyMatches = [];

                        // qSa(:focus) reports false when true (Chrome 21)
                        // We allow this because of a bug in IE8/9 that throws an error
                        // whenever `document.activeElement` is accessed on an iframe
                        // So, we allow :focus to pass through QSA all the time to avoid the IE error
                        // See http://bugs.jquery.com/ticket/13378
                        rbuggyQSA = [];

                        if ((support.qsa = rnative.test(document.querySelectorAll))) {
                            // Build QSA regex
                            // Regex strategy adopted from Diego Perini
                            assert(function (div) {
                                // Select is set to empty string on purpose
                                // This is to test IE's treatment of not explicitly
                                // setting a boolean content attribute,
                                // since its presence should be enough
                                // http://bugs.jquery.com/ticket/12359
                                docElem.appendChild(div).innerHTML = "<a id='" + expando + "'></a>" +
                                    "<select id='" + expando + "-\r\\' msallowcapture=''>" +
                                    "<option selected=''></option></select>";

                                // Support: IE8, Opera 11-12.16
                                // Nothing should be selected when empty strings follow ^= or $= or *=
                                // The test attribute must be unknown in Opera but "safe" for WinRT
                                // http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
                                if (div.querySelectorAll("[msallowcapture^='']").length) {
                                    rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
                                }

                                // Support: IE8
                                // Boolean attributes and "value" are not treated correctly
                                if (!div.querySelectorAll("[selected]").length) {
                                    rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
                                }

                                // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
                                if (!div.querySelectorAll("[id~=" + expando + "-]").length) {
                                    rbuggyQSA.push("~=");
                                }

                                // Webkit/Opera - :checked should return selected option elements
                                // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                                // IE8 throws error here and will not see later tests
                                if (!div.querySelectorAll(":checked").length) {
                                    rbuggyQSA.push(":checked");
                                }

                                // Support: Safari 8+, iOS 8+
                                // https://bugs.webkit.org/show_bug.cgi?id=136851
                                // In-page `selector#id sibing-combinator selector` fails
                                if (!div.querySelectorAll("a#" + expando + "+*").length) {
                                    rbuggyQSA.push(".#.+[+~]");
                                }
                            });

                            assert(function (div) {
                                // Support: Windows 8 Native Apps
                                // The type and name attributes are restricted during .innerHTML assignment
                                var input = document.createElement("input");
                                input.setAttribute("type", "hidden");
                                div.appendChild(input).setAttribute("name", "D");

                                // Support: IE8
                                // Enforce case-sensitivity of name attribute
                                if (div.querySelectorAll("[name=d]").length) {
                                    rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
                                }

                                // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
                                // IE8 throws error here and will not see later tests
                                if (!div.querySelectorAll(":enabled").length) {
                                    rbuggyQSA.push(":enabled", ":disabled");
                                }

                                // Opera 10-11 does not throw on post-comma invalid pseudos
                                div.querySelectorAll("*,:x");
                                rbuggyQSA.push(",.*:");
                            });
                        }

                        if ((support.matchesSelector = rnative.test((matches = docElem.matches ||
                            docElem.webkitMatchesSelector ||
                            docElem.mozMatchesSelector ||
                            docElem.oMatchesSelector ||
                            docElem.msMatchesSelector)))) {

                            assert(function (div) {
                                // Check to see if it's possible to do matchesSelector
                                // on a disconnected node (IE 9)
                                support.disconnectedMatch = matches.call(div, "div");

                                // This should fail with an exception
                                // Gecko does not error, returns false instead
                                matches.call(div, "[s!='']:x");
                                rbuggyMatches.push("!=", pseudos);
                            });
                        }

                        rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
                        rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));

                        /* Contains
                        ---------------------------------------------------------------------- */
                        hasCompare = rnative.test(docElem.compareDocumentPosition);

                        // Element contains another
                        // Purposefully self-exclusive
                        // As in, an element does not contain itself
                        contains = hasCompare || rnative.test(docElem.contains) ?
                            function (a, b) {
                                var adown = a.nodeType === 9 ? a.documentElement : a,
                                    bup = b && b.parentNode;
                                return a === bup || !!(bup && bup.nodeType === 1 && (
                                    adown.contains ?
                                        adown.contains(bup) :
                                        a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16
                                ));
                            } :
                            function (a, b) {
                                if (b) {
                                    while ((b = b.parentNode)) {
                                        if (b === a) {
                                            return true;
                                        }
                                    }
                                }
                                return false;
                            };

                        /* Sorting
                        ---------------------------------------------------------------------- */

                        // Document order sorting
                        sortOrder = hasCompare ?
                            function (a, b) {

                                // Flag for duplicate removal
                                if (a === b) {
                                    hasDuplicate = true;
                                    return 0;
                                }

                                // Sort on method existence if only one input has compareDocumentPosition
                                var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                                if (compare) {
                                    return compare;
                                }

                                // Calculate position if both inputs belong to the same document
                                compare = (a.ownerDocument || a) === (b.ownerDocument || b) ?
                                    a.compareDocumentPosition(b) :

                                    // Otherwise we know they are disconnected
                                    1;

                                // Disconnected nodes
                                if (compare & 1 ||
                                    (!support.sortDetached && b.compareDocumentPosition(a) === compare)) {

                                    // Choose the first element that is related to our preferred document
                                    if (a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
                                        return -1;
                                    }
                                    if (b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
                                        return 1;
                                    }

                                    // Maintain original order
                                    return sortInput ?
                                        (indexOf(sortInput, a) - indexOf(sortInput, b)) :
                                        0;
                                }

                                return compare & 4 ? -1 : 1;
                            } :
                            function (a, b) {
                                // Exit early if the nodes are identical
                                if (a === b) {
                                    hasDuplicate = true;
                                    return 0;
                                }

                                var cur,
                                    i = 0,
                                    aup = a.parentNode,
                                    bup = b.parentNode,
                                    ap = [a],
                                    bp = [b];

                                // Parentless nodes are either documents or disconnected
                                if (!aup || !bup) {
                                    return a === document ? -1 :
                                        b === document ? 1 :
                                            aup ? -1 :
                                                bup ? 1 :
                                                    sortInput ?
                                                        (indexOf(sortInput, a) - indexOf(sortInput, b)) :
                                                        0;

                                    // If the nodes are siblings, we can do a quick check
                                } else if (aup === bup) {
                                    return siblingCheck(a, b);
                                }

                                // Otherwise we need full lists of their ancestors for comparison
                                cur = a;
                                while ((cur = cur.parentNode)) {
                                    ap.unshift(cur);
                                }
                                cur = b;
                                while ((cur = cur.parentNode)) {
                                    bp.unshift(cur);
                                }

                                // Walk down the tree looking for a discrepancy
                                while (ap[i] === bp[i]) {
                                    i++;
                                }

                                return i ?
                                    // Do a sibling check if the nodes have a common ancestor
                                    siblingCheck(ap[i], bp[i]) :

                                    // Otherwise nodes in our document sort first
                                    ap[i] === preferredDoc ? -1 :
                                        bp[i] === preferredDoc ? 1 :
                                            0;
                            };

                        return document;
                    };

                    Sizzle.matches = function (expr, elements) {
                        return Sizzle(expr, null, null, elements);
                    };

                    Sizzle.matchesSelector = function (elem, expr) {
                        // Set document vars if needed
                        if ((elem.ownerDocument || elem) !== document) {
                            setDocument(elem);
                        }

                        // Make sure that attribute selectors are quoted
                        expr = expr.replace(rattributeQuotes, "='$1']");

                        if (support.matchesSelector && documentIsHTML &&
                            !compilerCache[expr + " "] &&
                            (!rbuggyMatches || !rbuggyMatches.test(expr)) &&
                            (!rbuggyQSA || !rbuggyQSA.test(expr))) {

                            try {
                                var ret = matches.call(elem, expr);

                                // IE 9's matchesSelector returns false on disconnected nodes
                                if (ret || support.disconnectedMatch ||
                                    // As well, disconnected nodes are said to be in a document
                                    // fragment in IE 9
                                    elem.document && elem.document.nodeType !== 11) {
                                    return ret;
                                }
                            } catch (e) { }
                        }

                        return Sizzle(expr, document, null, [elem]).length > 0;
                    };

                    Sizzle.contains = function (context, elem) {
                        // Set document vars if needed
                        if ((context.ownerDocument || context) !== document) {
                            setDocument(context);
                        }
                        return contains(context, elem);
                    };

                    Sizzle.attr = function (elem, name) {
                        // Set document vars if needed
                        if ((elem.ownerDocument || elem) !== document) {
                            setDocument(elem);
                        }

                        var fn = Expr.attrHandle[name.toLowerCase()],
                            // Don't get fooled by Object.prototype properties (jQuery #13807)
                            val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ?
                                fn(elem, name, !documentIsHTML) :
                                undefined;

                        return val !== undefined ?
                            val :
                            support.attributes || !documentIsHTML ?
                                elem.getAttribute(name) :
                                (val = elem.getAttributeNode(name)) && val.specified ?
                                    val.value :
                                    null;
                    };

                    Sizzle.error = function (msg) {
                        throw new Error("Syntax error, unrecognized expression: " + msg);
                    };

                    /**
                     * Document sorting and removing duplicates
                     * @param {ArrayLike} results
                     */
                    Sizzle.uniqueSort = function (results) {
                        var elem,
                            duplicates = [],
                            j = 0,
                            i = 0;

                        // Unless we *know* we can detect duplicates, assume their presence
                        hasDuplicate = !support.detectDuplicates;
                        sortInput = !support.sortStable && results.slice(0);
                        results.sort(sortOrder);

                        if (hasDuplicate) {
                            while ((elem = results[i++])) {
                                if (elem === results[i]) {
                                    j = duplicates.push(i);
                                }
                            }
                            while (j--) {
                                results.splice(duplicates[j], 1);
                            }
                        }

                        // Clear input after sorting to release objects
                        // See https://github.com/jquery/sizzle/pull/225
                        sortInput = null;

                        return results;
                    };

                    /**
                     * Utility function for retrieving the text value of an array of DOM nodes
                     * @param {Array|Element} elem
                     */
                    getText = Sizzle.getText = function (elem) {
                        var node,
                            ret = "",
                            i = 0,
                            nodeType = elem.nodeType;

                        if (!nodeType) {
                            // If no nodeType, this is expected to be an array
                            while ((node = elem[i++])) {
                                // Do not traverse comment nodes
                                ret += getText(node);
                            }
                        } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
                            // Use textContent for elements
                            // innerText usage removed for consistency of new lines (jQuery #11153)
                            if (typeof elem.textContent === "string") {
                                return elem.textContent;
                            } else {
                                // Traverse its children
                                for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                                    ret += getText(elem);
                                }
                            }
                        } else if (nodeType === 3 || nodeType === 4) {
                            return elem.nodeValue;
                        }
                        // Do not include comment or processing instruction nodes

                        return ret;
                    };

                    Expr = Sizzle.selectors = {

                        // Can be adjusted by the user
                        cacheLength: 50,

                        createPseudo: markFunction,

                        match: matchExpr,

                        attrHandle: {},

                        find: {},

                        relative: {
                            ">": { dir: "parentNode", first: true },
                            " ": { dir: "parentNode" },
                            "+": { dir: "previousSibling", first: true },
                            "~": { dir: "previousSibling" }
                        },

                        preFilter: {
                            "ATTR": function (match) {
                                match[1] = match[1].replace(runescape, funescape);

                                // Move the given value to match[3] whether quoted or unquoted
                                match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);

                                if (match[2] === "~=") {
                                    match[3] = " " + match[3] + " ";
                                }

                                return match.slice(0, 4);
                            },

                            "CHILD": function (match) {
                                /* matches from matchExpr["CHILD"]
                                    1 type (only|nth|...)
                                    2 what (child|of-type)
                                    3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
                                    4 xn-component of xn+y argument ([+-]?\d*n|)
                                    5 sign of xn-component
                                    6 x of xn-component
                                    7 sign of y-component
                                    8 y of y-component
                                */
                                match[1] = match[1].toLowerCase();

                                if (match[1].slice(0, 3) === "nth") {
                                    // nth-* requires argument
                                    if (!match[3]) {
                                        Sizzle.error(match[0]);
                                    }

                                    // numeric x and y parameters for Expr.filter.CHILD
                                    // remember that false/true cast respectively to 0/1
                                    match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
                                    match[5] = +((match[7] + match[8]) || match[3] === "odd");

                                    // other types prohibit arguments
                                } else if (match[3]) {
                                    Sizzle.error(match[0]);
                                }

                                return match;
                            },

                            "PSEUDO": function (match) {
                                var excess,
                                    unquoted = !match[6] && match[2];

                                if (matchExpr["CHILD"].test(match[0])) {
                                    return null;
                                }

                                // Accept quoted arguments as-is
                                if (match[3]) {
                                    match[2] = match[4] || match[5] || "";

                                    // Strip excess characters from unquoted arguments
                                } else if (unquoted && rpseudo.test(unquoted) &&
                                    // Get excess from tokenize (recursively)
                                    (excess = tokenize(unquoted, true)) &&
                                    // advance to the next closing parenthesis
                                    (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {

                                    // excess is a negative index
                                    match[0] = match[0].slice(0, excess);
                                    match[2] = unquoted.slice(0, excess);
                                }

                                // Return only captures needed by the pseudo filter method (type and argument)
                                return match.slice(0, 3);
                            }
                        },

                        filter: {

                            "TAG": function (nodeNameSelector) {
                                var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                                return nodeNameSelector === "*" ?
                                    function () { return true; } :
                                    function (elem) {
                                        return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                                    };
                            },

                            "CLASS": function (className) {
                                var pattern = classCache[className + " "];

                                return pattern ||
                                    (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) &&
                                    classCache(className, function (elem) {
                                        return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
                                    });
                            },

                            "ATTR": function (name, operator, check) {
                                return function (elem) {
                                    var result = Sizzle.attr(elem, name);

                                    if (result == null) {
                                        return operator === "!=";
                                    }
                                    if (!operator) {
                                        return true;
                                    }

                                    result += "";

                                    return operator === "=" ? result === check :
                                        operator === "!=" ? result !== check :
                                            operator === "^=" ? check && result.indexOf(check) === 0 :
                                                operator === "*=" ? check && result.indexOf(check) > -1 :
                                                    operator === "$=" ? check && result.slice(-check.length) === check :
                                                        operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 :
                                                            operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" :
                                                                false;
                                };
                            },

                            "CHILD": function (type, what, argument, first, last) {
                                var simple = type.slice(0, 3) !== "nth",
                                    forward = type.slice(-4) !== "last",
                                    ofType = what === "of-type";

                                return first === 1 && last === 0 ?

                                    // Shortcut for :nth-*(n)
                                    function (elem) {
                                        return !!elem.parentNode;
                                    } :

                                    function (elem, context, xml) {
                                        var cache, uniqueCache, outerCache, node, nodeIndex, start,
                                            dir = simple !== forward ? "nextSibling" : "previousSibling",
                                            parent = elem.parentNode,
                                            name = ofType && elem.nodeName.toLowerCase(),
                                            useCache = !xml && !ofType,
                                            diff = false;

                                        if (parent) {

                                            // :(first|last|only)-(child|of-type)
                                            if (simple) {
                                                while (dir) {
                                                    node = elem;
                                                    while ((node = node[dir])) {
                                                        if (ofType ?
                                                            node.nodeName.toLowerCase() === name :
                                                            node.nodeType === 1) {

                                                            return false;
                                                        }
                                                    }
                                                    // Reverse direction for :only-* (if we haven't yet done so)
                                                    start = dir = type === "only" && !start && "nextSibling";
                                                }
                                                return true;
                                            }

                                            start = [forward ? parent.firstChild : parent.lastChild];

                                            // non-xml :nth-child(...) stores cache data on `parent`
                                            if (forward && useCache) {

                                                // Seek `elem` from a previously-cached index

                                                // ...in a gzip-friendly way
                                                node = parent;
                                                outerCache = node[expando] || (node[expando] = {});

                                                // Support: IE <9 only
                                                // Defend against cloned attroperties (jQuery gh-1709)
                                                uniqueCache = outerCache[node.uniqueID] ||
                                                    (outerCache[node.uniqueID] = {});

                                                cache = uniqueCache[type] || [];
                                                nodeIndex = cache[0] === dirruns && cache[1];
                                                diff = nodeIndex && cache[2];
                                                node = nodeIndex && parent.childNodes[nodeIndex];

                                                while ((node = ++nodeIndex && node && node[dir] ||

                                                    // Fallback to seeking `elem` from the start
                                                    (diff = nodeIndex = 0) || start.pop())) {

                                                    // When found, cache indexes on `parent` and break
                                                    if (node.nodeType === 1 && ++diff && node === elem) {
                                                        uniqueCache[type] = [dirruns, nodeIndex, diff];
                                                        break;
                                                    }
                                                }

                                            } else {
                                                // Use previously-cached element index if available
                                                if (useCache) {
                                                    // ...in a gzip-friendly way
                                                    node = elem;
                                                    outerCache = node[expando] || (node[expando] = {});

                                                    // Support: IE <9 only
                                                    // Defend against cloned attroperties (jQuery gh-1709)
                                                    uniqueCache = outerCache[node.uniqueID] ||
                                                        (outerCache[node.uniqueID] = {});

                                                    cache = uniqueCache[type] || [];
                                                    nodeIndex = cache[0] === dirruns && cache[1];
                                                    diff = nodeIndex;
                                                }

                                                // xml :nth-child(...)
                                                // or :nth-last-child(...) or :nth(-last)?-of-type(...)
                                                if (diff === false) {
                                                    // Use the same loop as above to seek `elem` from the start
                                                    while ((node = ++nodeIndex && node && node[dir] ||
                                                        (diff = nodeIndex = 0) || start.pop())) {

                                                        if ((ofType ?
                                                            node.nodeName.toLowerCase() === name :
                                                            node.nodeType === 1) &&
                                                            ++diff) {

                                                            // Cache the index of each encountered element
                                                            if (useCache) {
                                                                outerCache = node[expando] || (node[expando] = {});

                                                                // Support: IE <9 only
                                                                // Defend against cloned attroperties (jQuery gh-1709)
                                                                uniqueCache = outerCache[node.uniqueID] ||
                                                                    (outerCache[node.uniqueID] = {});

                                                                uniqueCache[type] = [dirruns, diff];
                                                            }

                                                            if (node === elem) {
                                                                break;
                                                            }
                                                        }
                                                    }
                                                }
                                            }

                                            // Incorporate the offset, then check against cycle size
                                            diff -= last;
                                            return diff === first || (diff % first === 0 && diff / first >= 0);
                                        }
                                    };
                            },

                            "PSEUDO": function (pseudo, argument) {
                                // pseudo-class names are case-insensitive
                                // http://www.w3.org/TR/selectors/#pseudo-classes
                                // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
                                // Remember that setFilters inherits from pseudos
                                var args,
                                    fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] ||
                                        Sizzle.error("unsupported pseudo: " + pseudo);

                                // The user may use createPseudo to indicate that
                                // arguments are needed to create the filter function
                                // just as Sizzle does
                                if (fn[expando]) {
                                    return fn(argument);
                                }

                                // But maintain support for old signatures
                                if (fn.length > 1) {
                                    args = [pseudo, pseudo, "", argument];
                                    return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ?
                                        markFunction(function (seed, matches) {
                                            var idx,
                                                matched = fn(seed, argument),
                                                i = matched.length;
                                            while (i--) {
                                                idx = indexOf(seed, matched[i]);
                                                seed[idx] = !(matches[idx] = matched[i]);
                                            }
                                        }) :
                                        function (elem) {
                                            return fn(elem, 0, args);
                                        };
                                }

                                return fn;
                            }
                        },

                        pseudos: {
                            // Potentially complex pseudos
                            "not": markFunction(function (selector) {
                                // Trim the selector passed to compile
                                // to avoid treating leading and trailing
                                // spaces as combinators
                                var input = [],
                                    results = [],
                                    matcher = compile(selector.replace(rtrim, "$1"));

                                return matcher[expando] ?
                                    markFunction(function (seed, matches, context, xml) {
                                        var elem,
                                            unmatched = matcher(seed, null, xml, []),
                                            i = seed.length;

                                        // Match elements unmatched by `matcher`
                                        while (i--) {
                                            if ((elem = unmatched[i])) {
                                                seed[i] = !(matches[i] = elem);
                                            }
                                        }
                                    }) :
                                    function (elem, context, xml) {
                                        input[0] = elem;
                                        matcher(input, null, xml, results);
                                        // Don't keep the element (issue #299)
                                        input[0] = null;
                                        return !results.pop();
                                    };
                            }),

                            "has": markFunction(function (selector) {
                                return function (elem) {
                                    return Sizzle(selector, elem).length > 0;
                                };
                            }),

                            "contains": markFunction(function (text) {
                                text = text.replace(runescape, funescape);
                                return function (elem) {
                                    return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
                                };
                            }),

                            // "Whether an element is represented by a :lang() selector
                            // is based solely on the element's language value
                            // being equal to the identifier C,
                            // or beginning with the identifier C immediately followed by "-".
                            // The matching of C against the element's language value is performed case-insensitively.
                            // The identifier C does not have to be a valid language name."
                            // http://www.w3.org/TR/selectors/#lang-pseudo
                            "lang": markFunction(function (lang) {
                                // lang value must be a valid identifier
                                if (!ridentifier.test(lang || "")) {
                                    Sizzle.error("unsupported lang: " + lang);
                                }
                                lang = lang.replace(runescape, funescape).toLowerCase();
                                return function (elem) {
                                    var elemLang;
                                    do {
                                        if ((elemLang = documentIsHTML ?
                                            elem.lang :
                                            elem.getAttribute("xml:lang") || elem.getAttribute("lang"))) {

                                            elemLang = elemLang.toLowerCase();
                                            return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                                        }
                                    } while ((elem = elem.parentNode) && elem.nodeType === 1);
                                    return false;
                                };
                            }),

                            // Miscellaneous
                            "target": function (elem) {
                                var hash = window.location && window.location.hash;
                                return hash && hash.slice(1) === elem.id;
                            },

                            "root": function (elem) {
                                return elem === docElem;
                            },

                            "focus": function (elem) {
                                return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
                            },

                            // Boolean properties
                            "enabled": function (elem) {
                                return elem.disabled === false;
                            },

                            "disabled": function (elem) {
                                return elem.disabled === true;
                            },

                            "checked": function (elem) {
                                // In CSS3, :checked should return both checked and selected elements
                                // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                                var nodeName = elem.nodeName.toLowerCase();
                                return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
                            },

                            "selected": function (elem) {
                                // Accessing this property makes selected-by-default
                                // options in Safari work properly
                                if (elem.parentNode) {
                                    elem.parentNode.selectedIndex;
                                }

                                return elem.selected === true;
                            },

                            // Contents
                            "empty": function (elem) {
                                // http://www.w3.org/TR/selectors/#empty-pseudo
                                // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
                                //   but not by others (comment: 8; processing instruction: 7; etc.)
                                // nodeType < 6 works because attributes (2) do not appear as children
                                for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                                    if (elem.nodeType < 6) {
                                        return false;
                                    }
                                }
                                return true;
                            },

                            "parent": function (elem) {
                                return !Expr.pseudos["empty"](elem);
                            },

                            // Element/input types
                            "header": function (elem) {
                                return rheader.test(elem.nodeName);
                            },

                            "input": function (elem) {
                                return rinputs.test(elem.nodeName);
                            },

                            "button": function (elem) {
                                var name = elem.nodeName.toLowerCase();
                                return name === "input" && elem.type === "button" || name === "button";
                            },

                            "text": function (elem) {
                                var attr;
                                return elem.nodeName.toLowerCase() === "input" &&
                                    elem.type === "text" &&

                                    // Support: IE<8
                                    // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
                                    ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
                            },

                            // Position-in-collection
                            "first": createPositionalPseudo(function () {
                                return [0];
                            }),

                            "last": createPositionalPseudo(function (matchIndexes, length) {
                                return [length - 1];
                            }),

                            "eq": createPositionalPseudo(function (matchIndexes, length, argument) {
                                return [argument < 0 ? argument + length : argument];
                            }),

                            "even": createPositionalPseudo(function (matchIndexes, length) {
                                var i = 0;
                                for (; i < length; i += 2) {
                                    matchIndexes.push(i);
                                }
                                return matchIndexes;
                            }),

                            "odd": createPositionalPseudo(function (matchIndexes, length) {
                                var i = 1;
                                for (; i < length; i += 2) {
                                    matchIndexes.push(i);
                                }
                                return matchIndexes;
                            }),

                            "lt": createPositionalPseudo(function (matchIndexes, length, argument) {
                                var i = argument < 0 ? argument + length : argument;
                                for (; --i >= 0;) {
                                    matchIndexes.push(i);
                                }
                                return matchIndexes;
                            }),

                            "gt": createPositionalPseudo(function (matchIndexes, length, argument) {
                                var i = argument < 0 ? argument + length : argument;
                                for (; ++i < length;) {
                                    matchIndexes.push(i);
                                }
                                return matchIndexes;
                            })
                        }
                    };

                    Expr.pseudos["nth"] = Expr.pseudos["eq"];

                    // Add button/input type pseudos
                    for (i in { radio: true, checkbox: true, file: true, password: true, image: true }) {
                        Expr.pseudos[i] = createInputPseudo(i);
                    }
                    for (i in { submit: true, reset: true }) {
                        Expr.pseudos[i] = createButtonPseudo(i);
                    }

                    // Easy API for creating new setFilters
                    function setFilters() { }
                    setFilters.prototype = Expr.filters = Expr.pseudos;
                    Expr.setFilters = new setFilters();

                    tokenize = Sizzle.tokenize = function (selector, parseOnly) {
                        var matched, match, tokens, type,
                            soFar, groups, preFilters,
                            cached = tokenCache[selector + " "];

                        if (cached) {
                            return parseOnly ? 0 : cached.slice(0);
                        }

                        soFar = selector;
                        groups = [];
                        preFilters = Expr.preFilter;

                        while (soFar) {

                            // Comma and first run
                            if (!matched || (match = rcomma.exec(soFar))) {
                                if (match) {
                                    // Don't consume trailing commas as valid
                                    soFar = soFar.slice(match[0].length) || soFar;
                                }
                                groups.push((tokens = []));
                            }

                            matched = false;

                            // Combinators
                            if ((match = rcombinators.exec(soFar))) {
                                matched = match.shift();
                                tokens.push({
                                    value: matched,
                                    // Cast descendant combinators to space
                                    type: match[0].replace(rtrim, " ")
                                });
                                soFar = soFar.slice(matched.length);
                            }

                            // Filters
                            for (type in Expr.filter) {
                                if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] ||
                                    (match = preFilters[type](match)))) {
                                    matched = match.shift();
                                    tokens.push({
                                        value: matched,
                                        type: type,
                                        matches: match
                                    });
                                    soFar = soFar.slice(matched.length);
                                }
                            }

                            if (!matched) {
                                break;
                            }
                        }

                        // Return the length of the invalid excess
                        // if we're just parsing
                        // Otherwise, throw an error or return tokens
                        return parseOnly ?
                            soFar.length :
                            soFar ?
                                Sizzle.error(selector) :
                                // Cache the tokens
                                tokenCache(selector, groups).slice(0);
                    };

                    function toSelector(tokens) {
                        var i = 0,
                            len = tokens.length,
                            selector = "";
                        for (; i < len; i++) {
                            selector += tokens[i].value;
                        }
                        return selector;
                    }

                    function addCombinator(matcher, combinator, base) {
                        var dir = combinator.dir,
                            checkNonElements = base && dir === "parentNode",
                            doneName = done++;

                        return combinator.first ?
                            // Check against closest ancestor/preceding element
                            function (elem, context, xml) {
                                while ((elem = elem[dir])) {
                                    if (elem.nodeType === 1 || checkNonElements) {
                                        return matcher(elem, context, xml);
                                    }
                                }
                            } :

                            // Check against all ancestor/preceding elements
                            function (elem, context, xml) {
                                var oldCache, uniqueCache, outerCache,
                                    newCache = [dirruns, doneName];

                                // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
                                if (xml) {
                                    while ((elem = elem[dir])) {
                                        if (elem.nodeType === 1 || checkNonElements) {
                                            if (matcher(elem, context, xml)) {
                                                return true;
                                            }
                                        }
                                    }
                                } else {
                                    while ((elem = elem[dir])) {
                                        if (elem.nodeType === 1 || checkNonElements) {
                                            outerCache = elem[expando] || (elem[expando] = {});

                                            // Support: IE <9 only
                                            // Defend against cloned attroperties (jQuery gh-1709)
                                            uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});

                                            if ((oldCache = uniqueCache[dir]) &&
                                                oldCache[0] === dirruns && oldCache[1] === doneName) {

                                                // Assign to newCache so results back-propagate to previous elements
                                                return (newCache[2] = oldCache[2]);
                                            } else {
                                                // Reuse newcache so results back-propagate to previous elements
                                                uniqueCache[dir] = newCache;

                                                // A match means we're done; a fail means we have to keep checking
                                                if ((newCache[2] = matcher(elem, context, xml))) {
                                                    return true;
                                                }
                                            }
                                        }
                                    }
                                }
                            };
                    }

                    function elementMatcher(matchers) {
                        return matchers.length > 1 ?
                            function (elem, context, xml) {
                                var i = matchers.length;
                                while (i--) {
                                    if (!matchers[i](elem, context, xml)) {
                                        return false;
                                    }
                                }
                                return true;
                            } :
                            matchers[0];
                    }

                    function multipleContexts(selector, contexts, results) {
                        var i = 0,
                            len = contexts.length;
                        for (; i < len; i++) {
                            Sizzle(selector, contexts[i], results);
                        }
                        return results;
                    }

                    function condense(unmatched, map, filter, context, xml) {
                        var elem,
                            newUnmatched = [],
                            i = 0,
                            len = unmatched.length,
                            mapped = map != null;

                        for (; i < len; i++) {
                            if ((elem = unmatched[i])) {
                                if (!filter || filter(elem, context, xml)) {
                                    newUnmatched.push(elem);
                                    if (mapped) {
                                        map.push(i);
                                    }
                                }
                            }
                        }

                        return newUnmatched;
                    }

                    function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
                        if (postFilter && !postFilter[expando]) {
                            postFilter = setMatcher(postFilter);
                        }
                        if (postFinder && !postFinder[expando]) {
                            postFinder = setMatcher(postFinder, postSelector);
                        }
                        return markFunction(function (seed, results, context, xml) {
                            var temp, i, elem,
                                preMap = [],
                                postMap = [],
                                preexisting = results.length,

                                // Get initial elements from seed or context
                                elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),

                                // Prefilter to get matcher input, preserving a map for seed-results synchronization
                                matcherIn = preFilter && (seed || !selector) ?
                                    condense(elems, preMap, preFilter, context, xml) :
                                    elems,

                                matcherOut = matcher ?
                                    // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
                                    postFinder || (seed ? preFilter : preexisting || postFilter) ?

                                        // ...intermediate processing is necessary
                                        [] :

                                        // ...otherwise use results directly
                                        results :
                                    matcherIn;

                            // Find primary matches
                            if (matcher) {
                                matcher(matcherIn, matcherOut, context, xml);
                            }

                            // Apply postFilter
                            if (postFilter) {
                                temp = condense(matcherOut, postMap);
                                postFilter(temp, [], context, xml);

                                // Un-match failing elements by moving them back to matcherIn
                                i = temp.length;
                                while (i--) {
                                    if ((elem = temp[i])) {
                                        matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
                                    }
                                }
                            }

                            if (seed) {
                                if (postFinder || preFilter) {
                                    if (postFinder) {
                                        // Get the final matcherOut by condensing this intermediate into postFinder contexts
                                        temp = [];
                                        i = matcherOut.length;
                                        while (i--) {
                                            if ((elem = matcherOut[i])) {
                                                // Restore matcherIn since elem is not yet a final match
                                                temp.push((matcherIn[i] = elem));
                                            }
                                        }
                                        postFinder(null, (matcherOut = []), temp, xml);
                                    }

                                    // Move matched elements from seed to results to keep them synchronized
                                    i = matcherOut.length;
                                    while (i--) {
                                        if ((elem = matcherOut[i]) &&
                                            (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {

                                            seed[temp] = !(results[temp] = elem);
                                        }
                                    }
                                }

                                // Add elements to results, through postFinder if defined
                            } else {
                                matcherOut = condense(
                                    matcherOut === results ?
                                        matcherOut.splice(preexisting, matcherOut.length) :
                                        matcherOut
                                );
                                if (postFinder) {
                                    postFinder(null, results, matcherOut, xml);
                                } else {
                                    push.apply(results, matcherOut);
                                }
                            }
                        });
                    }

                    function matcherFromTokens(tokens) {
                        var checkContext, matcher, j,
                            len = tokens.length,
                            leadingRelative = Expr.relative[tokens[0].type],
                            implicitRelative = leadingRelative || Expr.relative[" "],
                            i = leadingRelative ? 1 : 0,

                            // The foundational matcher ensures that elements are reachable from top-level context(s)
                            matchContext = addCombinator(function (elem) {
                                return elem === checkContext;
                            }, implicitRelative, true),
                            matchAnyContext = addCombinator(function (elem) {
                                return indexOf(checkContext, elem) > -1;
                            }, implicitRelative, true),
                            matchers = [function (elem, context, xml) {
                                var ret = (!leadingRelative && (xml || context !== outermostContext)) || (
                                    (checkContext = context).nodeType ?
                                        matchContext(elem, context, xml) :
                                        matchAnyContext(elem, context, xml));
                                // Avoid hanging onto element (issue #299)
                                checkContext = null;
                                return ret;
                            }];

                        for (; i < len; i++) {
                            if ((matcher = Expr.relative[tokens[i].type])) {
                                matchers = [addCombinator(elementMatcher(matchers), matcher)];
                            } else {
                                matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);

                                // Return special upon seeing a positional matcher
                                if (matcher[expando]) {
                                    // Find the next relative operator (if any) for proper handling
                                    j = ++i;
                                    for (; j < len; j++) {
                                        if (Expr.relative[tokens[j].type]) {
                                            break;
                                        }
                                    }
                                    return setMatcher(
                                        i > 1 && elementMatcher(matchers),
                                        i > 1 && toSelector(
                                            // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                                            tokens.slice(0, i - 1).concat({ value: tokens[i - 2].type === " " ? "*" : "" })
                                        ).replace(rtrim, "$1"),
                                        matcher,
                                        i < j && matcherFromTokens(tokens.slice(i, j)),
                                        j < len && matcherFromTokens((tokens = tokens.slice(j))),
                                        j < len && toSelector(tokens)
                                    );
                                }
                                matchers.push(matcher);
                            }
                        }

                        return elementMatcher(matchers);
                    }

                    function matcherFromGroupMatchers(elementMatchers, setMatchers) {
                        var bySet = setMatchers.length > 0,
                            byElement = elementMatchers.length > 0,
                            superMatcher = function (seed, context, xml, results, outermost) {
                                var elem, j, matcher,
                                    matchedCount = 0,
                                    i = "0",
                                    unmatched = seed && [],
                                    setMatched = [],
                                    contextBackup = outermostContext,
                                    // We must always have either seed elements or outermost context
                                    elems = seed || byElement && Expr.find["TAG"]("*", outermost),
                                    // Use integer dirruns iff this is the outermost matcher
                                    dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
                                    len = elems.length;

                                if (outermost) {
                                    outermostContext = context === document || context || outermost;
                                }

                                // Add elements passing elementMatchers directly to results
                                // Support: IE<9, Safari
                                // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
                                for (; i !== len && (elem = elems[i]) != null; i++) {
                                    if (byElement && elem) {
                                        j = 0;
                                        if (!context && elem.ownerDocument !== document) {
                                            setDocument(elem);
                                            xml = !documentIsHTML;
                                        }
                                        while ((matcher = elementMatchers[j++])) {
                                            if (matcher(elem, context || document, xml)) {
                                                results.push(elem);
                                                break;
                                            }
                                        }
                                        if (outermost) {
                                            dirruns = dirrunsUnique;
                                        }
                                    }

                                    // Track unmatched elements for set filters
                                    if (bySet) {
                                        // They will have gone through all possible matchers
                                        if ((elem = !matcher && elem)) {
                                            matchedCount--;
                                        }

                                        // Lengthen the array for every element, matched or not
                                        if (seed) {
                                            unmatched.push(elem);
                                        }
                                    }
                                }

                                // `i` is now the count of elements visited above, and adding it to `matchedCount`
                                // makes the latter nonnegative.
                                matchedCount += i;

                                // Apply set filters to unmatched elements
                                // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
                                // equals `i`), unless we didn't visit _any_ elements in the above loop because we have
                                // no element matchers and no seed.
                                // Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
                                // case, which will result in a "00" `matchedCount` that differs from `i` but is also
                                // numerically zero.
                                if (bySet && i !== matchedCount) {
                                    j = 0;
                                    while ((matcher = setMatchers[j++])) {
                                        matcher(unmatched, setMatched, context, xml);
                                    }

                                    if (seed) {
                                        // Reintegrate element matches to eliminate the need for sorting
                                        if (matchedCount > 0) {
                                            while (i--) {
                                                if (!(unmatched[i] || setMatched[i])) {
                                                    setMatched[i] = pop.call(results);
                                                }
                                            }
                                        }

                                        // Discard index placeholder values to get only actual matches
                                        setMatched = condense(setMatched);
                                    }

                                    // Add matches to results
                                    push.apply(results, setMatched);

                                    // Seedless set matches succeeding multiple successful matchers stipulate sorting
                                    if (outermost && !seed && setMatched.length > 0 &&
                                        (matchedCount + setMatchers.length) > 1) {

                                        Sizzle.uniqueSort(results);
                                    }
                                }

                                // Override manipulation of globals by nested matchers
                                if (outermost) {
                                    dirruns = dirrunsUnique;
                                    outermostContext = contextBackup;
                                }

                                return unmatched;
                            };

                        return bySet ?
                            markFunction(superMatcher) :
                            superMatcher;
                    }

                    compile = Sizzle.compile = function (selector, match /* Internal Use Only */) {
                        var i,
                            setMatchers = [],
                            elementMatchers = [],
                            cached = compilerCache[selector + " "];

                        if (!cached) {
                            // Generate a function of recursive functions that can be used to check each element
                            if (!match) {
                                match = tokenize(selector);
                            }
                            i = match.length;
                            while (i--) {
                                cached = matcherFromTokens(match[i]);
                                if (cached[expando]) {
                                    setMatchers.push(cached);
                                } else {
                                    elementMatchers.push(cached);
                                }
                            }

                            // Cache the compiled function
                            cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));

                            // Save selector and tokenization
                            cached.selector = selector;
                        }
                        return cached;
                    };

                    /**
                     * A low-level selection function that works with Sizzle's compiled
                     *  selector functions
                     * @param {String|Function} selector A selector or a pre-compiled
                     *  selector function built with Sizzle.compile
                     * @param {Element} context
                     * @param {Array} [results]
                     * @param {Array} [seed] A set of elements to match against
                     */
                    select = Sizzle.select = function (selector, context, results, seed) {
                        var i, tokens, token, type, find,
                            compiled = typeof selector === "function" && selector,
                            match = !seed && tokenize((selector = compiled.selector || selector));

                        results = results || [];

                        // Try to minimize operations if there is only one selector in the list and no seed
                        // (the latter of which guarantees us context)
                        if (match.length === 1) {

                            // Reduce context if the leading compound selector is an ID
                            tokens = match[0] = match[0].slice(0);
                            if (tokens.length > 2 && (token = tokens[0]).type === "ID" &&
                                support.getById && context.nodeType === 9 && documentIsHTML &&
                                Expr.relative[tokens[1].type]) {

                                context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
                                if (!context) {
                                    return results;

                                    // Precompiled matchers will still verify ancestry, so step up a level
                                } else if (compiled) {
                                    context = context.parentNode;
                                }

                                selector = selector.slice(tokens.shift().value.length);
                            }

                            // Fetch a seed set for right-to-left matching
                            i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
                            while (i--) {
                                token = tokens[i];

                                // Abort if we hit a combinator
                                if (Expr.relative[(type = token.type)]) {
                                    break;
                                }
                                if ((find = Expr.find[type])) {
                                    // Search, expanding context for leading sibling combinators
                                    if ((seed = find(
                                        token.matches[0].replace(runescape, funescape),
                                        rsibling.test(tokens[0].type) && testContext(context.parentNode) || context
                                    ))) {

                                        // If seed is empty or no tokens remain, we can return early
                                        tokens.splice(i, 1);
                                        selector = seed.length && toSelector(tokens);
                                        if (!selector) {
                                            push.apply(results, seed);
                                            return results;
                                        }

                                        break;
                                    }
                                }
                            }
                        }

                        // Compile and execute a filtering function if one is not provided
                        // Provide `match` to avoid retokenization if we modified the selector above
                        (compiled || compile(selector, match))(
                            seed,
                            context,
                            !documentIsHTML,
                            results,
                            !context || rsibling.test(selector) && testContext(context.parentNode) || context
                        );
                        return results;
                    };

                    // One-time assignments

                    // Sort stability
                    support.sortStable = expando.split("").sort(sortOrder).join("") === expando;

                    // Support: Chrome 14-35+
                    // Always assume duplicates if they aren't passed to the comparison function
                    support.detectDuplicates = !!hasDuplicate;

                    // Initialize against the default document
                    setDocument();

                    // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
                    // Detached nodes confoundingly follow *each other*
                    support.sortDetached = assert(function (div1) {
                        // Should return 1, but returns 4 (following)
                        return div1.compareDocumentPosition(document.createElement("div")) & 1;
                    });

                    // Support: IE<8
                    // Prevent attribute/property "interpolation"
                    // http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
                    if (!assert(function (div) {
                        div.innerHTML = "<a href='#'></a>";
                        return div.firstChild.getAttribute("href") === "#";
                    })) {
                        addHandle("type|href|height|width", function (elem, name, isXML) {
                            if (!isXML) {
                                return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
                            }
                        });
                    }

                    // Support: IE<9
                    // Use defaultValue in place of getAttribute("value")
                    if (!support.attributes || !assert(function (div) {
                        div.innerHTML = "<input/>";
                        div.firstChild.setAttribute("value", "");
                        return div.firstChild.getAttribute("value") === "";
                    })) {
                        addHandle("value", function (elem, name, isXML) {
                            if (!isXML && elem.nodeName.toLowerCase() === "input") {
                                return elem.defaultValue;
                            }
                        });
                    }

                    // Support: IE<9
                    // Use getAttributeNode to fetch booleans when getAttribute lies
                    if (!assert(function (div) {
                        return div.getAttribute("disabled") == null;
                    })) {
                        addHandle(booleans, function (elem, name, isXML) {
                            var val;
                            if (!isXML) {
                                return elem[name] === true ? name.toLowerCase() :
                                    (val = elem.getAttributeNode(name)) && val.specified ?
                                        val.value :
                                        null;
                            }
                        });
                    }

                    return Sizzle;

                })(window);



            jQuery.find = Sizzle;
            jQuery.expr = Sizzle.selectors;
            jQuery.expr[":"] = jQuery.expr.pseudos;
            jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
            jQuery.text = Sizzle.getText;
            jQuery.isXMLDoc = Sizzle.isXML;
            jQuery.contains = Sizzle.contains;



            var dir = function (elem, dir, until) {
                var matched = [],
                    truncate = until !== undefined;

                while ((elem = elem[dir]) && elem.nodeType !== 9) {
                    if (elem.nodeType === 1) {
                        if (truncate && jQuery(elem).is(until)) {
                            break;
                        }
                        matched.push(elem);
                    }
                }
                return matched;
            };


            var siblings = function (n, elem) {
                var matched = [];

                for (; n; n = n.nextSibling) {
                    if (n.nodeType === 1 && n !== elem) {
                        matched.push(n);
                    }
                }

                return matched;
            };


            var rneedsContext = jQuery.expr.match.needsContext;

            var rsingleTag = (/^<([\w-]+)\s*\/?>(?:<\/\1>|)$/);



            var risSimple = /^.[^:#\[\.,]*$/;

            // Implement the identical functionality for filter and not
            function winnow(elements, qualifier, not) {
                if (jQuery.isFunction(qualifier)) {
                    return jQuery.grep(elements, function (elem, i) {
                        /* jshint -W018 */
                        return !!qualifier.call(elem, i, elem) !== not;
                    });

                }

                if (qualifier.nodeType) {
                    return jQuery.grep(elements, function (elem) {
                        return (elem === qualifier) !== not;
                    });

                }

                if (typeof qualifier === "string") {
                    if (risSimple.test(qualifier)) {
                        return jQuery.filter(qualifier, elements, not);
                    }

                    qualifier = jQuery.filter(qualifier, elements);
                }

                return jQuery.grep(elements, function (elem) {
                    return (indexOf.call(qualifier, elem) > -1) !== not;
                });
            }

            jQuery.filter = function (expr, elems, not) {
                var elem = elems[0];

                if (not) {
                    expr = ":not(" + expr + ")";
                }

                return elems.length === 1 && elem.nodeType === 1 ?
                    jQuery.find.matchesSelector(elem, expr) ? [elem] : [] :
                    jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
                        return elem.nodeType === 1;
                    }));
            };

            jQuery.fn.extend({
                find: function (selector) {
                    var i,
                        len = this.length,
                        ret = [],
                        self = this;

                    if (typeof selector !== "string") {
                        return this.pushStack(jQuery(selector).filter(function () {
                            for (i = 0; i < len; i++) {
                                if (jQuery.contains(self[i], this)) {
                                    return true;
                                }
                            }
                        }));
                    }

                    for (i = 0; i < len; i++) {
                        jQuery.find(selector, self[i], ret);
                    }

                    // Needed because $( selector, context ) becomes $( context ).find( selector )
                    ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);
                    ret.selector = this.selector ? this.selector + " " + selector : selector;
                    return ret;
                },
                filter: function (selector) {
                    return this.pushStack(winnow(this, selector || [], false));
                },
                not: function (selector) {
                    return this.pushStack(winnow(this, selector || [], true));
                },
                is: function (selector) {
                    return !!winnow(
                        this,

                        // If this is a positional/relative selector, check membership in the returned set
                        // so $("p:first").is("p:last") won't return true for a doc with two "p".
                        typeof selector === "string" && rneedsContext.test(selector) ?
                            jQuery(selector) :
                            selector || [],
                        false
                    ).length;
                }
            });


            // Initialize a jQuery object


            // A central reference to the root jQuery(document)
            var rootjQuery,

                // A simple way to check for HTML strings
                // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
                // Strict HTML recognition (#11290: must start with <)
                rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

                init = jQuery.fn.init = function (selector, context, root) {
                    var match, elem;

                    // HANDLE: $(""), $(null), $(undefined), $(false)
                    if (!selector) {
                        return this;
                    }

                    // Method init() accepts an alternate rootjQuery
                    // so migrate can support jQuery.sub (gh-2101)
                    root = root || rootjQuery;

                    // Handle HTML strings
                    if (typeof selector === "string") {
                        if (selector[0] === "<" &&
                            selector[selector.length - 1] === ">" &&
                            selector.length >= 3) {

                            // Assume that strings that start and end with <> are HTML and skip the regex check
                            match = [null, selector, null];

                        } else {
                            match = rquickExpr.exec(selector);
                        }

                        // Match html or make sure no context is specified for #id
                        if (match && (match[1] || !context)) {

                            // HANDLE: $(html) -> $(array)
                            if (match[1]) {
                                context = context instanceof jQuery ? context[0] : context;

                                // Option to run scripts is true for back-compat
                                // Intentionally let the error be thrown if parseHTML is not present
                                jQuery.merge(this, jQuery.parseHTML(
                                    match[1],
                                    context && context.nodeType ? context.ownerDocument || context : document,
                                    true
                                ));

                                // HANDLE: $(html, props)
                                if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                                    for (match in context) {

                                        // Properties of context are called as methods if possible
                                        if (jQuery.isFunction(this[match])) {
                                            this[match](context[match]);

                                            // ...and otherwise set as attributes
                                        } else {
                                            this.attr(match, context[match]);
                                        }
                                    }
                                }

                                return this;

                                // HANDLE: $(#id)
                            } else {
                                elem = document.getElementById(match[2]);

                                // Support: Blackberry 4.6
                                // gEBID returns nodes no longer in the document (#6963)
                                if (elem && elem.parentNode) {

                                    // Inject the element directly into the jQuery object
                                    this.length = 1;
                                    this[0] = elem;
                                }

                                this.context = document;
                                this.selector = selector;
                                return this;
                            }

                            // HANDLE: $(expr, $(...))
                        } else if (!context || context.jquery) {
                            return (context || root).find(selector);

                            // HANDLE: $(expr, context)
                            // (which is just equivalent to: $(context).find(expr)
                        } else {
                            return this.constructor(context).find(selector);
                        }

                        // HANDLE: $(DOMElement)
                    } else if (selector.nodeType) {
                        this.context = this[0] = selector;
                        this.length = 1;
                        return this;

                        // HANDLE: $(function)
                        // Shortcut for document ready
                    } else if (jQuery.isFunction(selector)) {
                        return root.ready !== undefined ?
                            root.ready(selector) :

                            // Execute immediately if ready is not present
                            selector(jQuery);
                    }

                    if (selector.selector !== undefined) {
                        this.selector = selector.selector;
                        this.context = selector.context;
                    }

                    return jQuery.makeArray(selector, this);
                };

            // Give the init function the jQuery prototype for later instantiation
            init.prototype = jQuery.fn;

            // Initialize central reference
            rootjQuery = jQuery(document);


            var rparentsprev = /^(?:parents|prev(?:Until|All))/,

                // Methods guaranteed to produce a unique set when starting from a unique set
                guaranteedUnique = {
                    children: true,
                    contents: true,
                    next: true,
                    prev: true
                };

            jQuery.fn.extend({
                has: function (target) {
                    var targets = jQuery(target, this),
                        l = targets.length;

                    return this.filter(function () {
                        var i = 0;
                        for (; i < l; i++) {
                            if (jQuery.contains(this, targets[i])) {
                                return true;
                            }
                        }
                    });
                },

                closest: function (selectors, context) {
                    var cur,
                        i = 0,
                        l = this.length,
                        matched = [],
                        pos = rneedsContext.test(selectors) || typeof selectors !== "string" ?
                            jQuery(selectors, context || this.context) :
                            0;

                    for (; i < l; i++) {
                        for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {

                            // Always skip document fragments
                            if (cur.nodeType < 11 && (pos ?
                                pos.index(cur) > -1 :

                                // Don't pass non-elements to Sizzle
                                cur.nodeType === 1 &&
                                jQuery.find.matchesSelector(cur, selectors))) {

                                matched.push(cur);
                                break;
                            }
                        }
                    }

                    return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
                },

                // Determine the position of an element within the set
                index: function (elem) {

                    // No argument, return index in parent
                    if (!elem) {
                        return (this[0] && this[0].parentNode) ? this.first().prevAll().length : -1;
                    }

                    // Index in selector
                    if (typeof elem === "string") {
                        return indexOf.call(jQuery(elem), this[0]);
                    }

                    // Locate the position of the desired element
                    return indexOf.call(this,

                        // If it receives a jQuery object, the first element is used
                        elem.jquery ? elem[0] : elem
                    );
                },

                add: function (selector, context) {
                    return this.pushStack(
                        jQuery.uniqueSort(
                            jQuery.merge(this.get(), jQuery(selector, context))
                        )
                    );
                },

                addBack: function (selector) {
                    return this.add(selector == null ?
                        this.prevObject : this.prevObject.filter(selector)
                    );
                }
            });

            function sibling(cur, dir) {
                while ((cur = cur[dir]) && cur.nodeType !== 1) { }
                return cur;
            }

            jQuery.each({
                parent: function (elem) {
                    var parent = elem.parentNode;
                    return parent && parent.nodeType !== 11 ? parent : null;
                },
                parents: function (elem) {
                    return dir(elem, "parentNode");
                },
                parentsUntil: function (elem, i, until) {
                    return dir(elem, "parentNode", until);
                },
                next: function (elem) {
                    return sibling(elem, "nextSibling");
                },
                prev: function (elem) {
                    return sibling(elem, "previousSibling");
                },
                nextAll: function (elem) {
                    return dir(elem, "nextSibling");
                },
                prevAll: function (elem) {
                    return dir(elem, "previousSibling");
                },
                nextUntil: function (elem, i, until) {
                    return dir(elem, "nextSibling", until);
                },
                prevUntil: function (elem, i, until) {
                    return dir(elem, "previousSibling", until);
                },
                siblings: function (elem) {
                    return siblings((elem.parentNode || {}).firstChild, elem);
                },
                children: function (elem) {
                    return siblings(elem.firstChild);
                },
                contents: function (elem) {
                    return elem.contentDocument || jQuery.merge([], elem.childNodes);
                }
            }, function (name, fn) {
                jQuery.fn[name] = function (until, selector) {
                    var matched = jQuery.map(this, fn, until);

                    if (name.slice(-5) !== "Until") {
                        selector = until;
                    }

                    if (selector && typeof selector === "string") {
                        matched = jQuery.filter(selector, matched);
                    }

                    if (this.length > 1) {

                        // Remove duplicates
                        if (!guaranteedUnique[name]) {
                            jQuery.uniqueSort(matched);
                        }

                        // Reverse order for parents* and prev-derivatives
                        if (rparentsprev.test(name)) {
                            matched.reverse();
                        }
                    }

                    return this.pushStack(matched);
                };
            });
            var rnotwhite = (/\S+/g);



            // Convert String-formatted options into Object-formatted ones
            function createOptions(options) {
                var object = {};
                jQuery.each(options.match(rnotwhite) || [], function (_, flag) {
                    object[flag] = true;
                });
                return object;
            }

            /*
             * Create a callback list using the following parameters:
             *
             *	options: an optional list of space-separated options that will change how
             *			the callback list behaves or a more traditional option object
             *
             * By default a callback list will act like an event callback list and can be
             * "fired" multiple times.
             *
             * Possible options:
             *
             *	once:			will ensure the callback list can only be fired once (like a Deferred)
             *
             *	memory:			will keep track of previous values and will call any callback added
             *					after the list has been fired right away with the latest "memorized"
             *					values (like a Deferred)
             *
             *	unique:			will ensure a callback can only be added once (no duplicate in the list)
             *
             *	stopOnFalse:	interrupt callings when a callback returns false
             *
             */
            jQuery.Callbacks = function (options) {

                // Convert options from String-formatted to Object-formatted if needed
                // (we check in cache first)
                options = typeof options === "string" ?
                    createOptions(options) :
                    jQuery.extend({}, options);

                var // Flag to know if list is currently firing
                    firing,

                    // Last fire value for non-forgettable lists
                    memory,

                    // Flag to know if list was already fired
                    fired,

                    // Flag to prevent firing
                    locked,

                    // Actual callback list
                    list = [],

                    // Queue of execution data for repeatable lists
                    queue = [],

                    // Index of currently firing callback (modified by add/remove as needed)
                    firingIndex = -1,

                    // Fire callbacks
                    fire = function () {

                        // Enforce single-firing
                        locked = options.once;

                        // Execute callbacks for all pending executions,
                        // respecting firingIndex overrides and runtime changes
                        fired = firing = true;
                        for (; queue.length; firingIndex = -1) {
                            memory = queue.shift();
                            while (++firingIndex < list.length) {

                                // Run callback and check for early termination
                                if (list[firingIndex].apply(memory[0], memory[1]) === false &&
                                    options.stopOnFalse) {

                                    // Jump to end and forget the data so .add doesn't re-fire
                                    firingIndex = list.length;
                                    memory = false;
                                }
                            }
                        }

                        // Forget the data if we're done with it
                        if (!options.memory) {
                            memory = false;
                        }

                        firing = false;

                        // Clean up if we're done firing for good
                        if (locked) {

                            // Keep an empty list if we have data for future add calls
                            if (memory) {
                                list = [];

                                // Otherwise, this object is spent
                            } else {
                                list = "";
                            }
                        }
                    },

                    // Actual Callbacks object
                    self = {

                        // Add a callback or a collection of callbacks to the list
                        add: function () {
                            if (list) {

                                // If we have memory from a past run, we should fire after adding
                                if (memory && !firing) {
                                    firingIndex = list.length - 1;
                                    queue.push(memory);
                                }

                                (function add(args) {
                                    jQuery.each(args, function (_, arg) {
                                        if (jQuery.isFunction(arg)) {
                                            if (!options.unique || !self.has(arg)) {
                                                list.push(arg);
                                            }
                                        } else if (arg && arg.length && jQuery.type(arg) !== "string") {

                                            // Inspect recursively
                                            add(arg);
                                        }
                                    });
                                })(arguments);

                                if (memory && !firing) {
                                    fire();
                                }
                            }
                            return this;
                        },

                        // Remove a callback from the list
                        remove: function () {
                            jQuery.each(arguments, function (_, arg) {
                                var index;
                                while ((index = jQuery.inArray(arg, list, index)) > -1) {
                                    list.splice(index, 1);

                                    // Handle firing indexes
                                    if (index <= firingIndex) {
                                        firingIndex--;
                                    }
                                }
                            });
                            return this;
                        },

                        // Check if a given callback is in the list.
                        // If no argument is given, return whether or not list has callbacks attached.
                        has: function (fn) {
                            return fn ?
                                jQuery.inArray(fn, list) > -1 :
                                list.length > 0;
                        },

                        // Remove all callbacks from the list
                        empty: function () {
                            if (list) {
                                list = [];
                            }
                            return this;
                        },

                        // Disable .fire and .add
                        // Abort any current/pending executions
                        // Clear all callbacks and values
                        disable: function () {
                            locked = queue = [];
                            list = memory = "";
                            return this;
                        },
                        disabled: function () {
                            return !list;
                        },

                        // Disable .fire
                        // Also disable .add unless we have memory (since it would have no effect)
                        // Abort any pending executions
                        lock: function () {
                            locked = queue = [];
                            if (!memory) {
                                list = memory = "";
                            }
                            return this;
                        },
                        locked: function () {
                            return !!locked;
                        },

                        // Call all callbacks with the given context and arguments
                        fireWith: function (context, args) {
                            if (!locked) {
                                args = args || [];
                                args = [context, args.slice ? args.slice() : args];
                                queue.push(args);
                                if (!firing) {
                                    fire();
                                }
                            }
                            return this;
                        },

                        // Call all the callbacks with the given arguments
                        fire: function () {
                            self.fireWith(this, arguments);
                            return this;
                        },

                        // To know if the callbacks have already been called at least once
                        fired: function () {
                            return !!fired;
                        }
                    };

                return self;
            };


            jQuery.extend({

                Deferred: function (func) {
                    var tuples = [

                        // action, add listener, listener list, final state
                        ["resolve", "done", jQuery.Callbacks("once memory"), "resolved"],
                        ["reject", "fail", jQuery.Callbacks("once memory"), "rejected"],
                        ["notify", "progress", jQuery.Callbacks("memory")]
                    ],
                        state = "pending",
                        promise = {
                            state: function () {
                                return state;
                            },
                            always: function () {
                                deferred.done(arguments).fail(arguments);
                                return this;
                            },
                            then: function ( /* fnDone, fnFail, fnProgress */) {
                                var fns = arguments;
                                return jQuery.Deferred(function (newDefer) {
                                    jQuery.each(tuples, function (i, tuple) {
                                        var fn = jQuery.isFunction(fns[i]) && fns[i];

                                        // deferred[ done | fail | progress ] for forwarding actions to newDefer
                                        deferred[tuple[1]](function () {
                                            var returned = fn && fn.apply(this, arguments);
                                            if (returned && jQuery.isFunction(returned.promise)) {
                                                returned.promise()
                                                    .progress(newDefer.notify)
                                                    .done(newDefer.resolve)
                                                    .fail(newDefer.reject);
                                            } else {
                                                newDefer[tuple[0] + "With"](
                                                    this === promise ? newDefer.promise() : this,
                                                    fn ? [returned] : arguments
                                                );
                                            }
                                        });
                                    });
                                    fns = null;
                                }).promise();
                            },

                            // Get a promise for this deferred
                            // If obj is provided, the promise aspect is added to the object
                            promise: function (obj) {
                                return obj != null ? jQuery.extend(obj, promise) : promise;
                            }
                        },
                        deferred = {};

                    // Keep pipe for back-compat
                    promise.pipe = promise.then;

                    // Add list-specific methods
                    jQuery.each(tuples, function (i, tuple) {
                        var list = tuple[2],
                            stateString = tuple[3];

                        // promise[ done | fail | progress ] = list.add
                        promise[tuple[1]] = list.add;

                        // Handle state
                        if (stateString) {
                            list.add(function () {

                                // state = [ resolved | rejected ]
                                state = stateString;

                                // [ reject_list | resolve_list ].disable; progress_list.lock
                            }, tuples[i ^ 1][2].disable, tuples[2][2].lock);
                        }

                        // deferred[ resolve | reject | notify ]
                        deferred[tuple[0]] = function () {
                            deferred[tuple[0] + "With"](this === deferred ? promise : this, arguments);
                            return this;
                        };
                        deferred[tuple[0] + "With"] = list.fireWith;
                    });

                    // Make the deferred a promise
                    promise.promise(deferred);

                    // Call given func if any
                    if (func) {
                        func.call(deferred, deferred);
                    }

                    // All done!
                    return deferred;
                },

                // Deferred helper
                when: function (subordinate /* , ..., subordinateN */) {
                    var i = 0,
                        resolveValues = slice.call(arguments),
                        length = resolveValues.length,

                        // the count of uncompleted subordinates
                        remaining = length !== 1 ||
                            (subordinate && jQuery.isFunction(subordinate.promise)) ? length : 0,

                        // the master Deferred.
                        // If resolveValues consist of only a single Deferred, just use that.
                        deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

                        // Update function for both resolve and progress values
                        updateFunc = function (i, contexts, values) {
                            return function (value) {
                                contexts[i] = this;
                                values[i] = arguments.length > 1 ? slice.call(arguments) : value;
                                if (values === progressValues) {
                                    deferred.notifyWith(contexts, values);
                                } else if (!(--remaining)) {
                                    deferred.resolveWith(contexts, values);
                                }
                            };
                        },

                        progressValues, progressContexts, resolveContexts;

                    // Add listeners to Deferred subordinates; treat others as resolved
                    if (length > 1) {
                        progressValues = new Array(length);
                        progressContexts = new Array(length);
                        resolveContexts = new Array(length);
                        for (; i < length; i++) {
                            if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
                                resolveValues[i].promise()
                                    .progress(updateFunc(i, progressContexts, progressValues))
                                    .done(updateFunc(i, resolveContexts, resolveValues))
                                    .fail(deferred.reject);
                            } else {
                                --remaining;
                            }
                        }
                    }

                    // If we're not waiting on anything, resolve the master
                    if (!remaining) {
                        deferred.resolveWith(resolveContexts, resolveValues);
                    }

                    return deferred.promise();
                }
            });


            // The deferred used on DOM ready
            var readyList;

            jQuery.fn.ready = function (fn) {

                // Add the callback
                jQuery.ready.promise().done(fn);

                return this;
            };

            jQuery.extend({

                // Is the DOM ready to be used? Set to true once it occurs.
                isReady: false,

                // A counter to track how many items to wait for before
                // the ready event fires. See #6781
                readyWait: 1,

                // Hold (or release) the ready event
                holdReady: function (hold) {
                    if (hold) {
                        jQuery.readyWait++;
                    } else {
                        jQuery.ready(true);
                    }
                },

                // Handle when the DOM is ready
                ready: function (wait) {

                    // Abort if there are pending holds or we're already ready
                    if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
                        return;
                    }

                    // Remember that the DOM is ready
                    jQuery.isReady = true;

                    // If a normal DOM Ready event fired, decrement, and wait if need be
                    if (wait !== true && --jQuery.readyWait > 0) {
                        return;
                    }

                    // If there are functions bound, to execute
                    readyList.resolveWith(document, [jQuery]);

                    // Trigger any bound ready events
                    if (jQuery.fn.triggerHandler) {
                        jQuery(document).triggerHandler("ready");
                        jQuery(document).off("ready");
                    }
                }
            });

            /**
             * The ready event handler and self cleanup method
             */
            function completed() {
                document.removeEventListener("DOMContentLoaded", completed);
                window.removeEventListener("load", completed);
                jQuery.ready();
            }

            jQuery.ready.promise = function (obj) {
                if (!readyList) {

                    readyList = jQuery.Deferred();

                    // Catch cases where $(document).ready() is called
                    // after the browser event has already occurred.
                    // Support: IE9-10 only
                    // Older IE sometimes signals "interactive" too soon
                    if (document.readyState === "complete" ||
                        (document.readyState !== "loading" && !document.documentElement.doScroll)) {

                        // Handle it asynchronously to allow scripts the opportunity to delay ready
                        window.setTimeout(jQuery.ready);

                    } else {

                        // Use the handy event callback
                        document.addEventListener("DOMContentLoaded", completed);

                        // A fallback to window.onload, that will always work
                        window.addEventListener("load", completed);
                    }
                }
                return readyList.promise(obj);
            };

            // Kick off the DOM ready check even if the user does not
            jQuery.ready.promise();




            // Multifunctional method to get and set values of a collection
            // The value/s can optionally be executed if it's a function
            var access = function (elems, fn, key, value, chainable, emptyGet, raw) {
                var i = 0,
                    len = elems.length,
                    bulk = key == null;

                // Sets many values
                if (jQuery.type(key) === "object") {
                    chainable = true;
                    for (i in key) {
                        access(elems, fn, i, key[i], true, emptyGet, raw);
                    }

                    // Sets one value
                } else if (value !== undefined) {
                    chainable = true;

                    if (!jQuery.isFunction(value)) {
                        raw = true;
                    }

                    if (bulk) {

                        // Bulk operations run against the entire set
                        if (raw) {
                            fn.call(elems, value);
                            fn = null;

                            // ...except when executing function values
                        } else {
                            bulk = fn;
                            fn = function (elem, key, value) {
                                return bulk.call(jQuery(elem), value);
                            };
                        }
                    }

                    if (fn) {
                        for (; i < len; i++) {
                            fn(
                                elems[i], key, raw ?
                                value :
                                value.call(elems[i], i, fn(elems[i], key))
                            );
                        }
                    }
                }

                return chainable ?
                    elems :

                    // Gets
                    bulk ?
                        fn.call(elems) :
                        len ? fn(elems[0], key) : emptyGet;
            };
            var acceptData = function (owner) {

                // Accepts only:
                //  - Node
                //    - Node.ELEMENT_NODE
                //    - Node.DOCUMENT_NODE
                //  - Object
                //    - Any
                /* jshint -W018 */
                return owner.nodeType === 1 || owner.nodeType === 9 || !(+owner.nodeType);
            };




            function Data() {
                this.expando = jQuery.expando + Data.uid++;
            }

            Data.uid = 1;

            Data.prototype = {

                register: function (owner, initial) {
                    var value = initial || {};

                    // If it is a node unlikely to be stringify-ed or looped over
                    // use plain assignment
                    if (owner.nodeType) {
                        owner[this.expando] = value;

                        // Otherwise secure it in a non-enumerable, non-writable property
                        // configurability must be true to allow the property to be
                        // deleted with the delete operator
                    } else {
                        Object.defineProperty(owner, this.expando, {
                            value: value,
                            writable: true,
                            configurable: true
                        });
                    }
                    return owner[this.expando];
                },
                cache: function (owner) {

                    // We can accept data for non-element nodes in modern browsers,
                    // but we should not, see #8335.
                    // Always return an empty object.
                    if (!acceptData(owner)) {
                        return {};
                    }

                    // Check if the owner object already has a cache
                    var value = owner[this.expando];

                    // If not, create one
                    if (!value) {
                        value = {};

                        // We can accept data for non-element nodes in modern browsers,
                        // but we should not, see #8335.
                        // Always return an empty object.
                        if (acceptData(owner)) {

                            // If it is a node unlikely to be stringify-ed or looped over
                            // use plain assignment
                            if (owner.nodeType) {
                                owner[this.expando] = value;

                                // Otherwise secure it in a non-enumerable property
                                // configurable must be true to allow the property to be
                                // deleted when data is removed
                            } else {
                                Object.defineProperty(owner, this.expando, {
                                    value: value,
                                    configurable: true
                                });
                            }
                        }
                    }

                    return value;
                },
                set: function (owner, data, value) {
                    var prop,
                        cache = this.cache(owner);

                    // Handle: [ owner, key, value ] args
                    if (typeof data === "string") {
                        cache[data] = value;

                        // Handle: [ owner, { properties } ] args
                    } else {

                        // Copy the properties one-by-one to the cache object
                        for (prop in data) {
                            cache[prop] = data[prop];
                        }
                    }
                    return cache;
                },
                get: function (owner, key) {
                    return key === undefined ?
                        this.cache(owner) :
                        owner[this.expando] && owner[this.expando][key];
                },
                access: function (owner, key, value) {
                    var stored;

                    // In cases where either:
                    //
                    //   1. No key was specified
                    //   2. A string key was specified, but no value provided
                    //
                    // Take the "read" path and allow the get method to determine
                    // which value to return, respectively either:
                    //
                    //   1. The entire cache object
                    //   2. The data stored at the key
                    //
                    if (key === undefined ||
                        ((key && typeof key === "string") && value === undefined)) {

                        stored = this.get(owner, key);

                        return stored !== undefined ?
                            stored : this.get(owner, jQuery.camelCase(key));
                    }

                    // When the key is not a string, or both a key and value
                    // are specified, set or extend (existing objects) with either:
                    //
                    //   1. An object of properties
                    //   2. A key and value
                    //
                    this.set(owner, key, value);

                    // Since the "set" path can have two possible entry points
                    // return the expected data based on which path was taken[*]
                    return value !== undefined ? value : key;
                },
                remove: function (owner, key) {
                    var i, name, camel,
                        cache = owner[this.expando];

                    if (cache === undefined) {
                        return;
                    }

                    if (key === undefined) {
                        this.register(owner);

                    } else {

                        // Support array or space separated string of keys
                        if (jQuery.isArray(key)) {

                            // If "name" is an array of keys...
                            // When data is initially created, via ("key", "val") signature,
                            // keys will be converted to camelCase.
                            // Since there is no way to tell _how_ a key was added, remove
                            // both plain key and camelCase key. #12786
                            // This will only penalize the array argument path.
                            name = key.concat(key.map(jQuery.camelCase));
                        } else {
                            camel = jQuery.camelCase(key);

                            // Try the string as a key before any manipulation
                            if (key in cache) {
                                name = [key, camel];
                            } else {

                                // If a key with the spaces exists, use it.
                                // Otherwise, create an array by matching non-whitespace
                                name = camel;
                                name = name in cache ?
                                    [name] : (name.match(rnotwhite) || []);
                            }
                        }

                        i = name.length;

                        while (i--) {
                            delete cache[name[i]];
                        }
                    }

                    // Remove the expando if there's no more data
                    if (key === undefined || jQuery.isEmptyObject(cache)) {

                        // Support: Chrome <= 35-45+
                        // Webkit & Blink performance suffers when deleting properties
                        // from DOM nodes, so set to undefined instead
                        // https://code.google.com/p/chromium/issues/detail?id=378607
                        if (owner.nodeType) {
                            owner[this.expando] = undefined;
                        } else {
                            delete owner[this.expando];
                        }
                    }
                },
                hasData: function (owner) {
                    var cache = owner[this.expando];
                    return cache !== undefined && !jQuery.isEmptyObject(cache);
                }
            };
            var dataPriv = new Data();

            var dataUser = new Data();



            //	Implementation Summary
            //
            //	1. Enforce API surface and semantic compatibility with 1.9.x branch
            //	2. Improve the module's maintainability by reducing the storage
            //		paths to a single mechanism.
            //	3. Use the same single mechanism to support "private" and "user" data.
            //	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
            //	5. Avoid exposing implementation details on user objects (eg. expando properties)
            //	6. Provide a clear path for implementation upgrade to WeakMap in 2014

            var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
                rmultiDash = /[A-Z]/g;

            function dataAttr(elem, key, data) {
                var name;

                // If nothing was found internally, try to fetch any
                // data from the HTML5 data-* attribute
                if (data === undefined && elem.nodeType === 1) {
                    name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
                    data = elem.getAttribute(name);

                    if (typeof data === "string") {
                        try {
                            data = data === "true" ? true :
                                data === "false" ? false :
                                    data === "null" ? null :

                                        // Only convert to a number if it doesn't change the string
                                        +data + "" === data ? +data :
                                            rbrace.test(data) ? jQuery.parseJSON(data) :
                                                data;
                        } catch (e) { }

                        // Make sure we set the data so it isn't changed later
                        dataUser.set(elem, key, data);
                    } else {
                        data = undefined;
                    }
                }
                return data;
            }

            jQuery.extend({
                hasData: function (elem) {
                    return dataUser.hasData(elem) || dataPriv.hasData(elem);
                },

                data: function (elem, name, data) {
                    return dataUser.access(elem, name, data);
                },

                removeData: function (elem, name) {
                    dataUser.remove(elem, name);
                },

                // TODO: Now that all calls to _data and _removeData have been replaced
                // with direct calls to dataPriv methods, these can be deprecated.
                _data: function (elem, name, data) {
                    return dataPriv.access(elem, name, data);
                },

                _removeData: function (elem, name) {
                    dataPriv.remove(elem, name);
                }
            });

            jQuery.fn.extend({
                data: function (key, value) {
                    var i, name, data,
                        elem = this[0],
                        attrs = elem && elem.attributes;

                    // Gets all values
                    if (key === undefined) {
                        if (this.length) {
                            data = dataUser.get(elem);

                            if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
                                i = attrs.length;
                                while (i--) {

                                    // Support: IE11+
                                    // The attrs elements can be null (#14894)
                                    if (attrs[i]) {
                                        name = attrs[i].name;
                                        if (name.indexOf("data-") === 0) {
                                            name = jQuery.camelCase(name.slice(5));
                                            dataAttr(elem, name, data[name]);
                                        }
                                    }
                                }
                                dataPriv.set(elem, "hasDataAttrs", true);
                            }
                        }

                        return data;
                    }

                    // Sets multiple values
                    if (typeof key === "object") {
                        return this.each(function () {
                            dataUser.set(this, key);
                        });
                    }

                    return access(this, function (value) {
                        var data, camelKey;

                        // The calling jQuery object (element matches) is not empty
                        // (and therefore has an element appears at this[ 0 ]) and the
                        // `value` parameter was not undefined. An empty jQuery object
                        // will result in `undefined` for elem = this[ 0 ] which will
                        // throw an exception if an attempt to read a data cache is made.
                        if (elem && value === undefined) {

                            // Attempt to get data from the cache
                            // with the key as-is
                            data = dataUser.get(elem, key) ||

                                // Try to find dashed key if it exists (gh-2779)
                                // This is for 2.2.x only
                                dataUser.get(elem, key.replace(rmultiDash, "-$&").toLowerCase());

                            if (data !== undefined) {
                                return data;
                            }

                            camelKey = jQuery.camelCase(key);

                            // Attempt to get data from the cache
                            // with the key camelized
                            data = dataUser.get(elem, camelKey);
                            if (data !== undefined) {
                                return data;
                            }

                            // Attempt to "discover" the data in
                            // HTML5 custom data-* attrs
                            data = dataAttr(elem, camelKey, undefined);
                            if (data !== undefined) {
                                return data;
                            }

                            // We tried really hard, but the data doesn't exist.
                            return;
                        }

                        // Set the data...
                        camelKey = jQuery.camelCase(key);
                        this.each(function () {

                            // First, attempt to store a copy or reference of any
                            // data that might've been store with a camelCased key.
                            var data = dataUser.get(this, camelKey);

                            // For HTML5 data-* attribute interop, we have to
                            // store property names with dashes in a camelCase form.
                            // This might not apply to all properties...*
                            dataUser.set(this, camelKey, value);

                            // *... In the case of properties that might _actually_
                            // have dashes, we need to also store a copy of that
                            // unchanged property.
                            if (key.indexOf("-") > -1 && data !== undefined) {
                                dataUser.set(this, key, value);
                            }
                        });
                    }, null, value, arguments.length > 1, null, true);
                },

                removeData: function (key) {
                    return this.each(function () {
                        dataUser.remove(this, key);
                    });
                }
            });


            jQuery.extend({
                queue: function (elem, type, data) {
                    var queue;

                    if (elem) {
                        type = (type || "fx") + "queue";
                        queue = dataPriv.get(elem, type);

                        // Speed up dequeue by getting out quickly if this is just a lookup
                        if (data) {
                            if (!queue || jQuery.isArray(data)) {
                                queue = dataPriv.access(elem, type, jQuery.makeArray(data));
                            } else {
                                queue.push(data);
                            }
                        }
                        return queue || [];
                    }
                },

                dequeue: function (elem, type) {
                    type = type || "fx";

                    var queue = jQuery.queue(elem, type),
                        startLength = queue.length,
                        fn = queue.shift(),
                        hooks = jQuery._queueHooks(elem, type),
                        next = function () {
                            jQuery.dequeue(elem, type);
                        };

                    // If the fx queue is dequeued, always remove the progress sentinel
                    if (fn === "inprogress") {
                        fn = queue.shift();
                        startLength--;
                    }

                    if (fn) {

                        // Add a progress sentinel to prevent the fx queue from being
                        // automatically dequeued
                        if (type === "fx") {
                            queue.unshift("inprogress");
                        }

                        // Clear up the last queue stop function
                        delete hooks.stop;
                        fn.call(elem, next, hooks);
                    }

                    if (!startLength && hooks) {
                        hooks.empty.fire();
                    }
                },

                // Not public - generate a queueHooks object, or return the current one
                _queueHooks: function (elem, type) {
                    var key = type + "queueHooks";
                    return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
                        empty: jQuery.Callbacks("once memory").add(function () {
                            dataPriv.remove(elem, [type + "queue", key]);
                        })
                    });
                }
            });

            jQuery.fn.extend({
                queue: function (type, data) {
                    var setter = 2;

                    if (typeof type !== "string") {
                        data = type;
                        type = "fx";
                        setter--;
                    }

                    if (arguments.length < setter) {
                        return jQuery.queue(this[0], type);
                    }

                    return data === undefined ?
                        this :
                        this.each(function () {
                            var queue = jQuery.queue(this, type, data);

                            // Ensure a hooks for this queue
                            jQuery._queueHooks(this, type);

                            if (type === "fx" && queue[0] !== "inprogress") {
                                jQuery.dequeue(this, type);
                            }
                        });
                },
                dequeue: function (type) {
                    return this.each(function () {
                        jQuery.dequeue(this, type);
                    });
                },
                clearQueue: function (type) {
                    return this.queue(type || "fx", []);
                },

                // Get a promise resolved when queues of a certain type
                // are emptied (fx is the type by default)
                promise: function (type, obj) {
                    var tmp,
                        count = 1,
                        defer = jQuery.Deferred(),
                        elements = this,
                        i = this.length,
                        resolve = function () {
                            if (!(--count)) {
                                defer.resolveWith(elements, [elements]);
                            }
                        };

                    if (typeof type !== "string") {
                        obj = type;
                        type = undefined;
                    }
                    type = type || "fx";

                    while (i--) {
                        tmp = dataPriv.get(elements[i], type + "queueHooks");
                        if (tmp && tmp.empty) {
                            count++;
                            tmp.empty.add(resolve);
                        }
                    }
                    resolve();
                    return defer.promise(obj);
                }
            });
            var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;

            var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");


            var cssExpand = ["Top", "Right", "Bottom", "Left"];

            var isHidden = function (elem, el) {

                // isHidden might be called from jQuery#filter function;
                // in that case, element will be second argument
                elem = el || elem;
                return jQuery.css(elem, "display") === "none" ||
                    !jQuery.contains(elem.ownerDocument, elem);
            };



            function adjustCSS(elem, prop, valueParts, tween) {
                var adjusted,
                    scale = 1,
                    maxIterations = 20,
                    currentValue = tween ?
                        function () { return tween.cur(); } :
                        function () { return jQuery.css(elem, prop, ""); },
                    initial = currentValue(),
                    unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"),

                    // Starting value computation is required for potential unit mismatches
                    initialInUnit = (jQuery.cssNumber[prop] || unit !== "px" && +initial) &&
                        rcssNum.exec(jQuery.css(elem, prop));

                if (initialInUnit && initialInUnit[3] !== unit) {

                    // Trust units reported by jQuery.css
                    unit = unit || initialInUnit[3];

                    // Make sure we update the tween properties later on
                    valueParts = valueParts || [];

                    // Iteratively approximate from a nonzero starting point
                    initialInUnit = +initial || 1;

                    do {

                        // If previous iteration zeroed out, double until we get *something*.
                        // Use string for doubling so we don't accidentally see scale as unchanged below
                        scale = scale || ".5";

                        // Adjust and apply
                        initialInUnit = initialInUnit / scale;
                        jQuery.style(elem, prop, initialInUnit + unit);

                        // Update scale, tolerating zero or NaN from tween.cur()
                        // Break the loop if scale is unchanged or perfect, or if we've just had enough.
                    } while (
                        scale !== (scale = currentValue() / initial) && scale !== 1 && --maxIterations
                    );
                }

                if (valueParts) {
                    initialInUnit = +initialInUnit || +initial || 0;

                    // Apply relative offset (+=/-=) if specified
                    adjusted = valueParts[1] ?
                        initialInUnit + (valueParts[1] + 1) * valueParts[2] :
                        +valueParts[2];
                    if (tween) {
                        tween.unit = unit;
                        tween.start = initialInUnit;
                        tween.end = adjusted;
                    }
                }
                return adjusted;
            }
            var rcheckableType = (/^(?:checkbox|radio)$/i);

            var rtagName = (/<([\w:-]+)/);

            var rscriptType = (/^$|\/(?:java|ecma)script/i);



            // We have to close these tags to support XHTML (#13200)
            var wrapMap = {

                // Support: IE9
                option: [1, "<select multiple='multiple'>", "</select>"],

                // XHTML parsers do not magically insert elements in the
                // same way that tag soup parsers do. So we cannot shorten
                // this by omitting <tbody> or other required elements.
                thead: [1, "<table>", "</table>"],
                col: [2, "<table><colgroup>", "</colgroup></table>"],
                tr: [2, "<table><tbody>", "</tbody></table>"],
                td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],

                _default: [0, "", ""]
            };

            // Support: IE9
            wrapMap.optgroup = wrapMap.option;

            wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
            wrapMap.th = wrapMap.td;


            function getAll(context, tag) {

                // Support: IE9-11+
                // Use typeof to avoid zero-argument method invocation on host objects (#15151)
                var ret = typeof context.getElementsByTagName !== "undefined" ?
                    context.getElementsByTagName(tag || "*") :
                    typeof context.querySelectorAll !== "undefined" ?
                        context.querySelectorAll(tag || "*") :
                        [];

                return tag === undefined || tag && jQuery.nodeName(context, tag) ?
                    jQuery.merge([context], ret) :
                    ret;
            }


            // Mark scripts as having already been evaluated
            function setGlobalEval(elems, refElements) {
                var i = 0,
                    l = elems.length;

                for (; i < l; i++) {
                    dataPriv.set(
                        elems[i],
                        "globalEval",
                        !refElements || dataPriv.get(refElements[i], "globalEval")
                    );
                }
            }


            var rhtml = /<|&#?\w+;/;

            function buildFragment(elems, context, scripts, selection, ignored) {
                var elem, tmp, tag, wrap, contains, j,
                    fragment = context.createDocumentFragment(),
                    nodes = [],
                    i = 0,
                    l = elems.length;

                for (; i < l; i++) {
                    elem = elems[i];

                    if (elem || elem === 0) {

                        // Add nodes directly
                        if (jQuery.type(elem) === "object") {

                            // Support: Android<4.1, PhantomJS<2
                            // push.apply(_, arraylike) throws on ancient WebKit
                            jQuery.merge(nodes, elem.nodeType ? [elem] : elem);

                            // Convert non-html into a text node
                        } else if (!rhtml.test(elem)) {
                            nodes.push(context.createTextNode(elem));

                            // Convert html into DOM nodes
                        } else {
                            tmp = tmp || fragment.appendChild(context.createElement("div"));

                            // Deserialize a standard representation
                            tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
                            wrap = wrapMap[tag] || wrapMap._default;
                            tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];

                            // Descend through wrappers to the right content
                            j = wrap[0];
                            while (j--) {
                                tmp = tmp.lastChild;
                            }

                            // Support: Android<4.1, PhantomJS<2
                            // push.apply(_, arraylike) throws on ancient WebKit
                            jQuery.merge(nodes, tmp.childNodes);

                            // Remember the top-level container
                            tmp = fragment.firstChild;

                            // Ensure the created nodes are orphaned (#12392)
                            tmp.textContent = "";
                        }
                    }
                }

                // Remove wrapper from fragment
                fragment.textContent = "";

                i = 0;
                while ((elem = nodes[i++])) {

                    // Skip elements already in the context collection (trac-4087)
                    if (selection && jQuery.inArray(elem, selection) > -1) {
                        if (ignored) {
                            ignored.push(elem);
                        }
                        continue;
                    }

                    contains = jQuery.contains(elem.ownerDocument, elem);

                    // Append to fragment
                    tmp = getAll(fragment.appendChild(elem), "script");

                    // Preserve script evaluation history
                    if (contains) {
                        setGlobalEval(tmp);
                    }

                    // Capture executables
                    if (scripts) {
                        j = 0;
                        while ((elem = tmp[j++])) {
                            if (rscriptType.test(elem.type || "")) {
                                scripts.push(elem);
                            }
                        }
                    }
                }

                return fragment;
            }


            (function () {
                var fragment = document.createDocumentFragment(),
                    div = fragment.appendChild(document.createElement("div")),
                    input = document.createElement("input");

                // Support: Android 4.0-4.3, Safari<=5.1
                // Check state lost if the name is set (#11217)
                // Support: Windows Web Apps (WWA)
                // `name` and `type` must use .setAttribute for WWA (#14901)
                input.setAttribute("type", "radio");
                input.setAttribute("checked", "checked");
                input.setAttribute("name", "t");

                div.appendChild(input);

                // Support: Safari<=5.1, Android<4.2
                // Older WebKit doesn't clone checked state correctly in fragments
                support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;

                // Support: IE<=11+
                // Make sure textarea (and checkbox) defaultValue is properly cloned
                div.innerHTML = "<textarea>x</textarea>";
                support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
            })();


            var
                rkeyEvent = /^key/,
                rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
                rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

            function returnTrue() {
                return true;
            }

            function returnFalse() {
                return false;
            }

            // Support: IE9
            // See #13393 for more info
            function safeActiveElement() {
                try {
                    return document.activeElement;
                } catch (err) { }
            }

            function on(elem, types, selector, data, fn, one) {
                var origFn, type;

                // Types can be a map of types/handlers
                if (typeof types === "object") {

                    // ( types-Object, selector, data )
                    if (typeof selector !== "string") {

                        // ( types-Object, data )
                        data = data || selector;
                        selector = undefined;
                    }
                    for (type in types) {
                        on(elem, type, selector, data, types[type], one);
                    }
                    return elem;
                }

                if (data == null && fn == null) {

                    // ( types, fn )
                    fn = selector;
                    data = selector = undefined;
                } else if (fn == null) {
                    if (typeof selector === "string") {

                        // ( types, selector, fn )
                        fn = data;
                        data = undefined;
                    } else {

                        // ( types, data, fn )
                        fn = data;
                        data = selector;
                        selector = undefined;
                    }
                }
                if (fn === false) {
                    fn = returnFalse;
                } else if (!fn) {
                    return elem;
                }

                if (one === 1) {
                    origFn = fn;
                    fn = function (event) {

                        // Can use an empty set, since event contains the info
                        jQuery().off(event);
                        return origFn.apply(this, arguments);
                    };

                    // Use same guid so caller can remove using origFn
                    fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
                }
                return elem.each(function () {
                    jQuery.event.add(this, types, fn, data, selector);
                });
            }

            /*
             * Helper functions for managing events -- not part of the public interface.
             * Props to Dean Edwards' addEvent library for many of the ideas.
             */
            jQuery.event = {

                global: {},

                add: function (elem, types, handler, data, selector) {

                    var handleObjIn, eventHandle, tmp,
                        events, t, handleObj,
                        special, handlers, type, namespaces, origType,
                        elemData = dataPriv.get(elem);

                    // Don't attach events to noData or text/comment nodes (but allow plain objects)
                    if (!elemData) {
                        return;
                    }

                    // Caller can pass in an object of custom data in lieu of the handler
                    if (handler.handler) {
                        handleObjIn = handler;
                        handler = handleObjIn.handler;
                        selector = handleObjIn.selector;
                    }

                    // Make sure that the handler has a unique ID, used to find/remove it later
                    if (!handler.guid) {
                        handler.guid = jQuery.guid++;
                    }

                    // Init the element's event structure and main handler, if this is the first
                    if (!(events = elemData.events)) {
                        events = elemData.events = {};
                    }
                    if (!(eventHandle = elemData.handle)) {
                        eventHandle = elemData.handle = function (e) {

                            // Discard the second event of a jQuery.event.trigger() and
                            // when an event is called after a page has unloaded
                            return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
                                jQuery.event.dispatch.apply(elem, arguments) : undefined;
                        };
                    }

                    // Handle multiple events separated by a space
                    types = (types || "").match(rnotwhite) || [""];
                    t = types.length;
                    while (t--) {
                        tmp = rtypenamespace.exec(types[t]) || [];
                        type = origType = tmp[1];
                        namespaces = (tmp[2] || "").split(".").sort();

                        // There *must* be a type, no attaching namespace-only handlers
                        if (!type) {
                            continue;
                        }

                        // If event changes its type, use the special event handlers for the changed type
                        special = jQuery.event.special[type] || {};

                        // If selector defined, determine special event api type, otherwise given type
                        type = (selector ? special.delegateType : special.bindType) || type;

                        // Update special based on newly reset type
                        special = jQuery.event.special[type] || {};

                        // handleObj is passed to all event handlers
                        handleObj = jQuery.extend({
                            type: type,
                            origType: origType,
                            data: data,
                            handler: handler,
                            guid: handler.guid,
                            selector: selector,
                            needsContext: selector && jQuery.expr.match.needsContext.test(selector),
                            namespace: namespaces.join(".")
                        }, handleObjIn);

                        // Init the event handler queue if we're the first
                        if (!(handlers = events[type])) {
                            handlers = events[type] = [];
                            handlers.delegateCount = 0;

                            // Only use addEventListener if the special events handler returns false
                            if (!special.setup ||
                                special.setup.call(elem, data, namespaces, eventHandle) === false) {

                                if (elem.addEventListener) {
                                    elem.addEventListener(type, eventHandle);
                                }
                            }
                        }

                        if (special.add) {
                            special.add.call(elem, handleObj);

                            if (!handleObj.handler.guid) {
                                handleObj.handler.guid = handler.guid;
                            }
                        }

                        // Add to the element's handler list, delegates in front
                        if (selector) {
                            handlers.splice(handlers.delegateCount++, 0, handleObj);
                        } else {
                            handlers.push(handleObj);
                        }

                        // Keep track of which events have ever been used, for event optimization
                        jQuery.event.global[type] = true;
                    }

                },

                // Detach an event or set of events from an element
                remove: function (elem, types, handler, selector, mappedTypes) {

                    var j, origCount, tmp,
                        events, t, handleObj,
                        special, handlers, type, namespaces, origType,
                        elemData = dataPriv.hasData(elem) && dataPriv.get(elem);

                    if (!elemData || !(events = elemData.events)) {
                        return;
                    }

                    // Once for each type.namespace in types; type may be omitted
                    types = (types || "").match(rnotwhite) || [""];
                    t = types.length;
                    while (t--) {
                        tmp = rtypenamespace.exec(types[t]) || [];
                        type = origType = tmp[1];
                        namespaces = (tmp[2] || "").split(".").sort();

                        // Unbind all events (on this namespace, if provided) for the element
                        if (!type) {
                            for (type in events) {
                                jQuery.event.remove(elem, type + types[t], handler, selector, true);
                            }
                            continue;
                        }

                        special = jQuery.event.special[type] || {};
                        type = (selector ? special.delegateType : special.bindType) || type;
                        handlers = events[type] || [];
                        tmp = tmp[2] &&
                            new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");

                        // Remove matching events
                        origCount = j = handlers.length;
                        while (j--) {
                            handleObj = handlers[j];

                            if ((mappedTypes || origType === handleObj.origType) &&
                                (!handler || handler.guid === handleObj.guid) &&
                                (!tmp || tmp.test(handleObj.namespace)) &&
                                (!selector || selector === handleObj.selector ||
                                    selector === "**" && handleObj.selector)) {
                                handlers.splice(j, 1);

                                if (handleObj.selector) {
                                    handlers.delegateCount--;
                                }
                                if (special.remove) {
                                    special.remove.call(elem, handleObj);
                                }
                            }
                        }

                        // Remove generic event handler if we removed something and no more handlers exist
                        // (avoids potential for endless recursion during removal of special event handlers)
                        if (origCount && !handlers.length) {
                            if (!special.teardown ||
                                special.teardown.call(elem, namespaces, elemData.handle) === false) {

                                jQuery.removeEvent(elem, type, elemData.handle);
                            }

                            delete events[type];
                        }
                    }

                    // Remove data and the expando if it's no longer used
                    if (jQuery.isEmptyObject(events)) {
                        dataPriv.remove(elem, "handle events");
                    }
                },

                dispatch: function (event) {

                    // Make a writable jQuery.Event from the native event object
                    event = jQuery.event.fix(event);

                    var i, j, ret, matched, handleObj,
                        handlerQueue = [],
                        args = slice.call(arguments),
                        handlers = (dataPriv.get(this, "events") || {})[event.type] || [],
                        special = jQuery.event.special[event.type] || {};

                    // Use the fix-ed jQuery.Event rather than the (read-only) native event
                    args[0] = event;
                    event.delegateTarget = this;

                    // Call the preDispatch hook for the mapped type, and let it bail if desired
                    if (special.preDispatch && special.preDispatch.call(this, event) === false) {
                        return;
                    }

                    // Determine handlers
                    handlerQueue = jQuery.event.handlers.call(this, event, handlers);

                    // Run delegates first; they may want to stop propagation beneath us
                    i = 0;
                    while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
                        event.currentTarget = matched.elem;

                        j = 0;
                        while ((handleObj = matched.handlers[j++]) &&
                            !event.isImmediatePropagationStopped()) {

                            // Triggered event must either 1) have no namespace, or 2) have namespace(s)
                            // a subset or equal to those in the bound event (both can have no namespace).
                            if (!event.rnamespace || event.rnamespace.test(handleObj.namespace)) {

                                event.handleObj = handleObj;
                                event.data = handleObj.data;

                                ret = ((jQuery.event.special[handleObj.origType] || {}).handle ||
                                    handleObj.handler).apply(matched.elem, args);

                                if (ret !== undefined) {
                                    if ((event.result = ret) === false) {
                                        event.preventDefault();
                                        event.stopPropagation();
                                    }
                                }
                            }
                        }
                    }

                    // Call the postDispatch hook for the mapped type
                    if (special.postDispatch) {
                        special.postDispatch.call(this, event);
                    }

                    return event.result;
                },

                handlers: function (event, handlers) {
                    var i, matches, sel, handleObj,
                        handlerQueue = [],
                        delegateCount = handlers.delegateCount,
                        cur = event.target;

                    // Support (at least): Chrome, IE9
                    // Find delegate handlers
                    // Black-hole SVG <use> instance trees (#13180)
                    //
                    // Support: Firefox<=42+
                    // Avoid non-left-click in FF but don't block IE radio events (#3861, gh-2343)
                    if (delegateCount && cur.nodeType &&
                        (event.type !== "click" || isNaN(event.button) || event.button < 1)) {

                        for (; cur !== this; cur = cur.parentNode || this) {

                            // Don't check non-elements (#13208)
                            // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
                            if (cur.nodeType === 1 && (cur.disabled !== true || event.type !== "click")) {
                                matches = [];
                                for (i = 0; i < delegateCount; i++) {
                                    handleObj = handlers[i];

                                    // Don't conflict with Object.prototype properties (#13203)
                                    sel = handleObj.selector + " ";

                                    if (matches[sel] === undefined) {
                                        matches[sel] = handleObj.needsContext ?
                                            jQuery(sel, this).index(cur) > -1 :
                                            jQuery.find(sel, this, null, [cur]).length;
                                    }
                                    if (matches[sel]) {
                                        matches.push(handleObj);
                                    }
                                }
                                if (matches.length) {
                                    handlerQueue.push({ elem: cur, handlers: matches });
                                }
                            }
                        }
                    }

                    // Add the remaining (directly-bound) handlers
                    if (delegateCount < handlers.length) {
                        handlerQueue.push({ elem: this, handlers: handlers.slice(delegateCount) });
                    }

                    return handlerQueue;
                },

                // Includes some event props shared by KeyEvent and MouseEvent
                props: ("altKey bubbles cancelable ctrlKey currentTarget detail eventPhase " +
                    "metaKey relatedTarget shiftKey target timeStamp view which").split(" "),

                fixHooks: {},

                keyHooks: {
                    props: "char charCode key keyCode".split(" "),
                    filter: function (event, original) {

                        // Add which for key events
                        if (event.which == null) {
                            event.which = original.charCode != null ? original.charCode : original.keyCode;
                        }

                        return event;
                    }
                },

                mouseHooks: {
                    props: ("button buttons clientX clientY offsetX offsetY pageX pageY " +
                        "screenX screenY toElement").split(" "),
                    filter: function (event, original) {
                        var eventDoc, doc, body,
                            button = original.button;

                        // Calculate pageX/Y if missing and clientX/Y available
                        if (event.pageX == null && original.clientX != null) {
                            eventDoc = event.target.ownerDocument || document;
                            doc = eventDoc.documentElement;
                            body = eventDoc.body;

                            event.pageX = original.clientX +
                                (doc && doc.scrollLeft || body && body.scrollLeft || 0) -
                                (doc && doc.clientLeft || body && body.clientLeft || 0);
                            event.pageY = original.clientY +
                                (doc && doc.scrollTop || body && body.scrollTop || 0) -
                                (doc && doc.clientTop || body && body.clientTop || 0);
                        }

                        // Add which for click: 1 === left; 2 === middle; 3 === right
                        // Note: button is not normalized, so don't use it
                        if (!event.which && button !== undefined) {
                            event.which = (button & 1 ? 1 : (button & 2 ? 3 : (button & 4 ? 2 : 0)));
                        }

                        return event;
                    }
                },

                fix: function (event) {
                    if (event[jQuery.expando]) {
                        return event;
                    }

                    // Create a writable copy of the event object and normalize some properties
                    var i, prop, copy,
                        type = event.type,
                        originalEvent = event,
                        fixHook = this.fixHooks[type];

                    if (!fixHook) {
                        this.fixHooks[type] = fixHook =
                            rmouseEvent.test(type) ? this.mouseHooks :
                                rkeyEvent.test(type) ? this.keyHooks :
                                    {};
                    }
                    copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;

                    event = new jQuery.Event(originalEvent);

                    i = copy.length;
                    while (i--) {
                        prop = copy[i];
                        event[prop] = originalEvent[prop];
                    }

                    // Support: Cordova 2.5 (WebKit) (#13255)
                    // All events should have a target; Cordova deviceready doesn't
                    if (!event.target) {
                        event.target = document;
                    }

                    // Support: Safari 6.0+, Chrome<28
                    // Target should not be a text node (#504, #13143)
                    if (event.target.nodeType === 3) {
                        event.target = event.target.parentNode;
                    }

                    return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
                },

                special: {
                    load: {

                        // Prevent triggered image.load events from bubbling to window.load
                        noBubble: true
                    },
                    focus: {

                        // Fire native event if possible so blur/focus sequence is correct
                        trigger: function () {
                            if (this !== safeActiveElement() && this.focus) {
                                this.focus();
                                return false;
                            }
                        },
                        delegateType: "focusin"
                    },
                    blur: {
                        trigger: function () {
                            if (this === safeActiveElement() && this.blur) {
                                this.blur();
                                return false;
                            }
                        },
                        delegateType: "focusout"
                    },
                    click: {

                        // For checkbox, fire native event so checked state will be right
                        trigger: function () {
                            if (this.type === "checkbox" && this.click && jQuery.nodeName(this, "input")) {
                                this.click();
                                return false;
                            }
                        },

                        // For cross-browser consistency, don't fire native .click() on links
                        _default: function (event) {
                            return jQuery.nodeName(event.target, "a");
                        }
                    },

                    beforeunload: {
                        postDispatch: function (event) {

                            // Support: Firefox 20+
                            // Firefox doesn't alert if the returnValue field is not set.
                            if (event.result !== undefined && event.originalEvent) {
                                event.originalEvent.returnValue = event.result;
                            }
                        }
                    }
                }
            };

            jQuery.removeEvent = function (elem, type, handle) {

                // This "if" is needed for plain objects
                if (elem.removeEventListener) {
                    elem.removeEventListener(type, handle);
                }
            };

            jQuery.Event = function (src, props) {

                // Allow instantiation without the 'new' keyword
                if (!(this instanceof jQuery.Event)) {
                    return new jQuery.Event(src, props);
                }

                // Event object
                if (src && src.type) {
                    this.originalEvent = src;
                    this.type = src.type;

                    // Events bubbling up the document may have been marked as prevented
                    // by a handler lower down the tree; reflect the correct value.
                    this.isDefaultPrevented = src.defaultPrevented ||
                        src.defaultPrevented === undefined &&

                        // Support: Android<4.0
                        src.returnValue === false ?
                        returnTrue :
                        returnFalse;

                    // Event type
                } else {
                    this.type = src;
                }

                // Put explicitly provided properties onto the event object
                if (props) {
                    jQuery.extend(this, props);
                }

                // Create a timestamp if incoming event doesn't have one
                this.timeStamp = src && src.timeStamp || jQuery.now();

                // Mark it as fixed
                this[jQuery.expando] = true;
            };

            // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
            // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
            jQuery.Event.prototype = {
                constructor: jQuery.Event,
                isDefaultPrevented: returnFalse,
                isPropagationStopped: returnFalse,
                isImmediatePropagationStopped: returnFalse,
                isSimulated: false,

                preventDefault: function () {
                    var e = this.originalEvent;

                    this.isDefaultPrevented = returnTrue;

                    if (e && !this.isSimulated) {
                        e.preventDefault();
                    }
                },
                stopPropagation: function () {
                    var e = this.originalEvent;

                    this.isPropagationStopped = returnTrue;

                    if (e && !this.isSimulated) {
                        e.stopPropagation();
                    }
                },
                stopImmediatePropagation: function () {
                    var e = this.originalEvent;

                    this.isImmediatePropagationStopped = returnTrue;

                    if (e && !this.isSimulated) {
                        e.stopImmediatePropagation();
                    }

                    this.stopPropagation();
                }
            };

            // Create mouseenter/leave events using mouseover/out and event-time checks
            // so that event delegation works in jQuery.
            // Do the same for pointerenter/pointerleave and pointerover/pointerout
            //
            // Support: Safari 7 only
            // Safari sends mouseenter too often; see:
            // https://code.google.com/p/chromium/issues/detail?id=470258
            // for the description of the bug (it existed in older Chrome versions as well).
            jQuery.each({
                mouseenter: "mouseover",
                mouseleave: "mouseout",
                pointerenter: "pointerover",
                pointerleave: "pointerout"
            }, function (orig, fix) {
                jQuery.event.special[orig] = {
                    delegateType: fix,
                    bindType: fix,

                    handle: function (event) {
                        var ret,
                            target = this,
                            related = event.relatedTarget,
                            handleObj = event.handleObj;

                        // For mouseenter/leave call the handler if related is outside the target.
                        // NB: No relatedTarget if the mouse left/entered the browser window
                        if (!related || (related !== target && !jQuery.contains(target, related))) {
                            event.type = handleObj.origType;
                            ret = handleObj.handler.apply(this, arguments);
                            event.type = fix;
                        }
                        return ret;
                    }
                };
            });

            jQuery.fn.extend({
                on: function (types, selector, data, fn) {
                    return on(this, types, selector, data, fn);
                },
                one: function (types, selector, data, fn) {
                    return on(this, types, selector, data, fn, 1);
                },
                off: function (types, selector, fn) {
                    var handleObj, type;
                    if (types && types.preventDefault && types.handleObj) {

                        // ( event )  dispatched jQuery.Event
                        handleObj = types.handleObj;
                        jQuery(types.delegateTarget).off(
                            handleObj.namespace ?
                                handleObj.origType + "." + handleObj.namespace :
                                handleObj.origType,
                            handleObj.selector,
                            handleObj.handler
                        );
                        return this;
                    }
                    if (typeof types === "object") {

                        // ( types-object [, selector] )
                        for (type in types) {
                            this.off(type, selector, types[type]);
                        }
                        return this;
                    }
                    if (selector === false || typeof selector === "function") {

                        // ( types [, fn] )
                        fn = selector;
                        selector = undefined;
                    }
                    if (fn === false) {
                        fn = returnFalse;
                    }
                    return this.each(function () {
                        jQuery.event.remove(this, types, fn, selector);
                    });
                }
            });


            var
                rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi,

                // Support: IE 10-11, Edge 10240+
                // In IE/Edge using regex groups here causes severe slowdowns.
                // See https://connect.microsoft.com/IE/feedback/details/1736512/
                rnoInnerhtml = /<script|<style|<link/i,

                // checked="checked" or checked
                rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
                rscriptTypeMasked = /^true\/(.*)/,
                rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

            // Manipulating tables requires a tbody
            function manipulationTarget(elem, content) {
                return jQuery.nodeName(elem, "table") &&
                    jQuery.nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr") ?

                    elem.getElementsByTagName("tbody")[0] ||
                    elem.appendChild(elem.ownerDocument.createElement("tbody")) :
                    elem;
            }

            // Replace/restore the type attribute of script elements for safe DOM manipulation
            function disableScript(elem) {
                elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
                return elem;
            }
            function restoreScript(elem) {
                var match = rscriptTypeMasked.exec(elem.type);

                if (match) {
                    elem.type = match[1];
                } else {
                    elem.removeAttribute("type");
                }

                return elem;
            }

            function cloneCopyEvent(src, dest) {
                var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

                if (dest.nodeType !== 1) {
                    return;
                }

                // 1. Copy private data: events, handlers, etc.
                if (dataPriv.hasData(src)) {
                    pdataOld = dataPriv.access(src);
                    pdataCur = dataPriv.set(dest, pdataOld);
                    events = pdataOld.events;

                    if (events) {
                        delete pdataCur.handle;
                        pdataCur.events = {};

                        for (type in events) {
                            for (i = 0, l = events[type].length; i < l; i++) {
                                jQuery.event.add(dest, type, events[type][i]);
                            }
                        }
                    }
                }

                // 2. Copy user data
                if (dataUser.hasData(src)) {
                    udataOld = dataUser.access(src);
                    udataCur = jQuery.extend({}, udataOld);

                    dataUser.set(dest, udataCur);
                }
            }

            // Fix IE bugs, see support tests
            function fixInput(src, dest) {
                var nodeName = dest.nodeName.toLowerCase();

                // Fails to persist the checked state of a cloned checkbox or radio button.
                if (nodeName === "input" && rcheckableType.test(src.type)) {
                    dest.checked = src.checked;

                    // Fails to return the selected option to the default selected state when cloning options
                } else if (nodeName === "input" || nodeName === "textarea") {
                    dest.defaultValue = src.defaultValue;
                }
            }

            function domManip(collection, args, callback, ignored) {

                // Flatten any nested arrays
                args = concat.apply([], args);

                var fragment, first, scripts, hasScripts, node, doc,
                    i = 0,
                    l = collection.length,
                    iNoClone = l - 1,
                    value = args[0],
                    isFunction = jQuery.isFunction(value);

                // We can't cloneNode fragments that contain checked, in WebKit
                if (isFunction ||
                    (l > 1 && typeof value === "string" &&
                        !support.checkClone && rchecked.test(value))) {
                    return collection.each(function (index) {
                        var self = collection.eq(index);
                        if (isFunction) {
                            args[0] = value.call(this, index, self.html());
                        }
                        domManip(self, args, callback, ignored);
                    });
                }

                if (l) {
                    fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
                    first = fragment.firstChild;

                    if (fragment.childNodes.length === 1) {
                        fragment = first;
                    }

                    // Require either new content or an interest in ignored elements to invoke the callback
                    if (first || ignored) {
                        scripts = jQuery.map(getAll(fragment, "script"), disableScript);
                        hasScripts = scripts.length;

                        // Use the original fragment for the last item
                        // instead of the first because it can end up
                        // being emptied incorrectly in certain situations (#8070).
                        for (; i < l; i++) {
                            node = fragment;

                            if (i !== iNoClone) {
                                node = jQuery.clone(node, true, true);

                                // Keep references to cloned scripts for later restoration
                                if (hasScripts) {

                                    // Support: Android<4.1, PhantomJS<2
                                    // push.apply(_, arraylike) throws on ancient WebKit
                                    jQuery.merge(scripts, getAll(node, "script"));
                                }
                            }

                            callback.call(collection[i], node, i);
                        }

                        if (hasScripts) {
                            doc = scripts[scripts.length - 1].ownerDocument;

                            // Reenable scripts
                            jQuery.map(scripts, restoreScript);

                            // Evaluate executable scripts on first document insertion
                            for (i = 0; i < hasScripts; i++) {
                                node = scripts[i];
                                if (rscriptType.test(node.type || "") &&
                                    !dataPriv.access(node, "globalEval") &&
                                    jQuery.contains(doc, node)) {

                                    if (node.src) {

                                        // Optional AJAX dependency, but won't run scripts if not present
                                        if (jQuery._evalUrl) {
                                            jQuery._evalUrl(node.src);
                                        }
                                    } else {
                                        jQuery.globalEval(node.textContent.replace(rcleanScript, ""));
                                    }
                                }
                            }
                        }
                    }
                }

                return collection;
            }

            function remove(elem, selector, keepData) {
                var node,
                    nodes = selector ? jQuery.filter(selector, elem) : elem,
                    i = 0;

                for (; (node = nodes[i]) != null; i++) {
                    if (!keepData && node.nodeType === 1) {
                        jQuery.cleanData(getAll(node));
                    }

                    if (node.parentNode) {
                        if (keepData && jQuery.contains(node.ownerDocument, node)) {
                            setGlobalEval(getAll(node, "script"));
                        }
                        node.parentNode.removeChild(node);
                    }
                }

                return elem;
            }

            jQuery.extend({
                htmlPrefilter: function (html) {
                    return html.replace(rxhtmlTag, "<$1></$2>");
                },

                clone: function (elem, dataAndEvents, deepDataAndEvents) {
                    var i, l, srcElements, destElements,
                        clone = elem.cloneNode(true),
                        inPage = jQuery.contains(elem.ownerDocument, elem);

                    // Fix IE cloning issues
                    if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) &&
                        !jQuery.isXMLDoc(elem)) {

                        // We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
                        destElements = getAll(clone);
                        srcElements = getAll(elem);

                        for (i = 0, l = srcElements.length; i < l; i++) {
                            fixInput(srcElements[i], destElements[i]);
                        }
                    }

                    // Copy the events from the original to the clone
                    if (dataAndEvents) {
                        if (deepDataAndEvents) {
                            srcElements = srcElements || getAll(elem);
                            destElements = destElements || getAll(clone);

                            for (i = 0, l = srcElements.length; i < l; i++) {
                                cloneCopyEvent(srcElements[i], destElements[i]);
                            }
                        } else {
                            cloneCopyEvent(elem, clone);
                        }
                    }

                    // Preserve script evaluation history
                    destElements = getAll(clone, "script");
                    if (destElements.length > 0) {
                        setGlobalEval(destElements, !inPage && getAll(elem, "script"));
                    }

                    // Return the cloned set
                    return clone;
                },

                cleanData: function (elems) {
                    var data, elem, type,
                        special = jQuery.event.special,
                        i = 0;

                    for (; (elem = elems[i]) !== undefined; i++) {
                        if (acceptData(elem)) {
                            if ((data = elem[dataPriv.expando])) {
                                if (data.events) {
                                    for (type in data.events) {
                                        if (special[type]) {
                                            jQuery.event.remove(elem, type);

                                            // This is a shortcut to avoid jQuery.event.remove's overhead
                                        } else {
                                            jQuery.removeEvent(elem, type, data.handle);
                                        }
                                    }
                                }

                                // Support: Chrome <= 35-45+
                                // Assign undefined instead of using delete, see Data#remove
                                elem[dataPriv.expando] = undefined;
                            }
                            if (elem[dataUser.expando]) {

                                // Support: Chrome <= 35-45+
                                // Assign undefined instead of using delete, see Data#remove
                                elem[dataUser.expando] = undefined;
                            }
                        }
                    }
                }
            });

            jQuery.fn.extend({

                // Keep domManip exposed until 3.0 (gh-2225)
                domManip: domManip,

                detach: function (selector) {
                    return remove(this, selector, true);
                },

                remove: function (selector) {
                    return remove(this, selector);
                },

                text: function (value) {
                    return access(this, function (value) {
                        return value === undefined ?
                            jQuery.text(this) :
                            this.empty().each(function () {
                                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                                    this.textContent = value;
                                }
                            });
                    }, null, value, arguments.length);
                },

                append: function () {
                    return domManip(this, arguments, function (elem) {
                        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                            var target = manipulationTarget(this, elem);
                            target.appendChild(elem);
                        }
                    });
                },

                prepend: function () {
                    return domManip(this, arguments, function (elem) {
                        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                            var target = manipulationTarget(this, elem);
                            target.insertBefore(elem, target.firstChild);
                        }
                    });
                },

                before: function () {
                    return domManip(this, arguments, function (elem) {
                        if (this.parentNode) {
                            this.parentNode.insertBefore(elem, this);
                        }
                    });
                },

                after: function () {
                    return domManip(this, arguments, function (elem) {
                        if (this.parentNode) {
                            this.parentNode.insertBefore(elem, this.nextSibling);
                        }
                    });
                },

                empty: function () {
                    var elem,
                        i = 0;

                    for (; (elem = this[i]) != null; i++) {
                        if (elem.nodeType === 1) {

                            // Prevent memory leaks
                            jQuery.cleanData(getAll(elem, false));

                            // Remove any remaining nodes
                            elem.textContent = "";
                        }
                    }

                    return this;
                },

                clone: function (dataAndEvents, deepDataAndEvents) {
                    dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
                    deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

                    return this.map(function () {
                        return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
                    });
                },

                html: function (value) {
                    return access(this, function (value) {
                        var elem = this[0] || {},
                            i = 0,
                            l = this.length;

                        if (value === undefined && elem.nodeType === 1) {
                            return elem.innerHTML;
                        }

                        // See if we can take a shortcut and just use innerHTML
                        if (typeof value === "string" && !rnoInnerhtml.test(value) &&
                            !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {

                            value = jQuery.htmlPrefilter(value);

                            try {
                                for (; i < l; i++) {
                                    elem = this[i] || {};

                                    // Remove element nodes and prevent memory leaks
                                    if (elem.nodeType === 1) {
                                        jQuery.cleanData(getAll(elem, false));
                                        elem.innerHTML = value;
                                    }
                                }

                                elem = 0;

                                // If using innerHTML throws an exception, use the fallback method
                            } catch (e) { }
                        }

                        if (elem) {
                            this.empty().append(value);
                        }
                    }, null, value, arguments.length);
                },

                replaceWith: function () {
                    var ignored = [];

                    // Make the changes, replacing each non-ignored context element with the new content
                    return domManip(this, arguments, function (elem) {
                        var parent = this.parentNode;

                        if (jQuery.inArray(this, ignored) < 0) {
                            jQuery.cleanData(getAll(this));
                            if (parent) {
                                parent.replaceChild(elem, this);
                            }
                        }

                        // Force callback invocation
                    }, ignored);
                }
            });

            jQuery.each({
                appendTo: "append",
                prependTo: "prepend",
                insertBefore: "before",
                insertAfter: "after",
                replaceAll: "replaceWith"
            }, function (name, original) {
                jQuery.fn[name] = function (selector) {
                    var elems,
                        ret = [],
                        insert = jQuery(selector),
                        last = insert.length - 1,
                        i = 0;

                    for (; i <= last; i++) {
                        elems = i === last ? this : this.clone(true);
                        jQuery(insert[i])[original](elems);

                        // Support: QtWebKit
                        // .get() because push.apply(_, arraylike) throws
                        push.apply(ret, elems.get());
                    }

                    return this.pushStack(ret);
                };
            });


            var iframe,
                elemdisplay = {

                    // Support: Firefox
                    // We have to pre-define these values for FF (#10227)
                    HTML: "block",
                    BODY: "block"
                };

            /**
             * Retrieve the actual display of a element
             * @param {String} name nodeName of the element
             * @param {Object} doc Document object
             */

            // Called only from within defaultDisplay
            function actualDisplay(name, doc) {
                var elem = jQuery(doc.createElement(name)).appendTo(doc.body),

                    display = jQuery.css(elem[0], "display");

                // We don't have any data stored on the element,
                // so use "detach" method as fast way to get rid of the element
                elem.detach();

                return display;
            }

            /**
             * Try to determine the default display value of an element
             * @param {String} nodeName
             */
            function defaultDisplay(nodeName) {
                var doc = document,
                    display = elemdisplay[nodeName];

                if (!display) {
                    display = actualDisplay(nodeName, doc);

                    // If the simple way fails, read from inside an iframe
                    if (display === "none" || !display) {

                        // Use the already-created iframe if possible
                        iframe = (iframe || jQuery("<iframe frameborder='0' width='0' height='0'/>"))
                            .appendTo(doc.documentElement);

                        // Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
                        doc = iframe[0].contentDocument;

                        // Support: IE
                        doc.write();
                        doc.close();

                        display = actualDisplay(nodeName, doc);
                        iframe.detach();
                    }

                    // Store the correct default display
                    elemdisplay[nodeName] = display;
                }

                return display;
            }
            var rmargin = (/^margin/);

            var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");

            var getStyles = function (elem) {

                // Support: IE<=11+, Firefox<=30+ (#15098, #14150)
                // IE throws on elements created in popups
                // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
                var view = elem.ownerDocument.defaultView;

                if (!view || !view.opener) {
                    view = window;
                }

                return view.getComputedStyle(elem);
            };

            var swap = function (elem, options, callback, args) {
                var ret, name,
                    old = {};

                // Remember the old values, and insert the new ones
                for (name in options) {
                    old[name] = elem.style[name];
                    elem.style[name] = options[name];
                }

                ret = callback.apply(elem, args || []);

                // Revert the old values
                for (name in options) {
                    elem.style[name] = old[name];
                }

                return ret;
            };


            var documentElement = document.documentElement;



            (function () {
                var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,
                    container = document.createElement("div"),
                    div = document.createElement("div");

                // Finish early in limited (non-browser) environments
                if (!div.style) {
                    return;
                }

                // Support: IE9-11+
                // Style of cloned element affects source element cloned (#8908)
                div.style.backgroundClip = "content-box";
                div.cloneNode(true).style.backgroundClip = "";
                support.clearCloneStyle = div.style.backgroundClip === "content-box";

                container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" +
                    "padding:0;margin-top:1px;position:absolute";
                container.appendChild(div);

                // Executing both pixelPosition & boxSizingReliable tests require only one layout
                // so they're executed at the same time to save the second computation.
                function computeStyleTests() {
                    div.style.cssText =

                        // Support: Firefox<29, Android 2.3
                        // Vendor-prefix box-sizing
                        "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;" +
                        "position:relative;display:block;" +
                        "margin:auto;border:1px;padding:1px;" +
                        "top:1%;width:50%";
                    div.innerHTML = "";
                    documentElement.appendChild(container);

                    var divStyle = window.getComputedStyle(div);
                    pixelPositionVal = divStyle.top !== "1%";
                    reliableMarginLeftVal = divStyle.marginLeft === "2px";
                    boxSizingReliableVal = divStyle.width === "4px";

                    // Support: Android 4.0 - 4.3 only
                    // Some styles come back with percentage values, even though they shouldn't
                    div.style.marginRight = "50%";
                    pixelMarginRightVal = divStyle.marginRight === "4px";

                    documentElement.removeChild(container);
                }

                jQuery.extend(support, {
                    pixelPosition: function () {

                        // This test is executed only once but we still do memoizing
                        // since we can use the boxSizingReliable pre-computing.
                        // No need to check if the test was already performed, though.
                        computeStyleTests();
                        return pixelPositionVal;
                    },
                    boxSizingReliable: function () {
                        if (boxSizingReliableVal == null) {
                            computeStyleTests();
                        }
                        return boxSizingReliableVal;
                    },
                    pixelMarginRight: function () {

                        // Support: Android 4.0-4.3
                        // We're checking for boxSizingReliableVal here instead of pixelMarginRightVal
                        // since that compresses better and they're computed together anyway.
                        if (boxSizingReliableVal == null) {
                            computeStyleTests();
                        }
                        return pixelMarginRightVal;
                    },
                    reliableMarginLeft: function () {

                        // Support: IE <=8 only, Android 4.0 - 4.3 only, Firefox <=3 - 37
                        if (boxSizingReliableVal == null) {
                            computeStyleTests();
                        }
                        return reliableMarginLeftVal;
                    },
                    reliableMarginRight: function () {

                        // Support: Android 2.3
                        // Check if div with explicit width and no margin-right incorrectly
                        // gets computed margin-right based on width of container. (#3333)
                        // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
                        // This support function is only executed once so no memoizing is needed.
                        var ret,
                            marginDiv = div.appendChild(document.createElement("div"));

                        // Reset CSS: box-sizing; display; margin; border; padding
                        marginDiv.style.cssText = div.style.cssText =

                            // Support: Android 2.3
                            // Vendor-prefix box-sizing
                            "-webkit-box-sizing:content-box;box-sizing:content-box;" +
                            "display:block;margin:0;border:0;padding:0";
                        marginDiv.style.marginRight = marginDiv.style.width = "0";
                        div.style.width = "1px";
                        documentElement.appendChild(container);

                        ret = !parseFloat(window.getComputedStyle(marginDiv).marginRight);

                        documentElement.removeChild(container);
                        div.removeChild(marginDiv);

                        return ret;
                    }
                });
            })();


            function curCSS(elem, name, computed) {
                var width, minWidth, maxWidth, ret,
                    style = elem.style;

                computed = computed || getStyles(elem);
                ret = computed ? computed.getPropertyValue(name) || computed[name] : undefined;

                // Support: Opera 12.1x only
                // Fall back to style even without computed
                // computed is undefined for elems on document fragments
                if ((ret === "" || ret === undefined) && !jQuery.contains(elem.ownerDocument, elem)) {
                    ret = jQuery.style(elem, name);
                }

                // Support: IE9
                // getPropertyValue is only needed for .css('filter') (#12537)
                if (computed) {

                    // A tribute to the "awesome hack by Dean Edwards"
                    // Android Browser returns percentage for some values,
                    // but width seems to be reliably pixels.
                    // This is against the CSSOM draft spec:
                    // http://dev.w3.org/csswg/cssom/#resolved-values
                    if (!support.pixelMarginRight() && rnumnonpx.test(ret) && rmargin.test(name)) {

                        // Remember the original values
                        width = style.width;
                        minWidth = style.minWidth;
                        maxWidth = style.maxWidth;

                        // Put in the new values to get a computed value out
                        style.minWidth = style.maxWidth = style.width = ret;
                        ret = computed.width;

                        // Revert the changed values
                        style.width = width;
                        style.minWidth = minWidth;
                        style.maxWidth = maxWidth;
                    }
                }

                return ret !== undefined ?

                    // Support: IE9-11+
                    // IE returns zIndex value as an integer.
                    ret + "" :
                    ret;
            }


            function addGetHookIf(conditionFn, hookFn) {

                // Define the hook, we'll check on the first run if it's really needed.
                return {
                    get: function () {
                        if (conditionFn()) {

                            // Hook not needed (or it's not possible to use it due
                            // to missing dependency), remove it.
                            delete this.get;
                            return;
                        }

                        // Hook needed; redefine it so that the support test is not executed again.
                        return (this.get = hookFn).apply(this, arguments);
                    }
                };
            }


            var

                // Swappable if display is none or starts with table
                // except "table", "table-cell", or "table-caption"
                // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
                rdisplayswap = /^(none|table(?!-c[ea]).+)/,

                cssShow = { position: "absolute", visibility: "hidden", display: "block" },
                cssNormalTransform = {
                    letterSpacing: "0",
                    fontWeight: "400"
                },

                cssPrefixes = ["Webkit", "O", "Moz", "ms"],
                emptyStyle = document.createElement("div").style;

            // Return a css property mapped to a potentially vendor prefixed property
            function vendorPropName(name) {

                // Shortcut for names that are not vendor prefixed
                if (name in emptyStyle) {
                    return name;
                }

                // Check for vendor prefixed names
                var capName = name[0].toUpperCase() + name.slice(1),
                    i = cssPrefixes.length;

                while (i--) {
                    name = cssPrefixes[i] + capName;
                    if (name in emptyStyle) {
                        return name;
                    }
                }
            }

            function setPositiveNumber(elem, value, subtract) {

                // Any relative (+/-) values have already been
                // normalized at this point
                var matches = rcssNum.exec(value);
                return matches ?

                    // Guard against undefined "subtract", e.g., when used as in cssHooks
                    Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") :
                    value;
            }

            function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
                var i = extra === (isBorderBox ? "border" : "content") ?

                    // If we already have the right measurement, avoid augmentation
                    4 :

                    // Otherwise initialize for horizontal or vertical properties
                    name === "width" ? 1 : 0,

                    val = 0;

                for (; i < 4; i += 2) {

                    // Both box models exclude margin, so add it if we want it
                    if (extra === "margin") {
                        val += jQuery.css(elem, extra + cssExpand[i], true, styles);
                    }

                    if (isBorderBox) {

                        // border-box includes padding, so remove it if we want content
                        if (extra === "content") {
                            val -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
                        }

                        // At this point, extra isn't border nor margin, so remove border
                        if (extra !== "margin") {
                            val -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
                        }
                    } else {

                        // At this point, extra isn't content, so add padding
                        val += jQuery.css(elem, "padding" + cssExpand[i], true, styles);

                        // At this point, extra isn't content nor padding, so add border
                        if (extra !== "padding") {
                            val += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
                        }
                    }
                }

                return val;
            }

            function getWidthOrHeight(elem, name, extra) {

                // Start with offset property, which is equivalent to the border-box value
                var valueIsBorderBox = true,
                    val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
                    styles = getStyles(elem),
                    isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box";

                // Some non-html elements return undefined for offsetWidth, so check for null/undefined
                // svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
                // MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
                if (val <= 0 || val == null) {

                    // Fall back to computed then uncomputed css if necessary
                    val = curCSS(elem, name, styles);
                    if (val < 0 || val == null) {
                        val = elem.style[name];
                    }

                    // Computed unit is not pixels. Stop here and return.
                    if (rnumnonpx.test(val)) {
                        return val;
                    }

                    // Check for style in case a browser which returns unreliable values
                    // for getComputedStyle silently falls back to the reliable elem.style
                    valueIsBorderBox = isBorderBox &&
                        (support.boxSizingReliable() || val === elem.style[name]);

                    // Normalize "", auto, and prepare for extra
                    val = parseFloat(val) || 0;
                }

                // Use the active box-sizing model to add/subtract irrelevant styles
                return (val +
                    augmentWidthOrHeight(
                        elem,
                        name,
                        extra || (isBorderBox ? "border" : "content"),
                        valueIsBorderBox,
                        styles
                    )
                ) + "px";
            }

            function showHide(elements, show) {
                var display, elem, hidden,
                    values = [],
                    index = 0,
                    length = elements.length;

                for (; index < length; index++) {
                    elem = elements[index];
                    if (!elem.style) {
                        continue;
                    }

                    values[index] = dataPriv.get(elem, "olddisplay");
                    display = elem.style.display;
                    if (show) {

                        // Reset the inline display of this element to learn if it is
                        // being hidden by cascaded rules or not
                        if (!values[index] && display === "none") {
                            elem.style.display = "";
                        }

                        // Set elements which have been overridden with display: none
                        // in a stylesheet to whatever the default browser style is
                        // for such an element
                        if (elem.style.display === "" && isHidden(elem)) {
                            values[index] = dataPriv.access(
                                elem,
                                "olddisplay",
                                defaultDisplay(elem.nodeName)
                            );
                        }
                    } else {
                        hidden = isHidden(elem);

                        if (display !== "none" || !hidden) {
                            dataPriv.set(
                                elem,
                                "olddisplay",
                                hidden ? display : jQuery.css(elem, "display")
                            );
                        }
                    }
                }

                // Set the display of most of the elements in a second loop
                // to avoid the constant reflow
                for (index = 0; index < length; index++) {
                    elem = elements[index];
                    if (!elem.style) {
                        continue;
                    }
                    if (!show || elem.style.display === "none" || elem.style.display === "") {
                        elem.style.display = show ? values[index] || "" : "none";
                    }
                }

                return elements;
            }

            jQuery.extend({

                // Add in style property hooks for overriding the default
                // behavior of getting and setting a style property
                cssHooks: {
                    opacity: {
                        get: function (elem, computed) {
                            if (computed) {

                                // We should always get a number back from opacity
                                var ret = curCSS(elem, "opacity");
                                return ret === "" ? "1" : ret;
                            }
                        }
                    }
                },

                // Don't automatically add "px" to these possibly-unitless properties
                cssNumber: {
                    "animationIterationCount": true,
                    "columnCount": true,
                    "fillOpacity": true,
                    "flexGrow": true,
                    "flexShrink": true,
                    "fontWeight": true,
                    "lineHeight": true,
                    "opacity": true,
                    "order": true,
                    "orphans": true,
                    "widows": true,
                    "zIndex": true,
                    "zoom": true
                },

                // Add in properties whose names you wish to fix before
                // setting or getting the value
                cssProps: {
                    "float": "cssFloat"
                },

                // Get and set the style property on a DOM Node
                style: function (elem, name, value, extra) {

                    // Don't set styles on text and comment nodes
                    if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
                        return;
                    }

                    // Make sure that we're working with the right name
                    var ret, type, hooks,
                        origName = jQuery.camelCase(name),
                        style = elem.style;

                    name = jQuery.cssProps[origName] ||
                        (jQuery.cssProps[origName] = vendorPropName(origName) || origName);

                    // Gets hook for the prefixed version, then unprefixed version
                    hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

                    // Check if we're setting a value
                    if (value !== undefined) {
                        type = typeof value;

                        // Convert "+=" or "-=" to relative numbers (#7345)
                        if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
                            value = adjustCSS(elem, name, ret);

                            // Fixes bug #9237
                            type = "number";
                        }

                        // Make sure that null and NaN values aren't set (#7116)
                        if (value == null || value !== value) {
                            return;
                        }

                        // If a number was passed in, add the unit (except for certain CSS properties)
                        if (type === "number") {
                            value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
                        }

                        // Support: IE9-11+
                        // background-* props affect original clone's values
                        if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
                            style[name] = "inherit";
                        }

                        // If a hook was provided, use that value, otherwise just set the specified value
                        if (!hooks || !("set" in hooks) ||
                            (value = hooks.set(elem, value, extra)) !== undefined) {

                            style[name] = value;
                        }

                    } else {

                        // If a hook was provided get the non-computed value from there
                        if (hooks && "get" in hooks &&
                            (ret = hooks.get(elem, false, extra)) !== undefined) {

                            return ret;
                        }

                        // Otherwise just get the value from the style object
                        return style[name];
                    }
                },

                css: function (elem, name, extra, styles) {
                    var val, num, hooks,
                        origName = jQuery.camelCase(name);

                    // Make sure that we're working with the right name
                    name = jQuery.cssProps[origName] ||
                        (jQuery.cssProps[origName] = vendorPropName(origName) || origName);

                    // Try prefixed name followed by the unprefixed name
                    hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

                    // If a hook was provided get the computed value from there
                    if (hooks && "get" in hooks) {
                        val = hooks.get(elem, true, extra);
                    }

                    // Otherwise, if a way to get the computed value exists, use that
                    if (val === undefined) {
                        val = curCSS(elem, name, styles);
                    }

                    // Convert "normal" to computed value
                    if (val === "normal" && name in cssNormalTransform) {
                        val = cssNormalTransform[name];
                    }

                    // Make numeric if forced or a qualifier was provided and val looks numeric
                    if (extra === "" || extra) {
                        num = parseFloat(val);
                        return extra === true || isFinite(num) ? num || 0 : val;
                    }
                    return val;
                }
            });

            jQuery.each(["height", "width"], function (i, name) {
                jQuery.cssHooks[name] = {
                    get: function (elem, computed, extra) {
                        if (computed) {

                            // Certain elements can have dimension info if we invisibly show them
                            // but it must have a current display style that would benefit
                            return rdisplayswap.test(jQuery.css(elem, "display")) &&
                                elem.offsetWidth === 0 ?
                                swap(elem, cssShow, function () {
                                    return getWidthOrHeight(elem, name, extra);
                                }) :
                                getWidthOrHeight(elem, name, extra);
                        }
                    },

                    set: function (elem, value, extra) {
                        var matches,
                            styles = extra && getStyles(elem),
                            subtract = extra && augmentWidthOrHeight(
                                elem,
                                name,
                                extra,
                                jQuery.css(elem, "boxSizing", false, styles) === "border-box",
                                styles
                            );

                        // Convert to pixels if value adjustment is needed
                        if (subtract && (matches = rcssNum.exec(value)) &&
                            (matches[3] || "px") !== "px") {

                            elem.style[name] = value;
                            value = jQuery.css(elem, name);
                        }

                        return setPositiveNumber(elem, value, subtract);
                    }
                };
            });

            jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft,
                function (elem, computed) {
                    if (computed) {
                        return (parseFloat(curCSS(elem, "marginLeft")) ||
                            elem.getBoundingClientRect().left -
                            swap(elem, { marginLeft: 0 }, function () {
                                return elem.getBoundingClientRect().left;
                            })
                        ) + "px";
                    }
                }
            );

            // Support: Android 2.3
            jQuery.cssHooks.marginRight = addGetHookIf(support.reliableMarginRight,
                function (elem, computed) {
                    if (computed) {
                        return swap(elem, { "display": "inline-block" },
                            curCSS, [elem, "marginRight"]);
                    }
                }
            );

            // These hooks are used by animate to expand properties
            jQuery.each({
                margin: "",
                padding: "",
                border: "Width"
            }, function (prefix, suffix) {
                jQuery.cssHooks[prefix + suffix] = {
                    expand: function (value) {
                        var i = 0,
                            expanded = {},

                            // Assumes a single number if not a string
                            parts = typeof value === "string" ? value.split(" ") : [value];

                        for (; i < 4; i++) {
                            expanded[prefix + cssExpand[i] + suffix] =
                                parts[i] || parts[i - 2] || parts[0];
                        }

                        return expanded;
                    }
                };

                if (!rmargin.test(prefix)) {
                    jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
                }
            });

            jQuery.fn.extend({
                css: function (name, value) {
                    return access(this, function (elem, name, value) {
                        var styles, len,
                            map = {},
                            i = 0;

                        if (jQuery.isArray(name)) {
                            styles = getStyles(elem);
                            len = name.length;

                            for (; i < len; i++) {
                                map[name[i]] = jQuery.css(elem, name[i], false, styles);
                            }

                            return map;
                        }

                        return value !== undefined ?
                            jQuery.style(elem, name, value) :
                            jQuery.css(elem, name);
                    }, name, value, arguments.length > 1);
                },
                show: function () {
                    return showHide(this, true);
                },
                hide: function () {
                    return showHide(this);
                },
                toggle: function (state) {
                    if (typeof state === "boolean") {
                        return state ? this.show() : this.hide();
                    }

                    return this.each(function () {
                        if (isHidden(this)) {
                            jQuery(this).show();
                        } else {
                            jQuery(this).hide();
                        }
                    });
                }
            });


            function Tween(elem, options, prop, end, easing) {
                return new Tween.prototype.init(elem, options, prop, end, easing);
            }
            jQuery.Tween = Tween;

            Tween.prototype = {
                constructor: Tween,
                init: function (elem, options, prop, end, easing, unit) {
                    this.elem = elem;
                    this.prop = prop;
                    this.easing = easing || jQuery.easing._default;
                    this.options = options;
                    this.start = this.now = this.cur();
                    this.end = end;
                    this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
                },
                cur: function () {
                    var hooks = Tween.propHooks[this.prop];

                    return hooks && hooks.get ?
                        hooks.get(this) :
                        Tween.propHooks._default.get(this);
                },
                run: function (percent) {
                    var eased,
                        hooks = Tween.propHooks[this.prop];

                    if (this.options.duration) {
                        this.pos = eased = jQuery.easing[this.easing](
                            percent, this.options.duration * percent, 0, 1, this.options.duration
                        );
                    } else {
                        this.pos = eased = percent;
                    }
                    this.now = (this.end - this.start) * eased + this.start;

                    if (this.options.step) {
                        this.options.step.call(this.elem, this.now, this);
                    }

                    if (hooks && hooks.set) {
                        hooks.set(this);
                    } else {
                        Tween.propHooks._default.set(this);
                    }
                    return this;
                }
            };

            Tween.prototype.init.prototype = Tween.prototype;

            Tween.propHooks = {
                _default: {
                    get: function (tween) {
                        var result;

                        // Use a property on the element directly when it is not a DOM element,
                        // or when there is no matching style property that exists.
                        if (tween.elem.nodeType !== 1 ||
                            tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
                            return tween.elem[tween.prop];
                        }

                        // Passing an empty string as a 3rd parameter to .css will automatically
                        // attempt a parseFloat and fallback to a string if the parse fails.
                        // Simple values such as "10px" are parsed to Float;
                        // complex values such as "rotate(1rad)" are returned as-is.
                        result = jQuery.css(tween.elem, tween.prop, "");

                        // Empty strings, null, undefined and "auto" are converted to 0.
                        return !result || result === "auto" ? 0 : result;
                    },
                    set: function (tween) {

                        // Use step hook for back compat.
                        // Use cssHook if its there.
                        // Use .style if available and use plain properties where available.
                        if (jQuery.fx.step[tween.prop]) {
                            jQuery.fx.step[tween.prop](tween);
                        } else if (tween.elem.nodeType === 1 &&
                            (tween.elem.style[jQuery.cssProps[tween.prop]] != null ||
                                jQuery.cssHooks[tween.prop])) {
                            jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
                        } else {
                            tween.elem[tween.prop] = tween.now;
                        }
                    }
                }
            };

            // Support: IE9
            // Panic based approach to setting things on disconnected nodes
            Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
                set: function (tween) {
                    if (tween.elem.nodeType && tween.elem.parentNode) {
                        tween.elem[tween.prop] = tween.now;
                    }
                }
            };

            jQuery.easing = {
                linear: function (p) {
                    return p;
                },
                swing: function (p) {
                    return 0.5 - Math.cos(p * Math.PI) / 2;
                },
                _default: "swing"
            };

            jQuery.fx = Tween.prototype.init;

            // Back Compat <1.8 extension point
            jQuery.fx.step = {};




            var
                fxNow, timerId,
                rfxtypes = /^(?:toggle|show|hide)$/,
                rrun = /queueHooks$/;

            // Animations created synchronously will run synchronously
            function createFxNow() {
                window.setTimeout(function () {
                    fxNow = undefined;
                });
                return (fxNow = jQuery.now());
            }

            // Generate parameters to create a standard animation
            function genFx(type, includeWidth) {
                var which,
                    i = 0,
                    attrs = { height: type };

                // If we include width, step value is 1 to do all cssExpand values,
                // otherwise step value is 2 to skip over Left and Right
                includeWidth = includeWidth ? 1 : 0;
                for (; i < 4; i += 2 - includeWidth) {
                    which = cssExpand[i];
                    attrs["margin" + which] = attrs["padding" + which] = type;
                }

                if (includeWidth) {
                    attrs.opacity = attrs.width = type;
                }

                return attrs;
            }

            function createTween(value, prop, animation) {
                var tween,
                    collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]),
                    index = 0,
                    length = collection.length;
                for (; index < length; index++) {
                    if ((tween = collection[index].call(animation, prop, value))) {

                        // We're done with this property
                        return tween;
                    }
                }
            }

            function defaultPrefilter(elem, props, opts) {
                /* jshint validthis: true */
                var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
                    anim = this,
                    orig = {},
                    style = elem.style,
                    hidden = elem.nodeType && isHidden(elem),
                    dataShow = dataPriv.get(elem, "fxshow");

                // Handle queue: false promises
                if (!opts.queue) {
                    hooks = jQuery._queueHooks(elem, "fx");
                    if (hooks.unqueued == null) {
                        hooks.unqueued = 0;
                        oldfire = hooks.empty.fire;
                        hooks.empty.fire = function () {
                            if (!hooks.unqueued) {
                                oldfire();
                            }
                        };
                    }
                    hooks.unqueued++;

                    anim.always(function () {

                        // Ensure the complete handler is called before this completes
                        anim.always(function () {
                            hooks.unqueued--;
                            if (!jQuery.queue(elem, "fx").length) {
                                hooks.empty.fire();
                            }
                        });
                    });
                }

                // Height/width overflow pass
                if (elem.nodeType === 1 && ("height" in props || "width" in props)) {

                    // Make sure that nothing sneaks out
                    // Record all 3 overflow attributes because IE9-10 do not
                    // change the overflow attribute when overflowX and
                    // overflowY are set to the same value
                    opts.overflow = [style.overflow, style.overflowX, style.overflowY];

                    // Set display property to inline-block for height/width
                    // animations on inline elements that are having width/height animated
                    display = jQuery.css(elem, "display");

                    // Test default display if display is currently "none"
                    checkDisplay = display === "none" ?
                        dataPriv.get(elem, "olddisplay") || defaultDisplay(elem.nodeName) : display;

                    if (checkDisplay === "inline" && jQuery.css(elem, "float") === "none") {
                        style.display = "inline-block";
                    }
                }

                if (opts.overflow) {
                    style.overflow = "hidden";
                    anim.always(function () {
                        style.overflow = opts.overflow[0];
                        style.overflowX = opts.overflow[1];
                        style.overflowY = opts.overflow[2];
                    });
                }

                // show/hide pass
                for (prop in props) {
                    value = props[prop];
                    if (rfxtypes.exec(value)) {
                        delete props[prop];
                        toggle = toggle || value === "toggle";
                        if (value === (hidden ? "hide" : "show")) {

                            // If there is dataShow left over from a stopped hide or show
                            // and we are going to proceed with show, we should pretend to be hidden
                            if (value === "show" && dataShow && dataShow[prop] !== undefined) {
                                hidden = true;
                            } else {
                                continue;
                            }
                        }
                        orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);

                        // Any non-fx value stops us from restoring the original display value
                    } else {
                        display = undefined;
                    }
                }

                if (!jQuery.isEmptyObject(orig)) {
                    if (dataShow) {
                        if ("hidden" in dataShow) {
                            hidden = dataShow.hidden;
                        }
                    } else {
                        dataShow = dataPriv.access(elem, "fxshow", {});
                    }

                    // Store state if its toggle - enables .stop().toggle() to "reverse"
                    if (toggle) {
                        dataShow.hidden = !hidden;
                    }
                    if (hidden) {
                        jQuery(elem).show();
                    } else {
                        anim.done(function () {
                            jQuery(elem).hide();
                        });
                    }
                    anim.done(function () {
                        var prop;

                        dataPriv.remove(elem, "fxshow");
                        for (prop in orig) {
                            jQuery.style(elem, prop, orig[prop]);
                        }
                    });
                    for (prop in orig) {
                        tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);

                        if (!(prop in dataShow)) {
                            dataShow[prop] = tween.start;
                            if (hidden) {
                                tween.end = tween.start;
                                tween.start = prop === "width" || prop === "height" ? 1 : 0;
                            }
                        }
                    }

                    // If this is a noop like .hide().hide(), restore an overwritten display value
                } else if ((display === "none" ? defaultDisplay(elem.nodeName) : display) === "inline") {
                    style.display = display;
                }
            }

            function propFilter(props, specialEasing) {
                var index, name, easing, value, hooks;

                // camelCase, specialEasing and expand cssHook pass
                for (index in props) {
                    name = jQuery.camelCase(index);
                    easing = specialEasing[name];
                    value = props[index];
                    if (jQuery.isArray(value)) {
                        easing = value[1];
                        value = props[index] = value[0];
                    }

                    if (index !== name) {
                        props[name] = value;
                        delete props[index];
                    }

                    hooks = jQuery.cssHooks[name];
                    if (hooks && "expand" in hooks) {
                        value = hooks.expand(value);
                        delete props[name];

                        // Not quite $.extend, this won't overwrite existing keys.
                        // Reusing 'index' because we have the correct "name"
                        for (index in value) {
                            if (!(index in props)) {
                                props[index] = value[index];
                                specialEasing[index] = easing;
                            }
                        }
                    } else {
                        specialEasing[name] = easing;
                    }
                }
            }

            function Animation(elem, properties, options) {
                var result,
                    stopped,
                    index = 0,
                    length = Animation.prefilters.length,
                    deferred = jQuery.Deferred().always(function () {

                        // Don't match elem in the :animated selector
                        delete tick.elem;
                    }),
                    tick = function () {
                        if (stopped) {
                            return false;
                        }
                        var currentTime = fxNow || createFxNow(),
                            remaining = Math.max(0, animation.startTime + animation.duration - currentTime),

                            // Support: Android 2.3
                            // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
                            temp = remaining / animation.duration || 0,
                            percent = 1 - temp,
                            index = 0,
                            length = animation.tweens.length;

                        for (; index < length; index++) {
                            animation.tweens[index].run(percent);
                        }

                        deferred.notifyWith(elem, [animation, percent, remaining]);

                        if (percent < 1 && length) {
                            return remaining;
                        } else {
                            deferred.resolveWith(elem, [animation]);
                            return false;
                        }
                    },
                    animation = deferred.promise({
                        elem: elem,
                        props: jQuery.extend({}, properties),
                        opts: jQuery.extend(true, {
                            specialEasing: {},
                            easing: jQuery.easing._default
                        }, options),
                        originalProperties: properties,
                        originalOptions: options,
                        startTime: fxNow || createFxNow(),
                        duration: options.duration,
                        tweens: [],
                        createTween: function (prop, end) {
                            var tween = jQuery.Tween(elem, animation.opts, prop, end,
                                animation.opts.specialEasing[prop] || animation.opts.easing);
                            animation.tweens.push(tween);
                            return tween;
                        },
                        stop: function (gotoEnd) {
                            var index = 0,

                                // If we are going to the end, we want to run all the tweens
                                // otherwise we skip this part
                                length = gotoEnd ? animation.tweens.length : 0;
                            if (stopped) {
                                return this;
                            }
                            stopped = true;
                            for (; index < length; index++) {
                                animation.tweens[index].run(1);
                            }

                            // Resolve when we played the last frame; otherwise, reject
                            if (gotoEnd) {
                                deferred.notifyWith(elem, [animation, 1, 0]);
                                deferred.resolveWith(elem, [animation, gotoEnd]);
                            } else {
                                deferred.rejectWith(elem, [animation, gotoEnd]);
                            }
                            return this;
                        }
                    }),
                    props = animation.props;

                propFilter(props, animation.opts.specialEasing);

                for (; index < length; index++) {
                    result = Animation.prefilters[index].call(animation, elem, props, animation.opts);
                    if (result) {
                        if (jQuery.isFunction(result.stop)) {
                            jQuery._queueHooks(animation.elem, animation.opts.queue).stop =
                                jQuery.proxy(result.stop, result);
                        }
                        return result;
                    }
                }

                jQuery.map(props, createTween, animation);

                if (jQuery.isFunction(animation.opts.start)) {
                    animation.opts.start.call(elem, animation);
                }

                jQuery.fx.timer(
                    jQuery.extend(tick, {
                        elem: elem,
                        anim: animation,
                        queue: animation.opts.queue
                    })
                );

                // attach callbacks from options
                return animation.progress(animation.opts.progress)
                    .done(animation.opts.done, animation.opts.complete)
                    .fail(animation.opts.fail)
                    .always(animation.opts.always);
            }

            jQuery.Animation = jQuery.extend(Animation, {
                tweeners: {
                    "*": [function (prop, value) {
                        var tween = this.createTween(prop, value);
                        adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
                        return tween;
                    }]
                },

                tweener: function (props, callback) {
                    if (jQuery.isFunction(props)) {
                        callback = props;
                        props = ["*"];
                    } else {
                        props = props.match(rnotwhite);
                    }

                    var prop,
                        index = 0,
                        length = props.length;

                    for (; index < length; index++) {
                        prop = props[index];
                        Animation.tweeners[prop] = Animation.tweeners[prop] || [];
                        Animation.tweeners[prop].unshift(callback);
                    }
                },

                prefilters: [defaultPrefilter],

                prefilter: function (callback, prepend) {
                    if (prepend) {
                        Animation.prefilters.unshift(callback);
                    } else {
                        Animation.prefilters.push(callback);
                    }
                }
            });

            jQuery.speed = function (speed, easing, fn) {
                var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
                    complete: fn || !fn && easing ||
                        jQuery.isFunction(speed) && speed,
                    duration: speed,
                    easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
                };

                opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ?
                    opt.duration : opt.duration in jQuery.fx.speeds ?
                        jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;

                // Normalize opt.queue - true/undefined/null -> "fx"
                if (opt.queue == null || opt.queue === true) {
                    opt.queue = "fx";
                }

                // Queueing
                opt.old = opt.complete;

                opt.complete = function () {
                    if (jQuery.isFunction(opt.old)) {
                        opt.old.call(this);
                    }

                    if (opt.queue) {
                        jQuery.dequeue(this, opt.queue);
                    }
                };

                return opt;
            };

            jQuery.fn.extend({
                fadeTo: function (speed, to, easing, callback) {

                    // Show any hidden elements after setting opacity to 0
                    return this.filter(isHidden).css("opacity", 0).show()

                        // Animate to the value specified
                        .end().animate({ opacity: to }, speed, easing, callback);
                },
                animate: function (prop, speed, easing, callback) {
                    var empty = jQuery.isEmptyObject(prop),
                        optall = jQuery.speed(speed, easing, callback),
                        doAnimation = function () {

                            // Operate on a copy of prop so per-property easing won't be lost
                            var anim = Animation(this, jQuery.extend({}, prop), optall);

                            // Empty animations, or finishing resolves immediately
                            if (empty || dataPriv.get(this, "finish")) {
                                anim.stop(true);
                            }
                        };
                    doAnimation.finish = doAnimation;

                    return empty || optall.queue === false ?
                        this.each(doAnimation) :
                        this.queue(optall.queue, doAnimation);
                },
                stop: function (type, clearQueue, gotoEnd) {
                    var stopQueue = function (hooks) {
                        var stop = hooks.stop;
                        delete hooks.stop;
                        stop(gotoEnd);
                    };

                    if (typeof type !== "string") {
                        gotoEnd = clearQueue;
                        clearQueue = type;
                        type = undefined;
                    }
                    if (clearQueue && type !== false) {
                        this.queue(type || "fx", []);
                    }

                    return this.each(function () {
                        var dequeue = true,
                            index = type != null && type + "queueHooks",
                            timers = jQuery.timers,
                            data = dataPriv.get(this);

                        if (index) {
                            if (data[index] && data[index].stop) {
                                stopQueue(data[index]);
                            }
                        } else {
                            for (index in data) {
                                if (data[index] && data[index].stop && rrun.test(index)) {
                                    stopQueue(data[index]);
                                }
                            }
                        }

                        for (index = timers.length; index--;) {
                            if (timers[index].elem === this &&
                                (type == null || timers[index].queue === type)) {

                                timers[index].anim.stop(gotoEnd);
                                dequeue = false;
                                timers.splice(index, 1);
                            }
                        }

                        // Start the next in the queue if the last step wasn't forced.
                        // Timers currently will call their complete callbacks, which
                        // will dequeue but only if they were gotoEnd.
                        if (dequeue || !gotoEnd) {
                            jQuery.dequeue(this, type);
                        }
                    });
                },
                finish: function (type) {
                    if (type !== false) {
                        type = type || "fx";
                    }
                    return this.each(function () {
                        var index,
                            data = dataPriv.get(this),
                            queue = data[type + "queue"],
                            hooks = data[type + "queueHooks"],
                            timers = jQuery.timers,
                            length = queue ? queue.length : 0;

                        // Enable finishing flag on private data
                        data.finish = true;

                        // Empty the queue first
                        jQuery.queue(this, type, []);

                        if (hooks && hooks.stop) {
                            hooks.stop.call(this, true);
                        }

                        // Look for any active animations, and finish them
                        for (index = timers.length; index--;) {
                            if (timers[index].elem === this && timers[index].queue === type) {
                                timers[index].anim.stop(true);
                                timers.splice(index, 1);
                            }
                        }

                        // Look for any animations in the old queue and finish them
                        for (index = 0; index < length; index++) {
                            if (queue[index] && queue[index].finish) {
                                queue[index].finish.call(this);
                            }
                        }

                        // Turn off finishing flag
                        delete data.finish;
                    });
                }
            });

            jQuery.each(["toggle", "show", "hide"], function (i, name) {
                var cssFn = jQuery.fn[name];
                jQuery.fn[name] = function (speed, easing, callback) {
                    return speed == null || typeof speed === "boolean" ?
                        cssFn.apply(this, arguments) :
                        this.animate(genFx(name, true), speed, easing, callback);
                };
            });

            // Generate shortcuts for custom animations
            jQuery.each({
                slideDown: genFx("show"),
                slideUp: genFx("hide"),
                slideToggle: genFx("toggle"),
                fadeIn: { opacity: "show" },
                fadeOut: { opacity: "hide" },
                fadeToggle: { opacity: "toggle" }
            }, function (name, props) {
                jQuery.fn[name] = function (speed, easing, callback) {
                    return this.animate(props, speed, easing, callback);
                };
            });

            jQuery.timers = [];
            jQuery.fx.tick = function () {
                var timer,
                    i = 0,
                    timers = jQuery.timers;

                fxNow = jQuery.now();

                for (; i < timers.length; i++) {
                    timer = timers[i];

                    // Checks the timer has not already been removed
                    if (!timer() && timers[i] === timer) {
                        timers.splice(i--, 1);
                    }
                }

                if (!timers.length) {
                    jQuery.fx.stop();
                }
                fxNow = undefined;
            };

            jQuery.fx.timer = function (timer) {
                jQuery.timers.push(timer);
                if (timer()) {
                    jQuery.fx.start();
                } else {
                    jQuery.timers.pop();
                }
            };

            jQuery.fx.interval = 13;
            jQuery.fx.start = function () {
                if (!timerId) {
                    timerId = window.setInterval(jQuery.fx.tick, jQuery.fx.interval);
                }
            };

            jQuery.fx.stop = function () {
                window.clearInterval(timerId);

                timerId = null;
            };

            jQuery.fx.speeds = {
                slow: 600,
                fast: 200,

                // Default speed
                _default: 400
            };


            // Based off of the plugin by Clint Helfers, with permission.
            // http://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
            jQuery.fn.delay = function (time, type) {
                time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
                type = type || "fx";

                return this.queue(type, function (next, hooks) {
                    var timeout = window.setTimeout(next, time);
                    hooks.stop = function () {
                        window.clearTimeout(timeout);
                    };
                });
            };


            (function () {
                var input = document.createElement("input"),
                    select = document.createElement("select"),
                    opt = select.appendChild(document.createElement("option"));

                input.type = "checkbox";

                // Support: iOS<=5.1, Android<=4.2+
                // Default value for a checkbox should be "on"
                support.checkOn = input.value !== "";

                // Support: IE<=11+
                // Must access selectedIndex to make default options select
                support.optSelected = opt.selected;

                // Support: Android<=2.3
                // Options inside disabled selects are incorrectly marked as disabled
                select.disabled = true;
                support.optDisabled = !opt.disabled;

                // Support: IE<=11+
                // An input loses its value after becoming a radio
                input = document.createElement("input");
                input.value = "t";
                input.type = "radio";
                support.radioValue = input.value === "t";
            })();


            var boolHook,
                attrHandle = jQuery.expr.attrHandle;

            jQuery.fn.extend({
                attr: function (name, value) {
                    return access(this, jQuery.attr, name, value, arguments.length > 1);
                },

                removeAttr: function (name) {
                    return this.each(function () {
                        jQuery.removeAttr(this, name);
                    });
                }
            });

            jQuery.extend({
                attr: function (elem, name, value) {
                    var ret, hooks,
                        nType = elem.nodeType;

                    // Don't get/set attributes on text, comment and attribute nodes
                    if (nType === 3 || nType === 8 || nType === 2) {
                        return;
                    }

                    // Fallback to prop when attributes are not supported
                    if (typeof elem.getAttribute === "undefined") {
                        return jQuery.prop(elem, name, value);
                    }

                    // All attributes are lowercase
                    // Grab necessary hook if one is defined
                    if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
                        name = name.toLowerCase();
                        hooks = jQuery.attrHooks[name] ||
                            (jQuery.expr.match.bool.test(name) ? boolHook : undefined);
                    }

                    if (value !== undefined) {
                        if (value === null) {
                            jQuery.removeAttr(elem, name);
                            return;
                        }

                        if (hooks && "set" in hooks &&
                            (ret = hooks.set(elem, value, name)) !== undefined) {
                            return ret;
                        }

                        elem.setAttribute(name, value + "");
                        return value;
                    }

                    if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
                        return ret;
                    }

                    ret = jQuery.find.attr(elem, name);

                    // Non-existent attributes return null, we normalize to undefined
                    return ret == null ? undefined : ret;
                },

                attrHooks: {
                    type: {
                        set: function (elem, value) {
                            if (!support.radioValue && value === "radio" &&
                                jQuery.nodeName(elem, "input")) {
                                var val = elem.value;
                                elem.setAttribute("type", value);
                                if (val) {
                                    elem.value = val;
                                }
                                return value;
                            }
                        }
                    }
                },

                removeAttr: function (elem, value) {
                    var name, propName,
                        i = 0,
                        attrNames = value && value.match(rnotwhite);

                    if (attrNames && elem.nodeType === 1) {
                        while ((name = attrNames[i++])) {
                            propName = jQuery.propFix[name] || name;

                            // Boolean attributes get special treatment (#10870)
                            if (jQuery.expr.match.bool.test(name)) {

                                // Set corresponding property to false
                                elem[propName] = false;
                            }

                            elem.removeAttribute(name);
                        }
                    }
                }
            });

            // Hooks for boolean attributes
            boolHook = {
                set: function (elem, value, name) {
                    if (value === false) {

                        // Remove boolean attributes when set to false
                        jQuery.removeAttr(elem, name);
                    } else {
                        elem.setAttribute(name, name);
                    }
                    return name;
                }
            };
            jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (i, name) {
                var getter = attrHandle[name] || jQuery.find.attr;

                attrHandle[name] = function (elem, name, isXML) {
                    var ret, handle;
                    if (!isXML) {

                        // Avoid an infinite loop by temporarily removing this function from the getter
                        handle = attrHandle[name];
                        attrHandle[name] = ret;
                        ret = getter(elem, name, isXML) != null ?
                            name.toLowerCase() :
                            null;
                        attrHandle[name] = handle;
                    }
                    return ret;
                };
            });




            var rfocusable = /^(?:input|select|textarea|button)$/i,
                rclickable = /^(?:a|area)$/i;

            jQuery.fn.extend({
                prop: function (name, value) {
                    return access(this, jQuery.prop, name, value, arguments.length > 1);
                },

                removeProp: function (name) {
                    return this.each(function () {
                        delete this[jQuery.propFix[name] || name];
                    });
                }
            });

            jQuery.extend({
                prop: function (elem, name, value) {
                    var ret, hooks,
                        nType = elem.nodeType;

                    // Don't get/set properties on text, comment and attribute nodes
                    if (nType === 3 || nType === 8 || nType === 2) {
                        return;
                    }

                    if (nType !== 1 || !jQuery.isXMLDoc(elem)) {

                        // Fix name and attach hooks
                        name = jQuery.propFix[name] || name;
                        hooks = jQuery.propHooks[name];
                    }

                    if (value !== undefined) {
                        if (hooks && "set" in hooks &&
                            (ret = hooks.set(elem, value, name)) !== undefined) {
                            return ret;
                        }

                        return (elem[name] = value);
                    }

                    if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
                        return ret;
                    }

                    return elem[name];
                },

                propHooks: {
                    tabIndex: {
                        get: function (elem) {

                            // elem.tabIndex doesn't always return the
                            // correct value when it hasn't been explicitly set
                            // http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
                            // Use proper attribute retrieval(#12072)
                            var tabindex = jQuery.find.attr(elem, "tabindex");

                            return tabindex ?
                                parseInt(tabindex, 10) :
                                rfocusable.test(elem.nodeName) ||
                                    rclickable.test(elem.nodeName) && elem.href ?
                                    0 :
                                    -1;
                        }
                    }
                },

                propFix: {
                    "for": "htmlFor",
                    "class": "className"
                }
            });

            // Support: IE <=11 only
            // Accessing the selectedIndex property
            // forces the browser to respect setting selected
            // on the option
            // The getter ensures a default option is selected
            // when in an optgroup
            if (!support.optSelected) {
                jQuery.propHooks.selected = {
                    get: function (elem) {
                        var parent = elem.parentNode;
                        if (parent && parent.parentNode) {
                            parent.parentNode.selectedIndex;
                        }
                        return null;
                    },
                    set: function (elem) {
                        var parent = elem.parentNode;
                        if (parent) {
                            parent.selectedIndex;

                            if (parent.parentNode) {
                                parent.parentNode.selectedIndex;
                            }
                        }
                    }
                };
            }

            jQuery.each([
                "tabIndex",
                "readOnly",
                "maxLength",
                "cellSpacing",
                "cellPadding",
                "rowSpan",
                "colSpan",
                "useMap",
                "frameBorder",
                "contentEditable"
            ], function () {
                jQuery.propFix[this.toLowerCase()] = this;
            });




            var rclass = /[\t\r\n\f]/g;

            function getClass(elem) {
                return elem.getAttribute && elem.getAttribute("class") || "";
            }

            jQuery.fn.extend({
                addClass: function (value) {
                    var classes, elem, cur, curValue, clazz, j, finalValue,
                        i = 0;

                    if (jQuery.isFunction(value)) {
                        return this.each(function (j) {
                            jQuery(this).addClass(value.call(this, j, getClass(this)));
                        });
                    }

                    if (typeof value === "string" && value) {
                        classes = value.match(rnotwhite) || [];

                        while ((elem = this[i++])) {
                            curValue = getClass(elem);
                            cur = elem.nodeType === 1 &&
                                (" " + curValue + " ").replace(rclass, " ");

                            if (cur) {
                                j = 0;
                                while ((clazz = classes[j++])) {
                                    if (cur.indexOf(" " + clazz + " ") < 0) {
                                        cur += clazz + " ";
                                    }
                                }

                                // Only assign if different to avoid unneeded rendering.
                                finalValue = jQuery.trim(cur);
                                if (curValue !== finalValue) {
                                    elem.setAttribute("class", finalValue);
                                }
                            }
                        }
                    }

                    return this;
                },

                removeClass: function (value) {
                    var classes, elem, cur, curValue, clazz, j, finalValue,
                        i = 0;

                    if (jQuery.isFunction(value)) {
                        return this.each(function (j) {
                            jQuery(this).removeClass(value.call(this, j, getClass(this)));
                        });
                    }

                    if (!arguments.length) {
                        return this.attr("class", "");
                    }

                    if (typeof value === "string" && value) {
                        classes = value.match(rnotwhite) || [];

                        while ((elem = this[i++])) {
                            curValue = getClass(elem);

                            // This expression is here for better compressibility (see addClass)
                            cur = elem.nodeType === 1 &&
                                (" " + curValue + " ").replace(rclass, " ");

                            if (cur) {
                                j = 0;
                                while ((clazz = classes[j++])) {

                                    // Remove *all* instances
                                    while (cur.indexOf(" " + clazz + " ") > -1) {
                                        cur = cur.replace(" " + clazz + " ", " ");
                                    }
                                }

                                // Only assign if different to avoid unneeded rendering.
                                finalValue = jQuery.trim(cur);
                                if (curValue !== finalValue) {
                                    elem.setAttribute("class", finalValue);
                                }
                            }
                        }
                    }

                    return this;
                },

                toggleClass: function (value, stateVal) {
                    var type = typeof value;

                    if (typeof stateVal === "boolean" && type === "string") {
                        return stateVal ? this.addClass(value) : this.removeClass(value);
                    }

                    if (jQuery.isFunction(value)) {
                        return this.each(function (i) {
                            jQuery(this).toggleClass(
                                value.call(this, i, getClass(this), stateVal),
                                stateVal
                            );
                        });
                    }

                    return this.each(function () {
                        var className, i, self, classNames;

                        if (type === "string") {

                            // Toggle individual class names
                            i = 0;
                            self = jQuery(this);
                            classNames = value.match(rnotwhite) || [];

                            while ((className = classNames[i++])) {

                                // Check each className given, space separated list
                                if (self.hasClass(className)) {
                                    self.removeClass(className);
                                } else {
                                    self.addClass(className);
                                }
                            }

                            // Toggle whole class name
                        } else if (value === undefined || type === "boolean") {
                            className = getClass(this);
                            if (className) {

                                // Store className if set
                                dataPriv.set(this, "__className__", className);
                            }

                            // If the element has a class name or if we're passed `false`,
                            // then remove the whole classname (if there was one, the above saved it).
                            // Otherwise bring back whatever was previously saved (if anything),
                            // falling back to the empty string if nothing was stored.
                            if (this.setAttribute) {
                                this.setAttribute("class",
                                    className || value === false ?
                                        "" :
                                        dataPriv.get(this, "__className__") || ""
                                );
                            }
                        }
                    });
                },

                hasClass: function (selector) {
                    var className, elem,
                        i = 0;

                    className = " " + selector + " ";
                    while ((elem = this[i++])) {
                        if (elem.nodeType === 1 &&
                            (" " + getClass(elem) + " ").replace(rclass, " ")
                                .indexOf(className) > -1
                        ) {
                            return true;
                        }
                    }

                    return false;
                }
            });




            var rreturn = /\r/g,
                rspaces = /[\x20\t\r\n\f]+/g;

            jQuery.fn.extend({
                val: function (value) {
                    var hooks, ret, isFunction,
                        elem = this[0];

                    if (!arguments.length) {
                        if (elem) {
                            hooks = jQuery.valHooks[elem.type] ||
                                jQuery.valHooks[elem.nodeName.toLowerCase()];

                            if (hooks &&
                                "get" in hooks &&
                                (ret = hooks.get(elem, "value")) !== undefined
                            ) {
                                return ret;
                            }

                            ret = elem.value;

                            return typeof ret === "string" ?

                                // Handle most common string cases
                                ret.replace(rreturn, "") :

                                // Handle cases where value is null/undef or number
                                ret == null ? "" : ret;
                        }

                        return;
                    }

                    isFunction = jQuery.isFunction(value);

                    return this.each(function (i) {
                        var val;

                        if (this.nodeType !== 1) {
                            return;
                        }

                        if (isFunction) {
                            val = value.call(this, i, jQuery(this).val());
                        } else {
                            val = value;
                        }

                        // Treat null/undefined as ""; convert numbers to string
                        if (val == null) {
                            val = "";

                        } else if (typeof val === "number") {
                            val += "";

                        } else if (jQuery.isArray(val)) {
                            val = jQuery.map(val, function (value) {
                                return value == null ? "" : value + "";
                            });
                        }

                        hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];

                        // If set returns undefined, fall back to normal setting
                        if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
                            this.value = val;
                        }
                    });
                }
            });

            jQuery.extend({
                valHooks: {
                    option: {
                        get: function (elem) {

                            var val = jQuery.find.attr(elem, "value");
                            return val != null ?
                                val :

                                // Support: IE10-11+
                                // option.text throws exceptions (#14686, #14858)
                                // Strip and collapse whitespace
                                // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
                                jQuery.trim(jQuery.text(elem)).replace(rspaces, " ");
                        }
                    },
                    select: {
                        get: function (elem) {
                            var value, option,
                                options = elem.options,
                                index = elem.selectedIndex,
                                one = elem.type === "select-one" || index < 0,
                                values = one ? null : [],
                                max = one ? index + 1 : options.length,
                                i = index < 0 ?
                                    max :
                                    one ? index : 0;

                            // Loop through all the selected options
                            for (; i < max; i++) {
                                option = options[i];

                                // IE8-9 doesn't update selected after form reset (#2551)
                                if ((option.selected || i === index) &&

                                    // Don't return options that are disabled or in a disabled optgroup
                                    (support.optDisabled ?
                                        !option.disabled : option.getAttribute("disabled") === null) &&
                                    (!option.parentNode.disabled ||
                                        !jQuery.nodeName(option.parentNode, "optgroup"))) {

                                    // Get the specific value for the option
                                    value = jQuery(option).val();

                                    // We don't need an array for one selects
                                    if (one) {
                                        return value;
                                    }

                                    // Multi-Selects return an array
                                    values.push(value);
                                }
                            }

                            return values;
                        },

                        set: function (elem, value) {
                            var optionSet, option,
                                options = elem.options,
                                values = jQuery.makeArray(value),
                                i = options.length;

                            while (i--) {
                                option = options[i];
                                if (option.selected =
                                    jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1
                                ) {
                                    optionSet = true;
                                }
                            }

                            // Force browsers to behave consistently when non-matching value is set
                            if (!optionSet) {
                                elem.selectedIndex = -1;
                            }
                            return values;
                        }
                    }
                }
            });

            // Radios and checkboxes getter/setter
            jQuery.each(["radio", "checkbox"], function () {
                jQuery.valHooks[this] = {
                    set: function (elem, value) {
                        if (jQuery.isArray(value)) {
                            return (elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1);
                        }
                    }
                };
                if (!support.checkOn) {
                    jQuery.valHooks[this].get = function (elem) {
                        return elem.getAttribute("value") === null ? "on" : elem.value;
                    };
                }
            });




            // Return jQuery for attributes-only inclusion


            var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;

            jQuery.extend(jQuery.event, {

                trigger: function (event, data, elem, onlyHandlers) {

                    var i, cur, tmp, bubbleType, ontype, handle, special,
                        eventPath = [elem || document],
                        type = hasOwn.call(event, "type") ? event.type : event,
                        namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];

                    cur = tmp = elem = elem || document;

                    // Don't do events on text and comment nodes
                    if (elem.nodeType === 3 || elem.nodeType === 8) {
                        return;
                    }

                    // focus/blur morphs to focusin/out; ensure we're not firing them right now
                    if (rfocusMorph.test(type + jQuery.event.triggered)) {
                        return;
                    }

                    if (type.indexOf(".") > -1) {

                        // Namespaced trigger; create a regexp to match event type in handle()
                        namespaces = type.split(".");
                        type = namespaces.shift();
                        namespaces.sort();
                    }
                    ontype = type.indexOf(":") < 0 && "on" + type;

                    // Caller can pass in a jQuery.Event object, Object, or just an event type string
                    event = event[jQuery.expando] ?
                        event :
                        new jQuery.Event(type, typeof event === "object" && event);

                    // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
                    event.isTrigger = onlyHandlers ? 2 : 3;
                    event.namespace = namespaces.join(".");
                    event.rnamespace = event.namespace ?
                        new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") :
                        null;

                    // Clean up the event in case it is being reused
                    event.result = undefined;
                    if (!event.target) {
                        event.target = elem;
                    }

                    // Clone any incoming data and prepend the event, creating the handler arg list
                    data = data == null ?
                        [event] :
                        jQuery.makeArray(data, [event]);

                    // Allow special events to draw outside the lines
                    special = jQuery.event.special[type] || {};
                    if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
                        return;
                    }

                    // Determine event propagation path in advance, per W3C events spec (#9951)
                    // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
                    if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {

                        bubbleType = special.delegateType || type;
                        if (!rfocusMorph.test(bubbleType + type)) {
                            cur = cur.parentNode;
                        }
                        for (; cur; cur = cur.parentNode) {
                            eventPath.push(cur);
                            tmp = cur;
                        }

                        // Only add window if we got to document (e.g., not plain obj or detached DOM)
                        if (tmp === (elem.ownerDocument || document)) {
                            eventPath.push(tmp.defaultView || tmp.parentWindow || window);
                        }
                    }

                    // Fire handlers on the event path
                    i = 0;
                    while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {

                        event.type = i > 1 ?
                            bubbleType :
                            special.bindType || type;

                        // jQuery handler
                        handle = (dataPriv.get(cur, "events") || {})[event.type] &&
                            dataPriv.get(cur, "handle");
                        if (handle) {
                            handle.apply(cur, data);
                        }

                        // Native handler
                        handle = ontype && cur[ontype];
                        if (handle && handle.apply && acceptData(cur)) {
                            event.result = handle.apply(cur, data);
                            if (event.result === false) {
                                event.preventDefault();
                            }
                        }
                    }
                    event.type = type;

                    // If nobody prevented the default action, do it now
                    if (!onlyHandlers && !event.isDefaultPrevented()) {

                        if ((!special._default ||
                            special._default.apply(eventPath.pop(), data) === false) &&
                            acceptData(elem)) {

                            // Call a native DOM method on the target with the same name name as the event.
                            // Don't do default actions on window, that's where global variables be (#6170)
                            if (ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {

                                // Don't re-trigger an onFOO event when we call its FOO() method
                                tmp = elem[ontype];

                                if (tmp) {
                                    elem[ontype] = null;
                                }

                                // Prevent re-triggering of the same event, since we already bubbled it above
                                jQuery.event.triggered = type;
                                elem[type]();
                                jQuery.event.triggered = undefined;

                                if (tmp) {
                                    elem[ontype] = tmp;
                                }
                            }
                        }
                    }

                    return event.result;
                },

                // Piggyback on a donor event to simulate a different one
                // Used only for `focus(in | out)` events
                simulate: function (type, elem, event) {
                    var e = jQuery.extend(
                        new jQuery.Event(),
                        event,
                        {
                            type: type,
                            isSimulated: true
                        }
                    );

                    jQuery.event.trigger(e, null, elem);
                }

            });

            jQuery.fn.extend({

                trigger: function (type, data) {
                    return this.each(function () {
                        jQuery.event.trigger(type, data, this);
                    });
                },
                triggerHandler: function (type, data) {
                    var elem = this[0];
                    if (elem) {
                        return jQuery.event.trigger(type, data, elem, true);
                    }
                }
            });


            jQuery.each(("blur focus focusin focusout load resize scroll unload click dblclick " +
                "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
                "change select submit keydown keypress keyup error contextmenu").split(" "),
                function (i, name) {

                    // Handle event binding
                    jQuery.fn[name] = function (data, fn) {
                        return arguments.length > 0 ?
                            this.on(name, null, data, fn) :
                            this.trigger(name);
                    };
                });

            jQuery.fn.extend({
                hover: function (fnOver, fnOut) {
                    return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
                }
            });




            support.focusin = "onfocusin" in window;


            // Support: Firefox
            // Firefox doesn't have focus(in | out) events
            // Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
            //
            // Support: Chrome, Safari
            // focus(in | out) events fire after focus & blur events,
            // which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
            // Related ticket - https://code.google.com/p/chromium/issues/detail?id=449857
            if (!support.focusin) {
                jQuery.each({ focus: "focusin", blur: "focusout" }, function (orig, fix) {

                    // Attach a single capturing handler on the document while someone wants focusin/focusout
                    var handler = function (event) {
                        jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
                    };

                    jQuery.event.special[fix] = {
                        setup: function () {
                            var doc = this.ownerDocument || this,
                                attaches = dataPriv.access(doc, fix);

                            if (!attaches) {
                                doc.addEventListener(orig, handler, true);
                            }
                            dataPriv.access(doc, fix, (attaches || 0) + 1);
                        },
                        teardown: function () {
                            var doc = this.ownerDocument || this,
                                attaches = dataPriv.access(doc, fix) - 1;

                            if (!attaches) {
                                doc.removeEventListener(orig, handler, true);
                                dataPriv.remove(doc, fix);

                            } else {
                                dataPriv.access(doc, fix, attaches);
                            }
                        }
                    };
                });
            }
            var location = window.location;

            var nonce = jQuery.now();

            var rquery = (/\?/);



            // Support: Android 2.3
            // Workaround failure to string-cast null input
            jQuery.parseJSON = function (data) {
                return JSON.parse(data + "");
            };


            // Cross-browser xml parsing
            jQuery.parseXML = function (data) {
                var xml;
                if (!data || typeof data !== "string") {
                    return null;
                }

                // Support: IE9
                try {
                    xml = (new window.DOMParser()).parseFromString(data, "text/xml");
                } catch (e) {
                    xml = undefined;
                }

                if (!xml || xml.getElementsByTagName("parsererror").length) {
                    jQuery.error("Invalid XML: " + data);
                }
                return xml;
            };


            var
                rhash = /#.*$/,
                rts = /([?&])_=[^&]*/,
                rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

                // #7653, #8125, #8152: local protocol detection
                rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
                rnoContent = /^(?:GET|HEAD)$/,
                rprotocol = /^\/\//,

                /* Prefilters
                 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
                 * 2) These are called:
                 *    - BEFORE asking for a transport
                 *    - AFTER param serialization (s.data is a string if s.processData is true)
                 * 3) key is the dataType
                 * 4) the catchall symbol "*" can be used
                 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
                 */
                prefilters = {},

                /* Transports bindings
                 * 1) key is the dataType
                 * 2) the catchall symbol "*" can be used
                 * 3) selection will start with transport dataType and THEN go to "*" if needed
                 */
                transports = {},

                // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
                allTypes = "*/".concat("*"),

                // Anchor tag for parsing the document origin
                originAnchor = document.createElement("a");
            originAnchor.href = location.href;

            // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
            function addToPrefiltersOrTransports(structure) {

                // dataTypeExpression is optional and defaults to "*"
                return function (dataTypeExpression, func) {

                    if (typeof dataTypeExpression !== "string") {
                        func = dataTypeExpression;
                        dataTypeExpression = "*";
                    }

                    var dataType,
                        i = 0,
                        dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];

                    if (jQuery.isFunction(func)) {

                        // For each dataType in the dataTypeExpression
                        while ((dataType = dataTypes[i++])) {

                            // Prepend if requested
                            if (dataType[0] === "+") {
                                dataType = dataType.slice(1) || "*";
                                (structure[dataType] = structure[dataType] || []).unshift(func);

                                // Otherwise append
                            } else {
                                (structure[dataType] = structure[dataType] || []).push(func);
                            }
                        }
                    }
                };
            }

            // Base inspection function for prefilters and transports
            function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {

                var inspected = {},
                    seekingTransport = (structure === transports);

                function inspect(dataType) {
                    var selected;
                    inspected[dataType] = true;
                    jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
                        var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
                        if (typeof dataTypeOrTransport === "string" &&
                            !seekingTransport && !inspected[dataTypeOrTransport]) {

                            options.dataTypes.unshift(dataTypeOrTransport);
                            inspect(dataTypeOrTransport);
                            return false;
                        } else if (seekingTransport) {
                            return !(selected = dataTypeOrTransport);
                        }
                    });
                    return selected;
                }

                return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
            }

            // A special extend for ajax options
            // that takes "flat" options (not to be deep extended)
            // Fixes #9887
            function ajaxExtend(target, src) {
                var key, deep,
                    flatOptions = jQuery.ajaxSettings.flatOptions || {};

                for (key in src) {
                    if (src[key] !== undefined) {
                        (flatOptions[key] ? target : (deep || (deep = {})))[key] = src[key];
                    }
                }
                if (deep) {
                    jQuery.extend(true, target, deep);
                }

                return target;
            }

            /* Handles responses to an ajax request:
             * - finds the right dataType (mediates between content-type and expected dataType)
             * - returns the corresponding response
             */
            function ajaxHandleResponses(s, jqXHR, responses) {

                var ct, type, finalDataType, firstDataType,
                    contents = s.contents,
                    dataTypes = s.dataTypes;

                // Remove auto dataType and get content-type in the process
                while (dataTypes[0] === "*") {
                    dataTypes.shift();
                    if (ct === undefined) {
                        ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
                    }
                }

                // Check if we're dealing with a known content-type
                if (ct) {
                    for (type in contents) {
                        if (contents[type] && contents[type].test(ct)) {
                            dataTypes.unshift(type);
                            break;
                        }
                    }
                }

                // Check to see if we have a response for the expected dataType
                if (dataTypes[0] in responses) {
                    finalDataType = dataTypes[0];
                } else {

                    // Try convertible dataTypes
                    for (type in responses) {
                        if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
                            finalDataType = type;
                            break;
                        }
                        if (!firstDataType) {
                            firstDataType = type;
                        }
                    }

                    // Or just use first one
                    finalDataType = finalDataType || firstDataType;
                }

                // If we found a dataType
                // We add the dataType to the list if needed
                // and return the corresponding response
                if (finalDataType) {
                    if (finalDataType !== dataTypes[0]) {
                        dataTypes.unshift(finalDataType);
                    }
                    return responses[finalDataType];
                }
            }

            /* Chain conversions given the request and the original response
             * Also sets the responseXXX fields on the jqXHR instance
             */
            function ajaxConvert(s, response, jqXHR, isSuccess) {
                var conv2, current, conv, tmp, prev,
                    converters = {},

                    // Work with a copy of dataTypes in case we need to modify it for conversion
                    dataTypes = s.dataTypes.slice();

                // Create converters map with lowercased keys
                if (dataTypes[1]) {
                    for (conv in s.converters) {
                        converters[conv.toLowerCase()] = s.converters[conv];
                    }
                }

                current = dataTypes.shift();

                // Convert to each sequential dataType
                while (current) {

                    if (s.responseFields[current]) {
                        jqXHR[s.responseFields[current]] = response;
                    }

                    // Apply the dataFilter if provided
                    if (!prev && isSuccess && s.dataFilter) {
                        response = s.dataFilter(response, s.dataType);
                    }

                    prev = current;
                    current = dataTypes.shift();

                    if (current) {

                        // There's only work to do if current dataType is non-auto
                        if (current === "*") {

                            current = prev;

                            // Convert response if prev dataType is non-auto and differs from current
                        } else if (prev !== "*" && prev !== current) {

                            // Seek a direct converter
                            conv = converters[prev + " " + current] || converters["* " + current];

                            // If none found, seek a pair
                            if (!conv) {
                                for (conv2 in converters) {

                                    // If conv2 outputs current
                                    tmp = conv2.split(" ");
                                    if (tmp[1] === current) {

                                        // If prev can be converted to accepted input
                                        conv = converters[prev + " " + tmp[0]] ||
                                            converters["* " + tmp[0]];
                                        if (conv) {

                                            // Condense equivalence converters
                                            if (conv === true) {
                                                conv = converters[conv2];

                                                // Otherwise, insert the intermediate dataType
                                            } else if (converters[conv2] !== true) {
                                                current = tmp[0];
                                                dataTypes.unshift(tmp[1]);
                                            }
                                            break;
                                        }
                                    }
                                }
                            }

                            // Apply converter (if not an equivalence)
                            if (conv !== true) {

                                // Unless errors are allowed to bubble, catch and return them
                                if (conv && s.throws) {
                                    response = conv(response);
                                } else {
                                    try {
                                        response = conv(response);
                                    } catch (e) {
                                        return {
                                            state: "parsererror",
                                            error: conv ? e : "No conversion from " + prev + " to " + current
                                        };
                                    }
                                }
                            }
                        }
                    }
                }

                return { state: "success", data: response };
            }

            jQuery.extend({

                // Counter for holding the number of active queries
                active: 0,

                // Last-Modified header cache for next request
                lastModified: {},
                etag: {},

                ajaxSettings: {
                    url: location.href,
                    type: "GET",
                    isLocal: rlocalProtocol.test(location.protocol),
                    global: true,
                    processData: true,
                    async: true,
                    contentType: "application/x-www-form-urlencoded; charset=UTF-8",
                    /*
                    timeout: 0,
                    data: null,
                    dataType: null,
                    username: null,
                    password: null,
                    cache: null,
                    throws: false,
                    traditional: false,
                    headers: {},
                    */

                    accepts: {
                        "*": allTypes,
                        text: "text/plain",
                        html: "text/html",
                        xml: "application/xml, text/xml",
                        json: "application/json, text/javascript"
                    },

                    contents: {
                        xml: /\bxml\b/,
                        html: /\bhtml/,
                        json: /\bjson\b/
                    },

                    responseFields: {
                        xml: "responseXML",
                        text: "responseText",
                        json: "responseJSON"
                    },

                    // Data converters
                    // Keys separate source (or catchall "*") and destination types with a single space
                    converters: {

                        // Convert anything to text
                        "* text": String,

                        // Text to html (true = no transformation)
                        "text html": true,

                        // Evaluate text as a json expression
                        "text json": jQuery.parseJSON,

                        // Parse text as xml
                        "text xml": jQuery.parseXML
                    },

                    // For options that shouldn't be deep extended:
                    // you can add your own custom options here if
                    // and when you create one that shouldn't be
                    // deep extended (see ajaxExtend)
                    flatOptions: {
                        url: true,
                        context: true
                    }
                },

                // Creates a full fledged settings object into target
                // with both ajaxSettings and settings fields.
                // If target is omitted, writes into ajaxSettings.
                ajaxSetup: function (target, settings) {
                    return settings ?

                        // Building a settings object
                        ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) :

                        // Extending ajaxSettings
                        ajaxExtend(jQuery.ajaxSettings, target);
                },

                ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
                ajaxTransport: addToPrefiltersOrTransports(transports),

                // Main method
                ajax: function (url, options) {

                    // If url is an object, simulate pre-1.5 signature
                    if (typeof url === "object") {
                        options = url;
                        url = undefined;
                    }

                    // Force options to be an object
                    options = options || {};

                    var transport,

                        // URL without anti-cache param
                        cacheURL,

                        // Response headers
                        responseHeadersString,
                        responseHeaders,

                        // timeout handle
                        timeoutTimer,

                        // Url cleanup var
                        urlAnchor,

                        // To know if global events are to be dispatched
                        fireGlobals,

                        // Loop variable
                        i,

                        // Create the final options object
                        s = jQuery.ajaxSetup({}, options),

                        // Callbacks context
                        callbackContext = s.context || s,

                        // Context for global events is callbackContext if it is a DOM node or jQuery collection
                        globalEventContext = s.context &&
                            (callbackContext.nodeType || callbackContext.jquery) ?
                            jQuery(callbackContext) :
                            jQuery.event,

                        // Deferreds
                        deferred = jQuery.Deferred(),
                        completeDeferred = jQuery.Callbacks("once memory"),

                        // Status-dependent callbacks
                        statusCode = s.statusCode || {},

                        // Headers (they are sent all at once)
                        requestHeaders = {},
                        requestHeadersNames = {},

                        // The jqXHR state
                        state = 0,

                        // Default abort message
                        strAbort = "canceled",

                        // Fake xhr
                        jqXHR = {
                            readyState: 0,

                            // Builds headers hashtable if needed
                            getResponseHeader: function (key) {
                                var match;
                                if (state === 2) {
                                    if (!responseHeaders) {
                                        responseHeaders = {};
                                        while ((match = rheaders.exec(responseHeadersString))) {
                                            responseHeaders[match[1].toLowerCase()] = match[2];
                                        }
                                    }
                                    match = responseHeaders[key.toLowerCase()];
                                }
                                return match == null ? null : match;
                            },

                            // Raw string
                            getAllResponseHeaders: function () {
                                return state === 2 ? responseHeadersString : null;
                            },

                            // Caches the header
                            setRequestHeader: function (name, value) {
                                var lname = name.toLowerCase();
                                if (!state) {
                                    name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
                                    requestHeaders[name] = value;
                                }
                                return this;
                            },

                            // Overrides response content-type header
                            overrideMimeType: function (type) {
                                if (!state) {
                                    s.mimeType = type;
                                }
                                return this;
                            },

                            // Status-dependent callbacks
                            statusCode: function (map) {
                                var code;
                                if (map) {
                                    if (state < 2) {
                                        for (code in map) {

                                            // Lazy-add the new callback in a way that preserves old ones
                                            statusCode[code] = [statusCode[code], map[code]];
                                        }
                                    } else {

                                        // Execute the appropriate callbacks
                                        jqXHR.always(map[jqXHR.status]);
                                    }
                                }
                                return this;
                            },

                            // Cancel the request
                            abort: function (statusText) {
                                var finalText = statusText || strAbort;
                                if (transport) {
                                    transport.abort(finalText);
                                }
                                done(0, finalText);
                                return this;
                            }
                        };

                    // Attach deferreds
                    deferred.promise(jqXHR).complete = completeDeferred.add;
                    jqXHR.success = jqXHR.done;
                    jqXHR.error = jqXHR.fail;

                    // Remove hash character (#7531: and string promotion)
                    // Add protocol if not provided (prefilters might expect it)
                    // Handle falsy url in the settings object (#10093: consistency with old signature)
                    // We also use the url parameter if available
                    s.url = ((url || s.url || location.href) + "").replace(rhash, "")
                        .replace(rprotocol, location.protocol + "//");

                    // Alias method option to type as per ticket #12004
                    s.type = options.method || options.type || s.method || s.type;

                    // Extract dataTypes list
                    s.dataTypes = jQuery.trim(s.dataType || "*").toLowerCase().match(rnotwhite) || [""];

                    // A cross-domain request is in order when the origin doesn't match the current origin.
                    if (s.crossDomain == null) {
                        urlAnchor = document.createElement("a");

                        // Support: IE8-11+
                        // IE throws exception if url is malformed, e.g. http://example.com:80x/
                        try {
                            urlAnchor.href = s.url;

                            // Support: IE8-11+
                            // Anchor's host property isn't correctly set when s.url is relative
                            urlAnchor.href = urlAnchor.href;
                            s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
                                urlAnchor.protocol + "//" + urlAnchor.host;
                        } catch (e) {

                            // If there is an error parsing the URL, assume it is crossDomain,
                            // it can be rejected by the transport if it is invalid
                            s.crossDomain = true;
                        }
                    }

                    // Convert data if not already a string
                    if (s.data && s.processData && typeof s.data !== "string") {
                        s.data = jQuery.param(s.data, s.traditional);
                    }

                    // Apply prefilters
                    inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);

                    // If request was aborted inside a prefilter, stop there
                    if (state === 2) {
                        return jqXHR;
                    }

                    // We can fire global events as of now if asked to
                    // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
                    fireGlobals = jQuery.event && s.global;

                    // Watch for a new set of requests
                    if (fireGlobals && jQuery.active++ === 0) {
                        jQuery.event.trigger("ajaxStart");
                    }

                    // Uppercase the type
                    s.type = s.type.toUpperCase();

                    // Determine if request has content
                    s.hasContent = !rnoContent.test(s.type);

                    // Save the URL in case we're toying with the If-Modified-Since
                    // and/or If-None-Match header later on
                    cacheURL = s.url;

                    // More options handling for requests with no content
                    if (!s.hasContent) {

                        // If data is available, append data to url
                        if (s.data) {
                            cacheURL = (s.url += (rquery.test(cacheURL) ? "&" : "?") + s.data);

                            // #9682: remove data so that it's not used in an eventual retry
                            delete s.data;
                        }

                        // Add anti-cache in url if needed
                        if (s.cache === false) {
                            s.url = rts.test(cacheURL) ?

                                // If there is already a '_' parameter, set its value
                                cacheURL.replace(rts, "$1_=" + nonce++) :

                                // Otherwise add one to the end
                                cacheURL + (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++;
                        }
                    }

                    // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                    if (s.ifModified) {
                        if (jQuery.lastModified[cacheURL]) {
                            jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
                        }
                        if (jQuery.etag[cacheURL]) {
                            jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
                        }
                    }

                    // Set the correct header, if data is being sent
                    if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
                        jqXHR.setRequestHeader("Content-Type", s.contentType);
                    }

                    // Set the Accepts header for the server, depending on the dataType
                    jqXHR.setRequestHeader(
                        "Accept",
                        s.dataTypes[0] && s.accepts[s.dataTypes[0]] ?
                            s.accepts[s.dataTypes[0]] +
                            (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") :
                            s.accepts["*"]
                    );

                    // Check for headers option
                    for (i in s.headers) {
                        jqXHR.setRequestHeader(i, s.headers[i]);
                    }

                    // Allow custom headers/mimetypes and early abort
                    if (s.beforeSend &&
                        (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {

                        // Abort if not done already and return
                        return jqXHR.abort();
                    }

                    // Aborting is no longer a cancellation
                    strAbort = "abort";

                    // Install callbacks on deferreds
                    for (i in { success: 1, error: 1, complete: 1 }) {
                        jqXHR[i](s[i]);
                    }

                    // Get transport
                    transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);

                    // If no transport, we auto-abort
                    if (!transport) {
                        done(-1, "No Transport");
                    } else {
                        jqXHR.readyState = 1;

                        // Send global event
                        if (fireGlobals) {
                            globalEventContext.trigger("ajaxSend", [jqXHR, s]);
                        }

                        // If request was aborted inside ajaxSend, stop there
                        if (state === 2) {
                            return jqXHR;
                        }

                        // Timeout
                        if (s.async && s.timeout > 0) {
                            timeoutTimer = window.setTimeout(function () {
                                jqXHR.abort("timeout");
                            }, s.timeout);
                        }

                        try {
                            state = 1;
                            transport.send(requestHeaders, done);
                        } catch (e) {

                            // Propagate exception as error if not done
                            if (state < 2) {
                                done(-1, e);

                                // Simply rethrow otherwise
                            } else {
                                throw e;
                            }
                        }
                    }

                    // Callback for when everything is done
                    function done(status, nativeStatusText, responses, headers) {
                        var isSuccess, success, error, response, modified,
                            statusText = nativeStatusText;

                        // Called once
                        if (state === 2) {
                            return;
                        }

                        // State is "done" now
                        state = 2;

                        // Clear timeout if it exists
                        if (timeoutTimer) {
                            window.clearTimeout(timeoutTimer);
                        }

                        // Dereference transport for early garbage collection
                        // (no matter how long the jqXHR object will be used)
                        transport = undefined;

                        // Cache response headers
                        responseHeadersString = headers || "";

                        // Set readyState
                        jqXHR.readyState = status > 0 ? 4 : 0;

                        // Determine if successful
                        isSuccess = status >= 200 && status < 300 || status === 304;

                        // Get response data
                        if (responses) {
                            response = ajaxHandleResponses(s, jqXHR, responses);
                        }

                        // Convert no matter what (that way responseXXX fields are always set)
                        response = ajaxConvert(s, response, jqXHR, isSuccess);

                        // If successful, handle type chaining
                        if (isSuccess) {

                            // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                            if (s.ifModified) {
                                modified = jqXHR.getResponseHeader("Last-Modified");
                                if (modified) {
                                    jQuery.lastModified[cacheURL] = modified;
                                }
                                modified = jqXHR.getResponseHeader("etag");
                                if (modified) {
                                    jQuery.etag[cacheURL] = modified;
                                }
                            }

                            // if no content
                            if (status === 204 || s.type === "HEAD") {
                                statusText = "nocontent";

                                // if not modified
                            } else if (status === 304) {
                                statusText = "notmodified";

                                // If we have data, let's convert it
                            } else {
                                statusText = response.state;
                                success = response.data;
                                error = response.error;
                                isSuccess = !error;
                            }
                        } else {

                            // Extract error from statusText and normalize for non-aborts
                            error = statusText;
                            if (status || !statusText) {
                                statusText = "error";
                                if (status < 0) {
                                    status = 0;
                                }
                            }
                        }

                        // Set data for the fake xhr object
                        jqXHR.status = status;
                        jqXHR.statusText = (nativeStatusText || statusText) + "";

                        // Success/Error
                        if (isSuccess) {
                            deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
                        } else {
                            deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
                        }

                        // Status-dependent callbacks
                        jqXHR.statusCode(statusCode);
                        statusCode = undefined;

                        if (fireGlobals) {
                            globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError",
                                [jqXHR, s, isSuccess ? success : error]);
                        }

                        // Complete
                        completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);

                        if (fireGlobals) {
                            globalEventContext.trigger("ajaxComplete", [jqXHR, s]);

                            // Handle the global AJAX counter
                            if (!(--jQuery.active)) {
                                jQuery.event.trigger("ajaxStop");
                            }
                        }
                    }

                    return jqXHR;
                },

                getJSON: function (url, data, callback) {
                    return jQuery.get(url, data, callback, "json");
                },

                getScript: function (url, callback) {
                    return jQuery.get(url, undefined, callback, "script");
                }
            });

            jQuery.each(["get", "post"], function (i, method) {
                jQuery[method] = function (url, data, callback, type) {

                    // Shift arguments if data argument was omitted
                    if (jQuery.isFunction(data)) {
                        type = type || callback;
                        callback = data;
                        data = undefined;
                    }

                    // The url can be an options object (which then must have .url)
                    return jQuery.ajax(jQuery.extend({
                        url: url,
                        type: method,
                        dataType: type,
                        data: data,
                        success: callback
                    }, jQuery.isPlainObject(url) && url));
                };
            });


            jQuery._evalUrl = function (url) {
                return jQuery.ajax({
                    url: url,

                    // Make this explicit, since user can override this through ajaxSetup (#11264)
                    type: "GET",
                    dataType: "script",
                    async: false,
                    global: false,
                    "throws": true
                });
            };


            jQuery.fn.extend({
                wrapAll: function (html) {
                    var wrap;

                    if (jQuery.isFunction(html)) {
                        return this.each(function (i) {
                            jQuery(this).wrapAll(html.call(this, i));
                        });
                    }

                    if (this[0]) {

                        // The elements to wrap the target around
                        wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);

                        if (this[0].parentNode) {
                            wrap.insertBefore(this[0]);
                        }

                        wrap.map(function () {
                            var elem = this;

                            while (elem.firstElementChild) {
                                elem = elem.firstElementChild;
                            }

                            return elem;
                        }).append(this);
                    }

                    return this;
                },

                wrapInner: function (html) {
                    if (jQuery.isFunction(html)) {
                        return this.each(function (i) {
                            jQuery(this).wrapInner(html.call(this, i));
                        });
                    }

                    return this.each(function () {
                        var self = jQuery(this),
                            contents = self.contents();

                        if (contents.length) {
                            contents.wrapAll(html);

                        } else {
                            self.append(html);
                        }
                    });
                },

                wrap: function (html) {
                    var isFunction = jQuery.isFunction(html);

                    return this.each(function (i) {
                        jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
                    });
                },

                unwrap: function () {
                    return this.parent().each(function () {
                        if (!jQuery.nodeName(this, "body")) {
                            jQuery(this).replaceWith(this.childNodes);
                        }
                    }).end();
                }
            });


            jQuery.expr.filters.hidden = function (elem) {
                return !jQuery.expr.filters.visible(elem);
            };
            jQuery.expr.filters.visible = function (elem) {

                // Support: Opera <= 12.12
                // Opera reports offsetWidths and offsetHeights less than zero on some elements
                // Use OR instead of AND as the element is not visible if either is true
                // See tickets #10406 and #13132
                return elem.offsetWidth > 0 || elem.offsetHeight > 0 || elem.getClientRects().length > 0;
            };




            var r20 = /%20/g,
                rbracket = /\[\]$/,
                rCRLF = /\r?\n/g,
                rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
                rsubmittable = /^(?:input|select|textarea|keygen)/i;

            function buildParams(prefix, obj, traditional, add) {
                var name;

                if (jQuery.isArray(obj)) {

                    // Serialize array item.
                    jQuery.each(obj, function (i, v) {
                        if (traditional || rbracket.test(prefix)) {

                            // Treat each array item as a scalar.
                            add(prefix, v);

                        } else {

                            // Item is non-scalar (array or object), encode its numeric index.
                            buildParams(
                                prefix + "[" + (typeof v === "object" && v != null ? i : "") + "]",
                                v,
                                traditional,
                                add
                            );
                        }
                    });

                } else if (!traditional && jQuery.type(obj) === "object") {

                    // Serialize object item.
                    for (name in obj) {
                        buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
                    }

                } else {

                    // Serialize scalar item.
                    add(prefix, obj);
                }
            }

            // Serialize an array of form elements or a set of
            // key/values into a query string
            jQuery.param = function (a, traditional) {
                var prefix,
                    s = [],
                    add = function (key, value) {

                        // If value is a function, invoke it and return its value
                        value = jQuery.isFunction(value) ? value() : (value == null ? "" : value);
                        s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
                    };

                // Set traditional to true for jQuery <= 1.3.2 behavior.
                if (traditional === undefined) {
                    traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
                }

                // If an array was passed in, assume that it is an array of form elements.
                if (jQuery.isArray(a) || (a.jquery && !jQuery.isPlainObject(a))) {

                    // Serialize the form elements
                    jQuery.each(a, function () {
                        add(this.name, this.value);
                    });

                } else {

                    // If traditional, encode the "old" way (the way 1.3.2 or older
                    // did it), otherwise encode params recursively.
                    for (prefix in a) {
                        buildParams(prefix, a[prefix], traditional, add);
                    }
                }

                // Return the resulting serialization
                return s.join("&").replace(r20, "+");
            };

            jQuery.fn.extend({
                serialize: function () {
                    return jQuery.param(this.serializeArray());
                },
                serializeArray: function () {
                    return this.map(function () {

                        // Can add propHook for "elements" to filter or add form elements
                        var elements = jQuery.prop(this, "elements");
                        return elements ? jQuery.makeArray(elements) : this;
                    })
                        .filter(function () {
                            var type = this.type;

                            // Use .is( ":disabled" ) so that fieldset[disabled] works
                            return this.name && !jQuery(this).is(":disabled") &&
                                rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) &&
                                (this.checked || !rcheckableType.test(type));
                        })
                        .map(function (i, elem) {
                            var val = jQuery(this).val();

                            return val == null ?
                                null :
                                jQuery.isArray(val) ?
                                    jQuery.map(val, function (val) {
                                        return { name: elem.name, value: val.replace(rCRLF, "\r\n") };
                                    }) :
                                    { name: elem.name, value: val.replace(rCRLF, "\r\n") };
                        }).get();
                }
            });


            jQuery.ajaxSettings.xhr = function () {
                try {
                    return new window.XMLHttpRequest();
                } catch (e) { }
            };

            var xhrSuccessStatus = {

                // File protocol always yields status code 0, assume 200
                0: 200,

                // Support: IE9
                // #1450: sometimes IE returns 1223 when it should be 204
                1223: 204
            },
                xhrSupported = jQuery.ajaxSettings.xhr();

            support.cors = !!xhrSupported && ("withCredentials" in xhrSupported);
            support.ajax = xhrSupported = !!xhrSupported;

            jQuery.ajaxTransport(function (options) {
                var callback, errorCallback;

                // Cross domain only allowed if supported through XMLHttpRequest
                if (support.cors || xhrSupported && !options.crossDomain) {
                    return {
                        send: function (headers, complete) {
                            var i,
                                xhr = options.xhr();

                            xhr.open(
                                options.type,
                                options.url,
                                options.async,
                                options.username,
                                options.password
                            );

                            // Apply custom fields if provided
                            if (options.xhrFields) {
                                for (i in options.xhrFields) {
                                    xhr[i] = options.xhrFields[i];
                                }
                            }

                            // Override mime type if needed
                            if (options.mimeType && xhr.overrideMimeType) {
                                xhr.overrideMimeType(options.mimeType);
                            }

                            // X-Requested-With header
                            // For cross-domain requests, seeing as conditions for a preflight are
                            // akin to a jigsaw puzzle, we simply never set it to be sure.
                            // (it can always be set on a per-request basis or even using ajaxSetup)
                            // For same-domain requests, won't change header if already provided.
                            if (!options.crossDomain && !headers["X-Requested-With"]) {
                                headers["X-Requested-With"] = "XMLHttpRequest";
                            }

                            // Set headers
                            for (i in headers) {
                                xhr.setRequestHeader(i, headers[i]);
                            }

                            // Callback
                            callback = function (type) {
                                return function () {
                                    if (callback) {
                                        callback = errorCallback = xhr.onload =
                                            xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;

                                        if (type === "abort") {
                                            xhr.abort();
                                        } else if (type === "error") {

                                            // Support: IE9
                                            // On a manual native abort, IE9 throws
                                            // errors on any property access that is not readyState
                                            if (typeof xhr.status !== "number") {
                                                complete(0, "error");
                                            } else {
                                                complete(

                                                    // File: protocol always yields status 0; see #8605, #14207
                                                    xhr.status,
                                                    xhr.statusText
                                                );
                                            }
                                        } else {
                                            complete(
                                                xhrSuccessStatus[xhr.status] || xhr.status,
                                                xhr.statusText,

                                                // Support: IE9 only
                                                // IE9 has no XHR2 but throws on binary (trac-11426)
                                                // For XHR2 non-text, let the caller handle it (gh-2498)
                                                (xhr.responseType || "text") !== "text" ||
                                                    typeof xhr.responseText !== "string" ?
                                                    { binary: xhr.response } :
                                                    { text: xhr.responseText },
                                                xhr.getAllResponseHeaders()
                                            );
                                        }
                                    }
                                };
                            };

                            // Listen to events
                            xhr.onload = callback();
                            errorCallback = xhr.onerror = callback("error");

                            // Support: IE9
                            // Use onreadystatechange to replace onabort
                            // to handle uncaught aborts
                            if (xhr.onabort !== undefined) {
                                xhr.onabort = errorCallback;
                            } else {
                                xhr.onreadystatechange = function () {

                                    // Check readyState before timeout as it changes
                                    if (xhr.readyState === 4) {

                                        // Allow onerror to be called first,
                                        // but that will not handle a native abort
                                        // Also, save errorCallback to a variable
                                        // as xhr.onerror cannot be accessed
                                        window.setTimeout(function () {
                                            if (callback) {
                                                errorCallback();
                                            }
                                        });
                                    }
                                };
                            }

                            // Create the abort callback
                            callback = callback("abort");

                            try {

                                // Do send the request (this may raise an exception)
                                xhr.send(options.hasContent && options.data || null);
                            } catch (e) {

                                // #14683: Only rethrow if this hasn't been notified as an error yet
                                if (callback) {
                                    throw e;
                                }
                            }
                        },

                        abort: function () {
                            if (callback) {
                                callback();
                            }
                        }
                    };
                }
            });




            // Install script dataType
            jQuery.ajaxSetup({
                accepts: {
                    script: "text/javascript, application/javascript, " +
                        "application/ecmascript, application/x-ecmascript"
                },
                contents: {
                    script: /\b(?:java|ecma)script\b/
                },
                converters: {
                    "text script": function (text) {
                        jQuery.globalEval(text);
                        return text;
                    }
                }
            });

            // Handle cache's special case and crossDomain
            jQuery.ajaxPrefilter("script", function (s) {
                if (s.cache === undefined) {
                    s.cache = false;
                }
                if (s.crossDomain) {
                    s.type = "GET";
                }
            });

            // Bind script tag hack transport
            jQuery.ajaxTransport("script", function (s) {

                // This transport only deals with cross domain requests
                if (s.crossDomain) {
                    var script, callback;
                    return {
                        send: function (_, complete) {
                            script = jQuery("<script>").prop({
                                charset: s.scriptCharset,
                                src: s.url
                            }).on(
                                "load error",
                                callback = function (evt) {
                                    script.remove();
                                    callback = null;
                                    if (evt) {
                                        complete(evt.type === "error" ? 404 : 200, evt.type);
                                    }
                                }
                            );

                            // Use native DOM manipulation to avoid our domManip AJAX trickery
                            document.head.appendChild(script[0]);
                        },
                        abort: function () {
                            if (callback) {
                                callback();
                            }
                        }
                    };
                }
            });




            var oldCallbacks = [],
                rjsonp = /(=)\?(?=&|$)|\?\?/;

            // Default jsonp settings
            jQuery.ajaxSetup({
                jsonp: "callback",
                jsonpCallback: function () {
                    var callback = oldCallbacks.pop() || (jQuery.expando + "_" + (nonce++));
                    this[callback] = true;
                    return callback;
                }
            });

            // Detect, normalize options and install callbacks for jsonp requests
            jQuery.ajaxPrefilter("json jsonp", function (s, originalSettings, jqXHR) {

                var callbackName, overwritten, responseContainer,
                    jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ?
                        "url" :
                        typeof s.data === "string" &&
                        (s.contentType || "")
                            .indexOf("application/x-www-form-urlencoded") === 0 &&
                        rjsonp.test(s.data) && "data"
                    );

                // Handle iff the expected data type is "jsonp" or we have a parameter to set
                if (jsonProp || s.dataTypes[0] === "jsonp") {

                    // Get callback name, remembering preexisting value associated with it
                    callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ?
                        s.jsonpCallback() :
                        s.jsonpCallback;

                    // Insert callback into url or form data
                    if (jsonProp) {
                        s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
                    } else if (s.jsonp !== false) {
                        s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
                    }

                    // Use data converter to retrieve json after script execution
                    s.converters["script json"] = function () {
                        if (!responseContainer) {
                            jQuery.error(callbackName + " was not called");
                        }
                        return responseContainer[0];
                    };

                    // Force json dataType
                    s.dataTypes[0] = "json";

                    // Install callback
                    overwritten = window[callbackName];
                    window[callbackName] = function () {
                        responseContainer = arguments;
                    };

                    // Clean-up function (fires after converters)
                    jqXHR.always(function () {

                        // If previous value didn't exist - remove it
                        if (overwritten === undefined) {
                            jQuery(window).removeProp(callbackName);

                            // Otherwise restore preexisting value
                        } else {
                            window[callbackName] = overwritten;
                        }

                        // Save back as free
                        if (s[callbackName]) {

                            // Make sure that re-using the options doesn't screw things around
                            s.jsonpCallback = originalSettings.jsonpCallback;

                            // Save the callback name for future use
                            oldCallbacks.push(callbackName);
                        }

                        // Call if it was a function and we have a response
                        if (responseContainer && jQuery.isFunction(overwritten)) {
                            overwritten(responseContainer[0]);
                        }

                        responseContainer = overwritten = undefined;
                    });

                    // Delegate to script
                    return "script";
                }
            });




            // Argument "data" should be string of html
            // context (optional): If specified, the fragment will be created in this context,
            // defaults to document
            // keepScripts (optional): If true, will include scripts passed in the html string
            jQuery.parseHTML = function (data, context, keepScripts) {
                if (!data || typeof data !== "string") {
                    return null;
                }
                if (typeof context === "boolean") {
                    keepScripts = context;
                    context = false;
                }
                context = context || document;

                var parsed = rsingleTag.exec(data),
                    scripts = !keepScripts && [];

                // Single tag
                if (parsed) {
                    return [context.createElement(parsed[1])];
                }

                parsed = buildFragment([data], context, scripts);

                if (scripts && scripts.length) {
                    jQuery(scripts).remove();
                }

                return jQuery.merge([], parsed.childNodes);
            };


            // Keep a copy of the old load method
            var _load = jQuery.fn.load;

            /**
             * Load a url into a page
             */
            jQuery.fn.load = function (url, params, callback) {
                if (typeof url !== "string" && _load) {
                    return _load.apply(this, arguments);
                }

                var selector, type, response,
                    self = this,
                    off = url.indexOf(" ");

                if (off > -1) {
                    selector = jQuery.trim(url.slice(off));
                    url = url.slice(0, off);
                }

                // If it's a function
                if (jQuery.isFunction(params)) {

                    // We assume that it's the callback
                    callback = params;
                    params = undefined;

                    // Otherwise, build a param string
                } else if (params && typeof params === "object") {
                    type = "POST";
                }

                // If we have elements to modify, make the request
                if (self.length > 0) {
                    jQuery.ajax({
                        url: url,

                        // If "type" variable is undefined, then "GET" method will be used.
                        // Make value of this field explicit since
                        // user can override it through ajaxSetup method
                        type: type || "GET",
                        dataType: "html",
                        data: params
                    }).done(function (responseText) {

                        // Save response for use in complete callback
                        response = arguments;

                        self.html(selector ?

                            // If a selector was specified, locate the right elements in a dummy div
                            // Exclude scripts to avoid IE 'Permission Denied' errors
                            jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) :

                            // Otherwise use the full result
                            responseText);

                        // If the request succeeds, this function gets "data", "status", "jqXHR"
                        // but they are ignored because response was set above.
                        // If it fails, this function gets "jqXHR", "status", "error"
                    }).always(callback && function (jqXHR, status) {
                        self.each(function () {
                            callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
                        });
                    });
                }

                return this;
            };




            // Attach a bunch of functions for handling common AJAX events
            jQuery.each([
                "ajaxStart",
                "ajaxStop",
                "ajaxComplete",
                "ajaxError",
                "ajaxSuccess",
                "ajaxSend"
            ], function (i, type) {
                jQuery.fn[type] = function (fn) {
                    return this.on(type, fn);
                };
            });




            jQuery.expr.filters.animated = function (elem) {
                return jQuery.grep(jQuery.timers, function (fn) {
                    return elem === fn.elem;
                }).length;
            };




            /**
             * Gets a window from an element
             */
            function getWindow(elem) {
                return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;
            }

            jQuery.offset = {
                setOffset: function (elem, options, i) {
                    var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
                        position = jQuery.css(elem, "position"),
                        curElem = jQuery(elem),
                        props = {};

                    // Set position first, in-case top/left are set even on static elem
                    if (position === "static") {
                        elem.style.position = "relative";
                    }

                    curOffset = curElem.offset();
                    curCSSTop = jQuery.css(elem, "top");
                    curCSSLeft = jQuery.css(elem, "left");
                    calculatePosition = (position === "absolute" || position === "fixed") &&
                        (curCSSTop + curCSSLeft).indexOf("auto") > -1;

                    // Need to be able to calculate position if either
                    // top or left is auto and position is either absolute or fixed
                    if (calculatePosition) {
                        curPosition = curElem.position();
                        curTop = curPosition.top;
                        curLeft = curPosition.left;

                    } else {
                        curTop = parseFloat(curCSSTop) || 0;
                        curLeft = parseFloat(curCSSLeft) || 0;
                    }

                    if (jQuery.isFunction(options)) {

                        // Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
                        options = options.call(elem, i, jQuery.extend({}, curOffset));
                    }

                    if (options.top != null) {
                        props.top = (options.top - curOffset.top) + curTop;
                    }
                    if (options.left != null) {
                        props.left = (options.left - curOffset.left) + curLeft;
                    }

                    if ("using" in options) {
                        options.using.call(elem, props);

                    } else {
                        curElem.css(props);
                    }
                }
            };

            jQuery.fn.extend({
                offset: function (options) {
                    if (arguments.length) {
                        return options === undefined ?
                            this :
                            this.each(function (i) {
                                jQuery.offset.setOffset(this, options, i);
                            });
                    }

                    var docElem, win,
                        elem = this[0],
                        box = { top: 0, left: 0 },
                        doc = elem && elem.ownerDocument;

                    if (!doc) {
                        return;
                    }

                    docElem = doc.documentElement;

                    // Make sure it's not a disconnected DOM node
                    if (!jQuery.contains(docElem, elem)) {
                        return box;
                    }

                    box = elem.getBoundingClientRect();
                    win = getWindow(doc);
                    return {
                        top: box.top + win.pageYOffset - docElem.clientTop,
                        left: box.left + win.pageXOffset - docElem.clientLeft
                    };
                },

                position: function () {
                    if (!this[0]) {
                        return;
                    }

                    var offsetParent, offset,
                        elem = this[0],
                        parentOffset = { top: 0, left: 0 };

                    // Fixed elements are offset from window (parentOffset = {top:0, left: 0},
                    // because it is its only offset parent
                    if (jQuery.css(elem, "position") === "fixed") {

                        // Assume getBoundingClientRect is there when computed position is fixed
                        offset = elem.getBoundingClientRect();

                    } else {

                        // Get *real* offsetParent
                        offsetParent = this.offsetParent();

                        // Get correct offsets
                        offset = this.offset();
                        if (!jQuery.nodeName(offsetParent[0], "html")) {
                            parentOffset = offsetParent.offset();
                        }

                        // Add offsetParent borders
                        parentOffset.top += jQuery.css(offsetParent[0], "borderTopWidth", true);
                        parentOffset.left += jQuery.css(offsetParent[0], "borderLeftWidth", true);
                    }

                    // Subtract parent offsets and element margins
                    return {
                        top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
                        left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
                    };
                },

                // This method will return documentElement in the following cases:
                // 1) For the element inside the iframe without offsetParent, this method will return
                //    documentElement of the parent window
                // 2) For the hidden or detached element
                // 3) For body or html element, i.e. in case of the html node - it will return itself
                //
                // but those exceptions were never presented as a real life use-cases
                // and might be considered as more preferable results.
                //
                // This logic, however, is not guaranteed and can change at any point in the future
                offsetParent: function () {
                    return this.map(function () {
                        var offsetParent = this.offsetParent;

                        while (offsetParent && jQuery.css(offsetParent, "position") === "static") {
                            offsetParent = offsetParent.offsetParent;
                        }

                        return offsetParent || documentElement;
                    });
                }
            });

            // Create scrollLeft and scrollTop methods
            jQuery.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function (method, prop) {
                var top = "pageYOffset" === prop;

                jQuery.fn[method] = function (val) {
                    return access(this, function (elem, method, val) {
                        var win = getWindow(elem);

                        if (val === undefined) {
                            return win ? win[prop] : elem[method];
                        }

                        if (win) {
                            win.scrollTo(
                                !top ? val : win.pageXOffset,
                                top ? val : win.pageYOffset
                            );

                        } else {
                            elem[method] = val;
                        }
                    }, method, val, arguments.length);
                };
            });

            // Support: Safari<7-8+, Chrome<37-44+
            // Add the top/left cssHooks using jQuery.fn.position
            // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
            // Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280
            // getComputedStyle returns percent when specified for top/left/bottom/right;
            // rather than make the css module depend on the offset module, just check for it here
            jQuery.each(["top", "left"], function (i, prop) {
                jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition,
                    function (elem, computed) {
                        if (computed) {
                            computed = curCSS(elem, prop);

                            // If curCSS returns percentage, fallback to offset
                            return rnumnonpx.test(computed) ?
                                jQuery(elem).position()[prop] + "px" :
                                computed;
                        }
                    }
                );
            });


            // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
            jQuery.each({ Height: "height", Width: "width" }, function (name, type) {
                jQuery.each({ padding: "inner" + name, content: type, "": "outer" + name },
                    function (defaultExtra, funcName) {

                        // Margin is only for outerHeight, outerWidth
                        jQuery.fn[funcName] = function (margin, value) {
                            var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
                                extra = defaultExtra || (margin === true || value === true ? "margin" : "border");

                            return access(this, function (elem, type, value) {
                                var doc;

                                if (jQuery.isWindow(elem)) {

                                    // As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
                                    // isn't a whole lot we can do. See pull request at this URL for discussion:
                                    // https://github.com/jquery/jquery/pull/764
                                    return elem.document.documentElement["client" + name];
                                }

                                // Get document width or height
                                if (elem.nodeType === 9) {
                                    doc = elem.documentElement;

                                    // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
                                    // whichever is greatest
                                    return Math.max(
                                        elem.body["scroll" + name], doc["scroll" + name],
                                        elem.body["offset" + name], doc["offset" + name],
                                        doc["client" + name]
                                    );
                                }

                                return value === undefined ?

                                    // Get width or height on the element, requesting but not forcing parseFloat
                                    jQuery.css(elem, type, extra) :

                                    // Set width or height on the element
                                    jQuery.style(elem, type, value, extra);
                            }, type, chainable ? margin : undefined, chainable, null);
                        };
                    });
            });


            jQuery.fn.extend({

                bind: function (types, data, fn) {
                    return this.on(types, null, data, fn);
                },
                unbind: function (types, fn) {
                    return this.off(types, null, fn);
                },

                delegate: function (selector, types, data, fn) {
                    return this.on(types, selector, data, fn);
                },
                undelegate: function (selector, types, fn) {

                    // ( namespace ) or ( selector, types [, fn] )
                    return arguments.length === 1 ?
                        this.off(selector, "**") :
                        this.off(types, selector || "**", fn);
                },
                size: function () {
                    return this.length;
                }
            });

            jQuery.fn.andSelf = jQuery.fn.addBack;




            // Register as a named AMD module, since jQuery can be concatenated with other
            // files that may use define, but not via a proper concatenation script that
            // understands anonymous AMD modules. A named AMD is safest and most robust
            // way to register. Lowercase jquery is used because AMD module names are
            // derived from file names, and jQuery is normally delivered in a lowercase
            // file name. Do this after creating the global so that if an AMD module wants
            // to call noConflict to hide this version of jQuery, it will work.

            // Note that for maximum portability, libraries that are not jQuery should
            // declare themselves as anonymous modules, and avoid setting a global if an
            // AMD loader is present. jQuery is a special case. For more information, see
            // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

            if (typeof define === "function" && define.amd) {
                define("jquery", [], function () {
                    return jQuery;
                });
            }



            var

                // Map over jQuery in case of overwrite
                _jQuery = window.jQuery,

                // Map over the $ in case of overwrite
                _$ = window.$;

            jQuery.noConflict = function (deep) {
                if (window.$ === jQuery) {
                    window.$ = _$;
                }

                if (deep && window.jQuery === jQuery) {
                    window.jQuery = _jQuery;
                }

                return jQuery;
            };

            // Expose jQuery and $ identifiers, even in AMD
            // (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
            // and CommonJS for browser emulators (#13566)
            if (!noGlobal) {
                window.jQuery = window.$ = jQuery;
            }

            return jQuery;
        }));

    }, {}], 291: [function (require, module, exports) {
        var createFindIndex = require('../internal/createFindIndex');

        /**
         * This method is like `_.find` except that it returns the index of the first
         * element `predicate` returns truthy for instead of the element itself.
         *
         * If a property name is provided for `predicate` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `predicate` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to search.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `predicate`.
         * @returns {number} Returns the index of the found element, else `-1`.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'active': false },
         *   { 'user': 'fred',    'active': false },
         *   { 'user': 'pebbles', 'active': true }
         * ];
         *
         * _.findIndex(users, function(chr) {
         *   return chr.user == 'barney';
         * });
         * // => 0
         *
         * // using the `_.matches` callback shorthand
         * _.findIndex(users, { 'user': 'fred', 'active': false });
         * // => 1
         *
         * // using the `_.matchesProperty` callback shorthand
         * _.findIndex(users, 'active', false);
         * // => 0
         *
         * // using the `_.property` callback shorthand
         * _.findIndex(users, 'active');
         * // => 2
         */
        var findIndex = createFindIndex();

        module.exports = findIndex;

    }, { "../internal/createFindIndex": 383 }], 292: [function (require, module, exports) {
        var baseFlatten = require('../internal/baseFlatten'),
            isIterateeCall = require('../internal/isIterateeCall');

        /**
         * Flattens a nested array. If `isDeep` is `true` the array is recursively
         * flattened, otherwise it's only flattened a single level.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to flatten.
         * @param {boolean} [isDeep] Specify a deep flatten.
         * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
         * @returns {Array} Returns the new flattened array.
         * @example
         *
         * _.flatten([1, [2, 3, [4]]]);
         * // => [1, 2, 3, [4]]
         *
         * // using `isDeep`
         * _.flatten([1, [2, 3, [4]]], true);
         * // => [1, 2, 3, 4]
         */
        function flatten(array, isDeep, guard) {
            var length = array ? array.length : 0;
            if (guard && isIterateeCall(array, isDeep, guard)) {
                isDeep = false;
            }
            return length ? baseFlatten(array, isDeep) : [];
        }

        module.exports = flatten;

    }, { "../internal/baseFlatten": 343, "../internal/isIterateeCall": 403 }], 293: [function (require, module, exports) {
        var baseIndexOf = require('../internal/baseIndexOf'),
            cacheIndexOf = require('../internal/cacheIndexOf'),
            createCache = require('../internal/createCache'),
            isArrayLike = require('../internal/isArrayLike'),
            restParam = require('../function/restParam');

        /**
         * Creates an array of unique values that are included in all of the provided
         * arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
         * for equality comparisons.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @returns {Array} Returns the new array of shared values.
         * @example
         * _.intersection([1, 2], [4, 2], [2, 1]);
         * // => [2]
         */
        var intersection = restParam(function (arrays) {
            var othLength = arrays.length,
                othIndex = othLength,
                caches = Array(length),
                indexOf = baseIndexOf,
                isCommon = true,
                result = [];

            while (othIndex--) {
                var value = arrays[othIndex] = isArrayLike(value = arrays[othIndex]) ? value : [];
                caches[othIndex] = (isCommon && value.length >= 120) ? createCache(othIndex && value) : null;
            }
            var array = arrays[0],
                index = -1,
                length = array ? array.length : 0,
                seen = caches[0];

            outer:
            while (++index < length) {
                value = array[index];
                if ((seen ? cacheIndexOf(seen, value) : indexOf(result, value, 0)) < 0) {
                    var othIndex = othLength;
                    while (--othIndex) {
                        var cache = caches[othIndex];
                        if ((cache ? cacheIndexOf(cache, value) : indexOf(arrays[othIndex], value, 0)) < 0) {
                            continue outer;
                        }
                    }
                    if (seen) {
                        seen.push(value);
                    }
                    result.push(value);
                }
            }
            return result;
        });

        module.exports = intersection;

    }, { "../function/restParam": 316, "../internal/baseIndexOf": 348, "../internal/cacheIndexOf": 370, "../internal/createCache": 380, "../internal/isArrayLike": 401 }], 294: [function (require, module, exports) {
        /**
         * Gets the last element of `array`.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to query.
         * @returns {*} Returns the last element of `array`.
         * @example
         *
         * _.last([1, 2, 3]);
         * // => 3
         */
        function last(array) {
            var length = array ? array.length : 0;
            return length ? array[length - 1] : undefined;
        }

        module.exports = last;

    }, {}], 295: [function (require, module, exports) {
        var baseFlatten = require('../internal/baseFlatten'),
            baseUniq = require('../internal/baseUniq'),
            restParam = require('../function/restParam');

        /**
         * Creates an array of unique values, in order, from all of the provided arrays
         * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
         * for equality comparisons.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @returns {Array} Returns the new array of combined values.
         * @example
         *
         * _.union([1, 2], [4, 2], [2, 1]);
         * // => [1, 2, 4]
         */
        var union = restParam(function (arrays) {
            return baseUniq(baseFlatten(arrays, false, true));
        });

        module.exports = union;

    }, { "../function/restParam": 316, "../internal/baseFlatten": 343, "../internal/baseUniq": 366 }], 296: [function (require, module, exports) {
        var baseCallback = require('../internal/baseCallback'),
            baseUniq = require('../internal/baseUniq'),
            isIterateeCall = require('../internal/isIterateeCall'),
            sortedUniq = require('../internal/sortedUniq');

        /**
         * Creates a duplicate-free version of an array, using
         * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
         * for equality comparisons, in which only the first occurence of each element
         * is kept. Providing `true` for `isSorted` performs a faster search algorithm
         * for sorted arrays. If an iteratee function is provided it's invoked for
         * each element in the array to generate the criterion by which uniqueness
         * is computed. The `iteratee` is bound to `thisArg` and invoked with three
         * arguments: (value, index, array).
         *
         * If a property name is provided for `iteratee` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `iteratee` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @alias unique
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {boolean} [isSorted] Specify the array is sorted.
         * @param {Function|Object|string} [iteratee] The function invoked per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {Array} Returns the new duplicate-value-free array.
         * @example
         *
         * _.uniq([2, 1, 2]);
         * // => [2, 1]
         *
         * // using `isSorted`
         * _.uniq([1, 1, 2], true);
         * // => [1, 2]
         *
         * // using an iteratee function
         * _.uniq([1, 2.5, 1.5, 2], function(n) {
         *   return this.floor(n);
         * }, Math);
         * // => [1, 2.5]
         *
         * // using the `_.property` callback shorthand
         * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
         * // => [{ 'x': 1 }, { 'x': 2 }]
         */
        function uniq(array, isSorted, iteratee, thisArg) {
            var length = array ? array.length : 0;
            if (!length) {
                return [];
            }
            if (isSorted != null && typeof isSorted != 'boolean') {
                thisArg = iteratee;
                iteratee = isIterateeCall(array, isSorted, thisArg) ? undefined : isSorted;
                isSorted = false;
            }
            iteratee = iteratee == null ? iteratee : baseCallback(iteratee, thisArg, 3);
            return (isSorted)
                ? sortedUniq(array, iteratee)
                : baseUniq(array, iteratee);
        }

        module.exports = uniq;

    }, { "../internal/baseCallback": 331, "../internal/baseUniq": 366, "../internal/isIterateeCall": 403, "../internal/sortedUniq": 418 }], 297: [function (require, module, exports) {
        module.exports = require('./uniq');

    }, { "./uniq": 296 }], 298: [function (require, module, exports) {
        var baseDifference = require('../internal/baseDifference'),
            isArrayLike = require('../internal/isArrayLike'),
            restParam = require('../function/restParam');

        /**
         * Creates an array excluding all provided values using
         * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
         * for equality comparisons.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to filter.
         * @param {...*} [values] The values to exclude.
         * @returns {Array} Returns the new array of filtered values.
         * @example
         *
         * _.without([1, 2, 1, 3], 1, 2);
         * // => [3]
         */
        var without = restParam(function (array, values) {
            return isArrayLike(array)
                ? baseDifference(array, values)
                : [];
        });

        module.exports = without;

    }, { "../function/restParam": 316, "../internal/baseDifference": 337, "../internal/isArrayLike": 401 }], 299: [function (require, module, exports) {
        var LazyWrapper = require('../internal/LazyWrapper'),
            LodashWrapper = require('../internal/LodashWrapper'),
            baseLodash = require('../internal/baseLodash'),
            isArray = require('../lang/isArray'),
            isObjectLike = require('../internal/isObjectLike'),
            wrapperClone = require('../internal/wrapperClone');

        /** Used for native method references. */
        var objectProto = Object.prototype;

        /** Used to check objects for own properties. */
        var hasOwnProperty = objectProto.hasOwnProperty;

        /**
         * Creates a `lodash` object which wraps `value` to enable implicit chaining.
         * Methods that operate on and return arrays, collections, and functions can
         * be chained together. Methods that retrieve a single value or may return a
         * primitive value will automatically end the chain returning the unwrapped
         * value. Explicit chaining may be enabled using `_.chain`. The execution of
         * chained methods is lazy, that is, execution is deferred until `_#value`
         * is implicitly or explicitly called.
         *
         * Lazy evaluation allows several methods to support shortcut fusion. Shortcut
         * fusion is an optimization strategy which merge iteratee calls; this can help
         * to avoid the creation of intermediate data structures and greatly reduce the
         * number of iteratee executions.
         *
         * Chaining is supported in custom builds as long as the `_#value` method is
         * directly or indirectly included in the build.
         *
         * In addition to lodash methods, wrappers have `Array` and `String` methods.
         *
         * The wrapper `Array` methods are:
         * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`,
         * `splice`, and `unshift`
         *
         * The wrapper `String` methods are:
         * `replace` and `split`
         *
         * The wrapper methods that support shortcut fusion are:
         * `compact`, `drop`, `dropRight`, `dropRightWhile`, `dropWhile`, `filter`,
         * `first`, `initial`, `last`, `map`, `pluck`, `reject`, `rest`, `reverse`,
         * `slice`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, `toArray`,
         * and `where`
         *
         * The chainable wrapper methods are:
         * `after`, `ary`, `assign`, `at`, `before`, `bind`, `bindAll`, `bindKey`,
         * `callback`, `chain`, `chunk`, `commit`, `compact`, `concat`, `constant`,
         * `countBy`, `create`, `curry`, `debounce`, `defaults`, `defaultsDeep`,
         * `defer`, `delay`, `difference`, `drop`, `dropRight`, `dropRightWhile`,
         * `dropWhile`, `fill`, `filter`, `flatten`, `flattenDeep`, `flow`, `flowRight`,
         * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
         * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
         * `invoke`, `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`,
         * `matchesProperty`, `memoize`, `merge`, `method`, `methodOf`, `mixin`,
         * `modArgs`, `negate`, `omit`, `once`, `pairs`, `partial`, `partialRight`,
         * `partition`, `pick`, `plant`, `pluck`, `property`, `propertyOf`, `pull`,
         * `pullAt`, `push`, `range`, `rearg`, `reject`, `remove`, `rest`, `restParam`,
         * `reverse`, `set`, `shuffle`, `slice`, `sort`, `sortBy`, `sortByAll`,
         * `sortByOrder`, `splice`, `spread`, `take`, `takeRight`, `takeRightWhile`,
         * `takeWhile`, `tap`, `throttle`, `thru`, `times`, `toArray`, `toPlainObject`,
         * `transform`, `union`, `uniq`, `unshift`, `unzip`, `unzipWith`, `values`,
         * `valuesIn`, `where`, `without`, `wrap`, `xor`, `zip`, `zipObject`, `zipWith`
         *
         * The wrapper methods that are **not** chainable by default are:
         * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clone`, `cloneDeep`,
         * `deburr`, `endsWith`, `escape`, `escapeRegExp`, `every`, `find`, `findIndex`,
         * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `findWhere`, `first`,
         * `floor`, `get`, `gt`, `gte`, `has`, `identity`, `includes`, `indexOf`,
         * `inRange`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
         * `isEmpty`, `isEqual`, `isError`, `isFinite` `isFunction`, `isMatch`,
         * `isNative`, `isNaN`, `isNull`, `isNumber`, `isObject`, `isPlainObject`,
         * `isRegExp`, `isString`, `isUndefined`, `isTypedArray`, `join`, `kebabCase`,
         * `last`, `lastIndexOf`, `lt`, `lte`, `max`, `min`, `noConflict`, `noop`,
         * `now`, `pad`, `padLeft`, `padRight`, `parseInt`, `pop`, `random`, `reduce`,
         * `reduceRight`, `repeat`, `result`, `round`, `runInContext`, `shift`, `size`,
         * `snakeCase`, `some`, `sortedIndex`, `sortedLastIndex`, `startCase`,
         * `startsWith`, `sum`, `template`, `trim`, `trimLeft`, `trimRight`, `trunc`,
         * `unescape`, `uniqueId`, `value`, and `words`
         *
         * The wrapper method `sample` will return a wrapped value when `n` is provided,
         * otherwise an unwrapped value is returned.
         *
         * @name _
         * @constructor
         * @category Chain
         * @param {*} value The value to wrap in a `lodash` instance.
         * @returns {Object} Returns the new `lodash` wrapper instance.
         * @example
         *
         * var wrapped = _([1, 2, 3]);
         *
         * // returns an unwrapped value
         * wrapped.reduce(function(total, n) {
         *   return total + n;
         * });
         * // => 6
         *
         * // returns a wrapped value
         * var squares = wrapped.map(function(n) {
         *   return n * n;
         * });
         *
         * _.isArray(squares);
         * // => false
         *
         * _.isArray(squares.value());
         * // => true
         */
        function lodash(value) {
            if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
                if (value instanceof LodashWrapper) {
                    return value;
                }
                if (hasOwnProperty.call(value, '__chain__') && hasOwnProperty.call(value, '__wrapped__')) {
                    return wrapperClone(value);
                }
            }
            return new LodashWrapper(value);
        }

        // Ensure wrappers are instances of `baseLodash`.
        lodash.prototype = baseLodash.prototype;

        module.exports = lodash;

    }, { "../internal/LazyWrapper": 318, "../internal/LodashWrapper": 319, "../internal/baseLodash": 352, "../internal/isObjectLike": 407, "../internal/wrapperClone": 421, "../lang/isArray": 424 }], 300: [function (require, module, exports) {
        module.exports = require('./some');

    }, { "./some": 310 }], 301: [function (require, module, exports) {
        var arrayEvery = require('../internal/arrayEvery'),
            baseCallback = require('../internal/baseCallback'),
            baseEvery = require('../internal/baseEvery'),
            isArray = require('../lang/isArray'),
            isIterateeCall = require('../internal/isIterateeCall');

        /**
         * Checks if `predicate` returns truthy for **all** elements of `collection`.
         * The predicate is bound to `thisArg` and invoked with three arguments:
         * (value, index|key, collection).
         *
         * If a property name is provided for `predicate` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `predicate` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @alias all
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `predicate`.
         * @returns {boolean} Returns `true` if all elements pass the predicate check,
         *  else `false`.
         * @example
         *
         * _.every([true, 1, null, 'yes'], Boolean);
         * // => false
         *
         * var users = [
         *   { 'user': 'barney', 'active': false },
         *   { 'user': 'fred',   'active': false }
         * ];
         *
         * // using the `_.matches` callback shorthand
         * _.every(users, { 'user': 'barney', 'active': false });
         * // => false
         *
         * // using the `_.matchesProperty` callback shorthand
         * _.every(users, 'active', false);
         * // => true
         *
         * // using the `_.property` callback shorthand
         * _.every(users, 'active');
         * // => false
         */
        function every(collection, predicate, thisArg) {
            var func = isArray(collection) ? arrayEvery : baseEvery;
            if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
                predicate = undefined;
            }
            if (typeof predicate != 'function' || thisArg !== undefined) {
                predicate = baseCallback(predicate, thisArg, 3);
            }
            return func(collection, predicate);
        }

        module.exports = every;

    }, { "../internal/arrayEvery": 323, "../internal/baseCallback": 331, "../internal/baseEvery": 339, "../internal/isIterateeCall": 403, "../lang/isArray": 424 }], 302: [function (require, module, exports) {
        var arrayFilter = require('../internal/arrayFilter'),
            baseCallback = require('../internal/baseCallback'),
            baseFilter = require('../internal/baseFilter'),
            isArray = require('../lang/isArray');

        /**
         * Iterates over elements of `collection`, returning an array of all elements
         * `predicate` returns truthy for. The predicate is bound to `thisArg` and
         * invoked with three arguments: (value, index|key, collection).
         *
         * If a property name is provided for `predicate` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `predicate` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @alias select
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `predicate`.
         * @returns {Array} Returns the new filtered array.
         * @example
         *
         * _.filter([4, 5, 6], function(n) {
         *   return n % 2 == 0;
         * });
         * // => [4, 6]
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36, 'active': true },
         *   { 'user': 'fred',   'age': 40, 'active': false }
         * ];
         *
         * // using the `_.matches` callback shorthand
         * _.pluck(_.filter(users, { 'age': 36, 'active': true }), 'user');
         * // => ['barney']
         *
         * // using the `_.matchesProperty` callback shorthand
         * _.pluck(_.filter(users, 'active', false), 'user');
         * // => ['fred']
         *
         * // using the `_.property` callback shorthand
         * _.pluck(_.filter(users, 'active'), 'user');
         * // => ['barney']
         */
        function filter(collection, predicate, thisArg) {
            var func = isArray(collection) ? arrayFilter : baseFilter;
            predicate = baseCallback(predicate, thisArg, 3);
            return func(collection, predicate);
        }

        module.exports = filter;

    }, { "../internal/arrayFilter": 324, "../internal/baseCallback": 331, "../internal/baseFilter": 340, "../lang/isArray": 424 }], 303: [function (require, module, exports) {
        var baseEach = require('../internal/baseEach'),
            createFind = require('../internal/createFind');

        /**
         * Iterates over elements of `collection`, returning the first element
         * `predicate` returns truthy for. The predicate is bound to `thisArg` and
         * invoked with three arguments: (value, index|key, collection).
         *
         * If a property name is provided for `predicate` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `predicate` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @alias detect
         * @category Collection
         * @param {Array|Object|string} collection The collection to search.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `predicate`.
         * @returns {*} Returns the matched element, else `undefined`.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'age': 36, 'active': true },
         *   { 'user': 'fred',    'age': 40, 'active': false },
         *   { 'user': 'pebbles', 'age': 1,  'active': true }
         * ];
         *
         * _.result(_.find(users, function(chr) {
         *   return chr.age < 40;
         * }), 'user');
         * // => 'barney'
         *
         * // using the `_.matches` callback shorthand
         * _.result(_.find(users, { 'age': 1, 'active': true }), 'user');
         * // => 'pebbles'
         *
         * // using the `_.matchesProperty` callback shorthand
         * _.result(_.find(users, 'active', false), 'user');
         * // => 'fred'
         *
         * // using the `_.property` callback shorthand
         * _.result(_.find(users, 'active'), 'user');
         * // => 'barney'
         */
        var find = createFind(baseEach);

        module.exports = find;

    }, { "../internal/baseEach": 338, "../internal/createFind": 382 }], 304: [function (require, module, exports) {
        var arrayEach = require('../internal/arrayEach'),
            baseEach = require('../internal/baseEach'),
            createForEach = require('../internal/createForEach');

        /**
         * Iterates over elements of `collection` invoking `iteratee` for each element.
         * The `iteratee` is bound to `thisArg` and invoked with three arguments:
         * (value, index|key, collection). Iteratee functions may exit iteration early
         * by explicitly returning `false`.
         *
         * **Note:** As with other "Collections" methods, objects with a "length" property
         * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
         * may be used for object iteration.
         *
         * @static
         * @memberOf _
         * @alias each
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {Array|Object|string} Returns `collection`.
         * @example
         *
         * _([1, 2]).forEach(function(n) {
         *   console.log(n);
         * }).value();
         * // => logs each value from left to right and returns the array
         *
         * _.forEach({ 'a': 1, 'b': 2 }, function(n, key) {
         *   console.log(n, key);
         * });
         * // => logs each value-key pair and returns the object (iteration order is not guaranteed)
         */
        var forEach = createForEach(arrayEach, baseEach);

        module.exports = forEach;

    }, { "../internal/arrayEach": 322, "../internal/baseEach": 338, "../internal/createForEach": 384 }], 305: [function (require, module, exports) {
        var createAggregator = require('../internal/createAggregator');

        /** Used for native method references. */
        var objectProto = Object.prototype;

        /** Used to check objects for own properties. */
        var hasOwnProperty = objectProto.hasOwnProperty;

        /**
         * Creates an object composed of keys generated from the results of running
         * each element of `collection` through `iteratee`. The corresponding value
         * of each key is an array of the elements responsible for generating the key.
         * The `iteratee` is bound to `thisArg` and invoked with three arguments:
         * (value, index|key, collection).
         *
         * If a property name is provided for `iteratee` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `iteratee` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function|Object|string} [iteratee=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {Object} Returns the composed aggregate object.
         * @example
         *
         * _.groupBy([4.2, 6.1, 6.4], function(n) {
         *   return Math.floor(n);
         * });
         * // => { '4': [4.2], '6': [6.1, 6.4] }
         *
         * _.groupBy([4.2, 6.1, 6.4], function(n) {
         *   return this.floor(n);
         * }, Math);
         * // => { '4': [4.2], '6': [6.1, 6.4] }
         *
         * // using the `_.property` callback shorthand
         * _.groupBy(['one', 'two', 'three'], 'length');
         * // => { '3': ['one', 'two'], '5': ['three'] }
         */
        var groupBy = createAggregator(function (result, value, key) {
            if (hasOwnProperty.call(result, key)) {
                result[key].push(value);
            } else {
                result[key] = [value];
            }
        });

        module.exports = groupBy;

    }, { "../internal/createAggregator": 375 }], 306: [function (require, module, exports) {
        var arrayMap = require('../internal/arrayMap'),
            baseCallback = require('../internal/baseCallback'),
            baseMap = require('../internal/baseMap'),
            isArray = require('../lang/isArray');

        /**
         * Creates an array of values by running each element in `collection` through
         * `iteratee`. The `iteratee` is bound to `thisArg` and invoked with three
         * arguments: (value, index|key, collection).
         *
         * If a property name is provided for `iteratee` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `iteratee` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * Many lodash methods are guarded to work as iteratees for methods like
         * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
         *
         * The guarded methods are:
         * `ary`, `callback`, `chunk`, `clone`, `create`, `curry`, `curryRight`,
         * `drop`, `dropRight`, `every`, `fill`, `flatten`, `invert`, `max`, `min`,
         * `parseInt`, `slice`, `sortBy`, `take`, `takeRight`, `template`, `trim`,
         * `trimLeft`, `trimRight`, `trunc`, `random`, `range`, `sample`, `some`,
         * `sum`, `uniq`, and `words`
         *
         * @static
         * @memberOf _
         * @alias collect
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function|Object|string} [iteratee=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {Array} Returns the new mapped array.
         * @example
         *
         * function timesThree(n) {
         *   return n * 3;
         * }
         *
         * _.map([1, 2], timesThree);
         * // => [3, 6]
         *
         * _.map({ 'a': 1, 'b': 2 }, timesThree);
         * // => [3, 6] (iteration order is not guaranteed)
         *
         * var users = [
         *   { 'user': 'barney' },
         *   { 'user': 'fred' }
         * ];
         *
         * // using the `_.property` callback shorthand
         * _.map(users, 'user');
         * // => ['barney', 'fred']
         */
        function map(collection, iteratee, thisArg) {
            var func = isArray(collection) ? arrayMap : baseMap;
            iteratee = baseCallback(iteratee, thisArg, 3);
            return func(collection, iteratee);
        }

        module.exports = map;

    }, { "../internal/arrayMap": 325, "../internal/baseCallback": 331, "../internal/baseMap": 353, "../lang/isArray": 424 }], 307: [function (require, module, exports) {
        var arrayReduce = require('../internal/arrayReduce'),
            baseEach = require('../internal/baseEach'),
            createReduce = require('../internal/createReduce');

        /**
         * Reduces `collection` to a value which is the accumulated result of running
         * each element in `collection` through `iteratee`, where each successive
         * invocation is supplied the return value of the previous. If `accumulator`
         * is not provided the first element of `collection` is used as the initial
         * value. The `iteratee` is bound to `thisArg` and invoked with four arguments:
         * (accumulator, value, index|key, collection).
         *
         * Many lodash methods are guarded to work as iteratees for methods like
         * `_.reduce`, `_.reduceRight`, and `_.transform`.
         *
         * The guarded methods are:
         * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `sortByAll`,
         * and `sortByOrder`
         *
         * @static
         * @memberOf _
         * @alias foldl, inject
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @param {*} [accumulator] The initial value.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {*} Returns the accumulated value.
         * @example
         *
         * _.reduce([1, 2], function(total, n) {
         *   return total + n;
         * });
         * // => 3
         *
         * _.reduce({ 'a': 1, 'b': 2 }, function(result, n, key) {
         *   result[key] = n * 3;
         *   return result;
         * }, {});
         * // => { 'a': 3, 'b': 6 } (iteration order is not guaranteed)
         */
        var reduce = createReduce(arrayReduce, baseEach);

        module.exports = reduce;

    }, { "../internal/arrayReduce": 327, "../internal/baseEach": 338, "../internal/createReduce": 387 }], 308: [function (require, module, exports) {
        var arrayFilter = require('../internal/arrayFilter'),
            baseCallback = require('../internal/baseCallback'),
            baseFilter = require('../internal/baseFilter'),
            isArray = require('../lang/isArray');

        /**
         * The opposite of `_.filter`; this method returns the elements of `collection`
         * that `predicate` does **not** return truthy for.
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `predicate`.
         * @returns {Array} Returns the new filtered array.
         * @example
         *
         * _.reject([1, 2, 3, 4], function(n) {
         *   return n % 2 == 0;
         * });
         * // => [1, 3]
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36, 'active': false },
         *   { 'user': 'fred',   'age': 40, 'active': true }
         * ];
         *
         * // using the `_.matches` callback shorthand
         * _.pluck(_.reject(users, { 'age': 40, 'active': true }), 'user');
         * // => ['barney']
         *
         * // using the `_.matchesProperty` callback shorthand
         * _.pluck(_.reject(users, 'active', false), 'user');
         * // => ['fred']
         *
         * // using the `_.property` callback shorthand
         * _.pluck(_.reject(users, 'active'), 'user');
         * // => ['barney']
         */
        function reject(collection, predicate, thisArg) {
            var func = isArray(collection) ? arrayFilter : baseFilter;
            predicate = baseCallback(predicate, thisArg, 3);
            return func(collection, function (value, index, collection) {
                return !predicate(value, index, collection);
            });
        }

        module.exports = reject;

    }, { "../internal/arrayFilter": 324, "../internal/baseCallback": 331, "../internal/baseFilter": 340, "../lang/isArray": 424 }], 309: [function (require, module, exports) {
        var getLength = require('../internal/getLength'),
            isLength = require('../internal/isLength'),
            keys = require('../object/keys');

        /**
         * Gets the size of `collection` by returning its length for array-like
         * values or the number of own enumerable properties for objects.
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object|string} collection The collection to inspect.
         * @returns {number} Returns the size of `collection`.
         * @example
         *
         * _.size([1, 2, 3]);
         * // => 3
         *
         * _.size({ 'a': 1, 'b': 2 });
         * // => 2
         *
         * _.size('pebbles');
         * // => 7
         */
        function size(collection) {
            var length = collection ? getLength(collection) : 0;
            return isLength(length) ? length : keys(collection).length;
        }

        module.exports = size;

    }, { "../internal/getLength": 394, "../internal/isLength": 406, "../object/keys": 435 }], 310: [function (require, module, exports) {
        var arraySome = require('../internal/arraySome'),
            baseCallback = require('../internal/baseCallback'),
            baseSome = require('../internal/baseSome'),
            isArray = require('../lang/isArray'),
            isIterateeCall = require('../internal/isIterateeCall');

        /**
         * Checks if `predicate` returns truthy for **any** element of `collection`.
         * The function returns as soon as it finds a passing value and does not iterate
         * over the entire collection. The predicate is bound to `thisArg` and invoked
         * with three arguments: (value, index|key, collection).
         *
         * If a property name is provided for `predicate` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `predicate` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @alias any
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `predicate`.
         * @returns {boolean} Returns `true` if any element passes the predicate check,
         *  else `false`.
         * @example
         *
         * _.some([null, 0, 'yes', false], Boolean);
         * // => true
         *
         * var users = [
         *   { 'user': 'barney', 'active': true },
         *   { 'user': 'fred',   'active': false }
         * ];
         *
         * // using the `_.matches` callback shorthand
         * _.some(users, { 'user': 'barney', 'active': false });
         * // => false
         *
         * // using the `_.matchesProperty` callback shorthand
         * _.some(users, 'active', false);
         * // => true
         *
         * // using the `_.property` callback shorthand
         * _.some(users, 'active');
         * // => true
         */
        function some(collection, predicate, thisArg) {
            var func = isArray(collection) ? arraySome : baseSome;
            if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
                predicate = undefined;
            }
            if (typeof predicate != 'function' || thisArg !== undefined) {
                predicate = baseCallback(predicate, thisArg, 3);
            }
            return func(collection, predicate);
        }

        module.exports = some;

    }, { "../internal/arraySome": 328, "../internal/baseCallback": 331, "../internal/baseSome": 363, "../internal/isIterateeCall": 403, "../lang/isArray": 424 }], 311: [function (require, module, exports) {
        var baseCallback = require('../internal/baseCallback'),
            baseMap = require('../internal/baseMap'),
            baseSortBy = require('../internal/baseSortBy'),
            compareAscending = require('../internal/compareAscending'),
            isIterateeCall = require('../internal/isIterateeCall');

        /**
         * Creates an array of elements, sorted in ascending order by the results of
         * running each element in a collection through `iteratee`. This method performs
         * a stable sort, that is, it preserves the original sort order of equal elements.
         * The `iteratee` is bound to `thisArg` and invoked with three arguments:
         * (value, index|key, collection).
         *
         * If a property name is provided for `iteratee` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `iteratee` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function|Object|string} [iteratee=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {Array} Returns the new sorted array.
         * @example
         *
         * _.sortBy([1, 2, 3], function(n) {
         *   return Math.sin(n);
         * });
         * // => [3, 1, 2]
         *
         * _.sortBy([1, 2, 3], function(n) {
         *   return this.sin(n);
         * }, Math);
         * // => [3, 1, 2]
         *
         * var users = [
         *   { 'user': 'fred' },
         *   { 'user': 'pebbles' },
         *   { 'user': 'barney' }
         * ];
         *
         * // using the `_.property` callback shorthand
         * _.pluck(_.sortBy(users, 'user'), 'user');
         * // => ['barney', 'fred', 'pebbles']
         */
        function sortBy(collection, iteratee, thisArg) {
            if (collection == null) {
                return [];
            }
            if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
                iteratee = undefined;
            }
            var index = -1;
            iteratee = baseCallback(iteratee, thisArg, 3);

            var result = baseMap(collection, function (value, key, collection) {
                return { 'criteria': iteratee(value, key, collection), 'index': ++index, 'value': value };
            });
            return baseSortBy(result, compareAscending);
        }

        module.exports = sortBy;

    }, { "../internal/baseCallback": 331, "../internal/baseMap": 353, "../internal/baseSortBy": 364, "../internal/compareAscending": 372, "../internal/isIterateeCall": 403 }], 312: [function (require, module, exports) {
        var getNative = require('../internal/getNative');

        /* Native method references for those with the same name as other `lodash` methods. */
        var nativeNow = getNative(Date, 'now');

        /**
         * Gets the number of milliseconds that have elapsed since the Unix epoch
         * (1 January 1970 00:00:00 UTC).
         *
         * @static
         * @memberOf _
         * @category Date
         * @example
         *
         * _.defer(function(stamp) {
         *   console.log(_.now() - stamp);
         * }, _.now());
         * // => logs the number of milliseconds it took for the deferred function to be invoked
         */
        var now = nativeNow || function () {
            return new Date().getTime();
        };

        module.exports = now;

    }, { "../internal/getNative": 396 }], 313: [function (require, module, exports) {
        var createWrapper = require('../internal/createWrapper'),
            replaceHolders = require('../internal/replaceHolders'),
            restParam = require('./restParam');

        /** Used to compose bitmasks for wrapper metadata. */
        var BIND_FLAG = 1,
            PARTIAL_FLAG = 32;

        /**
         * Creates a function that invokes `func` with the `this` binding of `thisArg`
         * and prepends any additional `_.bind` arguments to those provided to the
         * bound function.
         *
         * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
         * may be used as a placeholder for partially applied arguments.
         *
         * **Note:** Unlike native `Function#bind` this method does not set the "length"
         * property of bound functions.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to bind.
         * @param {*} thisArg The `this` binding of `func`.
         * @param {...*} [partials] The arguments to be partially applied.
         * @returns {Function} Returns the new bound function.
         * @example
         *
         * var greet = function(greeting, punctuation) {
         *   return greeting + ' ' + this.user + punctuation;
         * };
         *
         * var object = { 'user': 'fred' };
         *
         * var bound = _.bind(greet, object, 'hi');
         * bound('!');
         * // => 'hi fred!'
         *
         * // using placeholders
         * var bound = _.bind(greet, object, _, '!');
         * bound('hi');
         * // => 'hi fred!'
         */
        var bind = restParam(function (func, thisArg, partials) {
            var bitmask = BIND_FLAG;
            if (partials.length) {
                var holders = replaceHolders(partials, bind.placeholder);
                bitmask |= PARTIAL_FLAG;
            }
            return createWrapper(func, bitmask, thisArg, partials, holders);
        });

        // Assign default placeholders.
        bind.placeholder = {};

        module.exports = bind;

    }, { "../internal/createWrapper": 388, "../internal/replaceHolders": 415, "./restParam": 316 }], 314: [function (require, module, exports) {
        var isObject = require('../lang/isObject'),
            now = require('../date/now');

        /** Used as the `TypeError` message for "Functions" methods. */
        var FUNC_ERROR_TEXT = 'Expected a function';

        /* Native method references for those with the same name as other `lodash` methods. */
        var nativeMax = Math.max;

        /**
         * Creates a debounced function that delays invoking `func` until after `wait`
         * milliseconds have elapsed since the last time the debounced function was
         * invoked. The debounced function comes with a `cancel` method to cancel
         * delayed invocations. Provide an options object to indicate that `func`
         * should be invoked on the leading and/or trailing edge of the `wait` timeout.
         * Subsequent calls to the debounced function return the result of the last
         * `func` invocation.
         *
         * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
         * on the trailing edge of the timeout only if the the debounced function is
         * invoked more than once during the `wait` timeout.
         *
         * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
         * for details over the differences between `_.debounce` and `_.throttle`.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to debounce.
         * @param {number} [wait=0] The number of milliseconds to delay.
         * @param {Object} [options] The options object.
         * @param {boolean} [options.leading=false] Specify invoking on the leading
         *  edge of the timeout.
         * @param {number} [options.maxWait] The maximum time `func` is allowed to be
         *  delayed before it's invoked.
         * @param {boolean} [options.trailing=true] Specify invoking on the trailing
         *  edge of the timeout.
         * @returns {Function} Returns the new debounced function.
         * @example
         *
         * // avoid costly calculations while the window size is in flux
         * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
         *
         * // invoke `sendMail` when the click event is fired, debouncing subsequent calls
         * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
         *   'leading': true,
         *   'trailing': false
         * }));
         *
         * // ensure `batchLog` is invoked once after 1 second of debounced calls
         * var source = new EventSource('/stream');
         * jQuery(source).on('message', _.debounce(batchLog, 250, {
         *   'maxWait': 1000
         * }));
         *
         * // cancel a debounced call
         * var todoChanges = _.debounce(batchLog, 1000);
         * Object.observe(models.todo, todoChanges);
         *
         * Object.observe(models, function(changes) {
         *   if (_.find(changes, { 'user': 'todo', 'type': 'delete'})) {
         *     todoChanges.cancel();
         *   }
         * }, ['delete']);
         *
         * // ...at some point `models.todo` is changed
         * models.todo.completed = true;
         *
         * // ...before 1 second has passed `models.todo` is deleted
         * // which cancels the debounced `todoChanges` call
         * delete models.todo;
         */
        function debounce(func, wait, options) {
            var args,
                maxTimeoutId,
                result,
                stamp,
                thisArg,
                timeoutId,
                trailingCall,
                lastCalled = 0,
                maxWait = false,
                trailing = true;

            if (typeof func != 'function') {
                throw new TypeError(FUNC_ERROR_TEXT);
            }
            wait = wait < 0 ? 0 : (+wait || 0);
            if (options === true) {
                var leading = true;
                trailing = false;
            } else if (isObject(options)) {
                leading = !!options.leading;
                maxWait = 'maxWait' in options && nativeMax(+options.maxWait || 0, wait);
                trailing = 'trailing' in options ? !!options.trailing : trailing;
            }

            function cancel() {
                if (timeoutId) {
                    clearTimeout(timeoutId);
                }
                if (maxTimeoutId) {
                    clearTimeout(maxTimeoutId);
                }
                lastCalled = 0;
                maxTimeoutId = timeoutId = trailingCall = undefined;
            }

            function complete(isCalled, id) {
                if (id) {
                    clearTimeout(id);
                }
                maxTimeoutId = timeoutId = trailingCall = undefined;
                if (isCalled) {
                    lastCalled = now();
                    result = func.apply(thisArg, args);
                    if (!timeoutId && !maxTimeoutId) {
                        args = thisArg = undefined;
                    }
                }
            }

            function delayed() {
                var remaining = wait - (now() - stamp);
                if (remaining <= 0 || remaining > wait) {
                    complete(trailingCall, maxTimeoutId);
                } else {
                    timeoutId = setTimeout(delayed, remaining);
                }
            }

            function maxDelayed() {
                complete(trailing, timeoutId);
            }

            function debounced() {
                args = arguments;
                stamp = now();
                thisArg = this;
                trailingCall = trailing && (timeoutId || !leading);

                if (maxWait === false) {
                    var leadingCall = leading && !timeoutId;
                } else {
                    if (!maxTimeoutId && !leading) {
                        lastCalled = stamp;
                    }
                    var remaining = maxWait - (stamp - lastCalled),
                        isCalled = remaining <= 0 || remaining > maxWait;

                    if (isCalled) {
                        if (maxTimeoutId) {
                            maxTimeoutId = clearTimeout(maxTimeoutId);
                        }
                        lastCalled = stamp;
                        result = func.apply(thisArg, args);
                    }
                    else if (!maxTimeoutId) {
                        maxTimeoutId = setTimeout(maxDelayed, remaining);
                    }
                }
                if (isCalled && timeoutId) {
                    timeoutId = clearTimeout(timeoutId);
                }
                else if (!timeoutId && wait !== maxWait) {
                    timeoutId = setTimeout(delayed, wait);
                }
                if (leadingCall) {
                    isCalled = true;
                    result = func.apply(thisArg, args);
                }
                if (isCalled && !timeoutId && !maxTimeoutId) {
                    args = thisArg = undefined;
                }
                return result;
            }
            debounced.cancel = cancel;
            return debounced;
        }

        module.exports = debounce;

    }, { "../date/now": 312, "../lang/isObject": 428 }], 315: [function (require, module, exports) {
        var baseDelay = require('../internal/baseDelay'),
            restParam = require('./restParam');

        /**
         * Defers invoking the `func` until the current call stack has cleared. Any
         * additional arguments are provided to `func` when it's invoked.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to defer.
         * @param {...*} [args] The arguments to invoke the function with.
         * @returns {number} Returns the timer id.
         * @example
         *
         * _.defer(function(text) {
         *   console.log(text);
         * }, 'deferred');
         * // logs 'deferred' after one or more milliseconds
         */
        var defer = restParam(function (func, args) {
            return baseDelay(func, 1, args);
        });

        module.exports = defer;

    }, { "../internal/baseDelay": 336, "./restParam": 316 }], 316: [function (require, module, exports) {
        /** Used as the `TypeError` message for "Functions" methods. */
        var FUNC_ERROR_TEXT = 'Expected a function';

        /* Native method references for those with the same name as other `lodash` methods. */
        var nativeMax = Math.max;

        /**
         * Creates a function that invokes `func` with the `this` binding of the
         * created function and arguments from `start` and beyond provided as an array.
         *
         * **Note:** This method is based on the [rest parameter](https://developer.mozilla.org/Web/JavaScript/Reference/Functions/rest_parameters).
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to apply a rest parameter to.
         * @param {number} [start=func.length-1] The start position of the rest parameter.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var say = _.restParam(function(what, names) {
         *   return what + ' ' + _.initial(names).join(', ') +
         *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
         * });
         *
         * say('hello', 'fred', 'barney', 'pebbles');
         * // => 'hello fred, barney, & pebbles'
         */
        function restParam(func, start) {
            if (typeof func != 'function') {
                throw new TypeError(FUNC_ERROR_TEXT);
            }
            start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);
            return function () {
                var args = arguments,
                    index = -1,
                    length = nativeMax(args.length - start, 0),
                    rest = Array(length);

                while (++index < length) {
                    rest[index] = args[start + index];
                }
                switch (start) {
                    case 0: return func.call(this, rest);
                    case 1: return func.call(this, args[0], rest);
                    case 2: return func.call(this, args[0], args[1], rest);
                }
                var otherArgs = Array(start + 1);
                index = -1;
                while (++index < start) {
                    otherArgs[index] = args[index];
                }
                otherArgs[start] = rest;
                return func.apply(this, otherArgs);
            };
        }

        module.exports = restParam;

    }, {}], 317: [function (require, module, exports) {
        (function (global) {
            /**
             * @license
             * lodash 3.10.1 (Custom Build) <https://lodash.com/>
             * Build: `lodash modern -d -o ./index.js`
             * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
             * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
             * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
             * Available under MIT license <https://lodash.com/license>
             */
            ; (function () {

                /** Used as a safe reference for `undefined` in pre-ES5 environments. */
                var undefined;

                /** Used as the semantic version number. */
                var VERSION = '3.10.1';

                /** Used to compose bitmasks for wrapper metadata. */
                var BIND_FLAG = 1,
                    BIND_KEY_FLAG = 2,
                    CURRY_BOUND_FLAG = 4,
                    CURRY_FLAG = 8,
                    CURRY_RIGHT_FLAG = 16,
                    PARTIAL_FLAG = 32,
                    PARTIAL_RIGHT_FLAG = 64,
                    ARY_FLAG = 128,
                    REARG_FLAG = 256;

                /** Used as default options for `_.trunc`. */
                var DEFAULT_TRUNC_LENGTH = 30,
                    DEFAULT_TRUNC_OMISSION = '...';

                /** Used to detect when a function becomes hot. */
                var HOT_COUNT = 150,
                    HOT_SPAN = 16;

                /** Used as the size to enable large array optimizations. */
                var LARGE_ARRAY_SIZE = 200;

                /** Used to indicate the type of lazy iteratees. */
                var LAZY_FILTER_FLAG = 1,
                    LAZY_MAP_FLAG = 2;

                /** Used as the `TypeError` message for "Functions" methods. */
                var FUNC_ERROR_TEXT = 'Expected a function';

                /** Used as the internal argument placeholder. */
                var PLACEHOLDER = '__lodash_placeholder__';

                /** `Object#toString` result references. */
                var argsTag = '[object Arguments]',
                    arrayTag = '[object Array]',
                    boolTag = '[object Boolean]',
                    dateTag = '[object Date]',
                    errorTag = '[object Error]',
                    funcTag = '[object Function]',
                    mapTag = '[object Map]',
                    numberTag = '[object Number]',
                    objectTag = '[object Object]',
                    regexpTag = '[object RegExp]',
                    setTag = '[object Set]',
                    stringTag = '[object String]',
                    weakMapTag = '[object WeakMap]';

                var arrayBufferTag = '[object ArrayBuffer]',
                    float32Tag = '[object Float32Array]',
                    float64Tag = '[object Float64Array]',
                    int8Tag = '[object Int8Array]',
                    int16Tag = '[object Int16Array]',
                    int32Tag = '[object Int32Array]',
                    uint8Tag = '[object Uint8Array]',
                    uint8ClampedTag = '[object Uint8ClampedArray]',
                    uint16Tag = '[object Uint16Array]',
                    uint32Tag = '[object Uint32Array]';

                /** Used to match empty string literals in compiled template source. */
                var reEmptyStringLeading = /\b__p \+= '';/g,
                    reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
                    reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

                /** Used to match HTML entities and HTML characters. */
                var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g,
                    reUnescapedHtml = /[&<>"'`]/g,
                    reHasEscapedHtml = RegExp(reEscapedHtml.source),
                    reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

                /** Used to match template delimiters. */
                var reEscape = /<%-([\s\S]+?)%>/g,
                    reEvaluate = /<%([\s\S]+?)%>/g,
                    reInterpolate = /<%=([\s\S]+?)%>/g;

                /** Used to match property names within property paths. */
                var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\n\\]|\\.)*?\1)\]/,
                    reIsPlainProp = /^\w*$/,
                    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g;

                /**
                 * Used to match `RegExp` [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns)
                 * and those outlined by [`EscapeRegExpPattern`](http://ecma-international.org/ecma-262/6.0/#sec-escaperegexppattern).
                 */
                var reRegExpChars = /^[:!,]|[\\^$.*+?()[\]{}|\/]|(^[0-9a-fA-Fnrtuvx])|([\n\r\u2028\u2029])/g,
                    reHasRegExpChars = RegExp(reRegExpChars.source);

                /** Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks). */
                var reComboMark = /[\u0300-\u036f\ufe20-\ufe23]/g;

                /** Used to match backslashes in property paths. */
                var reEscapeChar = /\\(\\)?/g;

                /** Used to match [ES template delimiters](http://ecma-international.org/ecma-262/6.0/#sec-template-literal-lexical-components). */
                var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

                /** Used to match `RegExp` flags from their coerced string values. */
                var reFlags = /\w*$/;

                /** Used to detect hexadecimal string values. */
                var reHasHexPrefix = /^0[xX]/;

                /** Used to detect host constructors (Safari > 5). */
                var reIsHostCtor = /^\[object .+?Constructor\]$/;

                /** Used to detect unsigned integer values. */
                var reIsUint = /^\d+$/;

                /** Used to match latin-1 supplementary letters (excluding mathematical operators). */
                var reLatin1 = /[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g;

                /** Used to ensure capturing order of template delimiters. */
                var reNoMatch = /($^)/;

                /** Used to match unescaped characters in compiled string literals. */
                var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

                /** Used to match words to create compound words. */
                var reWords = (function () {
                    var upper = '[A-Z\\xc0-\\xd6\\xd8-\\xde]',
                        lower = '[a-z\\xdf-\\xf6\\xf8-\\xff]+';

                    return RegExp(upper + '+(?=' + upper + lower + ')|' + upper + '?' + lower + '|' + upper + '+|[0-9]+', 'g');
                }());

                /** Used to assign default `context` object properties. */
                var contextProps = [
                    'Array', 'ArrayBuffer', 'Date', 'Error', 'Float32Array', 'Float64Array',
                    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Math', 'Number',
                    'Object', 'RegExp', 'Set', 'String', '_', 'clearTimeout', 'isFinite',
                    'parseFloat', 'parseInt', 'setTimeout', 'TypeError', 'Uint8Array',
                    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap'
                ];

                /** Used to make template sourceURLs easier to identify. */
                var templateCounter = -1;

                /** Used to identify `toStringTag` values of typed arrays. */
                var typedArrayTags = {};
                typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
                    typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
                    typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
                    typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
                    typedArrayTags[uint32Tag] = true;
                typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
                    typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
                    typedArrayTags[dateTag] = typedArrayTags[errorTag] =
                    typedArrayTags[funcTag] = typedArrayTags[mapTag] =
                    typedArrayTags[numberTag] = typedArrayTags[objectTag] =
                    typedArrayTags[regexpTag] = typedArrayTags[setTag] =
                    typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

                /** Used to identify `toStringTag` values supported by `_.clone`. */
                var cloneableTags = {};
                cloneableTags[argsTag] = cloneableTags[arrayTag] =
                    cloneableTags[arrayBufferTag] = cloneableTags[boolTag] =
                    cloneableTags[dateTag] = cloneableTags[float32Tag] =
                    cloneableTags[float64Tag] = cloneableTags[int8Tag] =
                    cloneableTags[int16Tag] = cloneableTags[int32Tag] =
                    cloneableTags[numberTag] = cloneableTags[objectTag] =
                    cloneableTags[regexpTag] = cloneableTags[stringTag] =
                    cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
                    cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
                cloneableTags[errorTag] = cloneableTags[funcTag] =
                    cloneableTags[mapTag] = cloneableTags[setTag] =
                    cloneableTags[weakMapTag] = false;

                /** Used to map latin-1 supplementary letters to basic latin letters. */
                var deburredLetters = {
                    '\xc0': 'A', '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
                    '\xe0': 'a', '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
                    '\xc7': 'C', '\xe7': 'c',
                    '\xd0': 'D', '\xf0': 'd',
                    '\xc8': 'E', '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
                    '\xe8': 'e', '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
                    '\xcC': 'I', '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
                    '\xeC': 'i', '\xed': 'i', '\xee': 'i', '\xef': 'i',
                    '\xd1': 'N', '\xf1': 'n',
                    '\xd2': 'O', '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
                    '\xf2': 'o', '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
                    '\xd9': 'U', '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
                    '\xf9': 'u', '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
                    '\xdd': 'Y', '\xfd': 'y', '\xff': 'y',
                    '\xc6': 'Ae', '\xe6': 'ae',
                    '\xde': 'Th', '\xfe': 'th',
                    '\xdf': 'ss'
                };

                /** Used to map characters to HTML entities. */
                var htmlEscapes = {
                    '&': '&amp;',
                    '<': '&lt;',
                    '>': '&gt;',
                    '"': '&quot;',
                    "'": '&#39;',
                    '`': '&#96;'
                };

                /** Used to map HTML entities to characters. */
                var htmlUnescapes = {
                    '&amp;': '&',
                    '&lt;': '<',
                    '&gt;': '>',
                    '&quot;': '"',
                    '&#39;': "'",
                    '&#96;': '`'
                };

                /** Used to determine if values are of the language type `Object`. */
                var objectTypes = {
                    'function': true,
                    'object': true
                };

                /** Used to escape characters for inclusion in compiled regexes. */
                var regexpEscapes = {
                    '0': 'x30', '1': 'x31', '2': 'x32', '3': 'x33', '4': 'x34',
                    '5': 'x35', '6': 'x36', '7': 'x37', '8': 'x38', '9': 'x39',
                    'A': 'x41', 'B': 'x42', 'C': 'x43', 'D': 'x44', 'E': 'x45', 'F': 'x46',
                    'a': 'x61', 'b': 'x62', 'c': 'x63', 'd': 'x64', 'e': 'x65', 'f': 'x66',
                    'n': 'x6e', 'r': 'x72', 't': 'x74', 'u': 'x75', 'v': 'x76', 'x': 'x78'
                };

                /** Used to escape characters for inclusion in compiled string literals. */
                var stringEscapes = {
                    '\\': '\\',
                    "'": "'",
                    '\n': 'n',
                    '\r': 'r',
                    '\u2028': 'u2028',
                    '\u2029': 'u2029'
                };

                /** Detect free variable `exports`. */
                var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

                /** Detect free variable `module`. */
                var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

                /** Detect free variable `global` from Node.js. */
                var freeGlobal = freeExports && freeModule && typeof global == 'object' && global && global.Object && global;

                /** Detect free variable `self`. */
                var freeSelf = objectTypes[typeof self] && self && self.Object && self;

                /** Detect free variable `window`. */
                var freeWindow = objectTypes[typeof window] && window && window.Object && window;

                /** Detect the popular CommonJS extension `module.exports`. */
                var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;

                /**
                 * Used as a reference to the global object.
                 *
                 * The `this` value is used if it's the global object to avoid Greasemonkey's
                 * restricted `window` object, otherwise the `window` object is used.
                 */
                var root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || freeSelf || this;

                /*--------------------------------------------------------------------------*/

                /**
                 * The base implementation of `compareAscending` which compares values and
                 * sorts them in ascending order without guaranteeing a stable sort.
                 *
                 * @private
                 * @param {*} value The value to compare.
                 * @param {*} other The other value to compare.
                 * @returns {number} Returns the sort order indicator for `value`.
                 */
                function baseCompareAscending(value, other) {
                    if (value !== other) {
                        var valIsNull = value === null,
                            valIsUndef = value === undefined,
                            valIsReflexive = value === value;

                        var othIsNull = other === null,
                            othIsUndef = other === undefined,
                            othIsReflexive = other === other;

                        if ((value > other && !othIsNull) || !valIsReflexive ||
                            (valIsNull && !othIsUndef && othIsReflexive) ||
                            (valIsUndef && othIsReflexive)) {
                            return 1;
                        }
                        if ((value < other && !valIsNull) || !othIsReflexive ||
                            (othIsNull && !valIsUndef && valIsReflexive) ||
                            (othIsUndef && valIsReflexive)) {
                            return -1;
                        }
                    }
                    return 0;
                }

                /**
                 * The base implementation of `_.findIndex` and `_.findLastIndex` without
                 * support for callback shorthands and `this` binding.
                 *
                 * @private
                 * @param {Array} array The array to search.
                 * @param {Function} predicate The function invoked per iteration.
                 * @param {boolean} [fromRight] Specify iterating from right to left.
                 * @returns {number} Returns the index of the matched value, else `-1`.
                 */
                function baseFindIndex(array, predicate, fromRight) {
                    var length = array.length,
                        index = fromRight ? length : -1;

                    while ((fromRight ? index-- : ++index < length)) {
                        if (predicate(array[index], index, array)) {
                            return index;
                        }
                    }
                    return -1;
                }

                /**
                 * The base implementation of `_.indexOf` without support for binary searches.
                 *
                 * @private
                 * @param {Array} array The array to search.
                 * @param {*} value The value to search for.
                 * @param {number} fromIndex The index to search from.
                 * @returns {number} Returns the index of the matched value, else `-1`.
                 */
                function baseIndexOf(array, value, fromIndex) {
                    if (value !== value) {
                        return indexOfNaN(array, fromIndex);
                    }
                    var index = fromIndex - 1,
                        length = array.length;

                    while (++index < length) {
                        if (array[index] === value) {
                            return index;
                        }
                    }
                    return -1;
                }

                /**
                 * The base implementation of `_.isFunction` without support for environments
                 * with incorrect `typeof` results.
                 *
                 * @private
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
                 */
                function baseIsFunction(value) {
                    // Avoid a Chakra JIT bug in compatibility modes of IE 11.
                    // See https://github.com/jashkenas/underscore/issues/1621 for more details.
                    return typeof value == 'function' || false;
                }

                /**
                 * Converts `value` to a string if it's not one. An empty string is returned
                 * for `null` or `undefined` values.
                 *
                 * @private
                 * @param {*} value The value to process.
                 * @returns {string} Returns the string.
                 */
                function baseToString(value) {
                    return value == null ? '' : (value + '');
                }

                /**
                 * Used by `_.trim` and `_.trimLeft` to get the index of the first character
                 * of `string` that is not found in `chars`.
                 *
                 * @private
                 * @param {string} string The string to inspect.
                 * @param {string} chars The characters to find.
                 * @returns {number} Returns the index of the first character not found in `chars`.
                 */
                function charsLeftIndex(string, chars) {
                    var index = -1,
                        length = string.length;

                    while (++index < length && chars.indexOf(string.charAt(index)) > -1) { }
                    return index;
                }

                /**
                 * Used by `_.trim` and `_.trimRight` to get the index of the last character
                 * of `string` that is not found in `chars`.
                 *
                 * @private
                 * @param {string} string The string to inspect.
                 * @param {string} chars The characters to find.
                 * @returns {number} Returns the index of the last character not found in `chars`.
                 */
                function charsRightIndex(string, chars) {
                    var index = string.length;

                    while (index-- && chars.indexOf(string.charAt(index)) > -1) { }
                    return index;
                }

                /**
                 * Used by `_.sortBy` to compare transformed elements of a collection and stable
                 * sort them in ascending order.
                 *
                 * @private
                 * @param {Object} object The object to compare.
                 * @param {Object} other The other object to compare.
                 * @returns {number} Returns the sort order indicator for `object`.
                 */
                function compareAscending(object, other) {
                    return baseCompareAscending(object.criteria, other.criteria) || (object.index - other.index);
                }

                /**
                 * Used by `_.sortByOrder` to compare multiple properties of a value to another
                 * and stable sort them.
                 *
                 * If `orders` is unspecified, all valuess are sorted in ascending order. Otherwise,
                 * a value is sorted in ascending order if its corresponding order is "asc", and
                 * descending if "desc".
                 *
                 * @private
                 * @param {Object} object The object to compare.
                 * @param {Object} other The other object to compare.
                 * @param {boolean[]} orders The order to sort by for each property.
                 * @returns {number} Returns the sort order indicator for `object`.
                 */
                function compareMultiple(object, other, orders) {
                    var index = -1,
                        objCriteria = object.criteria,
                        othCriteria = other.criteria,
                        length = objCriteria.length,
                        ordersLength = orders.length;

                    while (++index < length) {
                        var result = baseCompareAscending(objCriteria[index], othCriteria[index]);
                        if (result) {
                            if (index >= ordersLength) {
                                return result;
                            }
                            var order = orders[index];
                            return result * ((order === 'asc' || order === true) ? 1 : -1);
                        }
                    }
                    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
                    // that causes it, under certain circumstances, to provide the same value for
                    // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
                    // for more details.
                    //
                    // This also ensures a stable sort in V8 and other engines.
                    // See https://code.google.com/p/v8/issues/detail?id=90 for more details.
                    return object.index - other.index;
                }

                /**
                 * Used by `_.deburr` to convert latin-1 supplementary letters to basic latin letters.
                 *
                 * @private
                 * @param {string} letter The matched letter to deburr.
                 * @returns {string} Returns the deburred letter.
                 */
                function deburrLetter(letter) {
                    return deburredLetters[letter];
                }

                /**
                 * Used by `_.escape` to convert characters to HTML entities.
                 *
                 * @private
                 * @param {string} chr The matched character to escape.
                 * @returns {string} Returns the escaped character.
                 */
                function escapeHtmlChar(chr) {
                    return htmlEscapes[chr];
                }

                /**
                 * Used by `_.escapeRegExp` to escape characters for inclusion in compiled regexes.
                 *
                 * @private
                 * @param {string} chr The matched character to escape.
                 * @param {string} leadingChar The capture group for a leading character.
                 * @param {string} whitespaceChar The capture group for a whitespace character.
                 * @returns {string} Returns the escaped character.
                 */
                function escapeRegExpChar(chr, leadingChar, whitespaceChar) {
                    if (leadingChar) {
                        chr = regexpEscapes[chr];
                    } else if (whitespaceChar) {
                        chr = stringEscapes[chr];
                    }
                    return '\\' + chr;
                }

                /**
                 * Used by `_.template` to escape characters for inclusion in compiled string literals.
                 *
                 * @private
                 * @param {string} chr The matched character to escape.
                 * @returns {string} Returns the escaped character.
                 */
                function escapeStringChar(chr) {
                    return '\\' + stringEscapes[chr];
                }

                /**
                 * Gets the index at which the first occurrence of `NaN` is found in `array`.
                 *
                 * @private
                 * @param {Array} array The array to search.
                 * @param {number} fromIndex The index to search from.
                 * @param {boolean} [fromRight] Specify iterating from right to left.
                 * @returns {number} Returns the index of the matched `NaN`, else `-1`.
                 */
                function indexOfNaN(array, fromIndex, fromRight) {
                    var length = array.length,
                        index = fromIndex + (fromRight ? 0 : -1);

                    while ((fromRight ? index-- : ++index < length)) {
                        var other = array[index];
                        if (other !== other) {
                            return index;
                        }
                    }
                    return -1;
                }

                /**
                 * Checks if `value` is object-like.
                 *
                 * @private
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
                 */
                function isObjectLike(value) {
                    return !!value && typeof value == 'object';
                }

                /**
                 * Used by `trimmedLeftIndex` and `trimmedRightIndex` to determine if a
                 * character code is whitespace.
                 *
                 * @private
                 * @param {number} charCode The character code to inspect.
                 * @returns {boolean} Returns `true` if `charCode` is whitespace, else `false`.
                 */
                function isSpace(charCode) {
                    return ((charCode <= 160 && (charCode >= 9 && charCode <= 13) || charCode == 32 || charCode == 160) || charCode == 5760 || charCode == 6158 ||
                        (charCode >= 8192 && (charCode <= 8202 || charCode == 8232 || charCode == 8233 || charCode == 8239 || charCode == 8287 || charCode == 12288 || charCode == 65279)));
                }

                /**
                 * Replaces all `placeholder` elements in `array` with an internal placeholder
                 * and returns an array of their indexes.
                 *
                 * @private
                 * @param {Array} array The array to modify.
                 * @param {*} placeholder The placeholder to replace.
                 * @returns {Array} Returns the new array of placeholder indexes.
                 */
                function replaceHolders(array, placeholder) {
                    var index = -1,
                        length = array.length,
                        resIndex = -1,
                        result = [];

                    while (++index < length) {
                        if (array[index] === placeholder) {
                            array[index] = PLACEHOLDER;
                            result[++resIndex] = index;
                        }
                    }
                    return result;
                }

                /**
                 * An implementation of `_.uniq` optimized for sorted arrays without support
                 * for callback shorthands and `this` binding.
                 *
                 * @private
                 * @param {Array} array The array to inspect.
                 * @param {Function} [iteratee] The function invoked per iteration.
                 * @returns {Array} Returns the new duplicate-value-free array.
                 */
                function sortedUniq(array, iteratee) {
                    var seen,
                        index = -1,
                        length = array.length,
                        resIndex = -1,
                        result = [];

                    while (++index < length) {
                        var value = array[index],
                            computed = iteratee ? iteratee(value, index, array) : value;

                        if (!index || seen !== computed) {
                            seen = computed;
                            result[++resIndex] = value;
                        }
                    }
                    return result;
                }

                /**
                 * Used by `_.trim` and `_.trimLeft` to get the index of the first non-whitespace
                 * character of `string`.
                 *
                 * @private
                 * @param {string} string The string to inspect.
                 * @returns {number} Returns the index of the first non-whitespace character.
                 */
                function trimmedLeftIndex(string) {
                    var index = -1,
                        length = string.length;

                    while (++index < length && isSpace(string.charCodeAt(index))) { }
                    return index;
                }

                /**
                 * Used by `_.trim` and `_.trimRight` to get the index of the last non-whitespace
                 * character of `string`.
                 *
                 * @private
                 * @param {string} string The string to inspect.
                 * @returns {number} Returns the index of the last non-whitespace character.
                 */
                function trimmedRightIndex(string) {
                    var index = string.length;

                    while (index-- && isSpace(string.charCodeAt(index))) { }
                    return index;
                }

                /**
                 * Used by `_.unescape` to convert HTML entities to characters.
                 *
                 * @private
                 * @param {string} chr The matched character to unescape.
                 * @returns {string} Returns the unescaped character.
                 */
                function unescapeHtmlChar(chr) {
                    return htmlUnescapes[chr];
                }

                /*--------------------------------------------------------------------------*/

                /**
                 * Create a new pristine `lodash` function using the given `context` object.
                 *
                 * @static
                 * @memberOf _
                 * @category Utility
                 * @param {Object} [context=root] The context object.
                 * @returns {Function} Returns a new `lodash` function.
                 * @example
                 *
                 * _.mixin({ 'foo': _.constant('foo') });
                 *
                 * var lodash = _.runInContext();
                 * lodash.mixin({ 'bar': lodash.constant('bar') });
                 *
                 * _.isFunction(_.foo);
                 * // => true
                 * _.isFunction(_.bar);
                 * // => false
                 *
                 * lodash.isFunction(lodash.foo);
                 * // => false
                 * lodash.isFunction(lodash.bar);
                 * // => true
                 *
                 * // using `context` to mock `Date#getTime` use in `_.now`
                 * var mock = _.runInContext({
                 *   'Date': function() {
                 *     return { 'getTime': getTimeMock };
                 *   }
                 * });
                 *
                 * // or creating a suped-up `defer` in Node.js
                 * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
                 */
                function runInContext(context) {
                    // Avoid issues with some ES3 environments that attempt to use values, named
                    // after built-in constructors like `Object`, for the creation of literals.
                    // ES5 clears this up by stating that literals must use built-in constructors.
                    // See https://es5.github.io/#x11.1.5 for more details.
                    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;

                    /** Native constructor references. */
                    var Array = context.Array,
                        Date = context.Date,
                        Error = context.Error,
                        Function = context.Function,
                        Math = context.Math,
                        Number = context.Number,
                        Object = context.Object,
                        RegExp = context.RegExp,
                        String = context.String,
                        TypeError = context.TypeError;

                    /** Used for native method references. */
                    var arrayProto = Array.prototype,
                        objectProto = Object.prototype,
                        stringProto = String.prototype;

                    /** Used to resolve the decompiled source of functions. */
                    var fnToString = Function.prototype.toString;

                    /** Used to check objects for own properties. */
                    var hasOwnProperty = objectProto.hasOwnProperty;

                    /** Used to generate unique IDs. */
                    var idCounter = 0;

                    /**
                     * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
                     * of values.
                     */
                    var objToString = objectProto.toString;

                    /** Used to restore the original `_` reference in `_.noConflict`. */
                    var oldDash = root._;

                    /** Used to detect if a method is native. */
                    var reIsNative = RegExp('^' +
                        fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
                            .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
                    );

                    /** Native method references. */
                    var ArrayBuffer = context.ArrayBuffer,
                        clearTimeout = context.clearTimeout,
                        parseFloat = context.parseFloat,
                        pow = Math.pow,
                        propertyIsEnumerable = objectProto.propertyIsEnumerable,
                        Set = getNative(context, 'Set'),
                        setTimeout = context.setTimeout,
                        splice = arrayProto.splice,
                        Uint8Array = context.Uint8Array,
                        WeakMap = getNative(context, 'WeakMap');

                    /* Native method references for those with the same name as other `lodash` methods. */
                    var nativeCeil = Math.ceil,
                        nativeCreate = getNative(Object, 'create'),
                        nativeFloor = Math.floor,
                        nativeIsArray = getNative(Array, 'isArray'),
                        nativeIsFinite = context.isFinite,
                        nativeKeys = getNative(Object, 'keys'),
                        nativeMax = Math.max,
                        nativeMin = Math.min,
                        nativeNow = getNative(Date, 'now'),
                        nativeParseInt = context.parseInt,
                        nativeRandom = Math.random;

                    /** Used as references for `-Infinity` and `Infinity`. */
                    var NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY,
                        POSITIVE_INFINITY = Number.POSITIVE_INFINITY;

                    /** Used as references for the maximum length and index of an array. */
                    var MAX_ARRAY_LENGTH = 4294967295,
                        MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
                        HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

                    /**
                     * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
                     * of an array-like value.
                     */
                    var MAX_SAFE_INTEGER = 9007199254740991;

                    /** Used to store function metadata. */
                    var metaMap = WeakMap && new WeakMap;

                    /** Used to lookup unminified function names. */
                    var realNames = {};

                    /*------------------------------------------------------------------------*/

                    /**
                     * Creates a `lodash` object which wraps `value` to enable implicit chaining.
                     * Methods that operate on and return arrays, collections, and functions can
                     * be chained together. Methods that retrieve a single value or may return a
                     * primitive value will automatically end the chain returning the unwrapped
                     * value. Explicit chaining may be enabled using `_.chain`. The execution of
                     * chained methods is lazy, that is, execution is deferred until `_#value`
                     * is implicitly or explicitly called.
                     *
                     * Lazy evaluation allows several methods to support shortcut fusion. Shortcut
                     * fusion is an optimization strategy which merge iteratee calls; this can help
                     * to avoid the creation of intermediate data structures and greatly reduce the
                     * number of iteratee executions.
                     *
                     * Chaining is supported in custom builds as long as the `_#value` method is
                     * directly or indirectly included in the build.
                     *
                     * In addition to lodash methods, wrappers have `Array` and `String` methods.
                     *
                     * The wrapper `Array` methods are:
                     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`,
                     * `splice`, and `unshift`
                     *
                     * The wrapper `String` methods are:
                     * `replace` and `split`
                     *
                     * The wrapper methods that support shortcut fusion are:
                     * `compact`, `drop`, `dropRight`, `dropRightWhile`, `dropWhile`, `filter`,
                     * `first`, `initial`, `last`, `map`, `pluck`, `reject`, `rest`, `reverse`,
                     * `slice`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, `toArray`,
                     * and `where`
                     *
                     * The chainable wrapper methods are:
                     * `after`, `ary`, `assign`, `at`, `before`, `bind`, `bindAll`, `bindKey`,
                     * `callback`, `chain`, `chunk`, `commit`, `compact`, `concat`, `constant`,
                     * `countBy`, `create`, `curry`, `debounce`, `defaults`, `defaultsDeep`,
                     * `defer`, `delay`, `difference`, `drop`, `dropRight`, `dropRightWhile`,
                     * `dropWhile`, `fill`, `filter`, `flatten`, `flattenDeep`, `flow`, `flowRight`,
                     * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
                     * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
                     * `invoke`, `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`,
                     * `matchesProperty`, `memoize`, `merge`, `method`, `methodOf`, `mixin`,
                     * `modArgs`, `negate`, `omit`, `once`, `pairs`, `partial`, `partialRight`,
                     * `partition`, `pick`, `plant`, `pluck`, `property`, `propertyOf`, `pull`,
                     * `pullAt`, `push`, `range`, `rearg`, `reject`, `remove`, `rest`, `restParam`,
                     * `reverse`, `set`, `shuffle`, `slice`, `sort`, `sortBy`, `sortByAll`,
                     * `sortByOrder`, `splice`, `spread`, `take`, `takeRight`, `takeRightWhile`,
                     * `takeWhile`, `tap`, `throttle`, `thru`, `times`, `toArray`, `toPlainObject`,
                     * `transform`, `union`, `uniq`, `unshift`, `unzip`, `unzipWith`, `values`,
                     * `valuesIn`, `where`, `without`, `wrap`, `xor`, `zip`, `zipObject`, `zipWith`
                     *
                     * The wrapper methods that are **not** chainable by default are:
                     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clone`, `cloneDeep`,
                     * `deburr`, `endsWith`, `escape`, `escapeRegExp`, `every`, `find`, `findIndex`,
                     * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `findWhere`, `first`,
                     * `floor`, `get`, `gt`, `gte`, `has`, `identity`, `includes`, `indexOf`,
                     * `inRange`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
                     * `isEmpty`, `isEqual`, `isError`, `isFinite` `isFunction`, `isMatch`,
                     * `isNative`, `isNaN`, `isNull`, `isNumber`, `isObject`, `isPlainObject`,
                     * `isRegExp`, `isString`, `isUndefined`, `isTypedArray`, `join`, `kebabCase`,
                     * `last`, `lastIndexOf`, `lt`, `lte`, `max`, `min`, `noConflict`, `noop`,
                     * `now`, `pad`, `padLeft`, `padRight`, `parseInt`, `pop`, `random`, `reduce`,
                     * `reduceRight`, `repeat`, `result`, `round`, `runInContext`, `shift`, `size`,
                     * `snakeCase`, `some`, `sortedIndex`, `sortedLastIndex`, `startCase`,
                     * `startsWith`, `sum`, `template`, `trim`, `trimLeft`, `trimRight`, `trunc`,
                     * `unescape`, `uniqueId`, `value`, and `words`
                     *
                     * The wrapper method `sample` will return a wrapped value when `n` is provided,
                     * otherwise an unwrapped value is returned.
                     *
                     * @name _
                     * @constructor
                     * @category Chain
                     * @param {*} value The value to wrap in a `lodash` instance.
                     * @returns {Object} Returns the new `lodash` wrapper instance.
                     * @example
                     *
                     * var wrapped = _([1, 2, 3]);
                     *
                     * // returns an unwrapped value
                     * wrapped.reduce(function(total, n) {
                     *   return total + n;
                     * });
                     * // => 6
                     *
                     * // returns a wrapped value
                     * var squares = wrapped.map(function(n) {
                     *   return n * n;
                     * });
                     *
                     * _.isArray(squares);
                     * // => false
                     *
                     * _.isArray(squares.value());
                     * // => true
                     */
                    function lodash(value) {
                        if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
                            if (value instanceof LodashWrapper) {
                                return value;
                            }
                            if (hasOwnProperty.call(value, '__chain__') && hasOwnProperty.call(value, '__wrapped__')) {
                                return wrapperClone(value);
                            }
                        }
                        return new LodashWrapper(value);
                    }

                    /**
                     * The function whose prototype all chaining wrappers inherit from.
                     *
                     * @private
                     */
                    function baseLodash() {
                        // No operation performed.
                    }

                    /**
                     * The base constructor for creating `lodash` wrapper objects.
                     *
                     * @private
                     * @param {*} value The value to wrap.
                     * @param {boolean} [chainAll] Enable chaining for all wrapper methods.
                     * @param {Array} [actions=[]] Actions to peform to resolve the unwrapped value.
                     */
                    function LodashWrapper(value, chainAll, actions) {
                        this.__wrapped__ = value;
                        this.__actions__ = actions || [];
                        this.__chain__ = !!chainAll;
                    }

                    /**
                     * An object environment feature flags.
                     *
                     * @static
                     * @memberOf _
                     * @type Object
                     */
                    var support = lodash.support = {};

                    /**
                     * By default, the template delimiters used by lodash are like those in
                     * embedded Ruby (ERB). Change the following template settings to use
                     * alternative delimiters.
                     *
                     * @static
                     * @memberOf _
                     * @type Object
                     */
                    lodash.templateSettings = {

                        /**
                         * Used to detect `data` property values to be HTML-escaped.
                         *
                         * @memberOf _.templateSettings
                         * @type RegExp
                         */
                        'escape': reEscape,

                        /**
                         * Used to detect code to be evaluated.
                         *
                         * @memberOf _.templateSettings
                         * @type RegExp
                         */
                        'evaluate': reEvaluate,

                        /**
                         * Used to detect `data` property values to inject.
                         *
                         * @memberOf _.templateSettings
                         * @type RegExp
                         */
                        'interpolate': reInterpolate,

                        /**
                         * Used to reference the data object in the template text.
                         *
                         * @memberOf _.templateSettings
                         * @type string
                         */
                        'variable': '',

                        /**
                         * Used to import variables into the compiled template.
                         *
                         * @memberOf _.templateSettings
                         * @type Object
                         */
                        'imports': {

                            /**
                             * A reference to the `lodash` function.
                             *
                             * @memberOf _.templateSettings.imports
                             * @type Function
                             */
                            '_': lodash
                        }
                    };

                    /*------------------------------------------------------------------------*/

                    /**
                     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
                     *
                     * @private
                     * @param {*} value The value to wrap.
                     */
                    function LazyWrapper(value) {
                        this.__wrapped__ = value;
                        this.__actions__ = [];
                        this.__dir__ = 1;
                        this.__filtered__ = false;
                        this.__iteratees__ = [];
                        this.__takeCount__ = POSITIVE_INFINITY;
                        this.__views__ = [];
                    }

                    /**
                     * Creates a clone of the lazy wrapper object.
                     *
                     * @private
                     * @name clone
                     * @memberOf LazyWrapper
                     * @returns {Object} Returns the cloned `LazyWrapper` object.
                     */
                    function lazyClone() {
                        var result = new LazyWrapper(this.__wrapped__);
                        result.__actions__ = arrayCopy(this.__actions__);
                        result.__dir__ = this.__dir__;
                        result.__filtered__ = this.__filtered__;
                        result.__iteratees__ = arrayCopy(this.__iteratees__);
                        result.__takeCount__ = this.__takeCount__;
                        result.__views__ = arrayCopy(this.__views__);
                        return result;
                    }

                    /**
                     * Reverses the direction of lazy iteration.
                     *
                     * @private
                     * @name reverse
                     * @memberOf LazyWrapper
                     * @returns {Object} Returns the new reversed `LazyWrapper` object.
                     */
                    function lazyReverse() {
                        if (this.__filtered__) {
                            var result = new LazyWrapper(this);
                            result.__dir__ = -1;
                            result.__filtered__ = true;
                        } else {
                            result = this.clone();
                            result.__dir__ *= -1;
                        }
                        return result;
                    }

                    /**
                     * Extracts the unwrapped value from its lazy wrapper.
                     *
                     * @private
                     * @name value
                     * @memberOf LazyWrapper
                     * @returns {*} Returns the unwrapped value.
                     */
                    function lazyValue() {
                        var array = this.__wrapped__.value(),
                            dir = this.__dir__,
                            isArr = isArray(array),
                            isRight = dir < 0,
                            arrLength = isArr ? array.length : 0,
                            view = getView(0, arrLength, this.__views__),
                            start = view.start,
                            end = view.end,
                            length = end - start,
                            index = isRight ? end : (start - 1),
                            iteratees = this.__iteratees__,
                            iterLength = iteratees.length,
                            resIndex = 0,
                            takeCount = nativeMin(length, this.__takeCount__);

                        if (!isArr || arrLength < LARGE_ARRAY_SIZE || (arrLength == length && takeCount == length)) {
                            return baseWrapperValue((isRight && isArr) ? array.reverse() : array, this.__actions__);
                        }
                        var result = [];

                        outer:
                        while (length-- && resIndex < takeCount) {
                            index += dir;

                            var iterIndex = -1,
                                value = array[index];

                            while (++iterIndex < iterLength) {
                                var data = iteratees[iterIndex],
                                    iteratee = data.iteratee,
                                    type = data.type,
                                    computed = iteratee(value);

                                if (type == LAZY_MAP_FLAG) {
                                    value = computed;
                                } else if (!computed) {
                                    if (type == LAZY_FILTER_FLAG) {
                                        continue outer;
                                    } else {
                                        break outer;
                                    }
                                }
                            }
                            result[resIndex++] = value;
                        }
                        return result;
                    }

                    /*------------------------------------------------------------------------*/

                    /**
                     * Creates a cache object to store key/value pairs.
                     *
                     * @private
                     * @static
                     * @name Cache
                     * @memberOf _.memoize
                     */
                    function MapCache() {
                        this.__data__ = {};
                    }

                    /**
                     * Removes `key` and its value from the cache.
                     *
                     * @private
                     * @name delete
                     * @memberOf _.memoize.Cache
                     * @param {string} key The key of the value to remove.
                     * @returns {boolean} Returns `true` if the entry was removed successfully, else `false`.
                     */
                    function mapDelete(key) {
                        return this.has(key) && delete this.__data__[key];
                    }

                    /**
                     * Gets the cached value for `key`.
                     *
                     * @private
                     * @name get
                     * @memberOf _.memoize.Cache
                     * @param {string} key The key of the value to get.
                     * @returns {*} Returns the cached value.
                     */
                    function mapGet(key) {
                        return key == '__proto__' ? undefined : this.__data__[key];
                    }

                    /**
                     * Checks if a cached value for `key` exists.
                     *
                     * @private
                     * @name has
                     * @memberOf _.memoize.Cache
                     * @param {string} key The key of the entry to check.
                     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
                     */
                    function mapHas(key) {
                        return key != '__proto__' && hasOwnProperty.call(this.__data__, key);
                    }

                    /**
                     * Sets `value` to `key` of the cache.
                     *
                     * @private
                     * @name set
                     * @memberOf _.memoize.Cache
                     * @param {string} key The key of the value to cache.
                     * @param {*} value The value to cache.
                     * @returns {Object} Returns the cache object.
                     */
                    function mapSet(key, value) {
                        if (key != '__proto__') {
                            this.__data__[key] = value;
                        }
                        return this;
                    }

                    /*------------------------------------------------------------------------*/

                    /**
                     *
                     * Creates a cache object to store unique values.
                     *
                     * @private
                     * @param {Array} [values] The values to cache.
                     */
                    function SetCache(values) {
                        var length = values ? values.length : 0;

                        this.data = { 'hash': nativeCreate(null), 'set': new Set };
                        while (length--) {
                            this.push(values[length]);
                        }
                    }

                    /**
                     * Checks if `value` is in `cache` mimicking the return signature of
                     * `_.indexOf` by returning `0` if the value is found, else `-1`.
                     *
                     * @private
                     * @param {Object} cache The cache to search.
                     * @param {*} value The value to search for.
                     * @returns {number} Returns `0` if `value` is found, else `-1`.
                     */
                    function cacheIndexOf(cache, value) {
                        var data = cache.data,
                            result = (typeof value == 'string' || isObject(value)) ? data.set.has(value) : data.hash[value];

                        return result ? 0 : -1;
                    }

                    /**
                     * Adds `value` to the cache.
                     *
                     * @private
                     * @name push
                     * @memberOf SetCache
                     * @param {*} value The value to cache.
                     */
                    function cachePush(value) {
                        var data = this.data;
                        if (typeof value == 'string' || isObject(value)) {
                            data.set.add(value);
                        } else {
                            data.hash[value] = true;
                        }
                    }

                    /*------------------------------------------------------------------------*/

                    /**
                     * Creates a new array joining `array` with `other`.
                     *
                     * @private
                     * @param {Array} array The array to join.
                     * @param {Array} other The other array to join.
                     * @returns {Array} Returns the new concatenated array.
                     */
                    function arrayConcat(array, other) {
                        var index = -1,
                            length = array.length,
                            othIndex = -1,
                            othLength = other.length,
                            result = Array(length + othLength);

                        while (++index < length) {
                            result[index] = array[index];
                        }
                        while (++othIndex < othLength) {
                            result[index++] = other[othIndex];
                        }
                        return result;
                    }

                    /**
                     * Copies the values of `source` to `array`.
                     *
                     * @private
                     * @param {Array} source The array to copy values from.
                     * @param {Array} [array=[]] The array to copy values to.
                     * @returns {Array} Returns `array`.
                     */
                    function arrayCopy(source, array) {
                        var index = -1,
                            length = source.length;

                        array || (array = Array(length));
                        while (++index < length) {
                            array[index] = source[index];
                        }
                        return array;
                    }

                    /**
                     * A specialized version of `_.forEach` for arrays without support for callback
                     * shorthands and `this` binding.
                     *
                     * @private
                     * @param {Array} array The array to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @returns {Array} Returns `array`.
                     */
                    function arrayEach(array, iteratee) {
                        var index = -1,
                            length = array.length;

                        while (++index < length) {
                            if (iteratee(array[index], index, array) === false) {
                                break;
                            }
                        }
                        return array;
                    }

                    /**
                     * A specialized version of `_.forEachRight` for arrays without support for
                     * callback shorthands and `this` binding.
                     *
                     * @private
                     * @param {Array} array The array to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @returns {Array} Returns `array`.
                     */
                    function arrayEachRight(array, iteratee) {
                        var length = array.length;

                        while (length--) {
                            if (iteratee(array[length], length, array) === false) {
                                break;
                            }
                        }
                        return array;
                    }

                    /**
                     * A specialized version of `_.every` for arrays without support for callback
                     * shorthands and `this` binding.
                     *
                     * @private
                     * @param {Array} array The array to iterate over.
                     * @param {Function} predicate The function invoked per iteration.
                     * @returns {boolean} Returns `true` if all elements pass the predicate check,
                     *  else `false`.
                     */
                    function arrayEvery(array, predicate) {
                        var index = -1,
                            length = array.length;

                        while (++index < length) {
                            if (!predicate(array[index], index, array)) {
                                return false;
                            }
                        }
                        return true;
                    }

                    /**
                     * A specialized version of `baseExtremum` for arrays which invokes `iteratee`
                     * with one argument: (value).
                     *
                     * @private
                     * @param {Array} array The array to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @param {Function} comparator The function used to compare values.
                     * @param {*} exValue The initial extremum value.
                     * @returns {*} Returns the extremum value.
                     */
                    function arrayExtremum(array, iteratee, comparator, exValue) {
                        var index = -1,
                            length = array.length,
                            computed = exValue,
                            result = computed;

                        while (++index < length) {
                            var value = array[index],
                                current = +iteratee(value);

                            if (comparator(current, computed)) {
                                computed = current;
                                result = value;
                            }
                        }
                        return result;
                    }

                    /**
                     * A specialized version of `_.filter` for arrays without support for callback
                     * shorthands and `this` binding.
                     *
                     * @private
                     * @param {Array} array The array to iterate over.
                     * @param {Function} predicate The function invoked per iteration.
                     * @returns {Array} Returns the new filtered array.
                     */
                    function arrayFilter(array, predicate) {
                        var index = -1,
                            length = array.length,
                            resIndex = -1,
                            result = [];

                        while (++index < length) {
                            var value = array[index];
                            if (predicate(value, index, array)) {
                                result[++resIndex] = value;
                            }
                        }
                        return result;
                    }

                    /**
                     * A specialized version of `_.map` for arrays without support for callback
                     * shorthands and `this` binding.
                     *
                     * @private
                     * @param {Array} array The array to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @returns {Array} Returns the new mapped array.
                     */
                    function arrayMap(array, iteratee) {
                        var index = -1,
                            length = array.length,
                            result = Array(length);

                        while (++index < length) {
                            result[index] = iteratee(array[index], index, array);
                        }
                        return result;
                    }

                    /**
                     * Appends the elements of `values` to `array`.
                     *
                     * @private
                     * @param {Array} array The array to modify.
                     * @param {Array} values The values to append.
                     * @returns {Array} Returns `array`.
                     */
                    function arrayPush(array, values) {
                        var index = -1,
                            length = values.length,
                            offset = array.length;

                        while (++index < length) {
                            array[offset + index] = values[index];
                        }
                        return array;
                    }

                    /**
                     * A specialized version of `_.reduce` for arrays without support for callback
                     * shorthands and `this` binding.
                     *
                     * @private
                     * @param {Array} array The array to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @param {*} [accumulator] The initial value.
                     * @param {boolean} [initFromArray] Specify using the first element of `array`
                     *  as the initial value.
                     * @returns {*} Returns the accumulated value.
                     */
                    function arrayReduce(array, iteratee, accumulator, initFromArray) {
                        var index = -1,
                            length = array.length;

                        if (initFromArray && length) {
                            accumulator = array[++index];
                        }
                        while (++index < length) {
                            accumulator = iteratee(accumulator, array[index], index, array);
                        }
                        return accumulator;
                    }

                    /**
                     * A specialized version of `_.reduceRight` for arrays without support for
                     * callback shorthands and `this` binding.
                     *
                     * @private
                     * @param {Array} array The array to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @param {*} [accumulator] The initial value.
                     * @param {boolean} [initFromArray] Specify using the last element of `array`
                     *  as the initial value.
                     * @returns {*} Returns the accumulated value.
                     */
                    function arrayReduceRight(array, iteratee, accumulator, initFromArray) {
                        var length = array.length;
                        if (initFromArray && length) {
                            accumulator = array[--length];
                        }
                        while (length--) {
                            accumulator = iteratee(accumulator, array[length], length, array);
                        }
                        return accumulator;
                    }

                    /**
                     * A specialized version of `_.some` for arrays without support for callback
                     * shorthands and `this` binding.
                     *
                     * @private
                     * @param {Array} array The array to iterate over.
                     * @param {Function} predicate The function invoked per iteration.
                     * @returns {boolean} Returns `true` if any element passes the predicate check,
                     *  else `false`.
                     */
                    function arraySome(array, predicate) {
                        var index = -1,
                            length = array.length;

                        while (++index < length) {
                            if (predicate(array[index], index, array)) {
                                return true;
                            }
                        }
                        return false;
                    }

                    /**
                     * A specialized version of `_.sum` for arrays without support for callback
                     * shorthands and `this` binding..
                     *
                     * @private
                     * @param {Array} array The array to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @returns {number} Returns the sum.
                     */
                    function arraySum(array, iteratee) {
                        var length = array.length,
                            result = 0;

                        while (length--) {
                            result += +iteratee(array[length]) || 0;
                        }
                        return result;
                    }

                    /**
                     * Used by `_.defaults` to customize its `_.assign` use.
                     *
                     * @private
                     * @param {*} objectValue The destination object property value.
                     * @param {*} sourceValue The source object property value.
                     * @returns {*} Returns the value to assign to the destination object.
                     */
                    function assignDefaults(objectValue, sourceValue) {
                        return objectValue === undefined ? sourceValue : objectValue;
                    }

                    /**
                     * Used by `_.template` to customize its `_.assign` use.
                     *
                     * **Note:** This function is like `assignDefaults` except that it ignores
                     * inherited property values when checking if a property is `undefined`.
                     *
                     * @private
                     * @param {*} objectValue The destination object property value.
                     * @param {*} sourceValue The source object property value.
                     * @param {string} key The key associated with the object and source values.
                     * @param {Object} object The destination object.
                     * @returns {*} Returns the value to assign to the destination object.
                     */
                    function assignOwnDefaults(objectValue, sourceValue, key, object) {
                        return (objectValue === undefined || !hasOwnProperty.call(object, key))
                            ? sourceValue
                            : objectValue;
                    }

                    /**
                     * A specialized version of `_.assign` for customizing assigned values without
                     * support for argument juggling, multiple sources, and `this` binding `customizer`
                     * functions.
                     *
                     * @private
                     * @param {Object} object The destination object.
                     * @param {Object} source The source object.
                     * @param {Function} customizer The function to customize assigned values.
                     * @returns {Object} Returns `object`.
                     */
                    function assignWith(object, source, customizer) {
                        var index = -1,
                            props = keys(source),
                            length = props.length;

                        while (++index < length) {
                            var key = props[index],
                                value = object[key],
                                result = customizer(value, source[key], key, object, source);

                            if ((result === result ? (result !== value) : (value === value)) ||
                                (value === undefined && !(key in object))) {
                                object[key] = result;
                            }
                        }
                        return object;
                    }

                    /**
                     * The base implementation of `_.assign` without support for argument juggling,
                     * multiple sources, and `customizer` functions.
                     *
                     * @private
                     * @param {Object} object The destination object.
                     * @param {Object} source The source object.
                     * @returns {Object} Returns `object`.
                     */
                    function baseAssign(object, source) {
                        return source == null
                            ? object
                            : baseCopy(source, keys(source), object);
                    }

                    /**
                     * The base implementation of `_.at` without support for string collections
                     * and individual key arguments.
                     *
                     * @private
                     * @param {Array|Object} collection The collection to iterate over.
                     * @param {number[]|string[]} props The property names or indexes of elements to pick.
                     * @returns {Array} Returns the new array of picked elements.
                     */
                    function baseAt(collection, props) {
                        var index = -1,
                            isNil = collection == null,
                            isArr = !isNil && isArrayLike(collection),
                            length = isArr ? collection.length : 0,
                            propsLength = props.length,
                            result = Array(propsLength);

                        while (++index < propsLength) {
                            var key = props[index];
                            if (isArr) {
                                result[index] = isIndex(key, length) ? collection[key] : undefined;
                            } else {
                                result[index] = isNil ? undefined : collection[key];
                            }
                        }
                        return result;
                    }

                    /**
                     * Copies properties of `source` to `object`.
                     *
                     * @private
                     * @param {Object} source The object to copy properties from.
                     * @param {Array} props The property names to copy.
                     * @param {Object} [object={}] The object to copy properties to.
                     * @returns {Object} Returns `object`.
                     */
                    function baseCopy(source, props, object) {
                        object || (object = {});

                        var index = -1,
                            length = props.length;

                        while (++index < length) {
                            var key = props[index];
                            object[key] = source[key];
                        }
                        return object;
                    }

                    /**
                     * The base implementation of `_.callback` which supports specifying the
                     * number of arguments to provide to `func`.
                     *
                     * @private
                     * @param {*} [func=_.identity] The value to convert to a callback.
                     * @param {*} [thisArg] The `this` binding of `func`.
                     * @param {number} [argCount] The number of arguments to provide to `func`.
                     * @returns {Function} Returns the callback.
                     */
                    function baseCallback(func, thisArg, argCount) {
                        var type = typeof func;
                        if (type == 'function') {
                            return thisArg === undefined
                                ? func
                                : bindCallback(func, thisArg, argCount);
                        }
                        if (func == null) {
                            return identity;
                        }
                        if (type == 'object') {
                            return baseMatches(func);
                        }
                        return thisArg === undefined
                            ? property(func)
                            : baseMatchesProperty(func, thisArg);
                    }

                    /**
                     * The base implementation of `_.clone` without support for argument juggling
                     * and `this` binding `customizer` functions.
                     *
                     * @private
                     * @param {*} value The value to clone.
                     * @param {boolean} [isDeep] Specify a deep clone.
                     * @param {Function} [customizer] The function to customize cloning values.
                     * @param {string} [key] The key of `value`.
                     * @param {Object} [object] The object `value` belongs to.
                     * @param {Array} [stackA=[]] Tracks traversed source objects.
                     * @param {Array} [stackB=[]] Associates clones with source counterparts.
                     * @returns {*} Returns the cloned value.
                     */
                    function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {
                        var result;
                        if (customizer) {
                            result = object ? customizer(value, key, object) : customizer(value);
                        }
                        if (result !== undefined) {
                            return result;
                        }
                        if (!isObject(value)) {
                            return value;
                        }
                        var isArr = isArray(value);
                        if (isArr) {
                            result = initCloneArray(value);
                            if (!isDeep) {
                                return arrayCopy(value, result);
                            }
                        } else {
                            var tag = objToString.call(value),
                                isFunc = tag == funcTag;

                            if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
                                result = initCloneObject(isFunc ? {} : value);
                                if (!isDeep) {
                                    return baseAssign(result, value);
                                }
                            } else {
                                return cloneableTags[tag]
                                    ? initCloneByTag(value, tag, isDeep)
                                    : (object ? value : {});
                            }
                        }
                        // Check for circular references and return its corresponding clone.
                        stackA || (stackA = []);
                        stackB || (stackB = []);

                        var length = stackA.length;
                        while (length--) {
                            if (stackA[length] == value) {
                                return stackB[length];
                            }
                        }
                        // Add the source value to the stack of traversed objects and associate it with its clone.
                        stackA.push(value);
                        stackB.push(result);

                        // Recursively populate clone (susceptible to call stack limits).
                        (isArr ? arrayEach : baseForOwn)(value, function (subValue, key) {
                            result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);
                        });
                        return result;
                    }

                    /**
                     * The base implementation of `_.create` without support for assigning
                     * properties to the created object.
                     *
                     * @private
                     * @param {Object} prototype The object to inherit from.
                     * @returns {Object} Returns the new object.
                     */
                    var baseCreate = (function () {
                        function object() { }
                        return function (prototype) {
                            if (isObject(prototype)) {
                                object.prototype = prototype;
                                var result = new object;
                                object.prototype = undefined;
                            }
                            return result || {};
                        };
                    }());

                    /**
                     * The base implementation of `_.delay` and `_.defer` which accepts an index
                     * of where to slice the arguments to provide to `func`.
                     *
                     * @private
                     * @param {Function} func The function to delay.
                     * @param {number} wait The number of milliseconds to delay invocation.
                     * @param {Object} args The arguments provide to `func`.
                     * @returns {number} Returns the timer id.
                     */
                    function baseDelay(func, wait, args) {
                        if (typeof func != 'function') {
                            throw new TypeError(FUNC_ERROR_TEXT);
                        }
                        return setTimeout(function () { func.apply(undefined, args); }, wait);
                    }

                    /**
                     * The base implementation of `_.difference` which accepts a single array
                     * of values to exclude.
                     *
                     * @private
                     * @param {Array} array The array to inspect.
                     * @param {Array} values The values to exclude.
                     * @returns {Array} Returns the new array of filtered values.
                     */
                    function baseDifference(array, values) {
                        var length = array ? array.length : 0,
                            result = [];

                        if (!length) {
                            return result;
                        }
                        var index = -1,
                            indexOf = getIndexOf(),
                            isCommon = indexOf == baseIndexOf,
                            cache = (isCommon && values.length >= LARGE_ARRAY_SIZE) ? createCache(values) : null,
                            valuesLength = values.length;

                        if (cache) {
                            indexOf = cacheIndexOf;
                            isCommon = false;
                            values = cache;
                        }
                        outer:
                        while (++index < length) {
                            var value = array[index];

                            if (isCommon && value === value) {
                                var valuesIndex = valuesLength;
                                while (valuesIndex--) {
                                    if (values[valuesIndex] === value) {
                                        continue outer;
                                    }
                                }
                                result.push(value);
                            }
                            else if (indexOf(values, value, 0) < 0) {
                                result.push(value);
                            }
                        }
                        return result;
                    }

                    /**
                     * The base implementation of `_.forEach` without support for callback
                     * shorthands and `this` binding.
                     *
                     * @private
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @returns {Array|Object|string} Returns `collection`.
                     */
                    var baseEach = createBaseEach(baseForOwn);

                    /**
                     * The base implementation of `_.forEachRight` without support for callback
                     * shorthands and `this` binding.
                     *
                     * @private
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @returns {Array|Object|string} Returns `collection`.
                     */
                    var baseEachRight = createBaseEach(baseForOwnRight, true);

                    /**
                     * The base implementation of `_.every` without support for callback
                     * shorthands and `this` binding.
                     *
                     * @private
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function} predicate The function invoked per iteration.
                     * @returns {boolean} Returns `true` if all elements pass the predicate check,
                     *  else `false`
                     */
                    function baseEvery(collection, predicate) {
                        var result = true;
                        baseEach(collection, function (value, index, collection) {
                            result = !!predicate(value, index, collection);
                            return result;
                        });
                        return result;
                    }

                    /**
                     * Gets the extremum value of `collection` invoking `iteratee` for each value
                     * in `collection` to generate the criterion by which the value is ranked.
                     * The `iteratee` is invoked with three arguments: (value, index|key, collection).
                     *
                     * @private
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @param {Function} comparator The function used to compare values.
                     * @param {*} exValue The initial extremum value.
                     * @returns {*} Returns the extremum value.
                     */
                    function baseExtremum(collection, iteratee, comparator, exValue) {
                        var computed = exValue,
                            result = computed;

                        baseEach(collection, function (value, index, collection) {
                            var current = +iteratee(value, index, collection);
                            if (comparator(current, computed) || (current === exValue && current === result)) {
                                computed = current;
                                result = value;
                            }
                        });
                        return result;
                    }

                    /**
                     * The base implementation of `_.fill` without an iteratee call guard.
                     *
                     * @private
                     * @param {Array} array The array to fill.
                     * @param {*} value The value to fill `array` with.
                     * @param {number} [start=0] The start position.
                     * @param {number} [end=array.length] The end position.
                     * @returns {Array} Returns `array`.
                     */
                    function baseFill(array, value, start, end) {
                        var length = array.length;

                        start = start == null ? 0 : (+start || 0);
                        if (start < 0) {
                            start = -start > length ? 0 : (length + start);
                        }
                        end = (end === undefined || end > length) ? length : (+end || 0);
                        if (end < 0) {
                            end += length;
                        }
                        length = start > end ? 0 : (end >>> 0);
                        start >>>= 0;

                        while (start < length) {
                            array[start++] = value;
                        }
                        return array;
                    }

                    /**
                     * The base implementation of `_.filter` without support for callback
                     * shorthands and `this` binding.
                     *
                     * @private
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function} predicate The function invoked per iteration.
                     * @returns {Array} Returns the new filtered array.
                     */
                    function baseFilter(collection, predicate) {
                        var result = [];
                        baseEach(collection, function (value, index, collection) {
                            if (predicate(value, index, collection)) {
                                result.push(value);
                            }
                        });
                        return result;
                    }

                    /**
                     * The base implementation of `_.find`, `_.findLast`, `_.findKey`, and `_.findLastKey`,
                     * without support for callback shorthands and `this` binding, which iterates
                     * over `collection` using the provided `eachFunc`.
                     *
                     * @private
                     * @param {Array|Object|string} collection The collection to search.
                     * @param {Function} predicate The function invoked per iteration.
                     * @param {Function} eachFunc The function to iterate over `collection`.
                     * @param {boolean} [retKey] Specify returning the key of the found element
                     *  instead of the element itself.
                     * @returns {*} Returns the found element or its key, else `undefined`.
                     */
                    function baseFind(collection, predicate, eachFunc, retKey) {
                        var result;
                        eachFunc(collection, function (value, key, collection) {
                            if (predicate(value, key, collection)) {
                                result = retKey ? key : value;
                                return false;
                            }
                        });
                        return result;
                    }

                    /**
                     * The base implementation of `_.flatten` with added support for restricting
                     * flattening and specifying the start index.
                     *
                     * @private
                     * @param {Array} array The array to flatten.
                     * @param {boolean} [isDeep] Specify a deep flatten.
                     * @param {boolean} [isStrict] Restrict flattening to arrays-like objects.
                     * @param {Array} [result=[]] The initial result value.
                     * @returns {Array} Returns the new flattened array.
                     */
                    function baseFlatten(array, isDeep, isStrict, result) {
                        result || (result = []);

                        var index = -1,
                            length = array.length;

                        while (++index < length) {
                            var value = array[index];
                            if (isObjectLike(value) && isArrayLike(value) &&
                                (isStrict || isArray(value) || isArguments(value))) {
                                if (isDeep) {
                                    // Recursively flatten arrays (susceptible to call stack limits).
                                    baseFlatten(value, isDeep, isStrict, result);
                                } else {
                                    arrayPush(result, value);
                                }
                            } else if (!isStrict) {
                                result[result.length] = value;
                            }
                        }
                        return result;
                    }

                    /**
                     * The base implementation of `baseForIn` and `baseForOwn` which iterates
                     * over `object` properties returned by `keysFunc` invoking `iteratee` for
                     * each property. Iteratee functions may exit iteration early by explicitly
                     * returning `false`.
                     *
                     * @private
                     * @param {Object} object The object to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @param {Function} keysFunc The function to get the keys of `object`.
                     * @returns {Object} Returns `object`.
                     */
                    var baseFor = createBaseFor();

                    /**
                     * This function is like `baseFor` except that it iterates over properties
                     * in the opposite order.
                     *
                     * @private
                     * @param {Object} object The object to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @param {Function} keysFunc The function to get the keys of `object`.
                     * @returns {Object} Returns `object`.
                     */
                    var baseForRight = createBaseFor(true);

                    /**
                     * The base implementation of `_.forIn` without support for callback
                     * shorthands and `this` binding.
                     *
                     * @private
                     * @param {Object} object The object to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @returns {Object} Returns `object`.
                     */
                    function baseForIn(object, iteratee) {
                        return baseFor(object, iteratee, keysIn);
                    }

                    /**
                     * The base implementation of `_.forOwn` without support for callback
                     * shorthands and `this` binding.
                     *
                     * @private
                     * @param {Object} object The object to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @returns {Object} Returns `object`.
                     */
                    function baseForOwn(object, iteratee) {
                        return baseFor(object, iteratee, keys);
                    }

                    /**
                     * The base implementation of `_.forOwnRight` without support for callback
                     * shorthands and `this` binding.
                     *
                     * @private
                     * @param {Object} object The object to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @returns {Object} Returns `object`.
                     */
                    function baseForOwnRight(object, iteratee) {
                        return baseForRight(object, iteratee, keys);
                    }

                    /**
                     * The base implementation of `_.functions` which creates an array of
                     * `object` function property names filtered from those provided.
                     *
                     * @private
                     * @param {Object} object The object to inspect.
                     * @param {Array} props The property names to filter.
                     * @returns {Array} Returns the new array of filtered property names.
                     */
                    function baseFunctions(object, props) {
                        var index = -1,
                            length = props.length,
                            resIndex = -1,
                            result = [];

                        while (++index < length) {
                            var key = props[index];
                            if (isFunction(object[key])) {
                                result[++resIndex] = key;
                            }
                        }
                        return result;
                    }

                    /**
                     * The base implementation of `get` without support for string paths
                     * and default values.
                     *
                     * @private
                     * @param {Object} object The object to query.
                     * @param {Array} path The path of the property to get.
                     * @param {string} [pathKey] The key representation of path.
                     * @returns {*} Returns the resolved value.
                     */
                    function baseGet(object, path, pathKey) {
                        if (object == null) {
                            return;
                        }
                        if (pathKey !== undefined && pathKey in toObject(object)) {
                            path = [pathKey];
                        }
                        var index = 0,
                            length = path.length;

                        while (object != null && index < length) {
                            object = object[path[index++]];
                        }
                        return (index && index == length) ? object : undefined;
                    }

                    /**
                     * The base implementation of `_.isEqual` without support for `this` binding
                     * `customizer` functions.
                     *
                     * @private
                     * @param {*} value The value to compare.
                     * @param {*} other The other value to compare.
                     * @param {Function} [customizer] The function to customize comparing values.
                     * @param {boolean} [isLoose] Specify performing partial comparisons.
                     * @param {Array} [stackA] Tracks traversed `value` objects.
                     * @param {Array} [stackB] Tracks traversed `other` objects.
                     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
                     */
                    function baseIsEqual(value, other, customizer, isLoose, stackA, stackB) {
                        if (value === other) {
                            return true;
                        }
                        if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
                            return value !== value && other !== other;
                        }
                        return baseIsEqualDeep(value, other, baseIsEqual, customizer, isLoose, stackA, stackB);
                    }

                    /**
                     * A specialized version of `baseIsEqual` for arrays and objects which performs
                     * deep comparisons and tracks traversed objects enabling objects with circular
                     * references to be compared.
                     *
                     * @private
                     * @param {Object} object The object to compare.
                     * @param {Object} other The other object to compare.
                     * @param {Function} equalFunc The function to determine equivalents of values.
                     * @param {Function} [customizer] The function to customize comparing objects.
                     * @param {boolean} [isLoose] Specify performing partial comparisons.
                     * @param {Array} [stackA=[]] Tracks traversed `value` objects.
                     * @param {Array} [stackB=[]] Tracks traversed `other` objects.
                     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
                     */
                    function baseIsEqualDeep(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
                        var objIsArr = isArray(object),
                            othIsArr = isArray(other),
                            objTag = arrayTag,
                            othTag = arrayTag;

                        if (!objIsArr) {
                            objTag = objToString.call(object);
                            if (objTag == argsTag) {
                                objTag = objectTag;
                            } else if (objTag != objectTag) {
                                objIsArr = isTypedArray(object);
                            }
                        }
                        if (!othIsArr) {
                            othTag = objToString.call(other);
                            if (othTag == argsTag) {
                                othTag = objectTag;
                            } else if (othTag != objectTag) {
                                othIsArr = isTypedArray(other);
                            }
                        }
                        var objIsObj = objTag == objectTag,
                            othIsObj = othTag == objectTag,
                            isSameTag = objTag == othTag;

                        if (isSameTag && !(objIsArr || objIsObj)) {
                            return equalByTag(object, other, objTag);
                        }
                        if (!isLoose) {
                            var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
                                othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

                            if (objIsWrapped || othIsWrapped) {
                                return equalFunc(objIsWrapped ? object.value() : object, othIsWrapped ? other.value() : other, customizer, isLoose, stackA, stackB);
                            }
                        }
                        if (!isSameTag) {
                            return false;
                        }
                        // Assume cyclic values are equal.
                        // For more information on detecting circular references see https://es5.github.io/#JO.
                        stackA || (stackA = []);
                        stackB || (stackB = []);

                        var length = stackA.length;
                        while (length--) {
                            if (stackA[length] == object) {
                                return stackB[length] == other;
                            }
                        }
                        // Add `object` and `other` to the stack of traversed objects.
                        stackA.push(object);
                        stackB.push(other);

                        var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isLoose, stackA, stackB);

                        stackA.pop();
                        stackB.pop();

                        return result;
                    }

                    /**
                     * The base implementation of `_.isMatch` without support for callback
                     * shorthands and `this` binding.
                     *
                     * @private
                     * @param {Object} object The object to inspect.
                     * @param {Array} matchData The propery names, values, and compare flags to match.
                     * @param {Function} [customizer] The function to customize comparing objects.
                     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
                     */
                    function baseIsMatch(object, matchData, customizer) {
                        var index = matchData.length,
                            length = index,
                            noCustomizer = !customizer;

                        if (object == null) {
                            return !length;
                        }
                        object = toObject(object);
                        while (index--) {
                            var data = matchData[index];
                            if ((noCustomizer && data[2])
                                ? data[1] !== object[data[0]]
                                : !(data[0] in object)
                            ) {
                                return false;
                            }
                        }
                        while (++index < length) {
                            data = matchData[index];
                            var key = data[0],
                                objValue = object[key],
                                srcValue = data[1];

                            if (noCustomizer && data[2]) {
                                if (objValue === undefined && !(key in object)) {
                                    return false;
                                }
                            } else {
                                var result = customizer ? customizer(objValue, srcValue, key) : undefined;
                                if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, true) : result)) {
                                    return false;
                                }
                            }
                        }
                        return true;
                    }

                    /**
                     * The base implementation of `_.map` without support for callback shorthands
                     * and `this` binding.
                     *
                     * @private
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @returns {Array} Returns the new mapped array.
                     */
                    function baseMap(collection, iteratee) {
                        var index = -1,
                            result = isArrayLike(collection) ? Array(collection.length) : [];

                        baseEach(collection, function (value, key, collection) {
                            result[++index] = iteratee(value, key, collection);
                        });
                        return result;
                    }

                    /**
                     * The base implementation of `_.matches` which does not clone `source`.
                     *
                     * @private
                     * @param {Object} source The object of property values to match.
                     * @returns {Function} Returns the new function.
                     */
                    function baseMatches(source) {
                        var matchData = getMatchData(source);
                        if (matchData.length == 1 && matchData[0][2]) {
                            var key = matchData[0][0],
                                value = matchData[0][1];

                            return function (object) {
                                if (object == null) {
                                    return false;
                                }
                                return object[key] === value && (value !== undefined || (key in toObject(object)));
                            };
                        }
                        return function (object) {
                            return baseIsMatch(object, matchData);
                        };
                    }

                    /**
                     * The base implementation of `_.matchesProperty` which does not clone `srcValue`.
                     *
                     * @private
                     * @param {string} path The path of the property to get.
                     * @param {*} srcValue The value to compare.
                     * @returns {Function} Returns the new function.
                     */
                    function baseMatchesProperty(path, srcValue) {
                        var isArr = isArray(path),
                            isCommon = isKey(path) && isStrictComparable(srcValue),
                            pathKey = (path + '');

                        path = toPath(path);
                        return function (object) {
                            if (object == null) {
                                return false;
                            }
                            var key = pathKey;
                            object = toObject(object);
                            if ((isArr || !isCommon) && !(key in object)) {
                                object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
                                if (object == null) {
                                    return false;
                                }
                                key = last(path);
                                object = toObject(object);
                            }
                            return object[key] === srcValue
                                ? (srcValue !== undefined || (key in object))
                                : baseIsEqual(srcValue, object[key], undefined, true);
                        };
                    }

                    /**
                     * The base implementation of `_.merge` without support for argument juggling,
                     * multiple sources, and `this` binding `customizer` functions.
                     *
                     * @private
                     * @param {Object} object The destination object.
                     * @param {Object} source The source object.
                     * @param {Function} [customizer] The function to customize merged values.
                     * @param {Array} [stackA=[]] Tracks traversed source objects.
                     * @param {Array} [stackB=[]] Associates values with source counterparts.
                     * @returns {Object} Returns `object`.
                     */
                    function baseMerge(object, source, customizer, stackA, stackB) {
                        if (!isObject(object)) {
                            return object;
                        }
                        var isSrcArr = isArrayLike(source) && (isArray(source) || isTypedArray(source)),
                            props = isSrcArr ? undefined : keys(source);

                        arrayEach(props || source, function (srcValue, key) {
                            if (props) {
                                key = srcValue;
                                srcValue = source[key];
                            }
                            if (isObjectLike(srcValue)) {
                                stackA || (stackA = []);
                                stackB || (stackB = []);
                                baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);
                            }
                            else {
                                var value = object[key],
                                    result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
                                    isCommon = result === undefined;

                                if (isCommon) {
                                    result = srcValue;
                                }
                                if ((result !== undefined || (isSrcArr && !(key in object))) &&
                                    (isCommon || (result === result ? (result !== value) : (value === value)))) {
                                    object[key] = result;
                                }
                            }
                        });
                        return object;
                    }

                    /**
                     * A specialized version of `baseMerge` for arrays and objects which performs
                     * deep merges and tracks traversed objects enabling objects with circular
                     * references to be merged.
                     *
                     * @private
                     * @param {Object} object The destination object.
                     * @param {Object} source The source object.
                     * @param {string} key The key of the value to merge.
                     * @param {Function} mergeFunc The function to merge values.
                     * @param {Function} [customizer] The function to customize merged values.
                     * @param {Array} [stackA=[]] Tracks traversed source objects.
                     * @param {Array} [stackB=[]] Associates values with source counterparts.
                     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
                     */
                    function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {
                        var length = stackA.length,
                            srcValue = source[key];

                        while (length--) {
                            if (stackA[length] == srcValue) {
                                object[key] = stackB[length];
                                return;
                            }
                        }
                        var value = object[key],
                            result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
                            isCommon = result === undefined;

                        if (isCommon) {
                            result = srcValue;
                            if (isArrayLike(srcValue) && (isArray(srcValue) || isTypedArray(srcValue))) {
                                result = isArray(value)
                                    ? value
                                    : (isArrayLike(value) ? arrayCopy(value) : []);
                            }
                            else if (isPlainObject(srcValue) || isArguments(srcValue)) {
                                result = isArguments(value)
                                    ? toPlainObject(value)
                                    : (isPlainObject(value) ? value : {});
                            }
                            else {
                                isCommon = false;
                            }
                        }
                        // Add the source value to the stack of traversed objects and associate
                        // it with its merged value.
                        stackA.push(srcValue);
                        stackB.push(result);

                        if (isCommon) {
                            // Recursively merge objects and arrays (susceptible to call stack limits).
                            object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);
                        } else if (result === result ? (result !== value) : (value === value)) {
                            object[key] = result;
                        }
                    }

                    /**
                     * The base implementation of `_.property` without support for deep paths.
                     *
                     * @private
                     * @param {string} key The key of the property to get.
                     * @returns {Function} Returns the new function.
                     */
                    function baseProperty(key) {
                        return function (object) {
                            return object == null ? undefined : object[key];
                        };
                    }

                    /**
                     * A specialized version of `baseProperty` which supports deep paths.
                     *
                     * @private
                     * @param {Array|string} path The path of the property to get.
                     * @returns {Function} Returns the new function.
                     */
                    function basePropertyDeep(path) {
                        var pathKey = (path + '');
                        path = toPath(path);
                        return function (object) {
                            return baseGet(object, path, pathKey);
                        };
                    }

                    /**
                     * The base implementation of `_.pullAt` without support for individual
                     * index arguments and capturing the removed elements.
                     *
                     * @private
                     * @param {Array} array The array to modify.
                     * @param {number[]} indexes The indexes of elements to remove.
                     * @returns {Array} Returns `array`.
                     */
                    function basePullAt(array, indexes) {
                        var length = array ? indexes.length : 0;
                        while (length--) {
                            var index = indexes[length];
                            if (index != previous && isIndex(index)) {
                                var previous = index;
                                splice.call(array, index, 1);
                            }
                        }
                        return array;
                    }

                    /**
                     * The base implementation of `_.random` without support for argument juggling
                     * and returning floating-point numbers.
                     *
                     * @private
                     * @param {number} min The minimum possible value.
                     * @param {number} max The maximum possible value.
                     * @returns {number} Returns the random number.
                     */
                    function baseRandom(min, max) {
                        return min + nativeFloor(nativeRandom() * (max - min + 1));
                    }

                    /**
                     * The base implementation of `_.reduce` and `_.reduceRight` without support
                     * for callback shorthands and `this` binding, which iterates over `collection`
                     * using the provided `eachFunc`.
                     *
                     * @private
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @param {*} accumulator The initial value.
                     * @param {boolean} initFromCollection Specify using the first or last element
                     *  of `collection` as the initial value.
                     * @param {Function} eachFunc The function to iterate over `collection`.
                     * @returns {*} Returns the accumulated value.
                     */
                    function baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {
                        eachFunc(collection, function (value, index, collection) {
                            accumulator = initFromCollection
                                ? (initFromCollection = false, value)
                                : iteratee(accumulator, value, index, collection);
                        });
                        return accumulator;
                    }

                    /**
                     * The base implementation of `setData` without support for hot loop detection.
                     *
                     * @private
                     * @param {Function} func The function to associate metadata with.
                     * @param {*} data The metadata.
                     * @returns {Function} Returns `func`.
                     */
                    var baseSetData = !metaMap ? identity : function (func, data) {
                        metaMap.set(func, data);
                        return func;
                    };

                    /**
                     * The base implementation of `_.slice` without an iteratee call guard.
                     *
                     * @private
                     * @param {Array} array The array to slice.
                     * @param {number} [start=0] The start position.
                     * @param {number} [end=array.length] The end position.
                     * @returns {Array} Returns the slice of `array`.
                     */
                    function baseSlice(array, start, end) {
                        var index = -1,
                            length = array.length;

                        start = start == null ? 0 : (+start || 0);
                        if (start < 0) {
                            start = -start > length ? 0 : (length + start);
                        }
                        end = (end === undefined || end > length) ? length : (+end || 0);
                        if (end < 0) {
                            end += length;
                        }
                        length = start > end ? 0 : ((end - start) >>> 0);
                        start >>>= 0;

                        var result = Array(length);
                        while (++index < length) {
                            result[index] = array[index + start];
                        }
                        return result;
                    }

                    /**
                     * The base implementation of `_.some` without support for callback shorthands
                     * and `this` binding.
                     *
                     * @private
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function} predicate The function invoked per iteration.
                     * @returns {boolean} Returns `true` if any element passes the predicate check,
                     *  else `false`.
                     */
                    function baseSome(collection, predicate) {
                        var result;

                        baseEach(collection, function (value, index, collection) {
                            result = predicate(value, index, collection);
                            return !result;
                        });
                        return !!result;
                    }

                    /**
                     * The base implementation of `_.sortBy` which uses `comparer` to define
                     * the sort order of `array` and replaces criteria objects with their
                     * corresponding values.
                     *
                     * @private
                     * @param {Array} array The array to sort.
                     * @param {Function} comparer The function to define sort order.
                     * @returns {Array} Returns `array`.
                     */
                    function baseSortBy(array, comparer) {
                        var length = array.length;

                        array.sort(comparer);
                        while (length--) {
                            array[length] = array[length].value;
                        }
                        return array;
                    }

                    /**
                     * The base implementation of `_.sortByOrder` without param guards.
                     *
                     * @private
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
                     * @param {boolean[]} orders The sort orders of `iteratees`.
                     * @returns {Array} Returns the new sorted array.
                     */
                    function baseSortByOrder(collection, iteratees, orders) {
                        var callback = getCallback(),
                            index = -1;

                        iteratees = arrayMap(iteratees, function (iteratee) { return callback(iteratee); });

                        var result = baseMap(collection, function (value) {
                            var criteria = arrayMap(iteratees, function (iteratee) { return iteratee(value); });
                            return { 'criteria': criteria, 'index': ++index, 'value': value };
                        });

                        return baseSortBy(result, function (object, other) {
                            return compareMultiple(object, other, orders);
                        });
                    }

                    /**
                     * The base implementation of `_.sum` without support for callback shorthands
                     * and `this` binding.
                     *
                     * @private
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @returns {number} Returns the sum.
                     */
                    function baseSum(collection, iteratee) {
                        var result = 0;
                        baseEach(collection, function (value, index, collection) {
                            result += +iteratee(value, index, collection) || 0;
                        });
                        return result;
                    }

                    /**
                     * The base implementation of `_.uniq` without support for callback shorthands
                     * and `this` binding.
                     *
                     * @private
                     * @param {Array} array The array to inspect.
                     * @param {Function} [iteratee] The function invoked per iteration.
                     * @returns {Array} Returns the new duplicate-value-free array.
                     */
                    function baseUniq(array, iteratee) {
                        var index = -1,
                            indexOf = getIndexOf(),
                            length = array.length,
                            isCommon = indexOf == baseIndexOf,
                            isLarge = isCommon && length >= LARGE_ARRAY_SIZE,
                            seen = isLarge ? createCache() : null,
                            result = [];

                        if (seen) {
                            indexOf = cacheIndexOf;
                            isCommon = false;
                        } else {
                            isLarge = false;
                            seen = iteratee ? [] : result;
                        }
                        outer:
                        while (++index < length) {
                            var value = array[index],
                                computed = iteratee ? iteratee(value, index, array) : value;

                            if (isCommon && value === value) {
                                var seenIndex = seen.length;
                                while (seenIndex--) {
                                    if (seen[seenIndex] === computed) {
                                        continue outer;
                                    }
                                }
                                if (iteratee) {
                                    seen.push(computed);
                                }
                                result.push(value);
                            }
                            else if (indexOf(seen, computed, 0) < 0) {
                                if (iteratee || isLarge) {
                                    seen.push(computed);
                                }
                                result.push(value);
                            }
                        }
                        return result;
                    }

                    /**
                     * The base implementation of `_.values` and `_.valuesIn` which creates an
                     * array of `object` property values corresponding to the property names
                     * of `props`.
                     *
                     * @private
                     * @param {Object} object The object to query.
                     * @param {Array} props The property names to get values for.
                     * @returns {Object} Returns the array of property values.
                     */
                    function baseValues(object, props) {
                        var index = -1,
                            length = props.length,
                            result = Array(length);

                        while (++index < length) {
                            result[index] = object[props[index]];
                        }
                        return result;
                    }

                    /**
                     * The base implementation of `_.dropRightWhile`, `_.dropWhile`, `_.takeRightWhile`,
                     * and `_.takeWhile` without support for callback shorthands and `this` binding.
                     *
                     * @private
                     * @param {Array} array The array to query.
                     * @param {Function} predicate The function invoked per iteration.
                     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
                     * @param {boolean} [fromRight] Specify iterating from right to left.
                     * @returns {Array} Returns the slice of `array`.
                     */
                    function baseWhile(array, predicate, isDrop, fromRight) {
                        var length = array.length,
                            index = fromRight ? length : -1;

                        while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) { }
                        return isDrop
                            ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
                            : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
                    }

                    /**
                     * The base implementation of `wrapperValue` which returns the result of
                     * performing a sequence of actions on the unwrapped `value`, where each
                     * successive action is supplied the return value of the previous.
                     *
                     * @private
                     * @param {*} value The unwrapped value.
                     * @param {Array} actions Actions to peform to resolve the unwrapped value.
                     * @returns {*} Returns the resolved value.
                     */
                    function baseWrapperValue(value, actions) {
                        var result = value;
                        if (result instanceof LazyWrapper) {
                            result = result.value();
                        }
                        var index = -1,
                            length = actions.length;

                        while (++index < length) {
                            var action = actions[index];
                            result = action.func.apply(action.thisArg, arrayPush([result], action.args));
                        }
                        return result;
                    }

                    /**
                     * Performs a binary search of `array` to determine the index at which `value`
                     * should be inserted into `array` in order to maintain its sort order.
                     *
                     * @private
                     * @param {Array} array The sorted array to inspect.
                     * @param {*} value The value to evaluate.
                     * @param {boolean} [retHighest] Specify returning the highest qualified index.
                     * @returns {number} Returns the index at which `value` should be inserted
                     *  into `array`.
                     */
                    function binaryIndex(array, value, retHighest) {
                        var low = 0,
                            high = array ? array.length : low;

                        if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
                            while (low < high) {
                                var mid = (low + high) >>> 1,
                                    computed = array[mid];

                                if ((retHighest ? (computed <= value) : (computed < value)) && computed !== null) {
                                    low = mid + 1;
                                } else {
                                    high = mid;
                                }
                            }
                            return high;
                        }
                        return binaryIndexBy(array, value, identity, retHighest);
                    }

                    /**
                     * This function is like `binaryIndex` except that it invokes `iteratee` for
                     * `value` and each element of `array` to compute their sort ranking. The
                     * iteratee is invoked with one argument; (value).
                     *
                     * @private
                     * @param {Array} array The sorted array to inspect.
                     * @param {*} value The value to evaluate.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @param {boolean} [retHighest] Specify returning the highest qualified index.
                     * @returns {number} Returns the index at which `value` should be inserted
                     *  into `array`.
                     */
                    function binaryIndexBy(array, value, iteratee, retHighest) {
                        value = iteratee(value);

                        var low = 0,
                            high = array ? array.length : 0,
                            valIsNaN = value !== value,
                            valIsNull = value === null,
                            valIsUndef = value === undefined;

                        while (low < high) {
                            var mid = nativeFloor((low + high) / 2),
                                computed = iteratee(array[mid]),
                                isDef = computed !== undefined,
                                isReflexive = computed === computed;

                            if (valIsNaN) {
                                var setLow = isReflexive || retHighest;
                            } else if (valIsNull) {
                                setLow = isReflexive && isDef && (retHighest || computed != null);
                            } else if (valIsUndef) {
                                setLow = isReflexive && (retHighest || isDef);
                            } else if (computed == null) {
                                setLow = false;
                            } else {
                                setLow = retHighest ? (computed <= value) : (computed < value);
                            }
                            if (setLow) {
                                low = mid + 1;
                            } else {
                                high = mid;
                            }
                        }
                        return nativeMin(high, MAX_ARRAY_INDEX);
                    }

                    /**
                     * A specialized version of `baseCallback` which only supports `this` binding
                     * and specifying the number of arguments to provide to `func`.
                     *
                     * @private
                     * @param {Function} func The function to bind.
                     * @param {*} thisArg The `this` binding of `func`.
                     * @param {number} [argCount] The number of arguments to provide to `func`.
                     * @returns {Function} Returns the callback.
                     */
                    function bindCallback(func, thisArg, argCount) {
                        if (typeof func != 'function') {
                            return identity;
                        }
                        if (thisArg === undefined) {
                            return func;
                        }
                        switch (argCount) {
                            case 1: return function (value) {
                                return func.call(thisArg, value);
                            };
                            case 3: return function (value, index, collection) {
                                return func.call(thisArg, value, index, collection);
                            };
                            case 4: return function (accumulator, value, index, collection) {
                                return func.call(thisArg, accumulator, value, index, collection);
                            };
                            case 5: return function (value, other, key, object, source) {
                                return func.call(thisArg, value, other, key, object, source);
                            };
                        }
                        return function () {
                            return func.apply(thisArg, arguments);
                        };
                    }

                    /**
                     * Creates a clone of the given array buffer.
                     *
                     * @private
                     * @param {ArrayBuffer} buffer The array buffer to clone.
                     * @returns {ArrayBuffer} Returns the cloned array buffer.
                     */
                    function bufferClone(buffer) {
                        var result = new ArrayBuffer(buffer.byteLength),
                            view = new Uint8Array(result);

                        view.set(new Uint8Array(buffer));
                        return result;
                    }

                    /**
                     * Creates an array that is the composition of partially applied arguments,
                     * placeholders, and provided arguments into a single array of arguments.
                     *
                     * @private
                     * @param {Array|Object} args The provided arguments.
                     * @param {Array} partials The arguments to prepend to those provided.
                     * @param {Array} holders The `partials` placeholder indexes.
                     * @returns {Array} Returns the new array of composed arguments.
                     */
                    function composeArgs(args, partials, holders) {
                        var holdersLength = holders.length,
                            argsIndex = -1,
                            argsLength = nativeMax(args.length - holdersLength, 0),
                            leftIndex = -1,
                            leftLength = partials.length,
                            result = Array(leftLength + argsLength);

                        while (++leftIndex < leftLength) {
                            result[leftIndex] = partials[leftIndex];
                        }
                        while (++argsIndex < holdersLength) {
                            result[holders[argsIndex]] = args[argsIndex];
                        }
                        while (argsLength--) {
                            result[leftIndex++] = args[argsIndex++];
                        }
                        return result;
                    }

                    /**
                     * This function is like `composeArgs` except that the arguments composition
                     * is tailored for `_.partialRight`.
                     *
                     * @private
                     * @param {Array|Object} args The provided arguments.
                     * @param {Array} partials The arguments to append to those provided.
                     * @param {Array} holders The `partials` placeholder indexes.
                     * @returns {Array} Returns the new array of composed arguments.
                     */
                    function composeArgsRight(args, partials, holders) {
                        var holdersIndex = -1,
                            holdersLength = holders.length,
                            argsIndex = -1,
                            argsLength = nativeMax(args.length - holdersLength, 0),
                            rightIndex = -1,
                            rightLength = partials.length,
                            result = Array(argsLength + rightLength);

                        while (++argsIndex < argsLength) {
                            result[argsIndex] = args[argsIndex];
                        }
                        var offset = argsIndex;
                        while (++rightIndex < rightLength) {
                            result[offset + rightIndex] = partials[rightIndex];
                        }
                        while (++holdersIndex < holdersLength) {
                            result[offset + holders[holdersIndex]] = args[argsIndex++];
                        }
                        return result;
                    }

                    /**
                     * Creates a `_.countBy`, `_.groupBy`, `_.indexBy`, or `_.partition` function.
                     *
                     * @private
                     * @param {Function} setter The function to set keys and values of the accumulator object.
                     * @param {Function} [initializer] The function to initialize the accumulator object.
                     * @returns {Function} Returns the new aggregator function.
                     */
                    function createAggregator(setter, initializer) {
                        return function (collection, iteratee, thisArg) {
                            var result = initializer ? initializer() : {};
                            iteratee = getCallback(iteratee, thisArg, 3);

                            if (isArray(collection)) {
                                var index = -1,
                                    length = collection.length;

                                while (++index < length) {
                                    var value = collection[index];
                                    setter(result, value, iteratee(value, index, collection), collection);
                                }
                            } else {
                                baseEach(collection, function (value, key, collection) {
                                    setter(result, value, iteratee(value, key, collection), collection);
                                });
                            }
                            return result;
                        };
                    }

                    /**
                     * Creates a `_.assign`, `_.defaults`, or `_.merge` function.
                     *
                     * @private
                     * @param {Function} assigner The function to assign values.
                     * @returns {Function} Returns the new assigner function.
                     */
                    function createAssigner(assigner) {
                        return restParam(function (object, sources) {
                            var index = -1,
                                length = object == null ? 0 : sources.length,
                                customizer = length > 2 ? sources[length - 2] : undefined,
                                guard = length > 2 ? sources[2] : undefined,
                                thisArg = length > 1 ? sources[length - 1] : undefined;

                            if (typeof customizer == 'function') {
                                customizer = bindCallback(customizer, thisArg, 5);
                                length -= 2;
                            } else {
                                customizer = typeof thisArg == 'function' ? thisArg : undefined;
                                length -= (customizer ? 1 : 0);
                            }
                            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                                customizer = length < 3 ? undefined : customizer;
                                length = 1;
                            }
                            while (++index < length) {
                                var source = sources[index];
                                if (source) {
                                    assigner(object, source, customizer);
                                }
                            }
                            return object;
                        });
                    }

                    /**
                     * Creates a `baseEach` or `baseEachRight` function.
                     *
                     * @private
                     * @param {Function} eachFunc The function to iterate over a collection.
                     * @param {boolean} [fromRight] Specify iterating from right to left.
                     * @returns {Function} Returns the new base function.
                     */
                    function createBaseEach(eachFunc, fromRight) {
                        return function (collection, iteratee) {
                            var length = collection ? getLength(collection) : 0;
                            if (!isLength(length)) {
                                return eachFunc(collection, iteratee);
                            }
                            var index = fromRight ? length : -1,
                                iterable = toObject(collection);

                            while ((fromRight ? index-- : ++index < length)) {
                                if (iteratee(iterable[index], index, iterable) === false) {
                                    break;
                                }
                            }
                            return collection;
                        };
                    }

                    /**
                     * Creates a base function for `_.forIn` or `_.forInRight`.
                     *
                     * @private
                     * @param {boolean} [fromRight] Specify iterating from right to left.
                     * @returns {Function} Returns the new base function.
                     */
                    function createBaseFor(fromRight) {
                        return function (object, iteratee, keysFunc) {
                            var iterable = toObject(object),
                                props = keysFunc(object),
                                length = props.length,
                                index = fromRight ? length : -1;

                            while ((fromRight ? index-- : ++index < length)) {
                                var key = props[index];
                                if (iteratee(iterable[key], key, iterable) === false) {
                                    break;
                                }
                            }
                            return object;
                        };
                    }

                    /**
                     * Creates a function that wraps `func` and invokes it with the `this`
                     * binding of `thisArg`.
                     *
                     * @private
                     * @param {Function} func The function to bind.
                     * @param {*} [thisArg] The `this` binding of `func`.
                     * @returns {Function} Returns the new bound function.
                     */
                    function createBindWrapper(func, thisArg) {
                        var Ctor = createCtorWrapper(func);

                        function wrapper() {
                            var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
                            return fn.apply(thisArg, arguments);
                        }
                        return wrapper;
                    }

                    /**
                     * Creates a `Set` cache object to optimize linear searches of large arrays.
                     *
                     * @private
                     * @param {Array} [values] The values to cache.
                     * @returns {null|Object} Returns the new cache object if `Set` is supported, else `null`.
                     */
                    function createCache(values) {
                        return (nativeCreate && Set) ? new SetCache(values) : null;
                    }

                    /**
                     * Creates a function that produces compound words out of the words in a
                     * given string.
                     *
                     * @private
                     * @param {Function} callback The function to combine each word.
                     * @returns {Function} Returns the new compounder function.
                     */
                    function createCompounder(callback) {
                        return function (string) {
                            var index = -1,
                                array = words(deburr(string)),
                                length = array.length,
                                result = '';

                            while (++index < length) {
                                result = callback(result, array[index], index);
                            }
                            return result;
                        };
                    }

                    /**
                     * Creates a function that produces an instance of `Ctor` regardless of
                     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
                     *
                     * @private
                     * @param {Function} Ctor The constructor to wrap.
                     * @returns {Function} Returns the new wrapped function.
                     */
                    function createCtorWrapper(Ctor) {
                        return function () {
                            // Use a `switch` statement to work with class constructors.
                            // See http://ecma-international.org/ecma-262/6.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
                            // for more details.
                            var args = arguments;
                            switch (args.length) {
                                case 0: return new Ctor;
                                case 1: return new Ctor(args[0]);
                                case 2: return new Ctor(args[0], args[1]);
                                case 3: return new Ctor(args[0], args[1], args[2]);
                                case 4: return new Ctor(args[0], args[1], args[2], args[3]);
                                case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
                                case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
                                case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
                            }
                            var thisBinding = baseCreate(Ctor.prototype),
                                result = Ctor.apply(thisBinding, args);

                            // Mimic the constructor's `return` behavior.
                            // See https://es5.github.io/#x13.2.2 for more details.
                            return isObject(result) ? result : thisBinding;
                        };
                    }

                    /**
                     * Creates a `_.curry` or `_.curryRight` function.
                     *
                     * @private
                     * @param {boolean} flag The curry bit flag.
                     * @returns {Function} Returns the new curry function.
                     */
                    function createCurry(flag) {
                        function curryFunc(func, arity, guard) {
                            if (guard && isIterateeCall(func, arity, guard)) {
                                arity = undefined;
                            }
                            var result = createWrapper(func, flag, undefined, undefined, undefined, undefined, undefined, arity);
                            result.placeholder = curryFunc.placeholder;
                            return result;
                        }
                        return curryFunc;
                    }

                    /**
                     * Creates a `_.defaults` or `_.defaultsDeep` function.
                     *
                     * @private
                     * @param {Function} assigner The function to assign values.
                     * @param {Function} customizer The function to customize assigned values.
                     * @returns {Function} Returns the new defaults function.
                     */
                    function createDefaults(assigner, customizer) {
                        return restParam(function (args) {
                            var object = args[0];
                            if (object == null) {
                                return object;
                            }
                            args.push(customizer);
                            return assigner.apply(undefined, args);
                        });
                    }

                    /**
                     * Creates a `_.max` or `_.min` function.
                     *
                     * @private
                     * @param {Function} comparator The function used to compare values.
                     * @param {*} exValue The initial extremum value.
                     * @returns {Function} Returns the new extremum function.
                     */
                    function createExtremum(comparator, exValue) {
                        return function (collection, iteratee, thisArg) {
                            if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
                                iteratee = undefined;
                            }
                            iteratee = getCallback(iteratee, thisArg, 3);
                            if (iteratee.length == 1) {
                                collection = isArray(collection) ? collection : toIterable(collection);
                                var result = arrayExtremum(collection, iteratee, comparator, exValue);
                                if (!(collection.length && result === exValue)) {
                                    return result;
                                }
                            }
                            return baseExtremum(collection, iteratee, comparator, exValue);
                        };
                    }

                    /**
                     * Creates a `_.find` or `_.findLast` function.
                     *
                     * @private
                     * @param {Function} eachFunc The function to iterate over a collection.
                     * @param {boolean} [fromRight] Specify iterating from right to left.
                     * @returns {Function} Returns the new find function.
                     */
                    function createFind(eachFunc, fromRight) {
                        return function (collection, predicate, thisArg) {
                            predicate = getCallback(predicate, thisArg, 3);
                            if (isArray(collection)) {
                                var index = baseFindIndex(collection, predicate, fromRight);
                                return index > -1 ? collection[index] : undefined;
                            }
                            return baseFind(collection, predicate, eachFunc);
                        };
                    }

                    /**
                     * Creates a `_.findIndex` or `_.findLastIndex` function.
                     *
                     * @private
                     * @param {boolean} [fromRight] Specify iterating from right to left.
                     * @returns {Function} Returns the new find function.
                     */
                    function createFindIndex(fromRight) {
                        return function (array, predicate, thisArg) {
                            if (!(array && array.length)) {
                                return -1;
                            }
                            predicate = getCallback(predicate, thisArg, 3);
                            return baseFindIndex(array, predicate, fromRight);
                        };
                    }

                    /**
                     * Creates a `_.findKey` or `_.findLastKey` function.
                     *
                     * @private
                     * @param {Function} objectFunc The function to iterate over an object.
                     * @returns {Function} Returns the new find function.
                     */
                    function createFindKey(objectFunc) {
                        return function (object, predicate, thisArg) {
                            predicate = getCallback(predicate, thisArg, 3);
                            return baseFind(object, predicate, objectFunc, true);
                        };
                    }

                    /**
                     * Creates a `_.flow` or `_.flowRight` function.
                     *
                     * @private
                     * @param {boolean} [fromRight] Specify iterating from right to left.
                     * @returns {Function} Returns the new flow function.
                     */
                    function createFlow(fromRight) {
                        return function () {
                            var wrapper,
                                length = arguments.length,
                                index = fromRight ? length : -1,
                                leftIndex = 0,
                                funcs = Array(length);

                            while ((fromRight ? index-- : ++index < length)) {
                                var func = funcs[leftIndex++] = arguments[index];
                                if (typeof func != 'function') {
                                    throw new TypeError(FUNC_ERROR_TEXT);
                                }
                                if (!wrapper && LodashWrapper.prototype.thru && getFuncName(func) == 'wrapper') {
                                    wrapper = new LodashWrapper([], true);
                                }
                            }
                            index = wrapper ? -1 : length;
                            while (++index < length) {
                                func = funcs[index];

                                var funcName = getFuncName(func),
                                    data = funcName == 'wrapper' ? getData(func) : undefined;

                                if (data && isLaziable(data[0]) && data[1] == (ARY_FLAG | CURRY_FLAG | PARTIAL_FLAG | REARG_FLAG) && !data[4].length && data[9] == 1) {
                                    wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
                                } else {
                                    wrapper = (func.length == 1 && isLaziable(func)) ? wrapper[funcName]() : wrapper.thru(func);
                                }
                            }
                            return function () {
                                var args = arguments,
                                    value = args[0];

                                if (wrapper && args.length == 1 && isArray(value) && value.length >= LARGE_ARRAY_SIZE) {
                                    return wrapper.plant(value).value();
                                }
                                var index = 0,
                                    result = length ? funcs[index].apply(this, args) : value;

                                while (++index < length) {
                                    result = funcs[index].call(this, result);
                                }
                                return result;
                            };
                        };
                    }

                    /**
                     * Creates a function for `_.forEach` or `_.forEachRight`.
                     *
                     * @private
                     * @param {Function} arrayFunc The function to iterate over an array.
                     * @param {Function} eachFunc The function to iterate over a collection.
                     * @returns {Function} Returns the new each function.
                     */
                    function createForEach(arrayFunc, eachFunc) {
                        return function (collection, iteratee, thisArg) {
                            return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))
                                ? arrayFunc(collection, iteratee)
                                : eachFunc(collection, bindCallback(iteratee, thisArg, 3));
                        };
                    }

                    /**
                     * Creates a function for `_.forIn` or `_.forInRight`.
                     *
                     * @private
                     * @param {Function} objectFunc The function to iterate over an object.
                     * @returns {Function} Returns the new each function.
                     */
                    function createForIn(objectFunc) {
                        return function (object, iteratee, thisArg) {
                            if (typeof iteratee != 'function' || thisArg !== undefined) {
                                iteratee = bindCallback(iteratee, thisArg, 3);
                            }
                            return objectFunc(object, iteratee, keysIn);
                        };
                    }

                    /**
                     * Creates a function for `_.forOwn` or `_.forOwnRight`.
                     *
                     * @private
                     * @param {Function} objectFunc The function to iterate over an object.
                     * @returns {Function} Returns the new each function.
                     */
                    function createForOwn(objectFunc) {
                        return function (object, iteratee, thisArg) {
                            if (typeof iteratee != 'function' || thisArg !== undefined) {
                                iteratee = bindCallback(iteratee, thisArg, 3);
                            }
                            return objectFunc(object, iteratee);
                        };
                    }

                    /**
                     * Creates a function for `_.mapKeys` or `_.mapValues`.
                     *
                     * @private
                     * @param {boolean} [isMapKeys] Specify mapping keys instead of values.
                     * @returns {Function} Returns the new map function.
                     */
                    function createObjectMapper(isMapKeys) {
                        return function (object, iteratee, thisArg) {
                            var result = {};
                            iteratee = getCallback(iteratee, thisArg, 3);

                            baseForOwn(object, function (value, key, object) {
                                var mapped = iteratee(value, key, object);
                                key = isMapKeys ? mapped : key;
                                value = isMapKeys ? value : mapped;
                                result[key] = value;
                            });
                            return result;
                        };
                    }

                    /**
                     * Creates a function for `_.padLeft` or `_.padRight`.
                     *
                     * @private
                     * @param {boolean} [fromRight] Specify padding from the right.
                     * @returns {Function} Returns the new pad function.
                     */
                    function createPadDir(fromRight) {
                        return function (string, length, chars) {
                            string = baseToString(string);
                            return (fromRight ? string : '') + createPadding(string, length, chars) + (fromRight ? '' : string);
                        };
                    }

                    /**
                     * Creates a `_.partial` or `_.partialRight` function.
                     *
                     * @private
                     * @param {boolean} flag The partial bit flag.
                     * @returns {Function} Returns the new partial function.
                     */
                    function createPartial(flag) {
                        var partialFunc = restParam(function (func, partials) {
                            var holders = replaceHolders(partials, partialFunc.placeholder);
                            return createWrapper(func, flag, undefined, partials, holders);
                        });
                        return partialFunc;
                    }

                    /**
                     * Creates a function for `_.reduce` or `_.reduceRight`.
                     *
                     * @private
                     * @param {Function} arrayFunc The function to iterate over an array.
                     * @param {Function} eachFunc The function to iterate over a collection.
                     * @returns {Function} Returns the new each function.
                     */
                    function createReduce(arrayFunc, eachFunc) {
                        return function (collection, iteratee, accumulator, thisArg) {
                            var initFromArray = arguments.length < 3;
                            return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))
                                ? arrayFunc(collection, iteratee, accumulator, initFromArray)
                                : baseReduce(collection, getCallback(iteratee, thisArg, 4), accumulator, initFromArray, eachFunc);
                        };
                    }

                    /**
                     * Creates a function that wraps `func` and invokes it with optional `this`
                     * binding of, partial application, and currying.
                     *
                     * @private
                     * @param {Function|string} func The function or method name to reference.
                     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
                     * @param {*} [thisArg] The `this` binding of `func`.
                     * @param {Array} [partials] The arguments to prepend to those provided to the new function.
                     * @param {Array} [holders] The `partials` placeholder indexes.
                     * @param {Array} [partialsRight] The arguments to append to those provided to the new function.
                     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
                     * @param {Array} [argPos] The argument positions of the new function.
                     * @param {number} [ary] The arity cap of `func`.
                     * @param {number} [arity] The arity of `func`.
                     * @returns {Function} Returns the new wrapped function.
                     */
                    function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
                        var isAry = bitmask & ARY_FLAG,
                            isBind = bitmask & BIND_FLAG,
                            isBindKey = bitmask & BIND_KEY_FLAG,
                            isCurry = bitmask & CURRY_FLAG,
                            isCurryBound = bitmask & CURRY_BOUND_FLAG,
                            isCurryRight = bitmask & CURRY_RIGHT_FLAG,
                            Ctor = isBindKey ? undefined : createCtorWrapper(func);

                        function wrapper() {
                            // Avoid `arguments` object use disqualifying optimizations by
                            // converting it to an array before providing it to other functions.
                            var length = arguments.length,
                                index = length,
                                args = Array(length);

                            while (index--) {
                                args[index] = arguments[index];
                            }
                            if (partials) {
                                args = composeArgs(args, partials, holders);
                            }
                            if (partialsRight) {
                                args = composeArgsRight(args, partialsRight, holdersRight);
                            }
                            if (isCurry || isCurryRight) {
                                var placeholder = wrapper.placeholder,
                                    argsHolders = replaceHolders(args, placeholder);

                                length -= argsHolders.length;
                                if (length < arity) {
                                    var newArgPos = argPos ? arrayCopy(argPos) : undefined,
                                        newArity = nativeMax(arity - length, 0),
                                        newsHolders = isCurry ? argsHolders : undefined,
                                        newHoldersRight = isCurry ? undefined : argsHolders,
                                        newPartials = isCurry ? args : undefined,
                                        newPartialsRight = isCurry ? undefined : args;

                                    bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);
                                    bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);

                                    if (!isCurryBound) {
                                        bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
                                    }
                                    var newData = [func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, newArity],
                                        result = createHybridWrapper.apply(undefined, newData);

                                    if (isLaziable(func)) {
                                        setData(result, newData);
                                    }
                                    result.placeholder = placeholder;
                                    return result;
                                }
                            }
                            var thisBinding = isBind ? thisArg : this,
                                fn = isBindKey ? thisBinding[func] : func;

                            if (argPos) {
                                args = reorder(args, argPos);
                            }
                            if (isAry && ary < args.length) {
                                args.length = ary;
                            }
                            if (this && this !== root && this instanceof wrapper) {
                                fn = Ctor || createCtorWrapper(func);
                            }
                            return fn.apply(thisBinding, args);
                        }
                        return wrapper;
                    }

                    /**
                     * Creates the padding required for `string` based on the given `length`.
                     * The `chars` string is truncated if the number of characters exceeds `length`.
                     *
                     * @private
                     * @param {string} string The string to create padding for.
                     * @param {number} [length=0] The padding length.
                     * @param {string} [chars=' '] The string used as padding.
                     * @returns {string} Returns the pad for `string`.
                     */
                    function createPadding(string, length, chars) {
                        var strLength = string.length;
                        length = +length;

                        if (strLength >= length || !nativeIsFinite(length)) {
                            return '';
                        }
                        var padLength = length - strLength;
                        chars = chars == null ? ' ' : (chars + '');
                        return repeat(chars, nativeCeil(padLength / chars.length)).slice(0, padLength);
                    }

                    /**
                     * Creates a function that wraps `func` and invokes it with the optional `this`
                     * binding of `thisArg` and the `partials` prepended to those provided to
                     * the wrapper.
                     *
                     * @private
                     * @param {Function} func The function to partially apply arguments to.
                     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
                     * @param {*} thisArg The `this` binding of `func`.
                     * @param {Array} partials The arguments to prepend to those provided to the new function.
                     * @returns {Function} Returns the new bound function.
                     */
                    function createPartialWrapper(func, bitmask, thisArg, partials) {
                        var isBind = bitmask & BIND_FLAG,
                            Ctor = createCtorWrapper(func);

                        function wrapper() {
                            // Avoid `arguments` object use disqualifying optimizations by
                            // converting it to an array before providing it `func`.
                            var argsIndex = -1,
                                argsLength = arguments.length,
                                leftIndex = -1,
                                leftLength = partials.length,
                                args = Array(leftLength + argsLength);

                            while (++leftIndex < leftLength) {
                                args[leftIndex] = partials[leftIndex];
                            }
                            while (argsLength--) {
                                args[leftIndex++] = arguments[++argsIndex];
                            }
                            var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
                            return fn.apply(isBind ? thisArg : this, args);
                        }
                        return wrapper;
                    }

                    /**
                     * Creates a `_.ceil`, `_.floor`, or `_.round` function.
                     *
                     * @private
                     * @param {string} methodName The name of the `Math` method to use when rounding.
                     * @returns {Function} Returns the new round function.
                     */
                    function createRound(methodName) {
                        var func = Math[methodName];
                        return function (number, precision) {
                            precision = precision === undefined ? 0 : (+precision || 0);
                            if (precision) {
                                precision = pow(10, precision);
                                return func(number * precision) / precision;
                            }
                            return func(number);
                        };
                    }

                    /**
                     * Creates a `_.sortedIndex` or `_.sortedLastIndex` function.
                     *
                     * @private
                     * @param {boolean} [retHighest] Specify returning the highest qualified index.
                     * @returns {Function} Returns the new index function.
                     */
                    function createSortedIndex(retHighest) {
                        return function (array, value, iteratee, thisArg) {
                            var callback = getCallback(iteratee);
                            return (iteratee == null && callback === baseCallback)
                                ? binaryIndex(array, value, retHighest)
                                : binaryIndexBy(array, value, callback(iteratee, thisArg, 1), retHighest);
                        };
                    }

                    /**
                     * Creates a function that either curries or invokes `func` with optional
                     * `this` binding and partially applied arguments.
                     *
                     * @private
                     * @param {Function|string} func The function or method name to reference.
                     * @param {number} bitmask The bitmask of flags.
                     *  The bitmask may be composed of the following flags:
                     *     1 - `_.bind`
                     *     2 - `_.bindKey`
                     *     4 - `_.curry` or `_.curryRight` of a bound function
                     *     8 - `_.curry`
                     *    16 - `_.curryRight`
                     *    32 - `_.partial`
                     *    64 - `_.partialRight`
                     *   128 - `_.rearg`
                     *   256 - `_.ary`
                     * @param {*} [thisArg] The `this` binding of `func`.
                     * @param {Array} [partials] The arguments to be partially applied.
                     * @param {Array} [holders] The `partials` placeholder indexes.
                     * @param {Array} [argPos] The argument positions of the new function.
                     * @param {number} [ary] The arity cap of `func`.
                     * @param {number} [arity] The arity of `func`.
                     * @returns {Function} Returns the new wrapped function.
                     */
                    function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
                        var isBindKey = bitmask & BIND_KEY_FLAG;
                        if (!isBindKey && typeof func != 'function') {
                            throw new TypeError(FUNC_ERROR_TEXT);
                        }
                        var length = partials ? partials.length : 0;
                        if (!length) {
                            bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
                            partials = holders = undefined;
                        }
                        length -= (holders ? holders.length : 0);
                        if (bitmask & PARTIAL_RIGHT_FLAG) {
                            var partialsRight = partials,
                                holdersRight = holders;

                            partials = holders = undefined;
                        }
                        var data = isBindKey ? undefined : getData(func),
                            newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];

                        if (data) {
                            mergeData(newData, data);
                            bitmask = newData[1];
                            arity = newData[9];
                        }
                        newData[9] = arity == null
                            ? (isBindKey ? 0 : func.length)
                            : (nativeMax(arity - length, 0) || 0);

                        if (bitmask == BIND_FLAG) {
                            var result = createBindWrapper(newData[0], newData[2]);
                        } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !newData[4].length) {
                            result = createPartialWrapper.apply(undefined, newData);
                        } else {
                            result = createHybridWrapper.apply(undefined, newData);
                        }
                        var setter = data ? baseSetData : setData;
                        return setter(result, newData);
                    }

                    /**
                     * A specialized version of `baseIsEqualDeep` for arrays with support for
                     * partial deep comparisons.
                     *
                     * @private
                     * @param {Array} array The array to compare.
                     * @param {Array} other The other array to compare.
                     * @param {Function} equalFunc The function to determine equivalents of values.
                     * @param {Function} [customizer] The function to customize comparing arrays.
                     * @param {boolean} [isLoose] Specify performing partial comparisons.
                     * @param {Array} [stackA] Tracks traversed `value` objects.
                     * @param {Array} [stackB] Tracks traversed `other` objects.
                     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
                     */
                    function equalArrays(array, other, equalFunc, customizer, isLoose, stackA, stackB) {
                        var index = -1,
                            arrLength = array.length,
                            othLength = other.length;

                        if (arrLength != othLength && !(isLoose && othLength > arrLength)) {
                            return false;
                        }
                        // Ignore non-index properties.
                        while (++index < arrLength) {
                            var arrValue = array[index],
                                othValue = other[index],
                                result = customizer ? customizer(isLoose ? othValue : arrValue, isLoose ? arrValue : othValue, index) : undefined;

                            if (result !== undefined) {
                                if (result) {
                                    continue;
                                }
                                return false;
                            }
                            // Recursively compare arrays (susceptible to call stack limits).
                            if (isLoose) {
                                if (!arraySome(other, function (othValue) {
                                    return arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);
                                })) {
                                    return false;
                                }
                            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB))) {
                                return false;
                            }
                        }
                        return true;
                    }

                    /**
                     * A specialized version of `baseIsEqualDeep` for comparing objects of
                     * the same `toStringTag`.
                     *
                     * **Note:** This function only supports comparing values with tags of
                     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
                     *
                     * @private
                     * @param {Object} object The object to compare.
                     * @param {Object} other The other object to compare.
                     * @param {string} tag The `toStringTag` of the objects to compare.
                     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
                     */
                    function equalByTag(object, other, tag) {
                        switch (tag) {
                            case boolTag:
                            case dateTag:
                                // Coerce dates and booleans to numbers, dates to milliseconds and booleans
                                // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.
                                return +object == +other;

                            case errorTag:
                                return object.name == other.name && object.message == other.message;

                            case numberTag:
                                // Treat `NaN` vs. `NaN` as equal.
                                return (object != +object)
                                    ? other != +other
                                    : object == +other;

                            case regexpTag:
                            case stringTag:
                                // Coerce regexes to strings and treat strings primitives and string
                                // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.
                                return object == (other + '');
                        }
                        return false;
                    }

                    /**
                     * A specialized version of `baseIsEqualDeep` for objects with support for
                     * partial deep comparisons.
                     *
                     * @private
                     * @param {Object} object The object to compare.
                     * @param {Object} other The other object to compare.
                     * @param {Function} equalFunc The function to determine equivalents of values.
                     * @param {Function} [customizer] The function to customize comparing values.
                     * @param {boolean} [isLoose] Specify performing partial comparisons.
                     * @param {Array} [stackA] Tracks traversed `value` objects.
                     * @param {Array} [stackB] Tracks traversed `other` objects.
                     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
                     */
                    function equalObjects(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
                        var objProps = keys(object),
                            objLength = objProps.length,
                            othProps = keys(other),
                            othLength = othProps.length;

                        if (objLength != othLength && !isLoose) {
                            return false;
                        }
                        var index = objLength;
                        while (index--) {
                            var key = objProps[index];
                            if (!(isLoose ? key in other : hasOwnProperty.call(other, key))) {
                                return false;
                            }
                        }
                        var skipCtor = isLoose;
                        while (++index < objLength) {
                            key = objProps[index];
                            var objValue = object[key],
                                othValue = other[key],
                                result = customizer ? customizer(isLoose ? othValue : objValue, isLoose ? objValue : othValue, key) : undefined;

                            // Recursively compare objects (susceptible to call stack limits).
                            if (!(result === undefined ? equalFunc(objValue, othValue, customizer, isLoose, stackA, stackB) : result)) {
                                return false;
                            }
                            skipCtor || (skipCtor = key == 'constructor');
                        }
                        if (!skipCtor) {
                            var objCtor = object.constructor,
                                othCtor = other.constructor;

                            // Non `Object` object instances with different constructors are not equal.
                            if (objCtor != othCtor &&
                                ('constructor' in object && 'constructor' in other) &&
                                !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
                                    typeof othCtor == 'function' && othCtor instanceof othCtor)) {
                                return false;
                            }
                        }
                        return true;
                    }

                    /**
                     * Gets the appropriate "callback" function. If the `_.callback` method is
                     * customized this function returns the custom method, otherwise it returns
                     * the `baseCallback` function. If arguments are provided the chosen function
                     * is invoked with them and its result is returned.
                     *
                     * @private
                     * @returns {Function} Returns the chosen function or its result.
                     */
                    function getCallback(func, thisArg, argCount) {
                        var result = lodash.callback || callback;
                        result = result === callback ? baseCallback : result;
                        return argCount ? result(func, thisArg, argCount) : result;
                    }

                    /**
                     * Gets metadata for `func`.
                     *
                     * @private
                     * @param {Function} func The function to query.
                     * @returns {*} Returns the metadata for `func`.
                     */
                    var getData = !metaMap ? noop : function (func) {
                        return metaMap.get(func);
                    };

                    /**
                     * Gets the name of `func`.
                     *
                     * @private
                     * @param {Function} func The function to query.
                     * @returns {string} Returns the function name.
                     */
                    function getFuncName(func) {
                        var result = func.name,
                            array = realNames[result],
                            length = array ? array.length : 0;

                        while (length--) {
                            var data = array[length],
                                otherFunc = data.func;
                            if (otherFunc == null || otherFunc == func) {
                                return data.name;
                            }
                        }
                        return result;
                    }

                    /**
                     * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
                     * customized this function returns the custom method, otherwise it returns
                     * the `baseIndexOf` function. If arguments are provided the chosen function
                     * is invoked with them and its result is returned.
                     *
                     * @private
                     * @returns {Function|number} Returns the chosen function or its result.
                     */
                    function getIndexOf(collection, target, fromIndex) {
                        var result = lodash.indexOf || indexOf;
                        result = result === indexOf ? baseIndexOf : result;
                        return collection ? result(collection, target, fromIndex) : result;
                    }

                    /**
                     * Gets the "length" property value of `object`.
                     *
                     * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
                     * that affects Safari on at least iOS 8.1-8.3 ARM64.
                     *
                     * @private
                     * @param {Object} object The object to query.
                     * @returns {*} Returns the "length" value.
                     */
                    var getLength = baseProperty('length');

                    /**
                     * Gets the propery names, values, and compare flags of `object`.
                     *
                     * @private
                     * @param {Object} object The object to query.
                     * @returns {Array} Returns the match data of `object`.
                     */
                    function getMatchData(object) {
                        var result = pairs(object),
                            length = result.length;

                        while (length--) {
                            result[length][2] = isStrictComparable(result[length][1]);
                        }
                        return result;
                    }

                    /**
                     * Gets the native function at `key` of `object`.
                     *
                     * @private
                     * @param {Object} object The object to query.
                     * @param {string} key The key of the method to get.
                     * @returns {*} Returns the function if it's native, else `undefined`.
                     */
                    function getNative(object, key) {
                        var value = object == null ? undefined : object[key];
                        return isNative(value) ? value : undefined;
                    }

                    /**
                     * Gets the view, applying any `transforms` to the `start` and `end` positions.
                     *
                     * @private
                     * @param {number} start The start of the view.
                     * @param {number} end The end of the view.
                     * @param {Array} transforms The transformations to apply to the view.
                     * @returns {Object} Returns an object containing the `start` and `end`
                     *  positions of the view.
                     */
                    function getView(start, end, transforms) {
                        var index = -1,
                            length = transforms.length;

                        while (++index < length) {
                            var data = transforms[index],
                                size = data.size;

                            switch (data.type) {
                                case 'drop': start += size; break;
                                case 'dropRight': end -= size; break;
                                case 'take': end = nativeMin(end, start + size); break;
                                case 'takeRight': start = nativeMax(start, end - size); break;
                            }
                        }
                        return { 'start': start, 'end': end };
                    }

                    /**
                     * Initializes an array clone.
                     *
                     * @private
                     * @param {Array} array The array to clone.
                     * @returns {Array} Returns the initialized clone.
                     */
                    function initCloneArray(array) {
                        var length = array.length,
                            result = new array.constructor(length);

                        // Add array properties assigned by `RegExp#exec`.
                        if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
                            result.index = array.index;
                            result.input = array.input;
                        }
                        return result;
                    }

                    /**
                     * Initializes an object clone.
                     *
                     * @private
                     * @param {Object} object The object to clone.
                     * @returns {Object} Returns the initialized clone.
                     */
                    function initCloneObject(object) {
                        var Ctor = object.constructor;
                        if (!(typeof Ctor == 'function' && Ctor instanceof Ctor)) {
                            Ctor = Object;
                        }
                        return new Ctor;
                    }

                    /**
                     * Initializes an object clone based on its `toStringTag`.
                     *
                     * **Note:** This function only supports cloning values with tags of
                     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
                     *
                     * @private
                     * @param {Object} object The object to clone.
                     * @param {string} tag The `toStringTag` of the object to clone.
                     * @param {boolean} [isDeep] Specify a deep clone.
                     * @returns {Object} Returns the initialized clone.
                     */
                    function initCloneByTag(object, tag, isDeep) {
                        var Ctor = object.constructor;
                        switch (tag) {
                            case arrayBufferTag:
                                return bufferClone(object);

                            case boolTag:
                            case dateTag:
                                return new Ctor(+object);

                            case float32Tag: case float64Tag:
                            case int8Tag: case int16Tag: case int32Tag:
                            case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
                                var buffer = object.buffer;
                                return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);

                            case numberTag:
                            case stringTag:
                                return new Ctor(object);

                            case regexpTag:
                                var result = new Ctor(object.source, reFlags.exec(object));
                                result.lastIndex = object.lastIndex;
                        }
                        return result;
                    }

                    /**
                     * Invokes the method at `path` on `object`.
                     *
                     * @private
                     * @param {Object} object The object to query.
                     * @param {Array|string} path The path of the method to invoke.
                     * @param {Array} args The arguments to invoke the method with.
                     * @returns {*} Returns the result of the invoked method.
                     */
                    function invokePath(object, path, args) {
                        if (object != null && !isKey(path, object)) {
                            path = toPath(path);
                            object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
                            path = last(path);
                        }
                        var func = object == null ? object : object[path];
                        return func == null ? undefined : func.apply(object, args);
                    }

                    /**
                     * Checks if `value` is array-like.
                     *
                     * @private
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
                     */
                    function isArrayLike(value) {
                        return value != null && isLength(getLength(value));
                    }

                    /**
                     * Checks if `value` is a valid array-like index.
                     *
                     * @private
                     * @param {*} value The value to check.
                     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
                     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
                     */
                    function isIndex(value, length) {
                        value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
                        length = length == null ? MAX_SAFE_INTEGER : length;
                        return value > -1 && value % 1 == 0 && value < length;
                    }

                    /**
                     * Checks if the provided arguments are from an iteratee call.
                     *
                     * @private
                     * @param {*} value The potential iteratee value argument.
                     * @param {*} index The potential iteratee index or key argument.
                     * @param {*} object The potential iteratee object argument.
                     * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.
                     */
                    function isIterateeCall(value, index, object) {
                        if (!isObject(object)) {
                            return false;
                        }
                        var type = typeof index;
                        if (type == 'number'
                            ? (isArrayLike(object) && isIndex(index, object.length))
                            : (type == 'string' && index in object)) {
                            var other = object[index];
                            return value === value ? (value === other) : (other !== other);
                        }
                        return false;
                    }

                    /**
                     * Checks if `value` is a property name and not a property path.
                     *
                     * @private
                     * @param {*} value The value to check.
                     * @param {Object} [object] The object to query keys on.
                     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
                     */
                    function isKey(value, object) {
                        var type = typeof value;
                        if ((type == 'string' && reIsPlainProp.test(value)) || type == 'number') {
                            return true;
                        }
                        if (isArray(value)) {
                            return false;
                        }
                        var result = !reIsDeepProp.test(value);
                        return result || (object != null && value in toObject(object));
                    }

                    /**
                     * Checks if `func` has a lazy counterpart.
                     *
                     * @private
                     * @param {Function} func The function to check.
                     * @returns {boolean} Returns `true` if `func` has a lazy counterpart, else `false`.
                     */
                    function isLaziable(func) {
                        var funcName = getFuncName(func);
                        if (!(funcName in LazyWrapper.prototype)) {
                            return false;
                        }
                        var other = lodash[funcName];
                        if (func === other) {
                            return true;
                        }
                        var data = getData(other);
                        return !!data && func === data[0];
                    }

                    /**
                     * Checks if `value` is a valid array-like length.
                     *
                     * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
                     *
                     * @private
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
                     */
                    function isLength(value) {
                        return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
                    }

                    /**
                     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
                     *
                     * @private
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` if suitable for strict
                     *  equality comparisons, else `false`.
                     */
                    function isStrictComparable(value) {
                        return value === value && !isObject(value);
                    }

                    /**
                     * Merges the function metadata of `source` into `data`.
                     *
                     * Merging metadata reduces the number of wrappers required to invoke a function.
                     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
                     * may be applied regardless of execution order. Methods like `_.ary` and `_.rearg`
                     * augment function arguments, making the order in which they are executed important,
                     * preventing the merging of metadata. However, we make an exception for a safe
                     * common case where curried functions have `_.ary` and or `_.rearg` applied.
                     *
                     * @private
                     * @param {Array} data The destination metadata.
                     * @param {Array} source The source metadata.
                     * @returns {Array} Returns `data`.
                     */
                    function mergeData(data, source) {
                        var bitmask = data[1],
                            srcBitmask = source[1],
                            newBitmask = bitmask | srcBitmask,
                            isCommon = newBitmask < ARY_FLAG;

                        var isCombo =
                            (srcBitmask == ARY_FLAG && bitmask == CURRY_FLAG) ||
                            (srcBitmask == ARY_FLAG && bitmask == REARG_FLAG && data[7].length <= source[8]) ||
                            (srcBitmask == (ARY_FLAG | REARG_FLAG) && bitmask == CURRY_FLAG);

                        // Exit early if metadata can't be merged.
                        if (!(isCommon || isCombo)) {
                            return data;
                        }
                        // Use source `thisArg` if available.
                        if (srcBitmask & BIND_FLAG) {
                            data[2] = source[2];
                            // Set when currying a bound function.
                            newBitmask |= (bitmask & BIND_FLAG) ? 0 : CURRY_BOUND_FLAG;
                        }
                        // Compose partial arguments.
                        var value = source[3];
                        if (value) {
                            var partials = data[3];
                            data[3] = partials ? composeArgs(partials, value, source[4]) : arrayCopy(value);
                            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : arrayCopy(source[4]);
                        }
                        // Compose partial right arguments.
                        value = source[5];
                        if (value) {
                            partials = data[5];
                            data[5] = partials ? composeArgsRight(partials, value, source[6]) : arrayCopy(value);
                            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : arrayCopy(source[6]);
                        }
                        // Use source `argPos` if available.
                        value = source[7];
                        if (value) {
                            data[7] = arrayCopy(value);
                        }
                        // Use source `ary` if it's smaller.
                        if (srcBitmask & ARY_FLAG) {
                            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
                        }
                        // Use source `arity` if one is not provided.
                        if (data[9] == null) {
                            data[9] = source[9];
                        }
                        // Use source `func` and merge bitmasks.
                        data[0] = source[0];
                        data[1] = newBitmask;

                        return data;
                    }

                    /**
                     * Used by `_.defaultsDeep` to customize its `_.merge` use.
                     *
                     * @private
                     * @param {*} objectValue The destination object property value.
                     * @param {*} sourceValue The source object property value.
                     * @returns {*} Returns the value to assign to the destination object.
                     */
                    function mergeDefaults(objectValue, sourceValue) {
                        return objectValue === undefined ? sourceValue : merge(objectValue, sourceValue, mergeDefaults);
                    }

                    /**
                     * A specialized version of `_.pick` which picks `object` properties specified
                     * by `props`.
                     *
                     * @private
                     * @param {Object} object The source object.
                     * @param {string[]} props The property names to pick.
                     * @returns {Object} Returns the new object.
                     */
                    function pickByArray(object, props) {
                        object = toObject(object);

                        var index = -1,
                            length = props.length,
                            result = {};

                        while (++index < length) {
                            var key = props[index];
                            if (key in object) {
                                result[key] = object[key];
                            }
                        }
                        return result;
                    }

                    /**
                     * A specialized version of `_.pick` which picks `object` properties `predicate`
                     * returns truthy for.
                     *
                     * @private
                     * @param {Object} object The source object.
                     * @param {Function} predicate The function invoked per iteration.
                     * @returns {Object} Returns the new object.
                     */
                    function pickByCallback(object, predicate) {
                        var result = {};
                        baseForIn(object, function (value, key, object) {
                            if (predicate(value, key, object)) {
                                result[key] = value;
                            }
                        });
                        return result;
                    }

                    /**
                     * Reorder `array` according to the specified indexes where the element at
                     * the first index is assigned as the first element, the element at
                     * the second index is assigned as the second element, and so on.
                     *
                     * @private
                     * @param {Array} array The array to reorder.
                     * @param {Array} indexes The arranged array indexes.
                     * @returns {Array} Returns `array`.
                     */
                    function reorder(array, indexes) {
                        var arrLength = array.length,
                            length = nativeMin(indexes.length, arrLength),
                            oldArray = arrayCopy(array);

                        while (length--) {
                            var index = indexes[length];
                            array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
                        }
                        return array;
                    }

                    /**
                     * Sets metadata for `func`.
                     *
                     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
                     * period of time, it will trip its breaker and transition to an identity function
                     * to avoid garbage collection pauses in V8. See [V8 issue 2070](https://code.google.com/p/v8/issues/detail?id=2070)
                     * for more details.
                     *
                     * @private
                     * @param {Function} func The function to associate metadata with.
                     * @param {*} data The metadata.
                     * @returns {Function} Returns `func`.
                     */
                    var setData = (function () {
                        var count = 0,
                            lastCalled = 0;

                        return function (key, value) {
                            var stamp = now(),
                                remaining = HOT_SPAN - (stamp - lastCalled);

                            lastCalled = stamp;
                            if (remaining > 0) {
                                if (++count >= HOT_COUNT) {
                                    return key;
                                }
                            } else {
                                count = 0;
                            }
                            return baseSetData(key, value);
                        };
                    }());

                    /**
                     * A fallback implementation of `Object.keys` which creates an array of the
                     * own enumerable property names of `object`.
                     *
                     * @private
                     * @param {Object} object The object to query.
                     * @returns {Array} Returns the array of property names.
                     */
                    function shimKeys(object) {
                        var props = keysIn(object),
                            propsLength = props.length,
                            length = propsLength && object.length;

                        var allowIndexes = !!length && isLength(length) &&
                            (isArray(object) || isArguments(object));

                        var index = -1,
                            result = [];

                        while (++index < propsLength) {
                            var key = props[index];
                            if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
                                result.push(key);
                            }
                        }
                        return result;
                    }

                    /**
                     * Converts `value` to an array-like object if it's not one.
                     *
                     * @private
                     * @param {*} value The value to process.
                     * @returns {Array|Object} Returns the array-like object.
                     */
                    function toIterable(value) {
                        if (value == null) {
                            return [];
                        }
                        if (!isArrayLike(value)) {
                            return values(value);
                        }
                        return isObject(value) ? value : Object(value);
                    }

                    /**
                     * Converts `value` to an object if it's not one.
                     *
                     * @private
                     * @param {*} value The value to process.
                     * @returns {Object} Returns the object.
                     */
                    function toObject(value) {
                        return isObject(value) ? value : Object(value);
                    }

                    /**
                     * Converts `value` to property path array if it's not one.
                     *
                     * @private
                     * @param {*} value The value to process.
                     * @returns {Array} Returns the property path array.
                     */
                    function toPath(value) {
                        if (isArray(value)) {
                            return value;
                        }
                        var result = [];
                        baseToString(value).replace(rePropName, function (match, number, quote, string) {
                            result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
                        });
                        return result;
                    }

                    /**
                     * Creates a clone of `wrapper`.
                     *
                     * @private
                     * @param {Object} wrapper The wrapper to clone.
                     * @returns {Object} Returns the cloned wrapper.
                     */
                    function wrapperClone(wrapper) {
                        return wrapper instanceof LazyWrapper
                            ? wrapper.clone()
                            : new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__, arrayCopy(wrapper.__actions__));
                    }

                    /*------------------------------------------------------------------------*/

                    /**
                     * Creates an array of elements split into groups the length of `size`.
                     * If `collection` can't be split evenly, the final chunk will be the remaining
                     * elements.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to process.
                     * @param {number} [size=1] The length of each chunk.
                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                     * @returns {Array} Returns the new array containing chunks.
                     * @example
                     *
                     * _.chunk(['a', 'b', 'c', 'd'], 2);
                     * // => [['a', 'b'], ['c', 'd']]
                     *
                     * _.chunk(['a', 'b', 'c', 'd'], 3);
                     * // => [['a', 'b', 'c'], ['d']]
                     */
                    function chunk(array, size, guard) {
                        if (guard ? isIterateeCall(array, size, guard) : size == null) {
                            size = 1;
                        } else {
                            size = nativeMax(nativeFloor(size) || 1, 1);
                        }
                        var index = 0,
                            length = array ? array.length : 0,
                            resIndex = -1,
                            result = Array(nativeCeil(length / size));

                        while (index < length) {
                            result[++resIndex] = baseSlice(array, index, (index += size));
                        }
                        return result;
                    }

                    /**
                     * Creates an array with all falsey values removed. The values `false`, `null`,
                     * `0`, `""`, `undefined`, and `NaN` are falsey.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to compact.
                     * @returns {Array} Returns the new array of filtered values.
                     * @example
                     *
                     * _.compact([0, 1, false, 2, '', 3]);
                     * // => [1, 2, 3]
                     */
                    function compact(array) {
                        var index = -1,
                            length = array ? array.length : 0,
                            resIndex = -1,
                            result = [];

                        while (++index < length) {
                            var value = array[index];
                            if (value) {
                                result[++resIndex] = value;
                            }
                        }
                        return result;
                    }

                    /**
                     * Creates an array of unique `array` values not included in the other
                     * provided arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
                     * for equality comparisons.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to inspect.
                     * @param {...Array} [values] The arrays of values to exclude.
                     * @returns {Array} Returns the new array of filtered values.
                     * @example
                     *
                     * _.difference([1, 2, 3], [4, 2]);
                     * // => [1, 3]
                     */
                    var difference = restParam(function (array, values) {
                        return (isObjectLike(array) && isArrayLike(array))
                            ? baseDifference(array, baseFlatten(values, false, true))
                            : [];
                    });

                    /**
                     * Creates a slice of `array` with `n` elements dropped from the beginning.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to query.
                     * @param {number} [n=1] The number of elements to drop.
                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                     * @returns {Array} Returns the slice of `array`.
                     * @example
                     *
                     * _.drop([1, 2, 3]);
                     * // => [2, 3]
                     *
                     * _.drop([1, 2, 3], 2);
                     * // => [3]
                     *
                     * _.drop([1, 2, 3], 5);
                     * // => []
                     *
                     * _.drop([1, 2, 3], 0);
                     * // => [1, 2, 3]
                     */
                    function drop(array, n, guard) {
                        var length = array ? array.length : 0;
                        if (!length) {
                            return [];
                        }
                        if (guard ? isIterateeCall(array, n, guard) : n == null) {
                            n = 1;
                        }
                        return baseSlice(array, n < 0 ? 0 : n);
                    }

                    /**
                     * Creates a slice of `array` with `n` elements dropped from the end.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to query.
                     * @param {number} [n=1] The number of elements to drop.
                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                     * @returns {Array} Returns the slice of `array`.
                     * @example
                     *
                     * _.dropRight([1, 2, 3]);
                     * // => [1, 2]
                     *
                     * _.dropRight([1, 2, 3], 2);
                     * // => [1]
                     *
                     * _.dropRight([1, 2, 3], 5);
                     * // => []
                     *
                     * _.dropRight([1, 2, 3], 0);
                     * // => [1, 2, 3]
                     */
                    function dropRight(array, n, guard) {
                        var length = array ? array.length : 0;
                        if (!length) {
                            return [];
                        }
                        if (guard ? isIterateeCall(array, n, guard) : n == null) {
                            n = 1;
                        }
                        n = length - (+n || 0);
                        return baseSlice(array, 0, n < 0 ? 0 : n);
                    }

                    /**
                     * Creates a slice of `array` excluding elements dropped from the end.
                     * Elements are dropped until `predicate` returns falsey. The predicate is
                     * bound to `thisArg` and invoked with three arguments: (value, index, array).
                     *
                     * If a property name is provided for `predicate` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `predicate` the created `_.matches` style
                     * callback returns `true` for elements that match the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to query.
                     * @param {Function|Object|string} [predicate=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `predicate`.
                     * @returns {Array} Returns the slice of `array`.
                     * @example
                     *
                     * _.dropRightWhile([1, 2, 3], function(n) {
                     *   return n > 1;
                     * });
                     * // => [1]
                     *
                     * var users = [
                     *   { 'user': 'barney',  'active': true },
                     *   { 'user': 'fred',    'active': false },
                     *   { 'user': 'pebbles', 'active': false }
                     * ];
                     *
                     * // using the `_.matches` callback shorthand
                     * _.pluck(_.dropRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');
                     * // => ['barney', 'fred']
                     *
                     * // using the `_.matchesProperty` callback shorthand
                     * _.pluck(_.dropRightWhile(users, 'active', false), 'user');
                     * // => ['barney']
                     *
                     * // using the `_.property` callback shorthand
                     * _.pluck(_.dropRightWhile(users, 'active'), 'user');
                     * // => ['barney', 'fred', 'pebbles']
                     */
                    function dropRightWhile(array, predicate, thisArg) {
                        return (array && array.length)
                            ? baseWhile(array, getCallback(predicate, thisArg, 3), true, true)
                            : [];
                    }

                    /**
                     * Creates a slice of `array` excluding elements dropped from the beginning.
                     * Elements are dropped until `predicate` returns falsey. The predicate is
                     * bound to `thisArg` and invoked with three arguments: (value, index, array).
                     *
                     * If a property name is provided for `predicate` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `predicate` the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to query.
                     * @param {Function|Object|string} [predicate=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `predicate`.
                     * @returns {Array} Returns the slice of `array`.
                     * @example
                     *
                     * _.dropWhile([1, 2, 3], function(n) {
                     *   return n < 3;
                     * });
                     * // => [3]
                     *
                     * var users = [
                     *   { 'user': 'barney',  'active': false },
                     *   { 'user': 'fred',    'active': false },
                     *   { 'user': 'pebbles', 'active': true }
                     * ];
                     *
                     * // using the `_.matches` callback shorthand
                     * _.pluck(_.dropWhile(users, { 'user': 'barney', 'active': false }), 'user');
                     * // => ['fred', 'pebbles']
                     *
                     * // using the `_.matchesProperty` callback shorthand
                     * _.pluck(_.dropWhile(users, 'active', false), 'user');
                     * // => ['pebbles']
                     *
                     * // using the `_.property` callback shorthand
                     * _.pluck(_.dropWhile(users, 'active'), 'user');
                     * // => ['barney', 'fred', 'pebbles']
                     */
                    function dropWhile(array, predicate, thisArg) {
                        return (array && array.length)
                            ? baseWhile(array, getCallback(predicate, thisArg, 3), true)
                            : [];
                    }

                    /**
                     * Fills elements of `array` with `value` from `start` up to, but not
                     * including, `end`.
                     *
                     * **Note:** This method mutates `array`.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to fill.
                     * @param {*} value The value to fill `array` with.
                     * @param {number} [start=0] The start position.
                     * @param {number} [end=array.length] The end position.
                     * @returns {Array} Returns `array`.
                     * @example
                     *
                     * var array = [1, 2, 3];
                     *
                     * _.fill(array, 'a');
                     * console.log(array);
                     * // => ['a', 'a', 'a']
                     *
                     * _.fill(Array(3), 2);
                     * // => [2, 2, 2]
                     *
                     * _.fill([4, 6, 8], '*', 1, 2);
                     * // => [4, '*', 8]
                     */
                    function fill(array, value, start, end) {
                        var length = array ? array.length : 0;
                        if (!length) {
                            return [];
                        }
                        if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
                            start = 0;
                            end = length;
                        }
                        return baseFill(array, value, start, end);
                    }

                    /**
                     * This method is like `_.find` except that it returns the index of the first
                     * element `predicate` returns truthy for instead of the element itself.
                     *
                     * If a property name is provided for `predicate` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `predicate` the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to search.
                     * @param {Function|Object|string} [predicate=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `predicate`.
                     * @returns {number} Returns the index of the found element, else `-1`.
                     * @example
                     *
                     * var users = [
                     *   { 'user': 'barney',  'active': false },
                     *   { 'user': 'fred',    'active': false },
                     *   { 'user': 'pebbles', 'active': true }
                     * ];
                     *
                     * _.findIndex(users, function(chr) {
                     *   return chr.user == 'barney';
                     * });
                     * // => 0
                     *
                     * // using the `_.matches` callback shorthand
                     * _.findIndex(users, { 'user': 'fred', 'active': false });
                     * // => 1
                     *
                     * // using the `_.matchesProperty` callback shorthand
                     * _.findIndex(users, 'active', false);
                     * // => 0
                     *
                     * // using the `_.property` callback shorthand
                     * _.findIndex(users, 'active');
                     * // => 2
                     */
                    var findIndex = createFindIndex();

                    /**
                     * This method is like `_.findIndex` except that it iterates over elements
                     * of `collection` from right to left.
                     *
                     * If a property name is provided for `predicate` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `predicate` the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to search.
                     * @param {Function|Object|string} [predicate=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `predicate`.
                     * @returns {number} Returns the index of the found element, else `-1`.
                     * @example
                     *
                     * var users = [
                     *   { 'user': 'barney',  'active': true },
                     *   { 'user': 'fred',    'active': false },
                     *   { 'user': 'pebbles', 'active': false }
                     * ];
                     *
                     * _.findLastIndex(users, function(chr) {
                     *   return chr.user == 'pebbles';
                     * });
                     * // => 2
                     *
                     * // using the `_.matches` callback shorthand
                     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
                     * // => 0
                     *
                     * // using the `_.matchesProperty` callback shorthand
                     * _.findLastIndex(users, 'active', false);
                     * // => 2
                     *
                     * // using the `_.property` callback shorthand
                     * _.findLastIndex(users, 'active');
                     * // => 0
                     */
                    var findLastIndex = createFindIndex(true);

                    /**
                     * Gets the first element of `array`.
                     *
                     * @static
                     * @memberOf _
                     * @alias head
                     * @category Array
                     * @param {Array} array The array to query.
                     * @returns {*} Returns the first element of `array`.
                     * @example
                     *
                     * _.first([1, 2, 3]);
                     * // => 1
                     *
                     * _.first([]);
                     * // => undefined
                     */
                    function first(array) {
                        return array ? array[0] : undefined;
                    }

                    /**
                     * Flattens a nested array. If `isDeep` is `true` the array is recursively
                     * flattened, otherwise it is only flattened a single level.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to flatten.
                     * @param {boolean} [isDeep] Specify a deep flatten.
                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                     * @returns {Array} Returns the new flattened array.
                     * @example
                     *
                     * _.flatten([1, [2, 3, [4]]]);
                     * // => [1, 2, 3, [4]]
                     *
                     * // using `isDeep`
                     * _.flatten([1, [2, 3, [4]]], true);
                     * // => [1, 2, 3, 4]
                     */
                    function flatten(array, isDeep, guard) {
                        var length = array ? array.length : 0;
                        if (guard && isIterateeCall(array, isDeep, guard)) {
                            isDeep = false;
                        }
                        return length ? baseFlatten(array, isDeep) : [];
                    }

                    /**
                     * Recursively flattens a nested array.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to recursively flatten.
                     * @returns {Array} Returns the new flattened array.
                     * @example
                     *
                     * _.flattenDeep([1, [2, 3, [4]]]);
                     * // => [1, 2, 3, 4]
                     */
                    function flattenDeep(array) {
                        var length = array ? array.length : 0;
                        return length ? baseFlatten(array, true) : [];
                    }

                    /**
                     * Gets the index at which the first occurrence of `value` is found in `array`
                     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
                     * for equality comparisons. If `fromIndex` is negative, it is used as the offset
                     * from the end of `array`. If `array` is sorted providing `true` for `fromIndex`
                     * performs a faster binary search.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to search.
                     * @param {*} value The value to search for.
                     * @param {boolean|number} [fromIndex=0] The index to search from or `true`
                     *  to perform a binary search on a sorted array.
                     * @returns {number} Returns the index of the matched value, else `-1`.
                     * @example
                     *
                     * _.indexOf([1, 2, 1, 2], 2);
                     * // => 1
                     *
                     * // using `fromIndex`
                     * _.indexOf([1, 2, 1, 2], 2, 2);
                     * // => 3
                     *
                     * // performing a binary search
                     * _.indexOf([1, 1, 2, 2], 2, true);
                     * // => 2
                     */
                    function indexOf(array, value, fromIndex) {
                        var length = array ? array.length : 0;
                        if (!length) {
                            return -1;
                        }
                        if (typeof fromIndex == 'number') {
                            fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : fromIndex;
                        } else if (fromIndex) {
                            var index = binaryIndex(array, value);
                            if (index < length &&
                                (value === value ? (value === array[index]) : (array[index] !== array[index]))) {
                                return index;
                            }
                            return -1;
                        }
                        return baseIndexOf(array, value, fromIndex || 0);
                    }

                    /**
                     * Gets all but the last element of `array`.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to query.
                     * @returns {Array} Returns the slice of `array`.
                     * @example
                     *
                     * _.initial([1, 2, 3]);
                     * // => [1, 2]
                     */
                    function initial(array) {
                        return dropRight(array, 1);
                    }

                    /**
                     * Creates an array of unique values that are included in all of the provided
                     * arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
                     * for equality comparisons.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {...Array} [arrays] The arrays to inspect.
                     * @returns {Array} Returns the new array of shared values.
                     * @example
                     * _.intersection([1, 2], [4, 2], [2, 1]);
                     * // => [2]
                     */
                    var intersection = restParam(function (arrays) {
                        var othLength = arrays.length,
                            othIndex = othLength,
                            caches = Array(length),
                            indexOf = getIndexOf(),
                            isCommon = indexOf == baseIndexOf,
                            result = [];

                        while (othIndex--) {
                            var value = arrays[othIndex] = isArrayLike(value = arrays[othIndex]) ? value : [];
                            caches[othIndex] = (isCommon && value.length >= 120) ? createCache(othIndex && value) : null;
                        }
                        var array = arrays[0],
                            index = -1,
                            length = array ? array.length : 0,
                            seen = caches[0];

                        outer:
                        while (++index < length) {
                            value = array[index];
                            if ((seen ? cacheIndexOf(seen, value) : indexOf(result, value, 0)) < 0) {
                                var othIndex = othLength;
                                while (--othIndex) {
                                    var cache = caches[othIndex];
                                    if ((cache ? cacheIndexOf(cache, value) : indexOf(arrays[othIndex], value, 0)) < 0) {
                                        continue outer;
                                    }
                                }
                                if (seen) {
                                    seen.push(value);
                                }
                                result.push(value);
                            }
                        }
                        return result;
                    });

                    /**
                     * Gets the last element of `array`.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to query.
                     * @returns {*} Returns the last element of `array`.
                     * @example
                     *
                     * _.last([1, 2, 3]);
                     * // => 3
                     */
                    function last(array) {
                        var length = array ? array.length : 0;
                        return length ? array[length - 1] : undefined;
                    }

                    /**
                     * This method is like `_.indexOf` except that it iterates over elements of
                     * `array` from right to left.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to search.
                     * @param {*} value The value to search for.
                     * @param {boolean|number} [fromIndex=array.length-1] The index to search from
                     *  or `true` to perform a binary search on a sorted array.
                     * @returns {number} Returns the index of the matched value, else `-1`.
                     * @example
                     *
                     * _.lastIndexOf([1, 2, 1, 2], 2);
                     * // => 3
                     *
                     * // using `fromIndex`
                     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
                     * // => 1
                     *
                     * // performing a binary search
                     * _.lastIndexOf([1, 1, 2, 2], 2, true);
                     * // => 3
                     */
                    function lastIndexOf(array, value, fromIndex) {
                        var length = array ? array.length : 0;
                        if (!length) {
                            return -1;
                        }
                        var index = length;
                        if (typeof fromIndex == 'number') {
                            index = (fromIndex < 0 ? nativeMax(length + fromIndex, 0) : nativeMin(fromIndex || 0, length - 1)) + 1;
                        } else if (fromIndex) {
                            index = binaryIndex(array, value, true) - 1;
                            var other = array[index];
                            if (value === value ? (value === other) : (other !== other)) {
                                return index;
                            }
                            return -1;
                        }
                        if (value !== value) {
                            return indexOfNaN(array, index, true);
                        }
                        while (index--) {
                            if (array[index] === value) {
                                return index;
                            }
                        }
                        return -1;
                    }

                    /**
                     * Removes all provided values from `array` using
                     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
                     * for equality comparisons.
                     *
                     * **Note:** Unlike `_.without`, this method mutates `array`.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to modify.
                     * @param {...*} [values] The values to remove.
                     * @returns {Array} Returns `array`.
                     * @example
                     *
                     * var array = [1, 2, 3, 1, 2, 3];
                     *
                     * _.pull(array, 2, 3);
                     * console.log(array);
                     * // => [1, 1]
                     */
                    function pull() {
                        var args = arguments,
                            array = args[0];

                        if (!(array && array.length)) {
                            return array;
                        }
                        var index = 0,
                            indexOf = getIndexOf(),
                            length = args.length;

                        while (++index < length) {
                            var fromIndex = 0,
                                value = args[index];

                            while ((fromIndex = indexOf(array, value, fromIndex)) > -1) {
                                splice.call(array, fromIndex, 1);
                            }
                        }
                        return array;
                    }

                    /**
                     * Removes elements from `array` corresponding to the given indexes and returns
                     * an array of the removed elements. Indexes may be specified as an array of
                     * indexes or as individual arguments.
                     *
                     * **Note:** Unlike `_.at`, this method mutates `array`.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to modify.
                     * @param {...(number|number[])} [indexes] The indexes of elements to remove,
                     *  specified as individual indexes or arrays of indexes.
                     * @returns {Array} Returns the new array of removed elements.
                     * @example
                     *
                     * var array = [5, 10, 15, 20];
                     * var evens = _.pullAt(array, 1, 3);
                     *
                     * console.log(array);
                     * // => [5, 15]
                     *
                     * console.log(evens);
                     * // => [10, 20]
                     */
                    var pullAt = restParam(function (array, indexes) {
                        indexes = baseFlatten(indexes);

                        var result = baseAt(array, indexes);
                        basePullAt(array, indexes.sort(baseCompareAscending));
                        return result;
                    });

                    /**
                     * Removes all elements from `array` that `predicate` returns truthy for
                     * and returns an array of the removed elements. The predicate is bound to
                     * `thisArg` and invoked with three arguments: (value, index, array).
                     *
                     * If a property name is provided for `predicate` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `predicate` the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * **Note:** Unlike `_.filter`, this method mutates `array`.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to modify.
                     * @param {Function|Object|string} [predicate=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `predicate`.
                     * @returns {Array} Returns the new array of removed elements.
                     * @example
                     *
                     * var array = [1, 2, 3, 4];
                     * var evens = _.remove(array, function(n) {
                     *   return n % 2 == 0;
                     * });
                     *
                     * console.log(array);
                     * // => [1, 3]
                     *
                     * console.log(evens);
                     * // => [2, 4]
                     */
                    function remove(array, predicate, thisArg) {
                        var result = [];
                        if (!(array && array.length)) {
                            return result;
                        }
                        var index = -1,
                            indexes = [],
                            length = array.length;

                        predicate = getCallback(predicate, thisArg, 3);
                        while (++index < length) {
                            var value = array[index];
                            if (predicate(value, index, array)) {
                                result.push(value);
                                indexes.push(index);
                            }
                        }
                        basePullAt(array, indexes);
                        return result;
                    }

                    /**
                     * Gets all but the first element of `array`.
                     *
                     * @static
                     * @memberOf _
                     * @alias tail
                     * @category Array
                     * @param {Array} array The array to query.
                     * @returns {Array} Returns the slice of `array`.
                     * @example
                     *
                     * _.rest([1, 2, 3]);
                     * // => [2, 3]
                     */
                    function rest(array) {
                        return drop(array, 1);
                    }

                    /**
                     * Creates a slice of `array` from `start` up to, but not including, `end`.
                     *
                     * **Note:** This method is used instead of `Array#slice` to support node
                     * lists in IE < 9 and to ensure dense arrays are returned.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to slice.
                     * @param {number} [start=0] The start position.
                     * @param {number} [end=array.length] The end position.
                     * @returns {Array} Returns the slice of `array`.
                     */
                    function slice(array, start, end) {
                        var length = array ? array.length : 0;
                        if (!length) {
                            return [];
                        }
                        if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
                            start = 0;
                            end = length;
                        }
                        return baseSlice(array, start, end);
                    }

                    /**
                     * Uses a binary search to determine the lowest index at which `value` should
                     * be inserted into `array` in order to maintain its sort order. If an iteratee
                     * function is provided it is invoked for `value` and each element of `array`
                     * to compute their sort ranking. The iteratee is bound to `thisArg` and
                     * invoked with one argument; (value).
                     *
                     * If a property name is provided for `iteratee` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `iteratee` the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The sorted array to inspect.
                     * @param {*} value The value to evaluate.
                     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {number} Returns the index at which `value` should be inserted
                     *  into `array`.
                     * @example
                     *
                     * _.sortedIndex([30, 50], 40);
                     * // => 1
                     *
                     * _.sortedIndex([4, 4, 5, 5], 5);
                     * // => 2
                     *
                     * var dict = { 'data': { 'thirty': 30, 'forty': 40, 'fifty': 50 } };
                     *
                     * // using an iteratee function
                     * _.sortedIndex(['thirty', 'fifty'], 'forty', function(word) {
                     *   return this.data[word];
                     * }, dict);
                     * // => 1
                     *
                     * // using the `_.property` callback shorthand
                     * _.sortedIndex([{ 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
                     * // => 1
                     */
                    var sortedIndex = createSortedIndex();

                    /**
                     * This method is like `_.sortedIndex` except that it returns the highest
                     * index at which `value` should be inserted into `array` in order to
                     * maintain its sort order.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The sorted array to inspect.
                     * @param {*} value The value to evaluate.
                     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {number} Returns the index at which `value` should be inserted
                     *  into `array`.
                     * @example
                     *
                     * _.sortedLastIndex([4, 4, 5, 5], 5);
                     * // => 4
                     */
                    var sortedLastIndex = createSortedIndex(true);

                    /**
                     * Creates a slice of `array` with `n` elements taken from the beginning.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to query.
                     * @param {number} [n=1] The number of elements to take.
                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                     * @returns {Array} Returns the slice of `array`.
                     * @example
                     *
                     * _.take([1, 2, 3]);
                     * // => [1]
                     *
                     * _.take([1, 2, 3], 2);
                     * // => [1, 2]
                     *
                     * _.take([1, 2, 3], 5);
                     * // => [1, 2, 3]
                     *
                     * _.take([1, 2, 3], 0);
                     * // => []
                     */
                    function take(array, n, guard) {
                        var length = array ? array.length : 0;
                        if (!length) {
                            return [];
                        }
                        if (guard ? isIterateeCall(array, n, guard) : n == null) {
                            n = 1;
                        }
                        return baseSlice(array, 0, n < 0 ? 0 : n);
                    }

                    /**
                     * Creates a slice of `array` with `n` elements taken from the end.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to query.
                     * @param {number} [n=1] The number of elements to take.
                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                     * @returns {Array} Returns the slice of `array`.
                     * @example
                     *
                     * _.takeRight([1, 2, 3]);
                     * // => [3]
                     *
                     * _.takeRight([1, 2, 3], 2);
                     * // => [2, 3]
                     *
                     * _.takeRight([1, 2, 3], 5);
                     * // => [1, 2, 3]
                     *
                     * _.takeRight([1, 2, 3], 0);
                     * // => []
                     */
                    function takeRight(array, n, guard) {
                        var length = array ? array.length : 0;
                        if (!length) {
                            return [];
                        }
                        if (guard ? isIterateeCall(array, n, guard) : n == null) {
                            n = 1;
                        }
                        n = length - (+n || 0);
                        return baseSlice(array, n < 0 ? 0 : n);
                    }

                    /**
                     * Creates a slice of `array` with elements taken from the end. Elements are
                     * taken until `predicate` returns falsey. The predicate is bound to `thisArg`
                     * and invoked with three arguments: (value, index, array).
                     *
                     * If a property name is provided for `predicate` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `predicate` the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to query.
                     * @param {Function|Object|string} [predicate=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `predicate`.
                     * @returns {Array} Returns the slice of `array`.
                     * @example
                     *
                     * _.takeRightWhile([1, 2, 3], function(n) {
                     *   return n > 1;
                     * });
                     * // => [2, 3]
                     *
                     * var users = [
                     *   { 'user': 'barney',  'active': true },
                     *   { 'user': 'fred',    'active': false },
                     *   { 'user': 'pebbles', 'active': false }
                     * ];
                     *
                     * // using the `_.matches` callback shorthand
                     * _.pluck(_.takeRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');
                     * // => ['pebbles']
                     *
                     * // using the `_.matchesProperty` callback shorthand
                     * _.pluck(_.takeRightWhile(users, 'active', false), 'user');
                     * // => ['fred', 'pebbles']
                     *
                     * // using the `_.property` callback shorthand
                     * _.pluck(_.takeRightWhile(users, 'active'), 'user');
                     * // => []
                     */
                    function takeRightWhile(array, predicate, thisArg) {
                        return (array && array.length)
                            ? baseWhile(array, getCallback(predicate, thisArg, 3), false, true)
                            : [];
                    }

                    /**
                     * Creates a slice of `array` with elements taken from the beginning. Elements
                     * are taken until `predicate` returns falsey. The predicate is bound to
                     * `thisArg` and invoked with three arguments: (value, index, array).
                     *
                     * If a property name is provided for `predicate` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `predicate` the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to query.
                     * @param {Function|Object|string} [predicate=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `predicate`.
                     * @returns {Array} Returns the slice of `array`.
                     * @example
                     *
                     * _.takeWhile([1, 2, 3], function(n) {
                     *   return n < 3;
                     * });
                     * // => [1, 2]
                     *
                     * var users = [
                     *   { 'user': 'barney',  'active': false },
                     *   { 'user': 'fred',    'active': false},
                     *   { 'user': 'pebbles', 'active': true }
                     * ];
                     *
                     * // using the `_.matches` callback shorthand
                     * _.pluck(_.takeWhile(users, { 'user': 'barney', 'active': false }), 'user');
                     * // => ['barney']
                     *
                     * // using the `_.matchesProperty` callback shorthand
                     * _.pluck(_.takeWhile(users, 'active', false), 'user');
                     * // => ['barney', 'fred']
                     *
                     * // using the `_.property` callback shorthand
                     * _.pluck(_.takeWhile(users, 'active'), 'user');
                     * // => []
                     */
                    function takeWhile(array, predicate, thisArg) {
                        return (array && array.length)
                            ? baseWhile(array, getCallback(predicate, thisArg, 3))
                            : [];
                    }

                    /**
                     * Creates an array of unique values, in order, from all of the provided arrays
                     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
                     * for equality comparisons.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {...Array} [arrays] The arrays to inspect.
                     * @returns {Array} Returns the new array of combined values.
                     * @example
                     *
                     * _.union([1, 2], [4, 2], [2, 1]);
                     * // => [1, 2, 4]
                     */
                    var union = restParam(function (arrays) {
                        return baseUniq(baseFlatten(arrays, false, true));
                    });

                    /**
                     * Creates a duplicate-free version of an array, using
                     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
                     * for equality comparisons, in which only the first occurence of each element
                     * is kept. Providing `true` for `isSorted` performs a faster search algorithm
                     * for sorted arrays. If an iteratee function is provided it is invoked for
                     * each element in the array to generate the criterion by which uniqueness
                     * is computed. The `iteratee` is bound to `thisArg` and invoked with three
                     * arguments: (value, index, array).
                     *
                     * If a property name is provided for `iteratee` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `iteratee` the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @alias unique
                     * @category Array
                     * @param {Array} array The array to inspect.
                     * @param {boolean} [isSorted] Specify the array is sorted.
                     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {Array} Returns the new duplicate-value-free array.
                     * @example
                     *
                     * _.uniq([2, 1, 2]);
                     * // => [2, 1]
                     *
                     * // using `isSorted`
                     * _.uniq([1, 1, 2], true);
                     * // => [1, 2]
                     *
                     * // using an iteratee function
                     * _.uniq([1, 2.5, 1.5, 2], function(n) {
                     *   return this.floor(n);
                     * }, Math);
                     * // => [1, 2.5]
                     *
                     * // using the `_.property` callback shorthand
                     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
                     * // => [{ 'x': 1 }, { 'x': 2 }]
                     */
                    function uniq(array, isSorted, iteratee, thisArg) {
                        var length = array ? array.length : 0;
                        if (!length) {
                            return [];
                        }
                        if (isSorted != null && typeof isSorted != 'boolean') {
                            thisArg = iteratee;
                            iteratee = isIterateeCall(array, isSorted, thisArg) ? undefined : isSorted;
                            isSorted = false;
                        }
                        var callback = getCallback();
                        if (!(iteratee == null && callback === baseCallback)) {
                            iteratee = callback(iteratee, thisArg, 3);
                        }
                        return (isSorted && getIndexOf() == baseIndexOf)
                            ? sortedUniq(array, iteratee)
                            : baseUniq(array, iteratee);
                    }

                    /**
                     * This method is like `_.zip` except that it accepts an array of grouped
                     * elements and creates an array regrouping the elements to their pre-zip
                     * configuration.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array of grouped elements to process.
                     * @returns {Array} Returns the new array of regrouped elements.
                     * @example
                     *
                     * var zipped = _.zip(['fred', 'barney'], [30, 40], [true, false]);
                     * // => [['fred', 30, true], ['barney', 40, false]]
                     *
                     * _.unzip(zipped);
                     * // => [['fred', 'barney'], [30, 40], [true, false]]
                     */
                    function unzip(array) {
                        if (!(array && array.length)) {
                            return [];
                        }
                        var index = -1,
                            length = 0;

                        array = arrayFilter(array, function (group) {
                            if (isArrayLike(group)) {
                                length = nativeMax(group.length, length);
                                return true;
                            }
                        });
                        var result = Array(length);
                        while (++index < length) {
                            result[index] = arrayMap(array, baseProperty(index));
                        }
                        return result;
                    }

                    /**
                     * This method is like `_.unzip` except that it accepts an iteratee to specify
                     * how regrouped values should be combined. The `iteratee` is bound to `thisArg`
                     * and invoked with four arguments: (accumulator, value, index, group).
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array of grouped elements to process.
                     * @param {Function} [iteratee] The function to combine regrouped values.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {Array} Returns the new array of regrouped elements.
                     * @example
                     *
                     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
                     * // => [[1, 10, 100], [2, 20, 200]]
                     *
                     * _.unzipWith(zipped, _.add);
                     * // => [3, 30, 300]
                     */
                    function unzipWith(array, iteratee, thisArg) {
                        var length = array ? array.length : 0;
                        if (!length) {
                            return [];
                        }
                        var result = unzip(array);
                        if (iteratee == null) {
                            return result;
                        }
                        iteratee = bindCallback(iteratee, thisArg, 4);
                        return arrayMap(result, function (group) {
                            return arrayReduce(group, iteratee, undefined, true);
                        });
                    }

                    /**
                     * Creates an array excluding all provided values using
                     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
                     * for equality comparisons.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to filter.
                     * @param {...*} [values] The values to exclude.
                     * @returns {Array} Returns the new array of filtered values.
                     * @example
                     *
                     * _.without([1, 2, 1, 3], 1, 2);
                     * // => [3]
                     */
                    var without = restParam(function (array, values) {
                        return isArrayLike(array)
                            ? baseDifference(array, values)
                            : [];
                    });

                    /**
                     * Creates an array of unique values that is the [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
                     * of the provided arrays.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {...Array} [arrays] The arrays to inspect.
                     * @returns {Array} Returns the new array of values.
                     * @example
                     *
                     * _.xor([1, 2], [4, 2]);
                     * // => [1, 4]
                     */
                    function xor() {
                        var index = -1,
                            length = arguments.length;

                        while (++index < length) {
                            var array = arguments[index];
                            if (isArrayLike(array)) {
                                var result = result
                                    ? arrayPush(baseDifference(result, array), baseDifference(array, result))
                                    : array;
                            }
                        }
                        return result ? baseUniq(result) : [];
                    }

                    /**
                     * Creates an array of grouped elements, the first of which contains the first
                     * elements of the given arrays, the second of which contains the second elements
                     * of the given arrays, and so on.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {...Array} [arrays] The arrays to process.
                     * @returns {Array} Returns the new array of grouped elements.
                     * @example
                     *
                     * _.zip(['fred', 'barney'], [30, 40], [true, false]);
                     * // => [['fred', 30, true], ['barney', 40, false]]
                     */
                    var zip = restParam(unzip);

                    /**
                     * The inverse of `_.pairs`; this method returns an object composed from arrays
                     * of property names and values. Provide either a single two dimensional array,
                     * e.g. `[[key1, value1], [key2, value2]]` or two arrays, one of property names
                     * and one of corresponding values.
                     *
                     * @static
                     * @memberOf _
                     * @alias object
                     * @category Array
                     * @param {Array} props The property names.
                     * @param {Array} [values=[]] The property values.
                     * @returns {Object} Returns the new object.
                     * @example
                     *
                     * _.zipObject([['fred', 30], ['barney', 40]]);
                     * // => { 'fred': 30, 'barney': 40 }
                     *
                     * _.zipObject(['fred', 'barney'], [30, 40]);
                     * // => { 'fred': 30, 'barney': 40 }
                     */
                    function zipObject(props, values) {
                        var index = -1,
                            length = props ? props.length : 0,
                            result = {};

                        if (length && !values && !isArray(props[0])) {
                            values = [];
                        }
                        while (++index < length) {
                            var key = props[index];
                            if (values) {
                                result[key] = values[index];
                            } else if (key) {
                                result[key[0]] = key[1];
                            }
                        }
                        return result;
                    }

                    /**
                     * This method is like `_.zip` except that it accepts an iteratee to specify
                     * how grouped values should be combined. The `iteratee` is bound to `thisArg`
                     * and invoked with four arguments: (accumulator, value, index, group).
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {...Array} [arrays] The arrays to process.
                     * @param {Function} [iteratee] The function to combine grouped values.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {Array} Returns the new array of grouped elements.
                     * @example
                     *
                     * _.zipWith([1, 2], [10, 20], [100, 200], _.add);
                     * // => [111, 222]
                     */
                    var zipWith = restParam(function (arrays) {
                        var length = arrays.length,
                            iteratee = length > 2 ? arrays[length - 2] : undefined,
                            thisArg = length > 1 ? arrays[length - 1] : undefined;

                        if (length > 2 && typeof iteratee == 'function') {
                            length -= 2;
                        } else {
                            iteratee = (length > 1 && typeof thisArg == 'function') ? (--length, thisArg) : undefined;
                            thisArg = undefined;
                        }
                        arrays.length = length;
                        return unzipWith(arrays, iteratee, thisArg);
                    });

                    /*------------------------------------------------------------------------*/

                    /**
                     * Creates a `lodash` object that wraps `value` with explicit method
                     * chaining enabled.
                     *
                     * @static
                     * @memberOf _
                     * @category Chain
                     * @param {*} value The value to wrap.
                     * @returns {Object} Returns the new `lodash` wrapper instance.
                     * @example
                     *
                     * var users = [
                     *   { 'user': 'barney',  'age': 36 },
                     *   { 'user': 'fred',    'age': 40 },
                     *   { 'user': 'pebbles', 'age': 1 }
                     * ];
                     *
                     * var youngest = _.chain(users)
                     *   .sortBy('age')
                     *   .map(function(chr) {
                     *     return chr.user + ' is ' + chr.age;
                     *   })
                     *   .first()
                     *   .value();
                     * // => 'pebbles is 1'
                     */
                    function chain(value) {
                        var result = lodash(value);
                        result.__chain__ = true;
                        return result;
                    }

                    /**
                     * This method invokes `interceptor` and returns `value`. The interceptor is
                     * bound to `thisArg` and invoked with one argument; (value). The purpose of
                     * this method is to "tap into" a method chain in order to perform operations
                     * on intermediate results within the chain.
                     *
                     * @static
                     * @memberOf _
                     * @category Chain
                     * @param {*} value The value to provide to `interceptor`.
                     * @param {Function} interceptor The function to invoke.
                     * @param {*} [thisArg] The `this` binding of `interceptor`.
                     * @returns {*} Returns `value`.
                     * @example
                     *
                     * _([1, 2, 3])
                     *  .tap(function(array) {
                     *    array.pop();
                     *  })
                     *  .reverse()
                     *  .value();
                     * // => [2, 1]
                     */
                    function tap(value, interceptor, thisArg) {
                        interceptor.call(thisArg, value);
                        return value;
                    }

                    /**
                     * This method is like `_.tap` except that it returns the result of `interceptor`.
                     *
                     * @static
                     * @memberOf _
                     * @category Chain
                     * @param {*} value The value to provide to `interceptor`.
                     * @param {Function} interceptor The function to invoke.
                     * @param {*} [thisArg] The `this` binding of `interceptor`.
                     * @returns {*} Returns the result of `interceptor`.
                     * @example
                     *
                     * _('  abc  ')
                     *  .chain()
                     *  .trim()
                     *  .thru(function(value) {
                     *    return [value];
                     *  })
                     *  .value();
                     * // => ['abc']
                     */
                    function thru(value, interceptor, thisArg) {
                        return interceptor.call(thisArg, value);
                    }

                    /**
                     * Enables explicit method chaining on the wrapper object.
                     *
                     * @name chain
                     * @memberOf _
                     * @category Chain
                     * @returns {Object} Returns the new `lodash` wrapper instance.
                     * @example
                     *
                     * var users = [
                     *   { 'user': 'barney', 'age': 36 },
                     *   { 'user': 'fred',   'age': 40 }
                     * ];
                     *
                     * // without explicit chaining
                     * _(users).first();
                     * // => { 'user': 'barney', 'age': 36 }
                     *
                     * // with explicit chaining
                     * _(users).chain()
                     *   .first()
                     *   .pick('user')
                     *   .value();
                     * // => { 'user': 'barney' }
                     */
                    function wrapperChain() {
                        return chain(this);
                    }

                    /**
                     * Executes the chained sequence and returns the wrapped result.
                     *
                     * @name commit
                     * @memberOf _
                     * @category Chain
                     * @returns {Object} Returns the new `lodash` wrapper instance.
                     * @example
                     *
                     * var array = [1, 2];
                     * var wrapped = _(array).push(3);
                     *
                     * console.log(array);
                     * // => [1, 2]
                     *
                     * wrapped = wrapped.commit();
                     * console.log(array);
                     * // => [1, 2, 3]
                     *
                     * wrapped.last();
                     * // => 3
                     *
                     * console.log(array);
                     * // => [1, 2, 3]
                     */
                    function wrapperCommit() {
                        return new LodashWrapper(this.value(), this.__chain__);
                    }

                    /**
                     * Creates a new array joining a wrapped array with any additional arrays
                     * and/or values.
                     *
                     * @name concat
                     * @memberOf _
                     * @category Chain
                     * @param {...*} [values] The values to concatenate.
                     * @returns {Array} Returns the new concatenated array.
                     * @example
                     *
                     * var array = [1];
                     * var wrapped = _(array).concat(2, [3], [[4]]);
                     *
                     * console.log(wrapped.value());
                     * // => [1, 2, 3, [4]]
                     *
                     * console.log(array);
                     * // => [1]
                     */
                    var wrapperConcat = restParam(function (values) {
                        values = baseFlatten(values);
                        return this.thru(function (array) {
                            return arrayConcat(isArray(array) ? array : [toObject(array)], values);
                        });
                    });

                    /**
                     * Creates a clone of the chained sequence planting `value` as the wrapped value.
                     *
                     * @name plant
                     * @memberOf _
                     * @category Chain
                     * @returns {Object} Returns the new `lodash` wrapper instance.
                     * @example
                     *
                     * var array = [1, 2];
                     * var wrapped = _(array).map(function(value) {
                     *   return Math.pow(value, 2);
                     * });
                     *
                     * var other = [3, 4];
                     * var otherWrapped = wrapped.plant(other);
                     *
                     * otherWrapped.value();
                     * // => [9, 16]
                     *
                     * wrapped.value();
                     * // => [1, 4]
                     */
                    function wrapperPlant(value) {
                        var result,
                            parent = this;

                        while (parent instanceof baseLodash) {
                            var clone = wrapperClone(parent);
                            if (result) {
                                previous.__wrapped__ = clone;
                            } else {
                                result = clone;
                            }
                            var previous = clone;
                            parent = parent.__wrapped__;
                        }
                        previous.__wrapped__ = value;
                        return result;
                    }

                    /**
                     * Reverses the wrapped array so the first element becomes the last, the
                     * second element becomes the second to last, and so on.
                     *
                     * **Note:** This method mutates the wrapped array.
                     *
                     * @name reverse
                     * @memberOf _
                     * @category Chain
                     * @returns {Object} Returns the new reversed `lodash` wrapper instance.
                     * @example
                     *
                     * var array = [1, 2, 3];
                     *
                     * _(array).reverse().value()
                     * // => [3, 2, 1]
                     *
                     * console.log(array);
                     * // => [3, 2, 1]
                     */
                    function wrapperReverse() {
                        var value = this.__wrapped__;

                        var interceptor = function (value) {
                            return (wrapped && wrapped.__dir__ < 0) ? value : value.reverse();
                        };
                        if (value instanceof LazyWrapper) {
                            var wrapped = value;
                            if (this.__actions__.length) {
                                wrapped = new LazyWrapper(this);
                            }
                            wrapped = wrapped.reverse();
                            wrapped.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });
                            return new LodashWrapper(wrapped, this.__chain__);
                        }
                        return this.thru(interceptor);
                    }

                    /**
                     * Produces the result of coercing the unwrapped value to a string.
                     *
                     * @name toString
                     * @memberOf _
                     * @category Chain
                     * @returns {string} Returns the coerced string value.
                     * @example
                     *
                     * _([1, 2, 3]).toString();
                     * // => '1,2,3'
                     */
                    function wrapperToString() {
                        return (this.value() + '');
                    }

                    /**
                     * Executes the chained sequence to extract the unwrapped value.
                     *
                     * @name value
                     * @memberOf _
                     * @alias run, toJSON, valueOf
                     * @category Chain
                     * @returns {*} Returns the resolved unwrapped value.
                     * @example
                     *
                     * _([1, 2, 3]).value();
                     * // => [1, 2, 3]
                     */
                    function wrapperValue() {
                        return baseWrapperValue(this.__wrapped__, this.__actions__);
                    }

                    /*------------------------------------------------------------------------*/

                    /**
                     * Creates an array of elements corresponding to the given keys, or indexes,
                     * of `collection`. Keys may be specified as individual arguments or as arrays
                     * of keys.
                     *
                     * @static
                     * @memberOf _
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {...(number|number[]|string|string[])} [props] The property names
                     *  or indexes of elements to pick, specified individually or in arrays.
                     * @returns {Array} Returns the new array of picked elements.
                     * @example
                     *
                     * _.at(['a', 'b', 'c'], [0, 2]);
                     * // => ['a', 'c']
                     *
                     * _.at(['barney', 'fred', 'pebbles'], 0, 2);
                     * // => ['barney', 'pebbles']
                     */
                    var at = restParam(function (collection, props) {
                        return baseAt(collection, baseFlatten(props));
                    });

                    /**
                     * Creates an object composed of keys generated from the results of running
                     * each element of `collection` through `iteratee`. The corresponding value
                     * of each key is the number of times the key was returned by `iteratee`.
                     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
                     * (value, index|key, collection).
                     *
                     * If a property name is provided for `iteratee` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `iteratee` the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {Object} Returns the composed aggregate object.
                     * @example
                     *
                     * _.countBy([4.3, 6.1, 6.4], function(n) {
                     *   return Math.floor(n);
                     * });
                     * // => { '4': 1, '6': 2 }
                     *
                     * _.countBy([4.3, 6.1, 6.4], function(n) {
                     *   return this.floor(n);
                     * }, Math);
                     * // => { '4': 1, '6': 2 }
                     *
                     * _.countBy(['one', 'two', 'three'], 'length');
                     * // => { '3': 2, '5': 1 }
                     */
                    var countBy = createAggregator(function (result, value, key) {
                        hasOwnProperty.call(result, key) ? ++result[key] : (result[key] = 1);
                    });

                    /**
                     * Checks if `predicate` returns truthy for **all** elements of `collection`.
                     * The predicate is bound to `thisArg` and invoked with three arguments:
                     * (value, index|key, collection).
                     *
                     * If a property name is provided for `predicate` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `predicate` the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @alias all
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [predicate=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `predicate`.
                     * @returns {boolean} Returns `true` if all elements pass the predicate check,
                     *  else `false`.
                     * @example
                     *
                     * _.every([true, 1, null, 'yes'], Boolean);
                     * // => false
                     *
                     * var users = [
                     *   { 'user': 'barney', 'active': false },
                     *   { 'user': 'fred',   'active': false }
                     * ];
                     *
                     * // using the `_.matches` callback shorthand
                     * _.every(users, { 'user': 'barney', 'active': false });
                     * // => false
                     *
                     * // using the `_.matchesProperty` callback shorthand
                     * _.every(users, 'active', false);
                     * // => true
                     *
                     * // using the `_.property` callback shorthand
                     * _.every(users, 'active');
                     * // => false
                     */
                    function every(collection, predicate, thisArg) {
                        var func = isArray(collection) ? arrayEvery : baseEvery;
                        if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
                            predicate = undefined;
                        }
                        if (typeof predicate != 'function' || thisArg !== undefined) {
                            predicate = getCallback(predicate, thisArg, 3);
                        }
                        return func(collection, predicate);
                    }

                    /**
                     * Iterates over elements of `collection`, returning an array of all elements
                     * `predicate` returns truthy for. The predicate is bound to `thisArg` and
                     * invoked with three arguments: (value, index|key, collection).
                     *
                     * If a property name is provided for `predicate` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `predicate` the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @alias select
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [predicate=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `predicate`.
                     * @returns {Array} Returns the new filtered array.
                     * @example
                     *
                     * _.filter([4, 5, 6], function(n) {
                     *   return n % 2 == 0;
                     * });
                     * // => [4, 6]
                     *
                     * var users = [
                     *   { 'user': 'barney', 'age': 36, 'active': true },
                     *   { 'user': 'fred',   'age': 40, 'active': false }
                     * ];
                     *
                     * // using the `_.matches` callback shorthand
                     * _.pluck(_.filter(users, { 'age': 36, 'active': true }), 'user');
                     * // => ['barney']
                     *
                     * // using the `_.matchesProperty` callback shorthand
                     * _.pluck(_.filter(users, 'active', false), 'user');
                     * // => ['fred']
                     *
                     * // using the `_.property` callback shorthand
                     * _.pluck(_.filter(users, 'active'), 'user');
                     * // => ['barney']
                     */
                    function filter(collection, predicate, thisArg) {
                        var func = isArray(collection) ? arrayFilter : baseFilter;
                        predicate = getCallback(predicate, thisArg, 3);
                        return func(collection, predicate);
                    }

                    /**
                     * Iterates over elements of `collection`, returning the first element
                     * `predicate` returns truthy for. The predicate is bound to `thisArg` and
                     * invoked with three arguments: (value, index|key, collection).
                     *
                     * If a property name is provided for `predicate` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `predicate` the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @alias detect
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to search.
                     * @param {Function|Object|string} [predicate=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `predicate`.
                     * @returns {*} Returns the matched element, else `undefined`.
                     * @example
                     *
                     * var users = [
                     *   { 'user': 'barney',  'age': 36, 'active': true },
                     *   { 'user': 'fred',    'age': 40, 'active': false },
                     *   { 'user': 'pebbles', 'age': 1,  'active': true }
                     * ];
                     *
                     * _.result(_.find(users, function(chr) {
                     *   return chr.age < 40;
                     * }), 'user');
                     * // => 'barney'
                     *
                     * // using the `_.matches` callback shorthand
                     * _.result(_.find(users, { 'age': 1, 'active': true }), 'user');
                     * // => 'pebbles'
                     *
                     * // using the `_.matchesProperty` callback shorthand
                     * _.result(_.find(users, 'active', false), 'user');
                     * // => 'fred'
                     *
                     * // using the `_.property` callback shorthand
                     * _.result(_.find(users, 'active'), 'user');
                     * // => 'barney'
                     */
                    var find = createFind(baseEach);

                    /**
                     * This method is like `_.find` except that it iterates over elements of
                     * `collection` from right to left.
                     *
                     * @static
                     * @memberOf _
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to search.
                     * @param {Function|Object|string} [predicate=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `predicate`.
                     * @returns {*} Returns the matched element, else `undefined`.
                     * @example
                     *
                     * _.findLast([1, 2, 3, 4], function(n) {
                     *   return n % 2 == 1;
                     * });
                     * // => 3
                     */
                    var findLast = createFind(baseEachRight, true);

                    /**
                     * Performs a deep comparison between each element in `collection` and the
                     * source object, returning the first element that has equivalent property
                     * values.
                     *
                     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
                     * numbers, `Object` objects, regexes, and strings. Objects are compared by
                     * their own, not inherited, enumerable properties. For comparing a single
                     * own or inherited property value see `_.matchesProperty`.
                     *
                     * @static
                     * @memberOf _
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to search.
                     * @param {Object} source The object of property values to match.
                     * @returns {*} Returns the matched element, else `undefined`.
                     * @example
                     *
                     * var users = [
                     *   { 'user': 'barney', 'age': 36, 'active': true },
                     *   { 'user': 'fred',   'age': 40, 'active': false }
                     * ];
                     *
                     * _.result(_.findWhere(users, { 'age': 36, 'active': true }), 'user');
                     * // => 'barney'
                     *
                     * _.result(_.findWhere(users, { 'age': 40, 'active': false }), 'user');
                     * // => 'fred'
                     */
                    function findWhere(collection, source) {
                        return find(collection, baseMatches(source));
                    }

                    /**
                     * Iterates over elements of `collection` invoking `iteratee` for each element.
                     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
                     * (value, index|key, collection). Iteratee functions may exit iteration early
                     * by explicitly returning `false`.
                     *
                     * **Note:** As with other "Collections" methods, objects with a "length" property
                     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
                     * may be used for object iteration.
                     *
                     * @static
                     * @memberOf _
                     * @alias each
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {Array|Object|string} Returns `collection`.
                     * @example
                     *
                     * _([1, 2]).forEach(function(n) {
                     *   console.log(n);
                     * }).value();
                     * // => logs each value from left to right and returns the array
                     *
                     * _.forEach({ 'a': 1, 'b': 2 }, function(n, key) {
                     *   console.log(n, key);
                     * });
                     * // => logs each value-key pair and returns the object (iteration order is not guaranteed)
                     */
                    var forEach = createForEach(arrayEach, baseEach);

                    /**
                     * This method is like `_.forEach` except that it iterates over elements of
                     * `collection` from right to left.
                     *
                     * @static
                     * @memberOf _
                     * @alias eachRight
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {Array|Object|string} Returns `collection`.
                     * @example
                     *
                     * _([1, 2]).forEachRight(function(n) {
                     *   console.log(n);
                     * }).value();
                     * // => logs each value from right to left and returns the array
                     */
                    var forEachRight = createForEach(arrayEachRight, baseEachRight);

                    /**
                     * Creates an object composed of keys generated from the results of running
                     * each element of `collection` through `iteratee`. The corresponding value
                     * of each key is an array of the elements responsible for generating the key.
                     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
                     * (value, index|key, collection).
                     *
                     * If a property name is provided for `iteratee` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `iteratee` the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {Object} Returns the composed aggregate object.
                     * @example
                     *
                     * _.groupBy([4.2, 6.1, 6.4], function(n) {
                     *   return Math.floor(n);
                     * });
                     * // => { '4': [4.2], '6': [6.1, 6.4] }
                     *
                     * _.groupBy([4.2, 6.1, 6.4], function(n) {
                     *   return this.floor(n);
                     * }, Math);
                     * // => { '4': [4.2], '6': [6.1, 6.4] }
                     *
                     * // using the `_.property` callback shorthand
                     * _.groupBy(['one', 'two', 'three'], 'length');
                     * // => { '3': ['one', 'two'], '5': ['three'] }
                     */
                    var groupBy = createAggregator(function (result, value, key) {
                        if (hasOwnProperty.call(result, key)) {
                            result[key].push(value);
                        } else {
                            result[key] = [value];
                        }
                    });

                    /**
                     * Checks if `value` is in `collection` using
                     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
                     * for equality comparisons. If `fromIndex` is negative, it is used as the offset
                     * from the end of `collection`.
                     *
                     * @static
                     * @memberOf _
                     * @alias contains, include
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to search.
                     * @param {*} target The value to search for.
                     * @param {number} [fromIndex=0] The index to search from.
                     * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.
                     * @returns {boolean} Returns `true` if a matching element is found, else `false`.
                     * @example
                     *
                     * _.includes([1, 2, 3], 1);
                     * // => true
                     *
                     * _.includes([1, 2, 3], 1, 2);
                     * // => false
                     *
                     * _.includes({ 'user': 'fred', 'age': 40 }, 'fred');
                     * // => true
                     *
                     * _.includes('pebbles', 'eb');
                     * // => true
                     */
                    function includes(collection, target, fromIndex, guard) {
                        var length = collection ? getLength(collection) : 0;
                        if (!isLength(length)) {
                            collection = values(collection);
                            length = collection.length;
                        }
                        if (typeof fromIndex != 'number' || (guard && isIterateeCall(target, fromIndex, guard))) {
                            fromIndex = 0;
                        } else {
                            fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);
                        }
                        return (typeof collection == 'string' || !isArray(collection) && isString(collection))
                            ? (fromIndex <= length && collection.indexOf(target, fromIndex) > -1)
                            : (!!length && getIndexOf(collection, target, fromIndex) > -1);
                    }

                    /**
                     * Creates an object composed of keys generated from the results of running
                     * each element of `collection` through `iteratee`. The corresponding value
                     * of each key is the last element responsible for generating the key. The
                     * iteratee function is bound to `thisArg` and invoked with three arguments:
                     * (value, index|key, collection).
                     *
                     * If a property name is provided for `iteratee` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `iteratee` the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {Object} Returns the composed aggregate object.
                     * @example
                     *
                     * var keyData = [
                     *   { 'dir': 'left', 'code': 97 },
                     *   { 'dir': 'right', 'code': 100 }
                     * ];
                     *
                     * _.indexBy(keyData, 'dir');
                     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
                     *
                     * _.indexBy(keyData, function(object) {
                     *   return String.fromCharCode(object.code);
                     * });
                     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
                     *
                     * _.indexBy(keyData, function(object) {
                     *   return this.fromCharCode(object.code);
                     * }, String);
                     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
                     */
                    var indexBy = createAggregator(function (result, value, key) {
                        result[key] = value;
                    });

                    /**
                     * Invokes the method at `path` of each element in `collection`, returning
                     * an array of the results of each invoked method. Any additional arguments
                     * are provided to each invoked method. If `methodName` is a function it is
                     * invoked for, and `this` bound to, each element in `collection`.
                     *
                     * @static
                     * @memberOf _
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Array|Function|string} path The path of the method to invoke or
                     *  the function invoked per iteration.
                     * @param {...*} [args] The arguments to invoke the method with.
                     * @returns {Array} Returns the array of results.
                     * @example
                     *
                     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
                     * // => [[1, 5, 7], [1, 2, 3]]
                     *
                     * _.invoke([123, 456], String.prototype.split, '');
                     * // => [['1', '2', '3'], ['4', '5', '6']]
                     */
                    var invoke = restParam(function (collection, path, args) {
                        var index = -1,
                            isFunc = typeof path == 'function',
                            isProp = isKey(path),
                            result = isArrayLike(collection) ? Array(collection.length) : [];

                        baseEach(collection, function (value) {
                            var func = isFunc ? path : ((isProp && value != null) ? value[path] : undefined);
                            result[++index] = func ? func.apply(value, args) : invokePath(value, path, args);
                        });
                        return result;
                    });

                    /**
                     * Creates an array of values by running each element in `collection` through
                     * `iteratee`. The `iteratee` is bound to `thisArg` and invoked with three
                     * arguments: (value, index|key, collection).
                     *
                     * If a property name is provided for `iteratee` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `iteratee` the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * Many lodash methods are guarded to work as iteratees for methods like
                     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
                     *
                     * The guarded methods are:
                     * `ary`, `callback`, `chunk`, `clone`, `create`, `curry`, `curryRight`,
                     * `drop`, `dropRight`, `every`, `fill`, `flatten`, `invert`, `max`, `min`,
                     * `parseInt`, `slice`, `sortBy`, `take`, `takeRight`, `template`, `trim`,
                     * `trimLeft`, `trimRight`, `trunc`, `random`, `range`, `sample`, `some`,
                     * `sum`, `uniq`, and `words`
                     *
                     * @static
                     * @memberOf _
                     * @alias collect
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {Array} Returns the new mapped array.
                     * @example
                     *
                     * function timesThree(n) {
                     *   return n * 3;
                     * }
                     *
                     * _.map([1, 2], timesThree);
                     * // => [3, 6]
                     *
                     * _.map({ 'a': 1, 'b': 2 }, timesThree);
                     * // => [3, 6] (iteration order is not guaranteed)
                     *
                     * var users = [
                     *   { 'user': 'barney' },
                     *   { 'user': 'fred' }
                     * ];
                     *
                     * // using the `_.property` callback shorthand
                     * _.map(users, 'user');
                     * // => ['barney', 'fred']
                     */
                    function map(collection, iteratee, thisArg) {
                        var func = isArray(collection) ? arrayMap : baseMap;
                        iteratee = getCallback(iteratee, thisArg, 3);
                        return func(collection, iteratee);
                    }

                    /**
                     * Creates an array of elements split into two groups, the first of which
                     * contains elements `predicate` returns truthy for, while the second of which
                     * contains elements `predicate` returns falsey for. The predicate is bound
                     * to `thisArg` and invoked with three arguments: (value, index|key, collection).
                     *
                     * If a property name is provided for `predicate` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `predicate` the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [predicate=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `predicate`.
                     * @returns {Array} Returns the array of grouped elements.
                     * @example
                     *
                     * _.partition([1, 2, 3], function(n) {
                     *   return n % 2;
                     * });
                     * // => [[1, 3], [2]]
                     *
                     * _.partition([1.2, 2.3, 3.4], function(n) {
                     *   return this.floor(n) % 2;
                     * }, Math);
                     * // => [[1.2, 3.4], [2.3]]
                     *
                     * var users = [
                     *   { 'user': 'barney',  'age': 36, 'active': false },
                     *   { 'user': 'fred',    'age': 40, 'active': true },
                     *   { 'user': 'pebbles', 'age': 1,  'active': false }
                     * ];
                     *
                     * var mapper = function(array) {
                     *   return _.pluck(array, 'user');
                     * };
                     *
                     * // using the `_.matches` callback shorthand
                     * _.map(_.partition(users, { 'age': 1, 'active': false }), mapper);
                     * // => [['pebbles'], ['barney', 'fred']]
                     *
                     * // using the `_.matchesProperty` callback shorthand
                     * _.map(_.partition(users, 'active', false), mapper);
                     * // => [['barney', 'pebbles'], ['fred']]
                     *
                     * // using the `_.property` callback shorthand
                     * _.map(_.partition(users, 'active'), mapper);
                     * // => [['fred'], ['barney', 'pebbles']]
                     */
                    var partition = createAggregator(function (result, value, key) {
                        result[key ? 0 : 1].push(value);
                    }, function () { return [[], []]; });

                    /**
                     * Gets the property value of `path` from all elements in `collection`.
                     *
                     * @static
                     * @memberOf _
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Array|string} path The path of the property to pluck.
                     * @returns {Array} Returns the property values.
                     * @example
                     *
                     * var users = [
                     *   { 'user': 'barney', 'age': 36 },
                     *   { 'user': 'fred',   'age': 40 }
                     * ];
                     *
                     * _.pluck(users, 'user');
                     * // => ['barney', 'fred']
                     *
                     * var userIndex = _.indexBy(users, 'user');
                     * _.pluck(userIndex, 'age');
                     * // => [36, 40] (iteration order is not guaranteed)
                     */
                    function pluck(collection, path) {
                        return map(collection, property(path));
                    }

                    /**
                     * Reduces `collection` to a value which is the accumulated result of running
                     * each element in `collection` through `iteratee`, where each successive
                     * invocation is supplied the return value of the previous. If `accumulator`
                     * is not provided the first element of `collection` is used as the initial
                     * value. The `iteratee` is bound to `thisArg` and invoked with four arguments:
                     * (accumulator, value, index|key, collection).
                     *
                     * Many lodash methods are guarded to work as iteratees for methods like
                     * `_.reduce`, `_.reduceRight`, and `_.transform`.
                     *
                     * The guarded methods are:
                     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `sortByAll`,
                     * and `sortByOrder`
                     *
                     * @static
                     * @memberOf _
                     * @alias foldl, inject
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                     * @param {*} [accumulator] The initial value.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {*} Returns the accumulated value.
                     * @example
                     *
                     * _.reduce([1, 2], function(total, n) {
                     *   return total + n;
                     * });
                     * // => 3
                     *
                     * _.reduce({ 'a': 1, 'b': 2 }, function(result, n, key) {
                     *   result[key] = n * 3;
                     *   return result;
                     * }, {});
                     * // => { 'a': 3, 'b': 6 } (iteration order is not guaranteed)
                     */
                    var reduce = createReduce(arrayReduce, baseEach);

                    /**
                     * This method is like `_.reduce` except that it iterates over elements of
                     * `collection` from right to left.
                     *
                     * @static
                     * @memberOf _
                     * @alias foldr
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                     * @param {*} [accumulator] The initial value.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {*} Returns the accumulated value.
                     * @example
                     *
                     * var array = [[0, 1], [2, 3], [4, 5]];
                     *
                     * _.reduceRight(array, function(flattened, other) {
                     *   return flattened.concat(other);
                     * }, []);
                     * // => [4, 5, 2, 3, 0, 1]
                     */
                    var reduceRight = createReduce(arrayReduceRight, baseEachRight);

                    /**
                     * The opposite of `_.filter`; this method returns the elements of `collection`
                     * that `predicate` does **not** return truthy for.
                     *
                     * @static
                     * @memberOf _
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [predicate=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `predicate`.
                     * @returns {Array} Returns the new filtered array.
                     * @example
                     *
                     * _.reject([1, 2, 3, 4], function(n) {
                     *   return n % 2 == 0;
                     * });
                     * // => [1, 3]
                     *
                     * var users = [
                     *   { 'user': 'barney', 'age': 36, 'active': false },
                     *   { 'user': 'fred',   'age': 40, 'active': true }
                     * ];
                     *
                     * // using the `_.matches` callback shorthand
                     * _.pluck(_.reject(users, { 'age': 40, 'active': true }), 'user');
                     * // => ['barney']
                     *
                     * // using the `_.matchesProperty` callback shorthand
                     * _.pluck(_.reject(users, 'active', false), 'user');
                     * // => ['fred']
                     *
                     * // using the `_.property` callback shorthand
                     * _.pluck(_.reject(users, 'active'), 'user');
                     * // => ['barney']
                     */
                    function reject(collection, predicate, thisArg) {
                        var func = isArray(collection) ? arrayFilter : baseFilter;
                        predicate = getCallback(predicate, thisArg, 3);
                        return func(collection, function (value, index, collection) {
                            return !predicate(value, index, collection);
                        });
                    }

                    /**
                     * Gets a random element or `n` random elements from a collection.
                     *
                     * @static
                     * @memberOf _
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to sample.
                     * @param {number} [n] The number of elements to sample.
                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                     * @returns {*} Returns the random sample(s).
                     * @example
                     *
                     * _.sample([1, 2, 3, 4]);
                     * // => 2
                     *
                     * _.sample([1, 2, 3, 4], 2);
                     * // => [3, 1]
                     */
                    function sample(collection, n, guard) {
                        if (guard ? isIterateeCall(collection, n, guard) : n == null) {
                            collection = toIterable(collection);
                            var length = collection.length;
                            return length > 0 ? collection[baseRandom(0, length - 1)] : undefined;
                        }
                        var index = -1,
                            result = toArray(collection),
                            length = result.length,
                            lastIndex = length - 1;

                        n = nativeMin(n < 0 ? 0 : (+n || 0), length);
                        while (++index < n) {
                            var rand = baseRandom(index, lastIndex),
                                value = result[rand];

                            result[rand] = result[index];
                            result[index] = value;
                        }
                        result.length = n;
                        return result;
                    }

                    /**
                     * Creates an array of shuffled values, using a version of the
                     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
                     *
                     * @static
                     * @memberOf _
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to shuffle.
                     * @returns {Array} Returns the new shuffled array.
                     * @example
                     *
                     * _.shuffle([1, 2, 3, 4]);
                     * // => [4, 1, 3, 2]
                     */
                    function shuffle(collection) {
                        return sample(collection, POSITIVE_INFINITY);
                    }

                    /**
                     * Gets the size of `collection` by returning its length for array-like
                     * values or the number of own enumerable properties for objects.
                     *
                     * @static
                     * @memberOf _
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to inspect.
                     * @returns {number} Returns the size of `collection`.
                     * @example
                     *
                     * _.size([1, 2, 3]);
                     * // => 3
                     *
                     * _.size({ 'a': 1, 'b': 2 });
                     * // => 2
                     *
                     * _.size('pebbles');
                     * // => 7
                     */
                    function size(collection) {
                        var length = collection ? getLength(collection) : 0;
                        return isLength(length) ? length : keys(collection).length;
                    }

                    /**
                     * Checks if `predicate` returns truthy for **any** element of `collection`.
                     * The function returns as soon as it finds a passing value and does not iterate
                     * over the entire collection. The predicate is bound to `thisArg` and invoked
                     * with three arguments: (value, index|key, collection).
                     *
                     * If a property name is provided for `predicate` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `predicate` the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @alias any
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [predicate=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `predicate`.
                     * @returns {boolean} Returns `true` if any element passes the predicate check,
                     *  else `false`.
                     * @example
                     *
                     * _.some([null, 0, 'yes', false], Boolean);
                     * // => true
                     *
                     * var users = [
                     *   { 'user': 'barney', 'active': true },
                     *   { 'user': 'fred',   'active': false }
                     * ];
                     *
                     * // using the `_.matches` callback shorthand
                     * _.some(users, { 'user': 'barney', 'active': false });
                     * // => false
                     *
                     * // using the `_.matchesProperty` callback shorthand
                     * _.some(users, 'active', false);
                     * // => true
                     *
                     * // using the `_.property` callback shorthand
                     * _.some(users, 'active');
                     * // => true
                     */
                    function some(collection, predicate, thisArg) {
                        var func = isArray(collection) ? arraySome : baseSome;
                        if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
                            predicate = undefined;
                        }
                        if (typeof predicate != 'function' || thisArg !== undefined) {
                            predicate = getCallback(predicate, thisArg, 3);
                        }
                        return func(collection, predicate);
                    }

                    /**
                     * Creates an array of elements, sorted in ascending order by the results of
                     * running each element in a collection through `iteratee`. This method performs
                     * a stable sort, that is, it preserves the original sort order of equal elements.
                     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
                     * (value, index|key, collection).
                     *
                     * If a property name is provided for `iteratee` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `iteratee` the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {Array} Returns the new sorted array.
                     * @example
                     *
                     * _.sortBy([1, 2, 3], function(n) {
                     *   return Math.sin(n);
                     * });
                     * // => [3, 1, 2]
                     *
                     * _.sortBy([1, 2, 3], function(n) {
                     *   return this.sin(n);
                     * }, Math);
                     * // => [3, 1, 2]
                     *
                     * var users = [
                     *   { 'user': 'fred' },
                     *   { 'user': 'pebbles' },
                     *   { 'user': 'barney' }
                     * ];
                     *
                     * // using the `_.property` callback shorthand
                     * _.pluck(_.sortBy(users, 'user'), 'user');
                     * // => ['barney', 'fred', 'pebbles']
                     */
                    function sortBy(collection, iteratee, thisArg) {
                        if (collection == null) {
                            return [];
                        }
                        if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
                            iteratee = undefined;
                        }
                        var index = -1;
                        iteratee = getCallback(iteratee, thisArg, 3);

                        var result = baseMap(collection, function (value, key, collection) {
                            return { 'criteria': iteratee(value, key, collection), 'index': ++index, 'value': value };
                        });
                        return baseSortBy(result, compareAscending);
                    }

                    /**
                     * This method is like `_.sortBy` except that it can sort by multiple iteratees
                     * or property names.
                     *
                     * If a property name is provided for an iteratee the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If an object is provided for an iteratee the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {...(Function|Function[]|Object|Object[]|string|string[])} iteratees
                     *  The iteratees to sort by, specified as individual values or arrays of values.
                     * @returns {Array} Returns the new sorted array.
                     * @example
                     *
                     * var users = [
                     *   { 'user': 'fred',   'age': 48 },
                     *   { 'user': 'barney', 'age': 36 },
                     *   { 'user': 'fred',   'age': 42 },
                     *   { 'user': 'barney', 'age': 34 }
                     * ];
                     *
                     * _.map(_.sortByAll(users, ['user', 'age']), _.values);
                     * // => [['barney', 34], ['barney', 36], ['fred', 42], ['fred', 48]]
                     *
                     * _.map(_.sortByAll(users, 'user', function(chr) {
                     *   return Math.floor(chr.age / 10);
                     * }), _.values);
                     * // => [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]
                     */
                    var sortByAll = restParam(function (collection, iteratees) {
                        if (collection == null) {
                            return [];
                        }
                        var guard = iteratees[2];
                        if (guard && isIterateeCall(iteratees[0], iteratees[1], guard)) {
                            iteratees.length = 1;
                        }
                        return baseSortByOrder(collection, baseFlatten(iteratees), []);
                    });

                    /**
                     * This method is like `_.sortByAll` except that it allows specifying the
                     * sort orders of the iteratees to sort by. If `orders` is unspecified, all
                     * values are sorted in ascending order. Otherwise, a value is sorted in
                     * ascending order if its corresponding order is "asc", and descending if "desc".
                     *
                     * If a property name is provided for an iteratee the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If an object is provided for an iteratee the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
                     * @param {boolean[]} [orders] The sort orders of `iteratees`.
                     * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.
                     * @returns {Array} Returns the new sorted array.
                     * @example
                     *
                     * var users = [
                     *   { 'user': 'fred',   'age': 48 },
                     *   { 'user': 'barney', 'age': 34 },
                     *   { 'user': 'fred',   'age': 42 },
                     *   { 'user': 'barney', 'age': 36 }
                     * ];
                     *
                     * // sort by `user` in ascending order and by `age` in descending order
                     * _.map(_.sortByOrder(users, ['user', 'age'], ['asc', 'desc']), _.values);
                     * // => [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]
                     */
                    function sortByOrder(collection, iteratees, orders, guard) {
                        if (collection == null) {
                            return [];
                        }
                        if (guard && isIterateeCall(iteratees, orders, guard)) {
                            orders = undefined;
                        }
                        if (!isArray(iteratees)) {
                            iteratees = iteratees == null ? [] : [iteratees];
                        }
                        if (!isArray(orders)) {
                            orders = orders == null ? [] : [orders];
                        }
                        return baseSortByOrder(collection, iteratees, orders);
                    }

                    /**
                     * Performs a deep comparison between each element in `collection` and the
                     * source object, returning an array of all elements that have equivalent
                     * property values.
                     *
                     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
                     * numbers, `Object` objects, regexes, and strings. Objects are compared by
                     * their own, not inherited, enumerable properties. For comparing a single
                     * own or inherited property value see `_.matchesProperty`.
                     *
                     * @static
                     * @memberOf _
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to search.
                     * @param {Object} source The object of property values to match.
                     * @returns {Array} Returns the new filtered array.
                     * @example
                     *
                     * var users = [
                     *   { 'user': 'barney', 'age': 36, 'active': false, 'pets': ['hoppy'] },
                     *   { 'user': 'fred',   'age': 40, 'active': true, 'pets': ['baby puss', 'dino'] }
                     * ];
                     *
                     * _.pluck(_.where(users, { 'age': 36, 'active': false }), 'user');
                     * // => ['barney']
                     *
                     * _.pluck(_.where(users, { 'pets': ['dino'] }), 'user');
                     * // => ['fred']
                     */
                    function where(collection, source) {
                        return filter(collection, baseMatches(source));
                    }

                    /*------------------------------------------------------------------------*/

                    /**
                     * Gets the number of milliseconds that have elapsed since the Unix epoch
                     * (1 January 1970 00:00:00 UTC).
                     *
                     * @static
                     * @memberOf _
                     * @category Date
                     * @example
                     *
                     * _.defer(function(stamp) {
                     *   console.log(_.now() - stamp);
                     * }, _.now());
                     * // => logs the number of milliseconds it took for the deferred function to be invoked
                     */
                    var now = nativeNow || function () {
                        return new Date().getTime();
                    };

                    /*------------------------------------------------------------------------*/

                    /**
                     * The opposite of `_.before`; this method creates a function that invokes
                     * `func` once it is called `n` or more times.
                     *
                     * @static
                     * @memberOf _
                     * @category Function
                     * @param {number} n The number of calls before `func` is invoked.
                     * @param {Function} func The function to restrict.
                     * @returns {Function} Returns the new restricted function.
                     * @example
                     *
                     * var saves = ['profile', 'settings'];
                     *
                     * var done = _.after(saves.length, function() {
                     *   console.log('done saving!');
                     * });
                     *
                     * _.forEach(saves, function(type) {
                     *   asyncSave({ 'type': type, 'complete': done });
                     * });
                     * // => logs 'done saving!' after the two async saves have completed
                     */
                    function after(n, func) {
                        if (typeof func != 'function') {
                            if (typeof n == 'function') {
                                var temp = n;
                                n = func;
                                func = temp;
                            } else {
                                throw new TypeError(FUNC_ERROR_TEXT);
                            }
                        }
                        n = nativeIsFinite(n = +n) ? n : 0;
                        return function () {
                            if (--n < 1) {
                                return func.apply(this, arguments);
                            }
                        };
                    }

                    /**
                     * Creates a function that accepts up to `n` arguments ignoring any
                     * additional arguments.
                     *
                     * @static
                     * @memberOf _
                     * @category Function
                     * @param {Function} func The function to cap arguments for.
                     * @param {number} [n=func.length] The arity cap.
                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                     * @returns {Function} Returns the new function.
                     * @example
                     *
                     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
                     * // => [6, 8, 10]
                     */
                    function ary(func, n, guard) {
                        if (guard && isIterateeCall(func, n, guard)) {
                            n = undefined;
                        }
                        n = (func && n == null) ? func.length : nativeMax(+n || 0, 0);
                        return createWrapper(func, ARY_FLAG, undefined, undefined, undefined, undefined, n);
                    }

                    /**
                     * Creates a function that invokes `func`, with the `this` binding and arguments
                     * of the created function, while it is called less than `n` times. Subsequent
                     * calls to the created function return the result of the last `func` invocation.
                     *
                     * @static
                     * @memberOf _
                     * @category Function
                     * @param {number} n The number of calls at which `func` is no longer invoked.
                     * @param {Function} func The function to restrict.
                     * @returns {Function} Returns the new restricted function.
                     * @example
                     *
                     * jQuery('#add').on('click', _.before(5, addContactToList));
                     * // => allows adding up to 4 contacts to the list
                     */
                    function before(n, func) {
                        var result;
                        if (typeof func != 'function') {
                            if (typeof n == 'function') {
                                var temp = n;
                                n = func;
                                func = temp;
                            } else {
                                throw new TypeError(FUNC_ERROR_TEXT);
                            }
                        }
                        return function () {
                            if (--n > 0) {
                                result = func.apply(this, arguments);
                            }
                            if (n <= 1) {
                                func = undefined;
                            }
                            return result;
                        };
                    }

                    /**
                     * Creates a function that invokes `func` with the `this` binding of `thisArg`
                     * and prepends any additional `_.bind` arguments to those provided to the
                     * bound function.
                     *
                     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
                     * may be used as a placeholder for partially applied arguments.
                     *
                     * **Note:** Unlike native `Function#bind` this method does not set the "length"
                     * property of bound functions.
                     *
                     * @static
                     * @memberOf _
                     * @category Function
                     * @param {Function} func The function to bind.
                     * @param {*} thisArg The `this` binding of `func`.
                     * @param {...*} [partials] The arguments to be partially applied.
                     * @returns {Function} Returns the new bound function.
                     * @example
                     *
                     * var greet = function(greeting, punctuation) {
                     *   return greeting + ' ' + this.user + punctuation;
                     * };
                     *
                     * var object = { 'user': 'fred' };
                     *
                     * var bound = _.bind(greet, object, 'hi');
                     * bound('!');
                     * // => 'hi fred!'
                     *
                     * // using placeholders
                     * var bound = _.bind(greet, object, _, '!');
                     * bound('hi');
                     * // => 'hi fred!'
                     */
                    var bind = restParam(function (func, thisArg, partials) {
                        var bitmask = BIND_FLAG;
                        if (partials.length) {
                            var holders = replaceHolders(partials, bind.placeholder);
                            bitmask |= PARTIAL_FLAG;
                        }
                        return createWrapper(func, bitmask, thisArg, partials, holders);
                    });

                    /**
                     * Binds methods of an object to the object itself, overwriting the existing
                     * method. Method names may be specified as individual arguments or as arrays
                     * of method names. If no method names are provided all enumerable function
                     * properties, own and inherited, of `object` are bound.
                     *
                     * **Note:** This method does not set the "length" property of bound functions.
                     *
                     * @static
                     * @memberOf _
                     * @category Function
                     * @param {Object} object The object to bind and assign the bound methods to.
                     * @param {...(string|string[])} [methodNames] The object method names to bind,
                     *  specified as individual method names or arrays of method names.
                     * @returns {Object} Returns `object`.
                     * @example
                     *
                     * var view = {
                     *   'label': 'docs',
                     *   'onClick': function() {
                     *     console.log('clicked ' + this.label);
                     *   }
                     * };
                     *
                     * _.bindAll(view);
                     * jQuery('#docs').on('click', view.onClick);
                     * // => logs 'clicked docs' when the element is clicked
                     */
                    var bindAll = restParam(function (object, methodNames) {
                        methodNames = methodNames.length ? baseFlatten(methodNames) : functions(object);

                        var index = -1,
                            length = methodNames.length;

                        while (++index < length) {
                            var key = methodNames[index];
                            object[key] = createWrapper(object[key], BIND_FLAG, object);
                        }
                        return object;
                    });

                    /**
                     * Creates a function that invokes the method at `object[key]` and prepends
                     * any additional `_.bindKey` arguments to those provided to the bound function.
                     *
                     * This method differs from `_.bind` by allowing bound functions to reference
                     * methods that may be redefined or don't yet exist.
                     * See [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
                     * for more details.
                     *
                     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
                     * builds, may be used as a placeholder for partially applied arguments.
                     *
                     * @static
                     * @memberOf _
                     * @category Function
                     * @param {Object} object The object the method belongs to.
                     * @param {string} key The key of the method.
                     * @param {...*} [partials] The arguments to be partially applied.
                     * @returns {Function} Returns the new bound function.
                     * @example
                     *
                     * var object = {
                     *   'user': 'fred',
                     *   'greet': function(greeting, punctuation) {
                     *     return greeting + ' ' + this.user + punctuation;
                     *   }
                     * };
                     *
                     * var bound = _.bindKey(object, 'greet', 'hi');
                     * bound('!');
                     * // => 'hi fred!'
                     *
                     * object.greet = function(greeting, punctuation) {
                     *   return greeting + 'ya ' + this.user + punctuation;
                     * };
                     *
                     * bound('!');
                     * // => 'hiya fred!'
                     *
                     * // using placeholders
                     * var bound = _.bindKey(object, 'greet', _, '!');
                     * bound('hi');
                     * // => 'hiya fred!'
                     */
                    var bindKey = restParam(function (object, key, partials) {
                        var bitmask = BIND_FLAG | BIND_KEY_FLAG;
                        if (partials.length) {
                            var holders = replaceHolders(partials, bindKey.placeholder);
                            bitmask |= PARTIAL_FLAG;
                        }
                        return createWrapper(key, bitmask, object, partials, holders);
                    });

                    /**
                     * Creates a function that accepts one or more arguments of `func` that when
                     * called either invokes `func` returning its result, if all `func` arguments
                     * have been provided, or returns a function that accepts one or more of the
                     * remaining `func` arguments, and so on. The arity of `func` may be specified
                     * if `func.length` is not sufficient.
                     *
                     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
                     * may be used as a placeholder for provided arguments.
                     *
                     * **Note:** This method does not set the "length" property of curried functions.
                     *
                     * @static
                     * @memberOf _
                     * @category Function
                     * @param {Function} func The function to curry.
                     * @param {number} [arity=func.length] The arity of `func`.
                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                     * @returns {Function} Returns the new curried function.
                     * @example
                     *
                     * var abc = function(a, b, c) {
                     *   return [a, b, c];
                     * };
                     *
                     * var curried = _.curry(abc);
                     *
                     * curried(1)(2)(3);
                     * // => [1, 2, 3]
                     *
                     * curried(1, 2)(3);
                     * // => [1, 2, 3]
                     *
                     * curried(1, 2, 3);
                     * // => [1, 2, 3]
                     *
                     * // using placeholders
                     * curried(1)(_, 3)(2);
                     * // => [1, 2, 3]
                     */
                    var curry = createCurry(CURRY_FLAG);

                    /**
                     * This method is like `_.curry` except that arguments are applied to `func`
                     * in the manner of `_.partialRight` instead of `_.partial`.
                     *
                     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
                     * builds, may be used as a placeholder for provided arguments.
                     *
                     * **Note:** This method does not set the "length" property of curried functions.
                     *
                     * @static
                     * @memberOf _
                     * @category Function
                     * @param {Function} func The function to curry.
                     * @param {number} [arity=func.length] The arity of `func`.
                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                     * @returns {Function} Returns the new curried function.
                     * @example
                     *
                     * var abc = function(a, b, c) {
                     *   return [a, b, c];
                     * };
                     *
                     * var curried = _.curryRight(abc);
                     *
                     * curried(3)(2)(1);
                     * // => [1, 2, 3]
                     *
                     * curried(2, 3)(1);
                     * // => [1, 2, 3]
                     *
                     * curried(1, 2, 3);
                     * // => [1, 2, 3]
                     *
                     * // using placeholders
                     * curried(3)(1, _)(2);
                     * // => [1, 2, 3]
                     */
                    var curryRight = createCurry(CURRY_RIGHT_FLAG);

                    /**
                     * Creates a debounced function that delays invoking `func` until after `wait`
                     * milliseconds have elapsed since the last time the debounced function was
                     * invoked. The debounced function comes with a `cancel` method to cancel
                     * delayed invocations. Provide an options object to indicate that `func`
                     * should be invoked on the leading and/or trailing edge of the `wait` timeout.
                     * Subsequent calls to the debounced function return the result of the last
                     * `func` invocation.
                     *
                     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
                     * on the trailing edge of the timeout only if the the debounced function is
                     * invoked more than once during the `wait` timeout.
                     *
                     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
                     * for details over the differences between `_.debounce` and `_.throttle`.
                     *
                     * @static
                     * @memberOf _
                     * @category Function
                     * @param {Function} func The function to debounce.
                     * @param {number} [wait=0] The number of milliseconds to delay.
                     * @param {Object} [options] The options object.
                     * @param {boolean} [options.leading=false] Specify invoking on the leading
                     *  edge of the timeout.
                     * @param {number} [options.maxWait] The maximum time `func` is allowed to be
                     *  delayed before it is invoked.
                     * @param {boolean} [options.trailing=true] Specify invoking on the trailing
                     *  edge of the timeout.
                     * @returns {Function} Returns the new debounced function.
                     * @example
                     *
                     * // avoid costly calculations while the window size is in flux
                     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
                     *
                     * // invoke `sendMail` when the click event is fired, debouncing subsequent calls
                     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
                     *   'leading': true,
                     *   'trailing': false
                     * }));
                     *
                     * // ensure `batchLog` is invoked once after 1 second of debounced calls
                     * var source = new EventSource('/stream');
                     * jQuery(source).on('message', _.debounce(batchLog, 250, {
                     *   'maxWait': 1000
                     * }));
                     *
                     * // cancel a debounced call
                     * var todoChanges = _.debounce(batchLog, 1000);
                     * Object.observe(models.todo, todoChanges);
                     *
                     * Object.observe(models, function(changes) {
                     *   if (_.find(changes, { 'user': 'todo', 'type': 'delete'})) {
                     *     todoChanges.cancel();
                     *   }
                     * }, ['delete']);
                     *
                     * // ...at some point `models.todo` is changed
                     * models.todo.completed = true;
                     *
                     * // ...before 1 second has passed `models.todo` is deleted
                     * // which cancels the debounced `todoChanges` call
                     * delete models.todo;
                     */
                    function debounce(func, wait, options) {
                        var args,
                            maxTimeoutId,
                            result,
                            stamp,
                            thisArg,
                            timeoutId,
                            trailingCall,
                            lastCalled = 0,
                            maxWait = false,
                            trailing = true;

                        if (typeof func != 'function') {
                            throw new TypeError(FUNC_ERROR_TEXT);
                        }
                        wait = wait < 0 ? 0 : (+wait || 0);
                        if (options === true) {
                            var leading = true;
                            trailing = false;
                        } else if (isObject(options)) {
                            leading = !!options.leading;
                            maxWait = 'maxWait' in options && nativeMax(+options.maxWait || 0, wait);
                            trailing = 'trailing' in options ? !!options.trailing : trailing;
                        }

                        function cancel() {
                            if (timeoutId) {
                                clearTimeout(timeoutId);
                            }
                            if (maxTimeoutId) {
                                clearTimeout(maxTimeoutId);
                            }
                            lastCalled = 0;
                            maxTimeoutId = timeoutId = trailingCall = undefined;
                        }

                        function complete(isCalled, id) {
                            if (id) {
                                clearTimeout(id);
                            }
                            maxTimeoutId = timeoutId = trailingCall = undefined;
                            if (isCalled) {
                                lastCalled = now();
                                result = func.apply(thisArg, args);
                                if (!timeoutId && !maxTimeoutId) {
                                    args = thisArg = undefined;
                                }
                            }
                        }

                        function delayed() {
                            var remaining = wait - (now() - stamp);
                            if (remaining <= 0 || remaining > wait) {
                                complete(trailingCall, maxTimeoutId);
                            } else {
                                timeoutId = setTimeout(delayed, remaining);
                            }
                        }

                        function maxDelayed() {
                            complete(trailing, timeoutId);
                        }

                        function debounced() {
                            args = arguments;
                            stamp = now();
                            thisArg = this;
                            trailingCall = trailing && (timeoutId || !leading);

                            if (maxWait === false) {
                                var leadingCall = leading && !timeoutId;
                            } else {
                                if (!maxTimeoutId && !leading) {
                                    lastCalled = stamp;
                                }
                                var remaining = maxWait - (stamp - lastCalled),
                                    isCalled = remaining <= 0 || remaining > maxWait;

                                if (isCalled) {
                                    if (maxTimeoutId) {
                                        maxTimeoutId = clearTimeout(maxTimeoutId);
                                    }
                                    lastCalled = stamp;
                                    result = func.apply(thisArg, args);
                                }
                                else if (!maxTimeoutId) {
                                    maxTimeoutId = setTimeout(maxDelayed, remaining);
                                }
                            }
                            if (isCalled && timeoutId) {
                                timeoutId = clearTimeout(timeoutId);
                            }
                            else if (!timeoutId && wait !== maxWait) {
                                timeoutId = setTimeout(delayed, wait);
                            }
                            if (leadingCall) {
                                isCalled = true;
                                result = func.apply(thisArg, args);
                            }
                            if (isCalled && !timeoutId && !maxTimeoutId) {
                                args = thisArg = undefined;
                            }
                            return result;
                        }
                        debounced.cancel = cancel;
                        return debounced;
                    }

                    /**
                     * Defers invoking the `func` until the current call stack has cleared. Any
                     * additional arguments are provided to `func` when it is invoked.
                     *
                     * @static
                     * @memberOf _
                     * @category Function
                     * @param {Function} func The function to defer.
                     * @param {...*} [args] The arguments to invoke the function with.
                     * @returns {number} Returns the timer id.
                     * @example
                     *
                     * _.defer(function(text) {
                     *   console.log(text);
                     * }, 'deferred');
                     * // logs 'deferred' after one or more milliseconds
                     */
                    var defer = restParam(function (func, args) {
                        return baseDelay(func, 1, args);
                    });

                    /**
                     * Invokes `func` after `wait` milliseconds. Any additional arguments are
                     * provided to `func` when it is invoked.
                     *
                     * @static
                     * @memberOf _
                     * @category Function
                     * @param {Function} func The function to delay.
                     * @param {number} wait The number of milliseconds to delay invocation.
                     * @param {...*} [args] The arguments to invoke the function with.
                     * @returns {number} Returns the timer id.
                     * @example
                     *
                     * _.delay(function(text) {
                     *   console.log(text);
                     * }, 1000, 'later');
                     * // => logs 'later' after one second
                     */
                    var delay = restParam(function (func, wait, args) {
                        return baseDelay(func, wait, args);
                    });

                    /**
                     * Creates a function that returns the result of invoking the provided
                     * functions with the `this` binding of the created function, where each
                     * successive invocation is supplied the return value of the previous.
                     *
                     * @static
                     * @memberOf _
                     * @category Function
                     * @param {...Function} [funcs] Functions to invoke.
                     * @returns {Function} Returns the new function.
                     * @example
                     *
                     * function square(n) {
                     *   return n * n;
                     * }
                     *
                     * var addSquare = _.flow(_.add, square);
                     * addSquare(1, 2);
                     * // => 9
                     */
                    var flow = createFlow();

                    /**
                     * This method is like `_.flow` except that it creates a function that
                     * invokes the provided functions from right to left.
                     *
                     * @static
                     * @memberOf _
                     * @alias backflow, compose
                     * @category Function
                     * @param {...Function} [funcs] Functions to invoke.
                     * @returns {Function} Returns the new function.
                     * @example
                     *
                     * function square(n) {
                     *   return n * n;
                     * }
                     *
                     * var addSquare = _.flowRight(square, _.add);
                     * addSquare(1, 2);
                     * // => 9
                     */
                    var flowRight = createFlow(true);

                    /**
                     * Creates a function that memoizes the result of `func`. If `resolver` is
                     * provided it determines the cache key for storing the result based on the
                     * arguments provided to the memoized function. By default, the first argument
                     * provided to the memoized function is coerced to a string and used as the
                     * cache key. The `func` is invoked with the `this` binding of the memoized
                     * function.
                     *
                     * **Note:** The cache is exposed as the `cache` property on the memoized
                     * function. Its creation may be customized by replacing the `_.memoize.Cache`
                     * constructor with one whose instances implement the [`Map`](http://ecma-international.org/ecma-262/6.0/#sec-properties-of-the-map-prototype-object)
                     * method interface of `get`, `has`, and `set`.
                     *
                     * @static
                     * @memberOf _
                     * @category Function
                     * @param {Function} func The function to have its output memoized.
                     * @param {Function} [resolver] The function to resolve the cache key.
                     * @returns {Function} Returns the new memoizing function.
                     * @example
                     *
                     * var upperCase = _.memoize(function(string) {
                     *   return string.toUpperCase();
                     * });
                     *
                     * upperCase('fred');
                     * // => 'FRED'
                     *
                     * // modifying the result cache
                     * upperCase.cache.set('fred', 'BARNEY');
                     * upperCase('fred');
                     * // => 'BARNEY'
                     *
                     * // replacing `_.memoize.Cache`
                     * var object = { 'user': 'fred' };
                     * var other = { 'user': 'barney' };
                     * var identity = _.memoize(_.identity);
                     *
                     * identity(object);
                     * // => { 'user': 'fred' }
                     * identity(other);
                     * // => { 'user': 'fred' }
                     *
                     * _.memoize.Cache = WeakMap;
                     * var identity = _.memoize(_.identity);
                     *
                     * identity(object);
                     * // => { 'user': 'fred' }
                     * identity(other);
                     * // => { 'user': 'barney' }
                     */
                    function memoize(func, resolver) {
                        if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
                            throw new TypeError(FUNC_ERROR_TEXT);
                        }
                        var memoized = function () {
                            var args = arguments,
                                key = resolver ? resolver.apply(this, args) : args[0],
                                cache = memoized.cache;

                            if (cache.has(key)) {
                                return cache.get(key);
                            }
                            var result = func.apply(this, args);
                            memoized.cache = cache.set(key, result);
                            return result;
                        };
                        memoized.cache = new memoize.Cache;
                        return memoized;
                    }

                    /**
                     * Creates a function that runs each argument through a corresponding
                     * transform function.
                     *
                     * @static
                     * @memberOf _
                     * @category Function
                     * @param {Function} func The function to wrap.
                     * @param {...(Function|Function[])} [transforms] The functions to transform
                     * arguments, specified as individual functions or arrays of functions.
                     * @returns {Function} Returns the new function.
                     * @example
                     *
                     * function doubled(n) {
                     *   return n * 2;
                     * }
                     *
                     * function square(n) {
                     *   return n * n;
                     * }
                     *
                     * var modded = _.modArgs(function(x, y) {
                     *   return [x, y];
                     * }, square, doubled);
                     *
                     * modded(1, 2);
                     * // => [1, 4]
                     *
                     * modded(5, 10);
                     * // => [25, 20]
                     */
                    var modArgs = restParam(function (func, transforms) {
                        transforms = baseFlatten(transforms);
                        if (typeof func != 'function' || !arrayEvery(transforms, baseIsFunction)) {
                            throw new TypeError(FUNC_ERROR_TEXT);
                        }
                        var length = transforms.length;
                        return restParam(function (args) {
                            var index = nativeMin(args.length, length);
                            while (index--) {
                                args[index] = transforms[index](args[index]);
                            }
                            return func.apply(this, args);
                        });
                    });

                    /**
                     * Creates a function that negates the result of the predicate `func`. The
                     * `func` predicate is invoked with the `this` binding and arguments of the
                     * created function.
                     *
                     * @static
                     * @memberOf _
                     * @category Function
                     * @param {Function} predicate The predicate to negate.
                     * @returns {Function} Returns the new function.
                     * @example
                     *
                     * function isEven(n) {
                     *   return n % 2 == 0;
                     * }
                     *
                     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
                     * // => [1, 3, 5]
                     */
                    function negate(predicate) {
                        if (typeof predicate != 'function') {
                            throw new TypeError(FUNC_ERROR_TEXT);
                        }
                        return function () {
                            return !predicate.apply(this, arguments);
                        };
                    }

                    /**
                     * Creates a function that is restricted to invoking `func` once. Repeat calls
                     * to the function return the value of the first call. The `func` is invoked
                     * with the `this` binding and arguments of the created function.
                     *
                     * @static
                     * @memberOf _
                     * @category Function
                     * @param {Function} func The function to restrict.
                     * @returns {Function} Returns the new restricted function.
                     * @example
                     *
                     * var initialize = _.once(createApplication);
                     * initialize();
                     * initialize();
                     * // `initialize` invokes `createApplication` once
                     */
                    function once(func) {
                        return before(2, func);
                    }

                    /**
                     * Creates a function that invokes `func` with `partial` arguments prepended
                     * to those provided to the new function. This method is like `_.bind` except
                     * it does **not** alter the `this` binding.
                     *
                     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
                     * builds, may be used as a placeholder for partially applied arguments.
                     *
                     * **Note:** This method does not set the "length" property of partially
                     * applied functions.
                     *
                     * @static
                     * @memberOf _
                     * @category Function
                     * @param {Function} func The function to partially apply arguments to.
                     * @param {...*} [partials] The arguments to be partially applied.
                     * @returns {Function} Returns the new partially applied function.
                     * @example
                     *
                     * var greet = function(greeting, name) {
                     *   return greeting + ' ' + name;
                     * };
                     *
                     * var sayHelloTo = _.partial(greet, 'hello');
                     * sayHelloTo('fred');
                     * // => 'hello fred'
                     *
                     * // using placeholders
                     * var greetFred = _.partial(greet, _, 'fred');
                     * greetFred('hi');
                     * // => 'hi fred'
                     */
                    var partial = createPartial(PARTIAL_FLAG);

                    /**
                     * This method is like `_.partial` except that partially applied arguments
                     * are appended to those provided to the new function.
                     *
                     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
                     * builds, may be used as a placeholder for partially applied arguments.
                     *
                     * **Note:** This method does not set the "length" property of partially
                     * applied functions.
                     *
                     * @static
                     * @memberOf _
                     * @category Function
                     * @param {Function} func The function to partially apply arguments to.
                     * @param {...*} [partials] The arguments to be partially applied.
                     * @returns {Function} Returns the new partially applied function.
                     * @example
                     *
                     * var greet = function(greeting, name) {
                     *   return greeting + ' ' + name;
                     * };
                     *
                     * var greetFred = _.partialRight(greet, 'fred');
                     * greetFred('hi');
                     * // => 'hi fred'
                     *
                     * // using placeholders
                     * var sayHelloTo = _.partialRight(greet, 'hello', _);
                     * sayHelloTo('fred');
                     * // => 'hello fred'
                     */
                    var partialRight = createPartial(PARTIAL_RIGHT_FLAG);

                    /**
                     * Creates a function that invokes `func` with arguments arranged according
                     * to the specified indexes where the argument value at the first index is
                     * provided as the first argument, the argument value at the second index is
                     * provided as the second argument, and so on.
                     *
                     * @static
                     * @memberOf _
                     * @category Function
                     * @param {Function} func The function to rearrange arguments for.
                     * @param {...(number|number[])} indexes The arranged argument indexes,
                     *  specified as individual indexes or arrays of indexes.
                     * @returns {Function} Returns the new function.
                     * @example
                     *
                     * var rearged = _.rearg(function(a, b, c) {
                     *   return [a, b, c];
                     * }, 2, 0, 1);
                     *
                     * rearged('b', 'c', 'a')
                     * // => ['a', 'b', 'c']
                     *
                     * var map = _.rearg(_.map, [1, 0]);
                     * map(function(n) {
                     *   return n * 3;
                     * }, [1, 2, 3]);
                     * // => [3, 6, 9]
                     */
                    var rearg = restParam(function (func, indexes) {
                        return createWrapper(func, REARG_FLAG, undefined, undefined, undefined, baseFlatten(indexes));
                    });

                    /**
                     * Creates a function that invokes `func` with the `this` binding of the
                     * created function and arguments from `start` and beyond provided as an array.
                     *
                     * **Note:** This method is based on the [rest parameter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters).
                     *
                     * @static
                     * @memberOf _
                     * @category Function
                     * @param {Function} func The function to apply a rest parameter to.
                     * @param {number} [start=func.length-1] The start position of the rest parameter.
                     * @returns {Function} Returns the new function.
                     * @example
                     *
                     * var say = _.restParam(function(what, names) {
                     *   return what + ' ' + _.initial(names).join(', ') +
                     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
                     * });
                     *
                     * say('hello', 'fred', 'barney', 'pebbles');
                     * // => 'hello fred, barney, & pebbles'
                     */
                    function restParam(func, start) {
                        if (typeof func != 'function') {
                            throw new TypeError(FUNC_ERROR_TEXT);
                        }
                        start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);
                        return function () {
                            var args = arguments,
                                index = -1,
                                length = nativeMax(args.length - start, 0),
                                rest = Array(length);

                            while (++index < length) {
                                rest[index] = args[start + index];
                            }
                            switch (start) {
                                case 0: return func.call(this, rest);
                                case 1: return func.call(this, args[0], rest);
                                case 2: return func.call(this, args[0], args[1], rest);
                            }
                            var otherArgs = Array(start + 1);
                            index = -1;
                            while (++index < start) {
                                otherArgs[index] = args[index];
                            }
                            otherArgs[start] = rest;
                            return func.apply(this, otherArgs);
                        };
                    }

                    /**
                     * Creates a function that invokes `func` with the `this` binding of the created
                     * function and an array of arguments much like [`Function#apply`](https://es5.github.io/#x15.3.4.3).
                     *
                     * **Note:** This method is based on the [spread operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator).
                     *
                     * @static
                     * @memberOf _
                     * @category Function
                     * @param {Function} func The function to spread arguments over.
                     * @returns {Function} Returns the new function.
                     * @example
                     *
                     * var say = _.spread(function(who, what) {
                     *   return who + ' says ' + what;
                     * });
                     *
                     * say(['fred', 'hello']);
                     * // => 'fred says hello'
                     *
                     * // with a Promise
                     * var numbers = Promise.all([
                     *   Promise.resolve(40),
                     *   Promise.resolve(36)
                     * ]);
                     *
                     * numbers.then(_.spread(function(x, y) {
                     *   return x + y;
                     * }));
                     * // => a Promise of 76
                     */
                    function spread(func) {
                        if (typeof func != 'function') {
                            throw new TypeError(FUNC_ERROR_TEXT);
                        }
                        return function (array) {
                            return func.apply(this, array);
                        };
                    }

                    /**
                     * Creates a throttled function that only invokes `func` at most once per
                     * every `wait` milliseconds. The throttled function comes with a `cancel`
                     * method to cancel delayed invocations. Provide an options object to indicate
                     * that `func` should be invoked on the leading and/or trailing edge of the
                     * `wait` timeout. Subsequent calls to the throttled function return the
                     * result of the last `func` call.
                     *
                     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
                     * on the trailing edge of the timeout only if the the throttled function is
                     * invoked more than once during the `wait` timeout.
                     *
                     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
                     * for details over the differences between `_.throttle` and `_.debounce`.
                     *
                     * @static
                     * @memberOf _
                     * @category Function
                     * @param {Function} func The function to throttle.
                     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
                     * @param {Object} [options] The options object.
                     * @param {boolean} [options.leading=true] Specify invoking on the leading
                     *  edge of the timeout.
                     * @param {boolean} [options.trailing=true] Specify invoking on the trailing
                     *  edge of the timeout.
                     * @returns {Function} Returns the new throttled function.
                     * @example
                     *
                     * // avoid excessively updating the position while scrolling
                     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
                     *
                     * // invoke `renewToken` when the click event is fired, but not more than once every 5 minutes
                     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
                     *   'trailing': false
                     * }));
                     *
                     * // cancel a trailing throttled call
                     * jQuery(window).on('popstate', throttled.cancel);
                     */
                    function throttle(func, wait, options) {
                        var leading = true,
                            trailing = true;

                        if (typeof func != 'function') {
                            throw new TypeError(FUNC_ERROR_TEXT);
                        }
                        if (options === false) {
                            leading = false;
                        } else if (isObject(options)) {
                            leading = 'leading' in options ? !!options.leading : leading;
                            trailing = 'trailing' in options ? !!options.trailing : trailing;
                        }
                        return debounce(func, wait, { 'leading': leading, 'maxWait': +wait, 'trailing': trailing });
                    }

                    /**
                     * Creates a function that provides `value` to the wrapper function as its
                     * first argument. Any additional arguments provided to the function are
                     * appended to those provided to the wrapper function. The wrapper is invoked
                     * with the `this` binding of the created function.
                     *
                     * @static
                     * @memberOf _
                     * @category Function
                     * @param {*} value The value to wrap.
                     * @param {Function} wrapper The wrapper function.
                     * @returns {Function} Returns the new function.
                     * @example
                     *
                     * var p = _.wrap(_.escape, function(func, text) {
                     *   return '<p>' + func(text) + '</p>';
                     * });
                     *
                     * p('fred, barney, & pebbles');
                     * // => '<p>fred, barney, &amp; pebbles</p>'
                     */
                    function wrap(value, wrapper) {
                        wrapper = wrapper == null ? identity : wrapper;
                        return createWrapper(wrapper, PARTIAL_FLAG, undefined, [value], []);
                    }

                    /*------------------------------------------------------------------------*/

                    /**
                     * Creates a clone of `value`. If `isDeep` is `true` nested objects are cloned,
                     * otherwise they are assigned by reference. If `customizer` is provided it is
                     * invoked to produce the cloned values. If `customizer` returns `undefined`
                     * cloning is handled by the method instead. The `customizer` is bound to
                     * `thisArg` and invoked with two argument; (value [, index|key, object]).
                     *
                     * **Note:** This method is loosely based on the
                     * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).
                     * The enumerable properties of `arguments` objects and objects created by
                     * constructors other than `Object` are cloned to plain `Object` objects. An
                     * empty object is returned for uncloneable values such as functions, DOM nodes,
                     * Maps, Sets, and WeakMaps.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to clone.
                     * @param {boolean} [isDeep] Specify a deep clone.
                     * @param {Function} [customizer] The function to customize cloning values.
                     * @param {*} [thisArg] The `this` binding of `customizer`.
                     * @returns {*} Returns the cloned value.
                     * @example
                     *
                     * var users = [
                     *   { 'user': 'barney' },
                     *   { 'user': 'fred' }
                     * ];
                     *
                     * var shallow = _.clone(users);
                     * shallow[0] === users[0];
                     * // => true
                     *
                     * var deep = _.clone(users, true);
                     * deep[0] === users[0];
                     * // => false
                     *
                     * // using a customizer callback
                     * var el = _.clone(document.body, function(value) {
                     *   if (_.isElement(value)) {
                     *     return value.cloneNode(false);
                     *   }
                     * });
                     *
                     * el === document.body
                     * // => false
                     * el.nodeName
                     * // => BODY
                     * el.childNodes.length;
                     * // => 0
                     */
                    function clone(value, isDeep, customizer, thisArg) {
                        if (isDeep && typeof isDeep != 'boolean' && isIterateeCall(value, isDeep, customizer)) {
                            isDeep = false;
                        }
                        else if (typeof isDeep == 'function') {
                            thisArg = customizer;
                            customizer = isDeep;
                            isDeep = false;
                        }
                        return typeof customizer == 'function'
                            ? baseClone(value, isDeep, bindCallback(customizer, thisArg, 1))
                            : baseClone(value, isDeep);
                    }

                    /**
                     * Creates a deep clone of `value`. If `customizer` is provided it is invoked
                     * to produce the cloned values. If `customizer` returns `undefined` cloning
                     * is handled by the method instead. The `customizer` is bound to `thisArg`
                     * and invoked with two argument; (value [, index|key, object]).
                     *
                     * **Note:** This method is loosely based on the
                     * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).
                     * The enumerable properties of `arguments` objects and objects created by
                     * constructors other than `Object` are cloned to plain `Object` objects. An
                     * empty object is returned for uncloneable values such as functions, DOM nodes,
                     * Maps, Sets, and WeakMaps.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to deep clone.
                     * @param {Function} [customizer] The function to customize cloning values.
                     * @param {*} [thisArg] The `this` binding of `customizer`.
                     * @returns {*} Returns the deep cloned value.
                     * @example
                     *
                     * var users = [
                     *   { 'user': 'barney' },
                     *   { 'user': 'fred' }
                     * ];
                     *
                     * var deep = _.cloneDeep(users);
                     * deep[0] === users[0];
                     * // => false
                     *
                     * // using a customizer callback
                     * var el = _.cloneDeep(document.body, function(value) {
                     *   if (_.isElement(value)) {
                     *     return value.cloneNode(true);
                     *   }
                     * });
                     *
                     * el === document.body
                     * // => false
                     * el.nodeName
                     * // => BODY
                     * el.childNodes.length;
                     * // => 20
                     */
                    function cloneDeep(value, customizer, thisArg) {
                        return typeof customizer == 'function'
                            ? baseClone(value, true, bindCallback(customizer, thisArg, 1))
                            : baseClone(value, true);
                    }

                    /**
                     * Checks if `value` is greater than `other`.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to compare.
                     * @param {*} other The other value to compare.
                     * @returns {boolean} Returns `true` if `value` is greater than `other`, else `false`.
                     * @example
                     *
                     * _.gt(3, 1);
                     * // => true
                     *
                     * _.gt(3, 3);
                     * // => false
                     *
                     * _.gt(1, 3);
                     * // => false
                     */
                    function gt(value, other) {
                        return value > other;
                    }

                    /**
                     * Checks if `value` is greater than or equal to `other`.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to compare.
                     * @param {*} other The other value to compare.
                     * @returns {boolean} Returns `true` if `value` is greater than or equal to `other`, else `false`.
                     * @example
                     *
                     * _.gte(3, 1);
                     * // => true
                     *
                     * _.gte(3, 3);
                     * // => true
                     *
                     * _.gte(1, 3);
                     * // => false
                     */
                    function gte(value, other) {
                        return value >= other;
                    }

                    /**
                     * Checks if `value` is classified as an `arguments` object.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
                     * @example
                     *
                     * _.isArguments(function() { return arguments; }());
                     * // => true
                     *
                     * _.isArguments([1, 2, 3]);
                     * // => false
                     */
                    function isArguments(value) {
                        return isObjectLike(value) && isArrayLike(value) &&
                            hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
                    }

                    /**
                     * Checks if `value` is classified as an `Array` object.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
                     * @example
                     *
                     * _.isArray([1, 2, 3]);
                     * // => true
                     *
                     * _.isArray(function() { return arguments; }());
                     * // => false
                     */
                    var isArray = nativeIsArray || function (value) {
                        return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
                    };

                    /**
                     * Checks if `value` is classified as a boolean primitive or object.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
                     * @example
                     *
                     * _.isBoolean(false);
                     * // => true
                     *
                     * _.isBoolean(null);
                     * // => false
                     */
                    function isBoolean(value) {
                        return value === true || value === false || (isObjectLike(value) && objToString.call(value) == boolTag);
                    }

                    /**
                     * Checks if `value` is classified as a `Date` object.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
                     * @example
                     *
                     * _.isDate(new Date);
                     * // => true
                     *
                     * _.isDate('Mon April 23 2012');
                     * // => false
                     */
                    function isDate(value) {
                        return isObjectLike(value) && objToString.call(value) == dateTag;
                    }

                    /**
                     * Checks if `value` is a DOM element.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
                     * @example
                     *
                     * _.isElement(document.body);
                     * // => true
                     *
                     * _.isElement('<body>');
                     * // => false
                     */
                    function isElement(value) {
                        return !!value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value);
                    }

                    /**
                     * Checks if `value` is empty. A value is considered empty unless it is an
                     * `arguments` object, array, string, or jQuery-like collection with a length
                     * greater than `0` or an object with own enumerable properties.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {Array|Object|string} value The value to inspect.
                     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
                     * @example
                     *
                     * _.isEmpty(null);
                     * // => true
                     *
                     * _.isEmpty(true);
                     * // => true
                     *
                     * _.isEmpty(1);
                     * // => true
                     *
                     * _.isEmpty([1, 2, 3]);
                     * // => false
                     *
                     * _.isEmpty({ 'a': 1 });
                     * // => false
                     */
                    function isEmpty(value) {
                        if (value == null) {
                            return true;
                        }
                        if (isArrayLike(value) && (isArray(value) || isString(value) || isArguments(value) ||
                            (isObjectLike(value) && isFunction(value.splice)))) {
                            return !value.length;
                        }
                        return !keys(value).length;
                    }

                    /**
                     * Performs a deep comparison between two values to determine if they are
                     * equivalent. If `customizer` is provided it is invoked to compare values.
                     * If `customizer` returns `undefined` comparisons are handled by the method
                     * instead. The `customizer` is bound to `thisArg` and invoked with three
                     * arguments: (value, other [, index|key]).
                     *
                     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
                     * numbers, `Object` objects, regexes, and strings. Objects are compared by
                     * their own, not inherited, enumerable properties. Functions and DOM nodes
                     * are **not** supported. Provide a customizer function to extend support
                     * for comparing other values.
                     *
                     * @static
                     * @memberOf _
                     * @alias eq
                     * @category Lang
                     * @param {*} value The value to compare.
                     * @param {*} other The other value to compare.
                     * @param {Function} [customizer] The function to customize value comparisons.
                     * @param {*} [thisArg] The `this` binding of `customizer`.
                     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
                     * @example
                     *
                     * var object = { 'user': 'fred' };
                     * var other = { 'user': 'fred' };
                     *
                     * object == other;
                     * // => false
                     *
                     * _.isEqual(object, other);
                     * // => true
                     *
                     * // using a customizer callback
                     * var array = ['hello', 'goodbye'];
                     * var other = ['hi', 'goodbye'];
                     *
                     * _.isEqual(array, other, function(value, other) {
                     *   if (_.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/)) {
                     *     return true;
                     *   }
                     * });
                     * // => true
                     */
                    function isEqual(value, other, customizer, thisArg) {
                        customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;
                        var result = customizer ? customizer(value, other) : undefined;
                        return result === undefined ? baseIsEqual(value, other, customizer) : !!result;
                    }

                    /**
                     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
                     * `SyntaxError`, `TypeError`, or `URIError` object.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
                     * @example
                     *
                     * _.isError(new Error);
                     * // => true
                     *
                     * _.isError(Error);
                     * // => false
                     */
                    function isError(value) {
                        return isObjectLike(value) && typeof value.message == 'string' && objToString.call(value) == errorTag;
                    }

                    /**
                     * Checks if `value` is a finite primitive number.
                     *
                     * **Note:** This method is based on [`Number.isFinite`](http://ecma-international.org/ecma-262/6.0/#sec-number.isfinite).
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
                     * @example
                     *
                     * _.isFinite(10);
                     * // => true
                     *
                     * _.isFinite('10');
                     * // => false
                     *
                     * _.isFinite(true);
                     * // => false
                     *
                     * _.isFinite(Object(10));
                     * // => false
                     *
                     * _.isFinite(Infinity);
                     * // => false
                     */
                    function isFinite(value) {
                        return typeof value == 'number' && nativeIsFinite(value);
                    }

                    /**
                     * Checks if `value` is classified as a `Function` object.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
                     * @example
                     *
                     * _.isFunction(_);
                     * // => true
                     *
                     * _.isFunction(/abc/);
                     * // => false
                     */
                    function isFunction(value) {
                        // The use of `Object#toString` avoids issues with the `typeof` operator
                        // in older versions of Chrome and Safari which return 'function' for regexes
                        // and Safari 8 equivalents which return 'object' for typed array constructors.
                        return isObject(value) && objToString.call(value) == funcTag;
                    }

                    /**
                     * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
                     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
                     * @example
                     *
                     * _.isObject({});
                     * // => true
                     *
                     * _.isObject([1, 2, 3]);
                     * // => true
                     *
                     * _.isObject(1);
                     * // => false
                     */
                    function isObject(value) {
                        // Avoid a V8 JIT bug in Chrome 19-20.
                        // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
                        var type = typeof value;
                        return !!value && (type == 'object' || type == 'function');
                    }

                    /**
                     * Performs a deep comparison between `object` and `source` to determine if
                     * `object` contains equivalent property values. If `customizer` is provided
                     * it is invoked to compare values. If `customizer` returns `undefined`
                     * comparisons are handled by the method instead. The `customizer` is bound
                     * to `thisArg` and invoked with three arguments: (value, other, index|key).
                     *
                     * **Note:** This method supports comparing properties of arrays, booleans,
                     * `Date` objects, numbers, `Object` objects, regexes, and strings. Functions
                     * and DOM nodes are **not** supported. Provide a customizer function to extend
                     * support for comparing other values.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {Object} object The object to inspect.
                     * @param {Object} source The object of property values to match.
                     * @param {Function} [customizer] The function to customize value comparisons.
                     * @param {*} [thisArg] The `this` binding of `customizer`.
                     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
                     * @example
                     *
                     * var object = { 'user': 'fred', 'age': 40 };
                     *
                     * _.isMatch(object, { 'age': 40 });
                     * // => true
                     *
                     * _.isMatch(object, { 'age': 36 });
                     * // => false
                     *
                     * // using a customizer callback
                     * var object = { 'greeting': 'hello' };
                     * var source = { 'greeting': 'hi' };
                     *
                     * _.isMatch(object, source, function(value, other) {
                     *   return _.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/) || undefined;
                     * });
                     * // => true
                     */
                    function isMatch(object, source, customizer, thisArg) {
                        customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;
                        return baseIsMatch(object, getMatchData(source), customizer);
                    }

                    /**
                     * Checks if `value` is `NaN`.
                     *
                     * **Note:** This method is not the same as [`isNaN`](https://es5.github.io/#x15.1.2.4)
                     * which returns `true` for `undefined` and other non-numeric values.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
                     * @example
                     *
                     * _.isNaN(NaN);
                     * // => true
                     *
                     * _.isNaN(new Number(NaN));
                     * // => true
                     *
                     * isNaN(undefined);
                     * // => true
                     *
                     * _.isNaN(undefined);
                     * // => false
                     */
                    function isNaN(value) {
                        // An `NaN` primitive is the only value that is not equal to itself.
                        // Perform the `toStringTag` check first to avoid errors with some host objects in IE.
                        return isNumber(value) && value != +value;
                    }

                    /**
                     * Checks if `value` is a native function.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
                     * @example
                     *
                     * _.isNative(Array.prototype.push);
                     * // => true
                     *
                     * _.isNative(_);
                     * // => false
                     */
                    function isNative(value) {
                        if (value == null) {
                            return false;
                        }
                        if (isFunction(value)) {
                            return reIsNative.test(fnToString.call(value));
                        }
                        return isObjectLike(value) && reIsHostCtor.test(value);
                    }

                    /**
                     * Checks if `value` is `null`.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
                     * @example
                     *
                     * _.isNull(null);
                     * // => true
                     *
                     * _.isNull(void 0);
                     * // => false
                     */
                    function isNull(value) {
                        return value === null;
                    }

                    /**
                     * Checks if `value` is classified as a `Number` primitive or object.
                     *
                     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are classified
                     * as numbers, use the `_.isFinite` method.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
                     * @example
                     *
                     * _.isNumber(8.4);
                     * // => true
                     *
                     * _.isNumber(NaN);
                     * // => true
                     *
                     * _.isNumber('8.4');
                     * // => false
                     */
                    function isNumber(value) {
                        return typeof value == 'number' || (isObjectLike(value) && objToString.call(value) == numberTag);
                    }

                    /**
                     * Checks if `value` is a plain object, that is, an object created by the
                     * `Object` constructor or one with a `[[Prototype]]` of `null`.
                     *
                     * **Note:** This method assumes objects created by the `Object` constructor
                     * have no inherited enumerable properties.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
                     * @example
                     *
                     * function Foo() {
                     *   this.a = 1;
                     * }
                     *
                     * _.isPlainObject(new Foo);
                     * // => false
                     *
                     * _.isPlainObject([1, 2, 3]);
                     * // => false
                     *
                     * _.isPlainObject({ 'x': 0, 'y': 0 });
                     * // => true
                     *
                     * _.isPlainObject(Object.create(null));
                     * // => true
                     */
                    function isPlainObject(value) {
                        var Ctor;

                        // Exit early for non `Object` objects.
                        if (!(isObjectLike(value) && objToString.call(value) == objectTag && !isArguments(value)) ||
                            (!hasOwnProperty.call(value, 'constructor') && (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor)))) {
                            return false;
                        }
                        // IE < 9 iterates inherited properties before own properties. If the first
                        // iterated property is an object's own property then there are no inherited
                        // enumerable properties.
                        var result;
                        // In most environments an object's own properties are iterated before
                        // its inherited properties. If the last iterated property is an object's
                        // own property then there are no inherited enumerable properties.
                        baseForIn(value, function (subValue, key) {
                            result = key;
                        });
                        return result === undefined || hasOwnProperty.call(value, result);
                    }

                    /**
                     * Checks if `value` is classified as a `RegExp` object.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
                     * @example
                     *
                     * _.isRegExp(/abc/);
                     * // => true
                     *
                     * _.isRegExp('/abc/');
                     * // => false
                     */
                    function isRegExp(value) {
                        return isObject(value) && objToString.call(value) == regexpTag;
                    }

                    /**
                     * Checks if `value` is classified as a `String` primitive or object.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
                     * @example
                     *
                     * _.isString('abc');
                     * // => true
                     *
                     * _.isString(1);
                     * // => false
                     */
                    function isString(value) {
                        return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag);
                    }

                    /**
                     * Checks if `value` is classified as a typed array.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
                     * @example
                     *
                     * _.isTypedArray(new Uint8Array);
                     * // => true
                     *
                     * _.isTypedArray([]);
                     * // => false
                     */
                    function isTypedArray(value) {
                        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];
                    }

                    /**
                     * Checks if `value` is `undefined`.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
                     * @example
                     *
                     * _.isUndefined(void 0);
                     * // => true
                     *
                     * _.isUndefined(null);
                     * // => false
                     */
                    function isUndefined(value) {
                        return value === undefined;
                    }

                    /**
                     * Checks if `value` is less than `other`.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to compare.
                     * @param {*} other The other value to compare.
                     * @returns {boolean} Returns `true` if `value` is less than `other`, else `false`.
                     * @example
                     *
                     * _.lt(1, 3);
                     * // => true
                     *
                     * _.lt(3, 3);
                     * // => false
                     *
                     * _.lt(3, 1);
                     * // => false
                     */
                    function lt(value, other) {
                        return value < other;
                    }

                    /**
                     * Checks if `value` is less than or equal to `other`.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to compare.
                     * @param {*} other The other value to compare.
                     * @returns {boolean} Returns `true` if `value` is less than or equal to `other`, else `false`.
                     * @example
                     *
                     * _.lte(1, 3);
                     * // => true
                     *
                     * _.lte(3, 3);
                     * // => true
                     *
                     * _.lte(3, 1);
                     * // => false
                     */
                    function lte(value, other) {
                        return value <= other;
                    }

                    /**
                     * Converts `value` to an array.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to convert.
                     * @returns {Array} Returns the converted array.
                     * @example
                     *
                     * (function() {
                     *   return _.toArray(arguments).slice(1);
                     * }(1, 2, 3));
                     * // => [2, 3]
                     */
                    function toArray(value) {
                        var length = value ? getLength(value) : 0;
                        if (!isLength(length)) {
                            return values(value);
                        }
                        if (!length) {
                            return [];
                        }
                        return arrayCopy(value);
                    }

                    /**
                     * Converts `value` to a plain object flattening inherited enumerable
                     * properties of `value` to own properties of the plain object.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to convert.
                     * @returns {Object} Returns the converted plain object.
                     * @example
                     *
                     * function Foo() {
                     *   this.b = 2;
                     * }
                     *
                     * Foo.prototype.c = 3;
                     *
                     * _.assign({ 'a': 1 }, new Foo);
                     * // => { 'a': 1, 'b': 2 }
                     *
                     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
                     * // => { 'a': 1, 'b': 2, 'c': 3 }
                     */
                    function toPlainObject(value) {
                        return baseCopy(value, keysIn(value));
                    }

                    /*------------------------------------------------------------------------*/

                    /**
                     * Recursively merges own enumerable properties of the source object(s), that
                     * don't resolve to `undefined` into the destination object. Subsequent sources
                     * overwrite property assignments of previous sources. If `customizer` is
                     * provided it is invoked to produce the merged values of the destination and
                     * source properties. If `customizer` returns `undefined` merging is handled
                     * by the method instead. The `customizer` is bound to `thisArg` and invoked
                     * with five arguments: (objectValue, sourceValue, key, object, source).
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The destination object.
                     * @param {...Object} [sources] The source objects.
                     * @param {Function} [customizer] The function to customize assigned values.
                     * @param {*} [thisArg] The `this` binding of `customizer`.
                     * @returns {Object} Returns `object`.
                     * @example
                     *
                     * var users = {
                     *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]
                     * };
                     *
                     * var ages = {
                     *   'data': [{ 'age': 36 }, { 'age': 40 }]
                     * };
                     *
                     * _.merge(users, ages);
                     * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }
                     *
                     * // using a customizer callback
                     * var object = {
                     *   'fruits': ['apple'],
                     *   'vegetables': ['beet']
                     * };
                     *
                     * var other = {
                     *   'fruits': ['banana'],
                     *   'vegetables': ['carrot']
                     * };
                     *
                     * _.merge(object, other, function(a, b) {
                     *   if (_.isArray(a)) {
                     *     return a.concat(b);
                     *   }
                     * });
                     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }
                     */
                    var merge = createAssigner(baseMerge);

                    /**
                     * Assigns own enumerable properties of source object(s) to the destination
                     * object. Subsequent sources overwrite property assignments of previous sources.
                     * If `customizer` is provided it is invoked to produce the assigned values.
                     * The `customizer` is bound to `thisArg` and invoked with five arguments:
                     * (objectValue, sourceValue, key, object, source).
                     *
                     * **Note:** This method mutates `object` and is based on
                     * [`Object.assign`](http://ecma-international.org/ecma-262/6.0/#sec-object.assign).
                     *
                     * @static
                     * @memberOf _
                     * @alias extend
                     * @category Object
                     * @param {Object} object The destination object.
                     * @param {...Object} [sources] The source objects.
                     * @param {Function} [customizer] The function to customize assigned values.
                     * @param {*} [thisArg] The `this` binding of `customizer`.
                     * @returns {Object} Returns `object`.
                     * @example
                     *
                     * _.assign({ 'user': 'barney' }, { 'age': 40 }, { 'user': 'fred' });
                     * // => { 'user': 'fred', 'age': 40 }
                     *
                     * // using a customizer callback
                     * var defaults = _.partialRight(_.assign, function(value, other) {
                     *   return _.isUndefined(value) ? other : value;
                     * });
                     *
                     * defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
                     * // => { 'user': 'barney', 'age': 36 }
                     */
                    var assign = createAssigner(function (object, source, customizer) {
                        return customizer
                            ? assignWith(object, source, customizer)
                            : baseAssign(object, source);
                    });

                    /**
                     * Creates an object that inherits from the given `prototype` object. If a
                     * `properties` object is provided its own enumerable properties are assigned
                     * to the created object.
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} prototype The object to inherit from.
                     * @param {Object} [properties] The properties to assign to the object.
                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                     * @returns {Object} Returns the new object.
                     * @example
                     *
                     * function Shape() {
                     *   this.x = 0;
                     *   this.y = 0;
                     * }
                     *
                     * function Circle() {
                     *   Shape.call(this);
                     * }
                     *
                     * Circle.prototype = _.create(Shape.prototype, {
                     *   'constructor': Circle
                     * });
                     *
                     * var circle = new Circle;
                     * circle instanceof Circle;
                     * // => true
                     *
                     * circle instanceof Shape;
                     * // => true
                     */
                    function create(prototype, properties, guard) {
                        var result = baseCreate(prototype);
                        if (guard && isIterateeCall(prototype, properties, guard)) {
                            properties = undefined;
                        }
                        return properties ? baseAssign(result, properties) : result;
                    }

                    /**
                     * Assigns own enumerable properties of source object(s) to the destination
                     * object for all destination properties that resolve to `undefined`. Once a
                     * property is set, additional values of the same property are ignored.
                     *
                     * **Note:** This method mutates `object`.
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The destination object.
                     * @param {...Object} [sources] The source objects.
                     * @returns {Object} Returns `object`.
                     * @example
                     *
                     * _.defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
                     * // => { 'user': 'barney', 'age': 36 }
                     */
                    var defaults = createDefaults(assign, assignDefaults);

                    /**
                     * This method is like `_.defaults` except that it recursively assigns
                     * default properties.
                     *
                     * **Note:** This method mutates `object`.
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The destination object.
                     * @param {...Object} [sources] The source objects.
                     * @returns {Object} Returns `object`.
                     * @example
                     *
                     * _.defaultsDeep({ 'user': { 'name': 'barney' } }, { 'user': { 'name': 'fred', 'age': 36 } });
                     * // => { 'user': { 'name': 'barney', 'age': 36 } }
                     *
                     */
                    var defaultsDeep = createDefaults(merge, mergeDefaults);

                    /**
                     * This method is like `_.find` except that it returns the key of the first
                     * element `predicate` returns truthy for instead of the element itself.
                     *
                     * If a property name is provided for `predicate` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `predicate` the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The object to search.
                     * @param {Function|Object|string} [predicate=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `predicate`.
                     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
                     * @example
                     *
                     * var users = {
                     *   'barney':  { 'age': 36, 'active': true },
                     *   'fred':    { 'age': 40, 'active': false },
                     *   'pebbles': { 'age': 1,  'active': true }
                     * };
                     *
                     * _.findKey(users, function(chr) {
                     *   return chr.age < 40;
                     * });
                     * // => 'barney' (iteration order is not guaranteed)
                     *
                     * // using the `_.matches` callback shorthand
                     * _.findKey(users, { 'age': 1, 'active': true });
                     * // => 'pebbles'
                     *
                     * // using the `_.matchesProperty` callback shorthand
                     * _.findKey(users, 'active', false);
                     * // => 'fred'
                     *
                     * // using the `_.property` callback shorthand
                     * _.findKey(users, 'active');
                     * // => 'barney'
                     */
                    var findKey = createFindKey(baseForOwn);

                    /**
                     * This method is like `_.findKey` except that it iterates over elements of
                     * a collection in the opposite order.
                     *
                     * If a property name is provided for `predicate` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `predicate` the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The object to search.
                     * @param {Function|Object|string} [predicate=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `predicate`.
                     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
                     * @example
                     *
                     * var users = {
                     *   'barney':  { 'age': 36, 'active': true },
                     *   'fred':    { 'age': 40, 'active': false },
                     *   'pebbles': { 'age': 1,  'active': true }
                     * };
                     *
                     * _.findLastKey(users, function(chr) {
                     *   return chr.age < 40;
                     * });
                     * // => returns `pebbles` assuming `_.findKey` returns `barney`
                     *
                     * // using the `_.matches` callback shorthand
                     * _.findLastKey(users, { 'age': 36, 'active': true });
                     * // => 'barney'
                     *
                     * // using the `_.matchesProperty` callback shorthand
                     * _.findLastKey(users, 'active', false);
                     * // => 'fred'
                     *
                     * // using the `_.property` callback shorthand
                     * _.findLastKey(users, 'active');
                     * // => 'pebbles'
                     */
                    var findLastKey = createFindKey(baseForOwnRight);

                    /**
                     * Iterates over own and inherited enumerable properties of an object invoking
                     * `iteratee` for each property. The `iteratee` is bound to `thisArg` and invoked
                     * with three arguments: (value, key, object). Iteratee functions may exit
                     * iteration early by explicitly returning `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The object to iterate over.
                     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {Object} Returns `object`.
                     * @example
                     *
                     * function Foo() {
                     *   this.a = 1;
                     *   this.b = 2;
                     * }
                     *
                     * Foo.prototype.c = 3;
                     *
                     * _.forIn(new Foo, function(value, key) {
                     *   console.log(key);
                     * });
                     * // => logs 'a', 'b', and 'c' (iteration order is not guaranteed)
                     */
                    var forIn = createForIn(baseFor);

                    /**
                     * This method is like `_.forIn` except that it iterates over properties of
                     * `object` in the opposite order.
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The object to iterate over.
                     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {Object} Returns `object`.
                     * @example
                     *
                     * function Foo() {
                     *   this.a = 1;
                     *   this.b = 2;
                     * }
                     *
                     * Foo.prototype.c = 3;
                     *
                     * _.forInRight(new Foo, function(value, key) {
                     *   console.log(key);
                     * });
                     * // => logs 'c', 'b', and 'a' assuming `_.forIn ` logs 'a', 'b', and 'c'
                     */
                    var forInRight = createForIn(baseForRight);

                    /**
                     * Iterates over own enumerable properties of an object invoking `iteratee`
                     * for each property. The `iteratee` is bound to `thisArg` and invoked with
                     * three arguments: (value, key, object). Iteratee functions may exit iteration
                     * early by explicitly returning `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The object to iterate over.
                     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {Object} Returns `object`.
                     * @example
                     *
                     * function Foo() {
                     *   this.a = 1;
                     *   this.b = 2;
                     * }
                     *
                     * Foo.prototype.c = 3;
                     *
                     * _.forOwn(new Foo, function(value, key) {
                     *   console.log(key);
                     * });
                     * // => logs 'a' and 'b' (iteration order is not guaranteed)
                     */
                    var forOwn = createForOwn(baseForOwn);

                    /**
                     * This method is like `_.forOwn` except that it iterates over properties of
                     * `object` in the opposite order.
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The object to iterate over.
                     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {Object} Returns `object`.
                     * @example
                     *
                     * function Foo() {
                     *   this.a = 1;
                     *   this.b = 2;
                     * }
                     *
                     * Foo.prototype.c = 3;
                     *
                     * _.forOwnRight(new Foo, function(value, key) {
                     *   console.log(key);
                     * });
                     * // => logs 'b' and 'a' assuming `_.forOwn` logs 'a' and 'b'
                     */
                    var forOwnRight = createForOwn(baseForOwnRight);

                    /**
                     * Creates an array of function property names from all enumerable properties,
                     * own and inherited, of `object`.
                     *
                     * @static
                     * @memberOf _
                     * @alias methods
                     * @category Object
                     * @param {Object} object The object to inspect.
                     * @returns {Array} Returns the new array of property names.
                     * @example
                     *
                     * _.functions(_);
                     * // => ['after', 'ary', 'assign', ...]
                     */
                    function functions(object) {
                        return baseFunctions(object, keysIn(object));
                    }

                    /**
                     * Gets the property value at `path` of `object`. If the resolved value is
                     * `undefined` the `defaultValue` is used in its place.
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The object to query.
                     * @param {Array|string} path The path of the property to get.
                     * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.
                     * @returns {*} Returns the resolved value.
                     * @example
                     *
                     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
                     *
                     * _.get(object, 'a[0].b.c');
                     * // => 3
                     *
                     * _.get(object, ['a', '0', 'b', 'c']);
                     * // => 3
                     *
                     * _.get(object, 'a.b.c', 'default');
                     * // => 'default'
                     */
                    function get(object, path, defaultValue) {
                        var result = object == null ? undefined : baseGet(object, toPath(path), path + '');
                        return result === undefined ? defaultValue : result;
                    }

                    /**
                     * Checks if `path` is a direct property.
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The object to query.
                     * @param {Array|string} path The path to check.
                     * @returns {boolean} Returns `true` if `path` is a direct property, else `false`.
                     * @example
                     *
                     * var object = { 'a': { 'b': { 'c': 3 } } };
                     *
                     * _.has(object, 'a');
                     * // => true
                     *
                     * _.has(object, 'a.b.c');
                     * // => true
                     *
                     * _.has(object, ['a', 'b', 'c']);
                     * // => true
                     */
                    function has(object, path) {
                        if (object == null) {
                            return false;
                        }
                        var result = hasOwnProperty.call(object, path);
                        if (!result && !isKey(path)) {
                            path = toPath(path);
                            object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
                            if (object == null) {
                                return false;
                            }
                            path = last(path);
                            result = hasOwnProperty.call(object, path);
                        }
                        return result || (isLength(object.length) && isIndex(path, object.length) &&
                            (isArray(object) || isArguments(object)));
                    }

                    /**
                     * Creates an object composed of the inverted keys and values of `object`.
                     * If `object` contains duplicate values, subsequent values overwrite property
                     * assignments of previous values unless `multiValue` is `true`.
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The object to invert.
                     * @param {boolean} [multiValue] Allow multiple values per key.
                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                     * @returns {Object} Returns the new inverted object.
                     * @example
                     *
                     * var object = { 'a': 1, 'b': 2, 'c': 1 };
                     *
                     * _.invert(object);
                     * // => { '1': 'c', '2': 'b' }
                     *
                     * // with `multiValue`
                     * _.invert(object, true);
                     * // => { '1': ['a', 'c'], '2': ['b'] }
                     */
                    function invert(object, multiValue, guard) {
                        if (guard && isIterateeCall(object, multiValue, guard)) {
                            multiValue = undefined;
                        }
                        var index = -1,
                            props = keys(object),
                            length = props.length,
                            result = {};

                        while (++index < length) {
                            var key = props[index],
                                value = object[key];

                            if (multiValue) {
                                if (hasOwnProperty.call(result, value)) {
                                    result[value].push(key);
                                } else {
                                    result[value] = [key];
                                }
                            }
                            else {
                                result[value] = key;
                            }
                        }
                        return result;
                    }

                    /**
                     * Creates an array of the own enumerable property names of `object`.
                     *
                     * **Note:** Non-object values are coerced to objects. See the
                     * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
                     * for more details.
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The object to query.
                     * @returns {Array} Returns the array of property names.
                     * @example
                     *
                     * function Foo() {
                     *   this.a = 1;
                     *   this.b = 2;
                     * }
                     *
                     * Foo.prototype.c = 3;
                     *
                     * _.keys(new Foo);
                     * // => ['a', 'b'] (iteration order is not guaranteed)
                     *
                     * _.keys('hi');
                     * // => ['0', '1']
                     */
                    var keys = !nativeKeys ? shimKeys : function (object) {
                        var Ctor = object == null ? undefined : object.constructor;
                        if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
                            (typeof object != 'function' && isArrayLike(object))) {
                            return shimKeys(object);
                        }
                        return isObject(object) ? nativeKeys(object) : [];
                    };

                    /**
                     * Creates an array of the own and inherited enumerable property names of `object`.
                     *
                     * **Note:** Non-object values are coerced to objects.
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The object to query.
                     * @returns {Array} Returns the array of property names.
                     * @example
                     *
                     * function Foo() {
                     *   this.a = 1;
                     *   this.b = 2;
                     * }
                     *
                     * Foo.prototype.c = 3;
                     *
                     * _.keysIn(new Foo);
                     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
                     */
                    function keysIn(object) {
                        if (object == null) {
                            return [];
                        }
                        if (!isObject(object)) {
                            object = Object(object);
                        }
                        var length = object.length;
                        length = (length && isLength(length) &&
                            (isArray(object) || isArguments(object)) && length) || 0;

                        var Ctor = object.constructor,
                            index = -1,
                            isProto = typeof Ctor == 'function' && Ctor.prototype === object,
                            result = Array(length),
                            skipIndexes = length > 0;

                        while (++index < length) {
                            result[index] = (index + '');
                        }
                        for (var key in object) {
                            if (!(skipIndexes && isIndex(key, length)) &&
                                !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
                                result.push(key);
                            }
                        }
                        return result;
                    }

                    /**
                     * The opposite of `_.mapValues`; this method creates an object with the
                     * same values as `object` and keys generated by running each own enumerable
                     * property of `object` through `iteratee`.
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The object to iterate over.
                     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {Object} Returns the new mapped object.
                     * @example
                     *
                     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
                     *   return key + value;
                     * });
                     * // => { 'a1': 1, 'b2': 2 }
                     */
                    var mapKeys = createObjectMapper(true);

                    /**
                     * Creates an object with the same keys as `object` and values generated by
                     * running each own enumerable property of `object` through `iteratee`. The
                     * iteratee function is bound to `thisArg` and invoked with three arguments:
                     * (value, key, object).
                     *
                     * If a property name is provided for `iteratee` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `iteratee` the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The object to iterate over.
                     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {Object} Returns the new mapped object.
                     * @example
                     *
                     * _.mapValues({ 'a': 1, 'b': 2 }, function(n) {
                     *   return n * 3;
                     * });
                     * // => { 'a': 3, 'b': 6 }
                     *
                     * var users = {
                     *   'fred':    { 'user': 'fred',    'age': 40 },
                     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
                     * };
                     *
                     * // using the `_.property` callback shorthand
                     * _.mapValues(users, 'age');
                     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
                     */
                    var mapValues = createObjectMapper();

                    /**
                     * The opposite of `_.pick`; this method creates an object composed of the
                     * own and inherited enumerable properties of `object` that are not omitted.
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The source object.
                     * @param {Function|...(string|string[])} [predicate] The function invoked per
                     *  iteration or property names to omit, specified as individual property
                     *  names or arrays of property names.
                     * @param {*} [thisArg] The `this` binding of `predicate`.
                     * @returns {Object} Returns the new object.
                     * @example
                     *
                     * var object = { 'user': 'fred', 'age': 40 };
                     *
                     * _.omit(object, 'age');
                     * // => { 'user': 'fred' }
                     *
                     * _.omit(object, _.isNumber);
                     * // => { 'user': 'fred' }
                     */
                    var omit = restParam(function (object, props) {
                        if (object == null) {
                            return {};
                        }
                        if (typeof props[0] != 'function') {
                            var props = arrayMap(baseFlatten(props), String);
                            return pickByArray(object, baseDifference(keysIn(object), props));
                        }
                        var predicate = bindCallback(props[0], props[1], 3);
                        return pickByCallback(object, function (value, key, object) {
                            return !predicate(value, key, object);
                        });
                    });

                    /**
                     * Creates a two dimensional array of the key-value pairs for `object`,
                     * e.g. `[[key1, value1], [key2, value2]]`.
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The object to query.
                     * @returns {Array} Returns the new array of key-value pairs.
                     * @example
                     *
                     * _.pairs({ 'barney': 36, 'fred': 40 });
                     * // => [['barney', 36], ['fred', 40]] (iteration order is not guaranteed)
                     */
                    function pairs(object) {
                        object = toObject(object);

                        var index = -1,
                            props = keys(object),
                            length = props.length,
                            result = Array(length);

                        while (++index < length) {
                            var key = props[index];
                            result[index] = [key, object[key]];
                        }
                        return result;
                    }

                    /**
                     * Creates an object composed of the picked `object` properties. Property
                     * names may be specified as individual arguments or as arrays of property
                     * names. If `predicate` is provided it is invoked for each property of `object`
                     * picking the properties `predicate` returns truthy for. The predicate is
                     * bound to `thisArg` and invoked with three arguments: (value, key, object).
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The source object.
                     * @param {Function|...(string|string[])} [predicate] The function invoked per
                     *  iteration or property names to pick, specified as individual property
                     *  names or arrays of property names.
                     * @param {*} [thisArg] The `this` binding of `predicate`.
                     * @returns {Object} Returns the new object.
                     * @example
                     *
                     * var object = { 'user': 'fred', 'age': 40 };
                     *
                     * _.pick(object, 'user');
                     * // => { 'user': 'fred' }
                     *
                     * _.pick(object, _.isString);
                     * // => { 'user': 'fred' }
                     */
                    var pick = restParam(function (object, props) {
                        if (object == null) {
                            return {};
                        }
                        return typeof props[0] == 'function'
                            ? pickByCallback(object, bindCallback(props[0], props[1], 3))
                            : pickByArray(object, baseFlatten(props));
                    });

                    /**
                     * This method is like `_.get` except that if the resolved value is a function
                     * it is invoked with the `this` binding of its parent object and its result
                     * is returned.
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The object to query.
                     * @param {Array|string} path The path of the property to resolve.
                     * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.
                     * @returns {*} Returns the resolved value.
                     * @example
                     *
                     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
                     *
                     * _.result(object, 'a[0].b.c1');
                     * // => 3
                     *
                     * _.result(object, 'a[0].b.c2');
                     * // => 4
                     *
                     * _.result(object, 'a.b.c', 'default');
                     * // => 'default'
                     *
                     * _.result(object, 'a.b.c', _.constant('default'));
                     * // => 'default'
                     */
                    function result(object, path, defaultValue) {
                        var result = object == null ? undefined : object[path];
                        if (result === undefined) {
                            if (object != null && !isKey(path, object)) {
                                path = toPath(path);
                                object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
                                result = object == null ? undefined : object[last(path)];
                            }
                            result = result === undefined ? defaultValue : result;
                        }
                        return isFunction(result) ? result.call(object) : result;
                    }

                    /**
                     * Sets the property value of `path` on `object`. If a portion of `path`
                     * does not exist it is created.
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The object to augment.
                     * @param {Array|string} path The path of the property to set.
                     * @param {*} value The value to set.
                     * @returns {Object} Returns `object`.
                     * @example
                     *
                     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
                     *
                     * _.set(object, 'a[0].b.c', 4);
                     * console.log(object.a[0].b.c);
                     * // => 4
                     *
                     * _.set(object, 'x[0].y.z', 5);
                     * console.log(object.x[0].y.z);
                     * // => 5
                     */
                    function set(object, path, value) {
                        if (object == null) {
                            return object;
                        }
                        var pathKey = (path + '');
                        path = (object[pathKey] != null || isKey(path, object)) ? [pathKey] : toPath(path);

                        var index = -1,
                            length = path.length,
                            lastIndex = length - 1,
                            nested = object;

                        while (nested != null && ++index < length) {
                            var key = path[index];
                            if (isObject(nested)) {
                                if (index == lastIndex) {
                                    nested[key] = value;
                                } else if (nested[key] == null) {
                                    nested[key] = isIndex(path[index + 1]) ? [] : {};
                                }
                            }
                            nested = nested[key];
                        }
                        return object;
                    }

                    /**
                     * An alternative to `_.reduce`; this method transforms `object` to a new
                     * `accumulator` object which is the result of running each of its own enumerable
                     * properties through `iteratee`, with each invocation potentially mutating
                     * the `accumulator` object. The `iteratee` is bound to `thisArg` and invoked
                     * with four arguments: (accumulator, value, key, object). Iteratee functions
                     * may exit iteration early by explicitly returning `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Array|Object} object The object to iterate over.
                     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                     * @param {*} [accumulator] The custom accumulator value.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {*} Returns the accumulated value.
                     * @example
                     *
                     * _.transform([2, 3, 4], function(result, n) {
                     *   result.push(n *= n);
                     *   return n % 2 == 0;
                     * });
                     * // => [4, 9]
                     *
                     * _.transform({ 'a': 1, 'b': 2 }, function(result, n, key) {
                     *   result[key] = n * 3;
                     * });
                     * // => { 'a': 3, 'b': 6 }
                     */
                    function transform(object, iteratee, accumulator, thisArg) {
                        var isArr = isArray(object) || isTypedArray(object);
                        iteratee = getCallback(iteratee, thisArg, 4);

                        if (accumulator == null) {
                            if (isArr || isObject(object)) {
                                var Ctor = object.constructor;
                                if (isArr) {
                                    accumulator = isArray(object) ? new Ctor : [];
                                } else {
                                    accumulator = baseCreate(isFunction(Ctor) ? Ctor.prototype : undefined);
                                }
                            } else {
                                accumulator = {};
                            }
                        }
                        (isArr ? arrayEach : baseForOwn)(object, function (value, index, object) {
                            return iteratee(accumulator, value, index, object);
                        });
                        return accumulator;
                    }

                    /**
                     * Creates an array of the own enumerable property values of `object`.
                     *
                     * **Note:** Non-object values are coerced to objects.
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The object to query.
                     * @returns {Array} Returns the array of property values.
                     * @example
                     *
                     * function Foo() {
                     *   this.a = 1;
                     *   this.b = 2;
                     * }
                     *
                     * Foo.prototype.c = 3;
                     *
                     * _.values(new Foo);
                     * // => [1, 2] (iteration order is not guaranteed)
                     *
                     * _.values('hi');
                     * // => ['h', 'i']
                     */
                    function values(object) {
                        return baseValues(object, keys(object));
                    }

                    /**
                     * Creates an array of the own and inherited enumerable property values
                     * of `object`.
                     *
                     * **Note:** Non-object values are coerced to objects.
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The object to query.
                     * @returns {Array} Returns the array of property values.
                     * @example
                     *
                     * function Foo() {
                     *   this.a = 1;
                     *   this.b = 2;
                     * }
                     *
                     * Foo.prototype.c = 3;
                     *
                     * _.valuesIn(new Foo);
                     * // => [1, 2, 3] (iteration order is not guaranteed)
                     */
                    function valuesIn(object) {
                        return baseValues(object, keysIn(object));
                    }

                    /*------------------------------------------------------------------------*/

                    /**
                     * Checks if `n` is between `start` and up to but not including, `end`. If
                     * `end` is not specified it is set to `start` with `start` then set to `0`.
                     *
                     * @static
                     * @memberOf _
                     * @category Number
                     * @param {number} n The number to check.
                     * @param {number} [start=0] The start of the range.
                     * @param {number} end The end of the range.
                     * @returns {boolean} Returns `true` if `n` is in the range, else `false`.
                     * @example
                     *
                     * _.inRange(3, 2, 4);
                     * // => true
                     *
                     * _.inRange(4, 8);
                     * // => true
                     *
                     * _.inRange(4, 2);
                     * // => false
                     *
                     * _.inRange(2, 2);
                     * // => false
                     *
                     * _.inRange(1.2, 2);
                     * // => true
                     *
                     * _.inRange(5.2, 4);
                     * // => false
                     */
                    function inRange(value, start, end) {
                        start = +start || 0;
                        if (end === undefined) {
                            end = start;
                            start = 0;
                        } else {
                            end = +end || 0;
                        }
                        return value >= nativeMin(start, end) && value < nativeMax(start, end);
                    }

                    /**
                     * Produces a random number between `min` and `max` (inclusive). If only one
                     * argument is provided a number between `0` and the given number is returned.
                     * If `floating` is `true`, or either `min` or `max` are floats, a floating-point
                     * number is returned instead of an integer.
                     *
                     * @static
                     * @memberOf _
                     * @category Number
                     * @param {number} [min=0] The minimum possible value.
                     * @param {number} [max=1] The maximum possible value.
                     * @param {boolean} [floating] Specify returning a floating-point number.
                     * @returns {number} Returns the random number.
                     * @example
                     *
                     * _.random(0, 5);
                     * // => an integer between 0 and 5
                     *
                     * _.random(5);
                     * // => also an integer between 0 and 5
                     *
                     * _.random(5, true);
                     * // => a floating-point number between 0 and 5
                     *
                     * _.random(1.2, 5.2);
                     * // => a floating-point number between 1.2 and 5.2
                     */
                    function random(min, max, floating) {
                        if (floating && isIterateeCall(min, max, floating)) {
                            max = floating = undefined;
                        }
                        var noMin = min == null,
                            noMax = max == null;

                        if (floating == null) {
                            if (noMax && typeof min == 'boolean') {
                                floating = min;
                                min = 1;
                            }
                            else if (typeof max == 'boolean') {
                                floating = max;
                                noMax = true;
                            }
                        }
                        if (noMin && noMax) {
                            max = 1;
                            noMax = false;
                        }
                        min = +min || 0;
                        if (noMax) {
                            max = min;
                            min = 0;
                        } else {
                            max = +max || 0;
                        }
                        if (floating || min % 1 || max % 1) {
                            var rand = nativeRandom();
                            return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand + '').length - 1)))), max);
                        }
                        return baseRandom(min, max);
                    }

                    /*------------------------------------------------------------------------*/

                    /**
                     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
                     *
                     * @static
                     * @memberOf _
                     * @category String
                     * @param {string} [string=''] The string to convert.
                     * @returns {string} Returns the camel cased string.
                     * @example
                     *
                     * _.camelCase('Foo Bar');
                     * // => 'fooBar'
                     *
                     * _.camelCase('--foo-bar');
                     * // => 'fooBar'
                     *
                     * _.camelCase('__foo_bar__');
                     * // => 'fooBar'
                     */
                    var camelCase = createCompounder(function (result, word, index) {
                        word = word.toLowerCase();
                        return result + (index ? (word.charAt(0).toUpperCase() + word.slice(1)) : word);
                    });

                    /**
                     * Capitalizes the first character of `string`.
                     *
                     * @static
                     * @memberOf _
                     * @category String
                     * @param {string} [string=''] The string to capitalize.
                     * @returns {string} Returns the capitalized string.
                     * @example
                     *
                     * _.capitalize('fred');
                     * // => 'Fred'
                     */
                    function capitalize(string) {
                        string = baseToString(string);
                        return string && (string.charAt(0).toUpperCase() + string.slice(1));
                    }

                    /**
                     * Deburrs `string` by converting [latin-1 supplementary letters](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
                     * to basic latin letters and removing [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
                     *
                     * @static
                     * @memberOf _
                     * @category String
                     * @param {string} [string=''] The string to deburr.
                     * @returns {string} Returns the deburred string.
                     * @example
                     *
                     * _.deburr('dj vu');
                     * // => 'deja vu'
                     */
                    function deburr(string) {
                        string = baseToString(string);
                        return string && string.replace(reLatin1, deburrLetter).replace(reComboMark, '');
                    }

                    /**
                     * Checks if `string` ends with the given target string.
                     *
                     * @static
                     * @memberOf _
                     * @category String
                     * @param {string} [string=''] The string to search.
                     * @param {string} [target] The string to search for.
                     * @param {number} [position=string.length] The position to search from.
                     * @returns {boolean} Returns `true` if `string` ends with `target`, else `false`.
                     * @example
                     *
                     * _.endsWith('abc', 'c');
                     * // => true
                     *
                     * _.endsWith('abc', 'b');
                     * // => false
                     *
                     * _.endsWith('abc', 'b', 2);
                     * // => true
                     */
                    function endsWith(string, target, position) {
                        string = baseToString(string);
                        target = (target + '');

                        var length = string.length;
                        position = position === undefined
                            ? length
                            : nativeMin(position < 0 ? 0 : (+position || 0), length);

                        position -= target.length;
                        return position >= 0 && string.indexOf(target, position) == position;
                    }

                    /**
                     * Converts the characters "&", "<", ">", '"', "'", and "\`", in `string` to
                     * their corresponding HTML entities.
                     *
                     * **Note:** No other characters are escaped. To escape additional characters
                     * use a third-party library like [_he_](https://mths.be/he).
                     *
                     * Though the ">" character is escaped for symmetry, characters like
                     * ">" and "/" don't need escaping in HTML and have no special meaning
                     * unless they're part of a tag or unquoted attribute value.
                     * See [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
                     * (under "semi-related fun fact") for more details.
                     *
                     * Backticks are escaped because in Internet Explorer < 9, they can break out
                     * of attribute values or HTML comments. See [#59](https://html5sec.org/#59),
                     * [#102](https://html5sec.org/#102), [#108](https://html5sec.org/#108), and
                     * [#133](https://html5sec.org/#133) of the [HTML5 Security Cheatsheet](https://html5sec.org/)
                     * for more details.
                     *
                     * When working with HTML you should always [quote attribute values](http://wonko.com/post/html-escaping)
                     * to reduce XSS vectors.
                     *
                     * @static
                     * @memberOf _
                     * @category String
                     * @param {string} [string=''] The string to escape.
                     * @returns {string} Returns the escaped string.
                     * @example
                     *
                     * _.escape('fred, barney, & pebbles');
                     * // => 'fred, barney, &amp; pebbles'
                     */
                    function escape(string) {
                        // Reset `lastIndex` because in IE < 9 `String#replace` does not.
                        string = baseToString(string);
                        return (string && reHasUnescapedHtml.test(string))
                            ? string.replace(reUnescapedHtml, escapeHtmlChar)
                            : string;
                    }

                    /**
                     * Escapes the `RegExp` special characters "\", "/", "^", "$", ".", "|", "?",
                     * "*", "+", "(", ")", "[", "]", "{" and "}" in `string`.
                     *
                     * @static
                     * @memberOf _
                     * @category String
                     * @param {string} [string=''] The string to escape.
                     * @returns {string} Returns the escaped string.
                     * @example
                     *
                     * _.escapeRegExp('[lodash](https://lodash.com/)');
                     * // => '\[lodash\]\(https:\/\/lodash\.com\/\)'
                     */
                    function escapeRegExp(string) {
                        string = baseToString(string);
                        return (string && reHasRegExpChars.test(string))
                            ? string.replace(reRegExpChars, escapeRegExpChar)
                            : (string || '(?:)');
                    }

                    /**
                     * Converts `string` to [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
                     *
                     * @static
                     * @memberOf _
                     * @category String
                     * @param {string} [string=''] The string to convert.
                     * @returns {string} Returns the kebab cased string.
                     * @example
                     *
                     * _.kebabCase('Foo Bar');
                     * // => 'foo-bar'
                     *
                     * _.kebabCase('fooBar');
                     * // => 'foo-bar'
                     *
                     * _.kebabCase('__foo_bar__');
                     * // => 'foo-bar'
                     */
                    var kebabCase = createCompounder(function (result, word, index) {
                        return result + (index ? '-' : '') + word.toLowerCase();
                    });

                    /**
                     * Pads `string` on the left and right sides if it's shorter than `length`.
                     * Padding characters are truncated if they can't be evenly divided by `length`.
                     *
                     * @static
                     * @memberOf _
                     * @category String
                     * @param {string} [string=''] The string to pad.
                     * @param {number} [length=0] The padding length.
                     * @param {string} [chars=' '] The string used as padding.
                     * @returns {string} Returns the padded string.
                     * @example
                     *
                     * _.pad('abc', 8);
                     * // => '  abc   '
                     *
                     * _.pad('abc', 8, '_-');
                     * // => '_-abc_-_'
                     *
                     * _.pad('abc', 3);
                     * // => 'abc'
                     */
                    function pad(string, length, chars) {
                        string = baseToString(string);
                        length = +length;

                        var strLength = string.length;
                        if (strLength >= length || !nativeIsFinite(length)) {
                            return string;
                        }
                        var mid = (length - strLength) / 2,
                            leftLength = nativeFloor(mid),
                            rightLength = nativeCeil(mid);

                        chars = createPadding('', rightLength, chars);
                        return chars.slice(0, leftLength) + string + chars;
                    }

                    /**
                     * Pads `string` on the left side if it's shorter than `length`. Padding
                     * characters are truncated if they exceed `length`.
                     *
                     * @static
                     * @memberOf _
                     * @category String
                     * @param {string} [string=''] The string to pad.
                     * @param {number} [length=0] The padding length.
                     * @param {string} [chars=' '] The string used as padding.
                     * @returns {string} Returns the padded string.
                     * @example
                     *
                     * _.padLeft('abc', 6);
                     * // => '   abc'
                     *
                     * _.padLeft('abc', 6, '_-');
                     * // => '_-_abc'
                     *
                     * _.padLeft('abc', 3);
                     * // => 'abc'
                     */
                    var padLeft = createPadDir();

                    /**
                     * Pads `string` on the right side if it's shorter than `length`. Padding
                     * characters are truncated if they exceed `length`.
                     *
                     * @static
                     * @memberOf _
                     * @category String
                     * @param {string} [string=''] The string to pad.
                     * @param {number} [length=0] The padding length.
                     * @param {string} [chars=' '] The string used as padding.
                     * @returns {string} Returns the padded string.
                     * @example
                     *
                     * _.padRight('abc', 6);
                     * // => 'abc   '
                     *
                     * _.padRight('abc', 6, '_-');
                     * // => 'abc_-_'
                     *
                     * _.padRight('abc', 3);
                     * // => 'abc'
                     */
                    var padRight = createPadDir(true);

                    /**
                     * Converts `string` to an integer of the specified radix. If `radix` is
                     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a hexadecimal,
                     * in which case a `radix` of `16` is used.
                     *
                     * **Note:** This method aligns with the [ES5 implementation](https://es5.github.io/#E)
                     * of `parseInt`.
                     *
                     * @static
                     * @memberOf _
                     * @category String
                     * @param {string} string The string to convert.
                     * @param {number} [radix] The radix to interpret `value` by.
                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                     * @returns {number} Returns the converted integer.
                     * @example
                     *
                     * _.parseInt('08');
                     * // => 8
                     *
                     * _.map(['6', '08', '10'], _.parseInt);
                     * // => [6, 8, 10]
                     */
                    function parseInt(string, radix, guard) {
                        // Firefox < 21 and Opera < 15 follow ES3 for `parseInt`.
                        // Chrome fails to trim leading <BOM> whitespace characters.
                        // See https://code.google.com/p/v8/issues/detail?id=3109 for more details.
                        if (guard ? isIterateeCall(string, radix, guard) : radix == null) {
                            radix = 0;
                        } else if (radix) {
                            radix = +radix;
                        }
                        string = trim(string);
                        return nativeParseInt(string, radix || (reHasHexPrefix.test(string) ? 16 : 10));
                    }

                    /**
                     * Repeats the given string `n` times.
                     *
                     * @static
                     * @memberOf _
                     * @category String
                     * @param {string} [string=''] The string to repeat.
                     * @param {number} [n=0] The number of times to repeat the string.
                     * @returns {string} Returns the repeated string.
                     * @example
                     *
                     * _.repeat('*', 3);
                     * // => '***'
                     *
                     * _.repeat('abc', 2);
                     * // => 'abcabc'
                     *
                     * _.repeat('abc', 0);
                     * // => ''
                     */
                    function repeat(string, n) {
                        var result = '';
                        string = baseToString(string);
                        n = +n;
                        if (n < 1 || !string || !nativeIsFinite(n)) {
                            return result;
                        }
                        // Leverage the exponentiation by squaring algorithm for a faster repeat.
                        // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
                        do {
                            if (n % 2) {
                                result += string;
                            }
                            n = nativeFloor(n / 2);
                            string += string;
                        } while (n);

                        return result;
                    }

                    /**
                     * Converts `string` to [snake case](https://en.wikipedia.org/wiki/Snake_case).
                     *
                     * @static
                     * @memberOf _
                     * @category String
                     * @param {string} [string=''] The string to convert.
                     * @returns {string} Returns the snake cased string.
                     * @example
                     *
                     * _.snakeCase('Foo Bar');
                     * // => 'foo_bar'
                     *
                     * _.snakeCase('fooBar');
                     * // => 'foo_bar'
                     *
                     * _.snakeCase('--foo-bar');
                     * // => 'foo_bar'
                     */
                    var snakeCase = createCompounder(function (result, word, index) {
                        return result + (index ? '_' : '') + word.toLowerCase();
                    });

                    /**
                     * Converts `string` to [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
                     *
                     * @static
                     * @memberOf _
                     * @category String
                     * @param {string} [string=''] The string to convert.
                     * @returns {string} Returns the start cased string.
                     * @example
                     *
                     * _.startCase('--foo-bar');
                     * // => 'Foo Bar'
                     *
                     * _.startCase('fooBar');
                     * // => 'Foo Bar'
                     *
                     * _.startCase('__foo_bar__');
                     * // => 'Foo Bar'
                     */
                    var startCase = createCompounder(function (result, word, index) {
                        return result + (index ? ' ' : '') + (word.charAt(0).toUpperCase() + word.slice(1));
                    });

                    /**
                     * Checks if `string` starts with the given target string.
                     *
                     * @static
                     * @memberOf _
                     * @category String
                     * @param {string} [string=''] The string to search.
                     * @param {string} [target] The string to search for.
                     * @param {number} [position=0] The position to search from.
                     * @returns {boolean} Returns `true` if `string` starts with `target`, else `false`.
                     * @example
                     *
                     * _.startsWith('abc', 'a');
                     * // => true
                     *
                     * _.startsWith('abc', 'b');
                     * // => false
                     *
                     * _.startsWith('abc', 'b', 1);
                     * // => true
                     */
                    function startsWith(string, target, position) {
                        string = baseToString(string);
                        position = position == null
                            ? 0
                            : nativeMin(position < 0 ? 0 : (+position || 0), string.length);

                        return string.lastIndexOf(target, position) == position;
                    }

                    /**
                     * Creates a compiled template function that can interpolate data properties
                     * in "interpolate" delimiters, HTML-escape interpolated data properties in
                     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
                     * properties may be accessed as free variables in the template. If a setting
                     * object is provided it takes precedence over `_.templateSettings` values.
                     *
                     * **Note:** In the development build `_.template` utilizes
                     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
                     * for easier debugging.
                     *
                     * For more information on precompiling templates see
                     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
                     *
                     * For more information on Chrome extension sandboxes see
                     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
                     *
                     * @static
                     * @memberOf _
                     * @category String
                     * @param {string} [string=''] The template string.
                     * @param {Object} [options] The options object.
                     * @param {RegExp} [options.escape] The HTML "escape" delimiter.
                     * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
                     * @param {Object} [options.imports] An object to import into the template as free variables.
                     * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
                     * @param {string} [options.sourceURL] The sourceURL of the template's compiled source.
                     * @param {string} [options.variable] The data object variable name.
                     * @param- {Object} [otherOptions] Enables the legacy `options` param signature.
                     * @returns {Function} Returns the compiled template function.
                     * @example
                     *
                     * // using the "interpolate" delimiter to create a compiled template
                     * var compiled = _.template('hello <%= user %>!');
                     * compiled({ 'user': 'fred' });
                     * // => 'hello fred!'
                     *
                     * // using the HTML "escape" delimiter to escape data property values
                     * var compiled = _.template('<b><%- value %></b>');
                     * compiled({ 'value': '<script>' });
                     * // => '<b>&lt;script&gt;</b>'
                     *
                     * // using the "evaluate" delimiter to execute JavaScript and generate HTML
                     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
                     * compiled({ 'users': ['fred', 'barney'] });
                     * // => '<li>fred</li><li>barney</li>'
                     *
                     * // using the internal `print` function in "evaluate" delimiters
                     * var compiled = _.template('<% print("hello " + user); %>!');
                     * compiled({ 'user': 'barney' });
                     * // => 'hello barney!'
                     *
                     * // using the ES delimiter as an alternative to the default "interpolate" delimiter
                     * var compiled = _.template('hello ${ user }!');
                     * compiled({ 'user': 'pebbles' });
                     * // => 'hello pebbles!'
                     *
                     * // using custom template delimiters
                     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
                     * var compiled = _.template('hello {{ user }}!');
                     * compiled({ 'user': 'mustache' });
                     * // => 'hello mustache!'
                     *
                     * // using backslashes to treat delimiters as plain text
                     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
                     * compiled({ 'value': 'ignored' });
                     * // => '<%- value %>'
                     *
                     * // using the `imports` option to import `jQuery` as `jq`
                     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
                     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
                     * compiled({ 'users': ['fred', 'barney'] });
                     * // => '<li>fred</li><li>barney</li>'
                     *
                     * // using the `sourceURL` option to specify a custom sourceURL for the template
                     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
                     * compiled(data);
                     * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
                     *
                     * // using the `variable` option to ensure a with-statement isn't used in the compiled template
                     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
                     * compiled.source;
                     * // => function(data) {
                     * //   var __t, __p = '';
                     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
                     * //   return __p;
                     * // }
                     *
                     * // using the `source` property to inline compiled templates for meaningful
                     * // line numbers in error messages and a stack trace
                     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
                     *   var JST = {\
                     *     "main": ' + _.template(mainText).source + '\
                     *   };\
                     * ');
                     */
                    function template(string, options, otherOptions) {
                        // Based on John Resig's `tmpl` implementation (http://ejohn.org/blog/javascript-micro-templating/)
                        // and Laura Doktorova's doT.js (https://github.com/olado/doT).
                        var settings = lodash.templateSettings;

                        if (otherOptions && isIterateeCall(string, options, otherOptions)) {
                            options = otherOptions = undefined;
                        }
                        string = baseToString(string);
                        options = assignWith(baseAssign({}, otherOptions || options), settings, assignOwnDefaults);

                        var imports = assignWith(baseAssign({}, options.imports), settings.imports, assignOwnDefaults),
                            importsKeys = keys(imports),
                            importsValues = baseValues(imports, importsKeys);

                        var isEscaping,
                            isEvaluating,
                            index = 0,
                            interpolate = options.interpolate || reNoMatch,
                            source = "__p += '";

                        // Compile the regexp to match each delimiter.
                        var reDelimiters = RegExp(
                            (options.escape || reNoMatch).source + '|' +
                            interpolate.source + '|' +
                            (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
                            (options.evaluate || reNoMatch).source + '|$'
                            , 'g');

                        // Use a sourceURL for easier debugging.
                        var sourceURL = '//# sourceURL=' +
                            ('sourceURL' in options
                                ? options.sourceURL
                                : ('lodash.templateSources[' + (++templateCounter) + ']')
                            ) + '\n';

                        string.replace(reDelimiters, function (match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
                            interpolateValue || (interpolateValue = esTemplateValue);

                            // Escape characters that can't be included in string literals.
                            source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

                            // Replace delimiters with snippets.
                            if (escapeValue) {
                                isEscaping = true;
                                source += "' +\n__e(" + escapeValue + ") +\n'";
                            }
                            if (evaluateValue) {
                                isEvaluating = true;
                                source += "';\n" + evaluateValue + ";\n__p += '";
                            }
                            if (interpolateValue) {
                                source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
                            }
                            index = offset + match.length;

                            // The JS engine embedded in Adobe products requires returning the `match`
                            // string in order to produce the correct `offset` value.
                            return match;
                        });

                        source += "';\n";

                        // If `variable` is not specified wrap a with-statement around the generated
                        // code to add the data object to the top of the scope chain.
                        var variable = options.variable;
                        if (!variable) {
                            source = 'with (obj) {\n' + source + '\n}\n';
                        }
                        // Cleanup code by stripping empty strings.
                        source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
                            .replace(reEmptyStringMiddle, '$1')
                            .replace(reEmptyStringTrailing, '$1;');

                        // Frame code as the function body.
                        source = 'function(' + (variable || 'obj') + ') {\n' +
                            (variable
                                ? ''
                                : 'obj || (obj = {});\n'
                            ) +
                            "var __t, __p = ''" +
                            (isEscaping
                                ? ', __e = _.escape'
                                : ''
                            ) +
                            (isEvaluating
                                ? ', __j = Array.prototype.join;\n' +
                                "function print() { __p += __j.call(arguments, '') }\n"
                                : ';\n'
                            ) +
                            source +
                            'return __p\n}';

                        var result = attempt(function () {
                            return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
                        });

                        // Provide the compiled function's source by its `toString` method or
                        // the `source` property as a convenience for inlining compiled templates.
                        result.source = source;
                        if (isError(result)) {
                            throw result;
                        }
                        return result;
                    }

                    /**
                     * Removes leading and trailing whitespace or specified characters from `string`.
                     *
                     * @static
                     * @memberOf _
                     * @category String
                     * @param {string} [string=''] The string to trim.
                     * @param {string} [chars=whitespace] The characters to trim.
                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                     * @returns {string} Returns the trimmed string.
                     * @example
                     *
                     * _.trim('  abc  ');
                     * // => 'abc'
                     *
                     * _.trim('-_-abc-_-', '_-');
                     * // => 'abc'
                     *
                     * _.map(['  foo  ', '  bar  '], _.trim);
                     * // => ['foo', 'bar']
                     */
                    function trim(string, chars, guard) {
                        var value = string;
                        string = baseToString(string);
                        if (!string) {
                            return string;
                        }
                        if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
                            return string.slice(trimmedLeftIndex(string), trimmedRightIndex(string) + 1);
                        }
                        chars = (chars + '');
                        return string.slice(charsLeftIndex(string, chars), charsRightIndex(string, chars) + 1);
                    }

                    /**
                     * Removes leading whitespace or specified characters from `string`.
                     *
                     * @static
                     * @memberOf _
                     * @category String
                     * @param {string} [string=''] The string to trim.
                     * @param {string} [chars=whitespace] The characters to trim.
                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                     * @returns {string} Returns the trimmed string.
                     * @example
                     *
                     * _.trimLeft('  abc  ');
                     * // => 'abc  '
                     *
                     * _.trimLeft('-_-abc-_-', '_-');
                     * // => 'abc-_-'
                     */
                    function trimLeft(string, chars, guard) {
                        var value = string;
                        string = baseToString(string);
                        if (!string) {
                            return string;
                        }
                        if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
                            return string.slice(trimmedLeftIndex(string));
                        }
                        return string.slice(charsLeftIndex(string, (chars + '')));
                    }

                    /**
                     * Removes trailing whitespace or specified characters from `string`.
                     *
                     * @static
                     * @memberOf _
                     * @category String
                     * @param {string} [string=''] The string to trim.
                     * @param {string} [chars=whitespace] The characters to trim.
                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                     * @returns {string} Returns the trimmed string.
                     * @example
                     *
                     * _.trimRight('  abc  ');
                     * // => '  abc'
                     *
                     * _.trimRight('-_-abc-_-', '_-');
                     * // => '-_-abc'
                     */
                    function trimRight(string, chars, guard) {
                        var value = string;
                        string = baseToString(string);
                        if (!string) {
                            return string;
                        }
                        if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
                            return string.slice(0, trimmedRightIndex(string) + 1);
                        }
                        return string.slice(0, charsRightIndex(string, (chars + '')) + 1);
                    }

                    /**
                     * Truncates `string` if it's longer than the given maximum string length.
                     * The last characters of the truncated string are replaced with the omission
                     * string which defaults to "...".
                     *
                     * @static
                     * @memberOf _
                     * @category String
                     * @param {string} [string=''] The string to truncate.
                     * @param {Object|number} [options] The options object or maximum string length.
                     * @param {number} [options.length=30] The maximum string length.
                     * @param {string} [options.omission='...'] The string to indicate text is omitted.
                     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                     * @returns {string} Returns the truncated string.
                     * @example
                     *
                     * _.trunc('hi-diddly-ho there, neighborino');
                     * // => 'hi-diddly-ho there, neighbo...'
                     *
                     * _.trunc('hi-diddly-ho there, neighborino', 24);
                     * // => 'hi-diddly-ho there, n...'
                     *
                     * _.trunc('hi-diddly-ho there, neighborino', {
                     *   'length': 24,
                     *   'separator': ' '
                     * });
                     * // => 'hi-diddly-ho there,...'
                     *
                     * _.trunc('hi-diddly-ho there, neighborino', {
                     *   'length': 24,
                     *   'separator': /,? +/
                     * });
                     * // => 'hi-diddly-ho there...'
                     *
                     * _.trunc('hi-diddly-ho there, neighborino', {
                     *   'omission': ' [...]'
                     * });
                     * // => 'hi-diddly-ho there, neig [...]'
                     */
                    function trunc(string, options, guard) {
                        if (guard && isIterateeCall(string, options, guard)) {
                            options = undefined;
                        }
                        var length = DEFAULT_TRUNC_LENGTH,
                            omission = DEFAULT_TRUNC_OMISSION;

                        if (options != null) {
                            if (isObject(options)) {
                                var separator = 'separator' in options ? options.separator : separator;
                                length = 'length' in options ? (+options.length || 0) : length;
                                omission = 'omission' in options ? baseToString(options.omission) : omission;
                            } else {
                                length = +options || 0;
                            }
                        }
                        string = baseToString(string);
                        if (length >= string.length) {
                            return string;
                        }
                        var end = length - omission.length;
                        if (end < 1) {
                            return omission;
                        }
                        var result = string.slice(0, end);
                        if (separator == null) {
                            return result + omission;
                        }
                        if (isRegExp(separator)) {
                            if (string.slice(end).search(separator)) {
                                var match,
                                    newEnd,
                                    substring = string.slice(0, end);

                                if (!separator.global) {
                                    separator = RegExp(separator.source, (reFlags.exec(separator) || '') + 'g');
                                }
                                separator.lastIndex = 0;
                                while ((match = separator.exec(substring))) {
                                    newEnd = match.index;
                                }
                                result = result.slice(0, newEnd == null ? end : newEnd);
                            }
                        } else if (string.indexOf(separator, end) != end) {
                            var index = result.lastIndexOf(separator);
                            if (index > -1) {
                                result = result.slice(0, index);
                            }
                        }
                        return result + omission;
                    }

                    /**
                     * The inverse of `_.escape`; this method converts the HTML entities
                     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, `&#39;`, and `&#96;` in `string` to their
                     * corresponding characters.
                     *
                     * **Note:** No other HTML entities are unescaped. To unescape additional HTML
                     * entities use a third-party library like [_he_](https://mths.be/he).
                     *
                     * @static
                     * @memberOf _
                     * @category String
                     * @param {string} [string=''] The string to unescape.
                     * @returns {string} Returns the unescaped string.
                     * @example
                     *
                     * _.unescape('fred, barney, &amp; pebbles');
                     * // => 'fred, barney, & pebbles'
                     */
                    function unescape(string) {
                        string = baseToString(string);
                        return (string && reHasEscapedHtml.test(string))
                            ? string.replace(reEscapedHtml, unescapeHtmlChar)
                            : string;
                    }

                    /**
                     * Splits `string` into an array of its words.
                     *
                     * @static
                     * @memberOf _
                     * @category String
                     * @param {string} [string=''] The string to inspect.
                     * @param {RegExp|string} [pattern] The pattern to match words.
                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                     * @returns {Array} Returns the words of `string`.
                     * @example
                     *
                     * _.words('fred, barney, & pebbles');
                     * // => ['fred', 'barney', 'pebbles']
                     *
                     * _.words('fred, barney, & pebbles', /[^, ]+/g);
                     * // => ['fred', 'barney', '&', 'pebbles']
                     */
                    function words(string, pattern, guard) {
                        if (guard && isIterateeCall(string, pattern, guard)) {
                            pattern = undefined;
                        }
                        string = baseToString(string);
                        return string.match(pattern || reWords) || [];
                    }

                    /*------------------------------------------------------------------------*/

                    /**
                     * Attempts to invoke `func`, returning either the result or the caught error
                     * object. Any additional arguments are provided to `func` when it is invoked.
                     *
                     * @static
                     * @memberOf _
                     * @category Utility
                     * @param {Function} func The function to attempt.
                     * @returns {*} Returns the `func` result or error object.
                     * @example
                     *
                     * // avoid throwing errors for invalid selectors
                     * var elements = _.attempt(function(selector) {
                     *   return document.querySelectorAll(selector);
                     * }, '>_>');
                     *
                     * if (_.isError(elements)) {
                     *   elements = [];
                     * }
                     */
                    var attempt = restParam(function (func, args) {
                        try {
                            return func.apply(undefined, args);
                        } catch (e) {
                            return isError(e) ? e : new Error(e);
                        }
                    });

                    /**
                     * Creates a function that invokes `func` with the `this` binding of `thisArg`
                     * and arguments of the created function. If `func` is a property name the
                     * created callback returns the property value for a given element. If `func`
                     * is an object the created callback returns `true` for elements that contain
                     * the equivalent object properties, otherwise it returns `false`.
                     *
                     * @static
                     * @memberOf _
                     * @alias iteratee
                     * @category Utility
                     * @param {*} [func=_.identity] The value to convert to a callback.
                     * @param {*} [thisArg] The `this` binding of `func`.
                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                     * @returns {Function} Returns the callback.
                     * @example
                     *
                     * var users = [
                     *   { 'user': 'barney', 'age': 36 },
                     *   { 'user': 'fred',   'age': 40 }
                     * ];
                     *
                     * // wrap to create custom callback shorthands
                     * _.callback = _.wrap(_.callback, function(callback, func, thisArg) {
                     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(func);
                     *   if (!match) {
                     *     return callback(func, thisArg);
                     *   }
                     *   return function(object) {
                     *     return match[2] == 'gt'
                     *       ? object[match[1]] > match[3]
                     *       : object[match[1]] < match[3];
                     *   };
                     * });
                     *
                     * _.filter(users, 'age__gt36');
                     * // => [{ 'user': 'fred', 'age': 40 }]
                     */
                    function callback(func, thisArg, guard) {
                        if (guard && isIterateeCall(func, thisArg, guard)) {
                            thisArg = undefined;
                        }
                        return isObjectLike(func)
                            ? matches(func)
                            : baseCallback(func, thisArg);
                    }

                    /**
                     * Creates a function that returns `value`.
                     *
                     * @static
                     * @memberOf _
                     * @category Utility
                     * @param {*} value The value to return from the new function.
                     * @returns {Function} Returns the new function.
                     * @example
                     *
                     * var object = { 'user': 'fred' };
                     * var getter = _.constant(object);
                     *
                     * getter() === object;
                     * // => true
                     */
                    function constant(value) {
                        return function () {
                            return value;
                        };
                    }

                    /**
                     * This method returns the first argument provided to it.
                     *
                     * @static
                     * @memberOf _
                     * @category Utility
                     * @param {*} value Any value.
                     * @returns {*} Returns `value`.
                     * @example
                     *
                     * var object = { 'user': 'fred' };
                     *
                     * _.identity(object) === object;
                     * // => true
                     */
                    function identity(value) {
                        return value;
                    }

                    /**
                     * Creates a function that performs a deep comparison between a given object
                     * and `source`, returning `true` if the given object has equivalent property
                     * values, else `false`.
                     *
                     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
                     * numbers, `Object` objects, regexes, and strings. Objects are compared by
                     * their own, not inherited, enumerable properties. For comparing a single
                     * own or inherited property value see `_.matchesProperty`.
                     *
                     * @static
                     * @memberOf _
                     * @category Utility
                     * @param {Object} source The object of property values to match.
                     * @returns {Function} Returns the new function.
                     * @example
                     *
                     * var users = [
                     *   { 'user': 'barney', 'age': 36, 'active': true },
                     *   { 'user': 'fred',   'age': 40, 'active': false }
                     * ];
                     *
                     * _.filter(users, _.matches({ 'age': 40, 'active': false }));
                     * // => [{ 'user': 'fred', 'age': 40, 'active': false }]
                     */
                    function matches(source) {
                        return baseMatches(baseClone(source, true));
                    }

                    /**
                     * Creates a function that compares the property value of `path` on a given
                     * object to `value`.
                     *
                     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
                     * numbers, `Object` objects, regexes, and strings. Objects are compared by
                     * their own, not inherited, enumerable properties.
                     *
                     * @static
                     * @memberOf _
                     * @category Utility
                     * @param {Array|string} path The path of the property to get.
                     * @param {*} srcValue The value to match.
                     * @returns {Function} Returns the new function.
                     * @example
                     *
                     * var users = [
                     *   { 'user': 'barney' },
                     *   { 'user': 'fred' }
                     * ];
                     *
                     * _.find(users, _.matchesProperty('user', 'fred'));
                     * // => { 'user': 'fred' }
                     */
                    function matchesProperty(path, srcValue) {
                        return baseMatchesProperty(path, baseClone(srcValue, true));
                    }

                    /**
                     * Creates a function that invokes the method at `path` on a given object.
                     * Any additional arguments are provided to the invoked method.
                     *
                     * @static
                     * @memberOf _
                     * @category Utility
                     * @param {Array|string} path The path of the method to invoke.
                     * @param {...*} [args] The arguments to invoke the method with.
                     * @returns {Function} Returns the new function.
                     * @example
                     *
                     * var objects = [
                     *   { 'a': { 'b': { 'c': _.constant(2) } } },
                     *   { 'a': { 'b': { 'c': _.constant(1) } } }
                     * ];
                     *
                     * _.map(objects, _.method('a.b.c'));
                     * // => [2, 1]
                     *
                     * _.invoke(_.sortBy(objects, _.method(['a', 'b', 'c'])), 'a.b.c');
                     * // => [1, 2]
                     */
                    var method = restParam(function (path, args) {
                        return function (object) {
                            return invokePath(object, path, args);
                        };
                    });

                    /**
                     * The opposite of `_.method`; this method creates a function that invokes
                     * the method at a given path on `object`. Any additional arguments are
                     * provided to the invoked method.
                     *
                     * @static
                     * @memberOf _
                     * @category Utility
                     * @param {Object} object The object to query.
                     * @param {...*} [args] The arguments to invoke the method with.
                     * @returns {Function} Returns the new function.
                     * @example
                     *
                     * var array = _.times(3, _.constant),
                     *     object = { 'a': array, 'b': array, 'c': array };
                     *
                     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
                     * // => [2, 0]
                     *
                     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
                     * // => [2, 0]
                     */
                    var methodOf = restParam(function (object, args) {
                        return function (path) {
                            return invokePath(object, path, args);
                        };
                    });

                    /**
                     * Adds all own enumerable function properties of a source object to the
                     * destination object. If `object` is a function then methods are added to
                     * its prototype as well.
                     *
                     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
                     * avoid conflicts caused by modifying the original.
                     *
                     * @static
                     * @memberOf _
                     * @category Utility
                     * @param {Function|Object} [object=lodash] The destination object.
                     * @param {Object} source The object of functions to add.
                     * @param {Object} [options] The options object.
                     * @param {boolean} [options.chain=true] Specify whether the functions added
                     *  are chainable.
                     * @returns {Function|Object} Returns `object`.
                     * @example
                     *
                     * function vowels(string) {
                     *   return _.filter(string, function(v) {
                     *     return /[aeiou]/i.test(v);
                     *   });
                     * }
                     *
                     * _.mixin({ 'vowels': vowels });
                     * _.vowels('fred');
                     * // => ['e']
                     *
                     * _('fred').vowels().value();
                     * // => ['e']
                     *
                     * _.mixin({ 'vowels': vowels }, { 'chain': false });
                     * _('fred').vowels();
                     * // => ['e']
                     */
                    function mixin(object, source, options) {
                        if (options == null) {
                            var isObj = isObject(source),
                                props = isObj ? keys(source) : undefined,
                                methodNames = (props && props.length) ? baseFunctions(source, props) : undefined;

                            if (!(methodNames ? methodNames.length : isObj)) {
                                methodNames = false;
                                options = source;
                                source = object;
                                object = this;
                            }
                        }
                        if (!methodNames) {
                            methodNames = baseFunctions(source, keys(source));
                        }
                        var chain = true,
                            index = -1,
                            isFunc = isFunction(object),
                            length = methodNames.length;

                        if (options === false) {
                            chain = false;
                        } else if (isObject(options) && 'chain' in options) {
                            chain = options.chain;
                        }
                        while (++index < length) {
                            var methodName = methodNames[index],
                                func = source[methodName];

                            object[methodName] = func;
                            if (isFunc) {
                                object.prototype[methodName] = (function (func) {
                                    return function () {
                                        var chainAll = this.__chain__;
                                        if (chain || chainAll) {
                                            var result = object(this.__wrapped__),
                                                actions = result.__actions__ = arrayCopy(this.__actions__);

                                            actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
                                            result.__chain__ = chainAll;
                                            return result;
                                        }
                                        return func.apply(object, arrayPush([this.value()], arguments));
                                    };
                                }(func));
                            }
                        }
                        return object;
                    }

                    /**
                     * Reverts the `_` variable to its previous value and returns a reference to
                     * the `lodash` function.
                     *
                     * @static
                     * @memberOf _
                     * @category Utility
                     * @returns {Function} Returns the `lodash` function.
                     * @example
                     *
                     * var lodash = _.noConflict();
                     */
                    function noConflict() {
                        root._ = oldDash;
                        return this;
                    }

                    /**
                     * A no-operation function that returns `undefined` regardless of the
                     * arguments it receives.
                     *
                     * @static
                     * @memberOf _
                     * @category Utility
                     * @example
                     *
                     * var object = { 'user': 'fred' };
                     *
                     * _.noop(object) === undefined;
                     * // => true
                     */
                    function noop() {
                        // No operation performed.
                    }

                    /**
                     * Creates a function that returns the property value at `path` on a
                     * given object.
                     *
                     * @static
                     * @memberOf _
                     * @category Utility
                     * @param {Array|string} path The path of the property to get.
                     * @returns {Function} Returns the new function.
                     * @example
                     *
                     * var objects = [
                     *   { 'a': { 'b': { 'c': 2 } } },
                     *   { 'a': { 'b': { 'c': 1 } } }
                     * ];
                     *
                     * _.map(objects, _.property('a.b.c'));
                     * // => [2, 1]
                     *
                     * _.pluck(_.sortBy(objects, _.property(['a', 'b', 'c'])), 'a.b.c');
                     * // => [1, 2]
                     */
                    function property(path) {
                        return isKey(path) ? baseProperty(path) : basePropertyDeep(path);
                    }

                    /**
                     * The opposite of `_.property`; this method creates a function that returns
                     * the property value at a given path on `object`.
                     *
                     * @static
                     * @memberOf _
                     * @category Utility
                     * @param {Object} object The object to query.
                     * @returns {Function} Returns the new function.
                     * @example
                     *
                     * var array = [0, 1, 2],
                     *     object = { 'a': array, 'b': array, 'c': array };
                     *
                     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
                     * // => [2, 0]
                     *
                     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
                     * // => [2, 0]
                     */
                    function propertyOf(object) {
                        return function (path) {
                            return baseGet(object, toPath(path), path + '');
                        };
                    }

                    /**
                     * Creates an array of numbers (positive and/or negative) progressing from
                     * `start` up to, but not including, `end`. If `end` is not specified it is
                     * set to `start` with `start` then set to `0`. If `end` is less than `start`
                     * a zero-length range is created unless a negative `step` is specified.
                     *
                     * @static
                     * @memberOf _
                     * @category Utility
                     * @param {number} [start=0] The start of the range.
                     * @param {number} end The end of the range.
                     * @param {number} [step=1] The value to increment or decrement by.
                     * @returns {Array} Returns the new array of numbers.
                     * @example
                     *
                     * _.range(4);
                     * // => [0, 1, 2, 3]
                     *
                     * _.range(1, 5);
                     * // => [1, 2, 3, 4]
                     *
                     * _.range(0, 20, 5);
                     * // => [0, 5, 10, 15]
                     *
                     * _.range(0, -4, -1);
                     * // => [0, -1, -2, -3]
                     *
                     * _.range(1, 4, 0);
                     * // => [1, 1, 1]
                     *
                     * _.range(0);
                     * // => []
                     */
                    function range(start, end, step) {
                        if (step && isIterateeCall(start, end, step)) {
                            end = step = undefined;
                        }
                        start = +start || 0;
                        step = step == null ? 1 : (+step || 0);

                        if (end == null) {
                            end = start;
                            start = 0;
                        } else {
                            end = +end || 0;
                        }
                        // Use `Array(length)` so engines like Chakra and V8 avoid slower modes.
                        // See https://youtu.be/XAqIpGU8ZZk#t=17m25s for more details.
                        var index = -1,
                            length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
                            result = Array(length);

                        while (++index < length) {
                            result[index] = start;
                            start += step;
                        }
                        return result;
                    }

                    /**
                     * Invokes the iteratee function `n` times, returning an array of the results
                     * of each invocation. The `iteratee` is bound to `thisArg` and invoked with
                     * one argument; (index).
                     *
                     * @static
                     * @memberOf _
                     * @category Utility
                     * @param {number} n The number of times to invoke `iteratee`.
                     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {Array} Returns the array of results.
                     * @example
                     *
                     * var diceRolls = _.times(3, _.partial(_.random, 1, 6, false));
                     * // => [3, 6, 4]
                     *
                     * _.times(3, function(n) {
                     *   mage.castSpell(n);
                     * });
                     * // => invokes `mage.castSpell(n)` three times with `n` of `0`, `1`, and `2`
                     *
                     * _.times(3, function(n) {
                     *   this.cast(n);
                     * }, mage);
                     * // => also invokes `mage.castSpell(n)` three times
                     */
                    function times(n, iteratee, thisArg) {
                        n = nativeFloor(n);

                        // Exit early to avoid a JSC JIT bug in Safari 8
                        // where `Array(0)` is treated as `Array(1)`.
                        if (n < 1 || !nativeIsFinite(n)) {
                            return [];
                        }
                        var index = -1,
                            result = Array(nativeMin(n, MAX_ARRAY_LENGTH));

                        iteratee = bindCallback(iteratee, thisArg, 1);
                        while (++index < n) {
                            if (index < MAX_ARRAY_LENGTH) {
                                result[index] = iteratee(index);
                            } else {
                                iteratee(index);
                            }
                        }
                        return result;
                    }

                    /**
                     * Generates a unique ID. If `prefix` is provided the ID is appended to it.
                     *
                     * @static
                     * @memberOf _
                     * @category Utility
                     * @param {string} [prefix] The value to prefix the ID with.
                     * @returns {string} Returns the unique ID.
                     * @example
                     *
                     * _.uniqueId('contact_');
                     * // => 'contact_104'
                     *
                     * _.uniqueId();
                     * // => '105'
                     */
                    function uniqueId(prefix) {
                        var id = ++idCounter;
                        return baseToString(prefix) + id;
                    }

                    /*------------------------------------------------------------------------*/

                    /**
                     * Adds two numbers.
                     *
                     * @static
                     * @memberOf _
                     * @category Math
                     * @param {number} augend The first number to add.
                     * @param {number} addend The second number to add.
                     * @returns {number} Returns the sum.
                     * @example
                     *
                     * _.add(6, 4);
                     * // => 10
                     */
                    function add(augend, addend) {
                        return (+augend || 0) + (+addend || 0);
                    }

                    /**
                     * Calculates `n` rounded up to `precision`.
                     *
                     * @static
                     * @memberOf _
                     * @category Math
                     * @param {number} n The number to round up.
                     * @param {number} [precision=0] The precision to round up to.
                     * @returns {number} Returns the rounded up number.
                     * @example
                     *
                     * _.ceil(4.006);
                     * // => 5
                     *
                     * _.ceil(6.004, 2);
                     * // => 6.01
                     *
                     * _.ceil(6040, -2);
                     * // => 6100
                     */
                    var ceil = createRound('ceil');

                    /**
                     * Calculates `n` rounded down to `precision`.
                     *
                     * @static
                     * @memberOf _
                     * @category Math
                     * @param {number} n The number to round down.
                     * @param {number} [precision=0] The precision to round down to.
                     * @returns {number} Returns the rounded down number.
                     * @example
                     *
                     * _.floor(4.006);
                     * // => 4
                     *
                     * _.floor(0.046, 2);
                     * // => 0.04
                     *
                     * _.floor(4060, -2);
                     * // => 4000
                     */
                    var floor = createRound('floor');

                    /**
                     * Gets the maximum value of `collection`. If `collection` is empty or falsey
                     * `-Infinity` is returned. If an iteratee function is provided it is invoked
                     * for each value in `collection` to generate the criterion by which the value
                     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three
                     * arguments: (value, index, collection).
                     *
                     * If a property name is provided for `iteratee` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `iteratee` the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Math
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {*} Returns the maximum value.
                     * @example
                     *
                     * _.max([4, 2, 8, 6]);
                     * // => 8
                     *
                     * _.max([]);
                     * // => -Infinity
                     *
                     * var users = [
                     *   { 'user': 'barney', 'age': 36 },
                     *   { 'user': 'fred',   'age': 40 }
                     * ];
                     *
                     * _.max(users, function(chr) {
                     *   return chr.age;
                     * });
                     * // => { 'user': 'fred', 'age': 40 }
                     *
                     * // using the `_.property` callback shorthand
                     * _.max(users, 'age');
                     * // => { 'user': 'fred', 'age': 40 }
                     */
                    var max = createExtremum(gt, NEGATIVE_INFINITY);

                    /**
                     * Gets the minimum value of `collection`. If `collection` is empty or falsey
                     * `Infinity` is returned. If an iteratee function is provided it is invoked
                     * for each value in `collection` to generate the criterion by which the value
                     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three
                     * arguments: (value, index, collection).
                     *
                     * If a property name is provided for `iteratee` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `iteratee` the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Math
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {*} Returns the minimum value.
                     * @example
                     *
                     * _.min([4, 2, 8, 6]);
                     * // => 2
                     *
                     * _.min([]);
                     * // => Infinity
                     *
                     * var users = [
                     *   { 'user': 'barney', 'age': 36 },
                     *   { 'user': 'fred',   'age': 40 }
                     * ];
                     *
                     * _.min(users, function(chr) {
                     *   return chr.age;
                     * });
                     * // => { 'user': 'barney', 'age': 36 }
                     *
                     * // using the `_.property` callback shorthand
                     * _.min(users, 'age');
                     * // => { 'user': 'barney', 'age': 36 }
                     */
                    var min = createExtremum(lt, POSITIVE_INFINITY);

                    /**
                     * Calculates `n` rounded to `precision`.
                     *
                     * @static
                     * @memberOf _
                     * @category Math
                     * @param {number} n The number to round.
                     * @param {number} [precision=0] The precision to round to.
                     * @returns {number} Returns the rounded number.
                     * @example
                     *
                     * _.round(4.006);
                     * // => 4
                     *
                     * _.round(4.006, 2);
                     * // => 4.01
                     *
                     * _.round(4060, -2);
                     * // => 4100
                     */
                    var round = createRound('round');

                    /**
                     * Gets the sum of the values in `collection`.
                     *
                     * @static
                     * @memberOf _
                     * @category Math
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {number} Returns the sum.
                     * @example
                     *
                     * _.sum([4, 6]);
                     * // => 10
                     *
                     * _.sum({ 'a': 4, 'b': 6 });
                     * // => 10
                     *
                     * var objects = [
                     *   { 'n': 4 },
                     *   { 'n': 6 }
                     * ];
                     *
                     * _.sum(objects, function(object) {
                     *   return object.n;
                     * });
                     * // => 10
                     *
                     * // using the `_.property` callback shorthand
                     * _.sum(objects, 'n');
                     * // => 10
                     */
                    function sum(collection, iteratee, thisArg) {
                        if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
                            iteratee = undefined;
                        }
                        iteratee = getCallback(iteratee, thisArg, 3);
                        return iteratee.length == 1
                            ? arraySum(isArray(collection) ? collection : toIterable(collection), iteratee)
                            : baseSum(collection, iteratee);
                    }

                    /*------------------------------------------------------------------------*/

                    // Ensure wrappers are instances of `baseLodash`.
                    lodash.prototype = baseLodash.prototype;

                    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
                    LodashWrapper.prototype.constructor = LodashWrapper;

                    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
                    LazyWrapper.prototype.constructor = LazyWrapper;

                    // Add functions to the `Map` cache.
                    MapCache.prototype['delete'] = mapDelete;
                    MapCache.prototype.get = mapGet;
                    MapCache.prototype.has = mapHas;
                    MapCache.prototype.set = mapSet;

                    // Add functions to the `Set` cache.
                    SetCache.prototype.push = cachePush;

                    // Assign cache to `_.memoize`.
                    memoize.Cache = MapCache;

                    // Add functions that return wrapped values when chaining.
                    lodash.after = after;
                    lodash.ary = ary;
                    lodash.assign = assign;
                    lodash.at = at;
                    lodash.before = before;
                    lodash.bind = bind;
                    lodash.bindAll = bindAll;
                    lodash.bindKey = bindKey;
                    lodash.callback = callback;
                    lodash.chain = chain;
                    lodash.chunk = chunk;
                    lodash.compact = compact;
                    lodash.constant = constant;
                    lodash.countBy = countBy;
                    lodash.create = create;
                    lodash.curry = curry;
                    lodash.curryRight = curryRight;
                    lodash.debounce = debounce;
                    lodash.defaults = defaults;
                    lodash.defaultsDeep = defaultsDeep;
                    lodash.defer = defer;
                    lodash.delay = delay;
                    lodash.difference = difference;
                    lodash.drop = drop;
                    lodash.dropRight = dropRight;
                    lodash.dropRightWhile = dropRightWhile;
                    lodash.dropWhile = dropWhile;
                    lodash.fill = fill;
                    lodash.filter = filter;
                    lodash.flatten = flatten;
                    lodash.flattenDeep = flattenDeep;
                    lodash.flow = flow;
                    lodash.flowRight = flowRight;
                    lodash.forEach = forEach;
                    lodash.forEachRight = forEachRight;
                    lodash.forIn = forIn;
                    lodash.forInRight = forInRight;
                    lodash.forOwn = forOwn;
                    lodash.forOwnRight = forOwnRight;
                    lodash.functions = functions;
                    lodash.groupBy = groupBy;
                    lodash.indexBy = indexBy;
                    lodash.initial = initial;
                    lodash.intersection = intersection;
                    lodash.invert = invert;
                    lodash.invoke = invoke;
                    lodash.keys = keys;
                    lodash.keysIn = keysIn;
                    lodash.map = map;
                    lodash.mapKeys = mapKeys;
                    lodash.mapValues = mapValues;
                    lodash.matches = matches;
                    lodash.matchesProperty = matchesProperty;
                    lodash.memoize = memoize;
                    lodash.merge = merge;
                    lodash.method = method;
                    lodash.methodOf = methodOf;
                    lodash.mixin = mixin;
                    lodash.modArgs = modArgs;
                    lodash.negate = negate;
                    lodash.omit = omit;
                    lodash.once = once;
                    lodash.pairs = pairs;
                    lodash.partial = partial;
                    lodash.partialRight = partialRight;
                    lodash.partition = partition;
                    lodash.pick = pick;
                    lodash.pluck = pluck;
                    lodash.property = property;
                    lodash.propertyOf = propertyOf;
                    lodash.pull = pull;
                    lodash.pullAt = pullAt;
                    lodash.range = range;
                    lodash.rearg = rearg;
                    lodash.reject = reject;
                    lodash.remove = remove;
                    lodash.rest = rest;
                    lodash.restParam = restParam;
                    lodash.set = set;
                    lodash.shuffle = shuffle;
                    lodash.slice = slice;
                    lodash.sortBy = sortBy;
                    lodash.sortByAll = sortByAll;
                    lodash.sortByOrder = sortByOrder;
                    lodash.spread = spread;
                    lodash.take = take;
                    lodash.takeRight = takeRight;
                    lodash.takeRightWhile = takeRightWhile;
                    lodash.takeWhile = takeWhile;
                    lodash.tap = tap;
                    lodash.throttle = throttle;
                    lodash.thru = thru;
                    lodash.times = times;
                    lodash.toArray = toArray;
                    lodash.toPlainObject = toPlainObject;
                    lodash.transform = transform;
                    lodash.union = union;
                    lodash.uniq = uniq;
                    lodash.unzip = unzip;
                    lodash.unzipWith = unzipWith;
                    lodash.values = values;
                    lodash.valuesIn = valuesIn;
                    lodash.where = where;
                    lodash.without = without;
                    lodash.wrap = wrap;
                    lodash.xor = xor;
                    lodash.zip = zip;
                    lodash.zipObject = zipObject;
                    lodash.zipWith = zipWith;

                    // Add aliases.
                    lodash.backflow = flowRight;
                    lodash.collect = map;
                    lodash.compose = flowRight;
                    lodash.each = forEach;
                    lodash.eachRight = forEachRight;
                    lodash.extend = assign;
                    lodash.iteratee = callback;
                    lodash.methods = functions;
                    lodash.object = zipObject;
                    lodash.select = filter;
                    lodash.tail = rest;
                    lodash.unique = uniq;

                    // Add functions to `lodash.prototype`.
                    mixin(lodash, lodash);

                    /*------------------------------------------------------------------------*/

                    // Add functions that return unwrapped values when chaining.
                    lodash.add = add;
                    lodash.attempt = attempt;
                    lodash.camelCase = camelCase;
                    lodash.capitalize = capitalize;
                    lodash.ceil = ceil;
                    lodash.clone = clone;
                    lodash.cloneDeep = cloneDeep;
                    lodash.deburr = deburr;
                    lodash.endsWith = endsWith;
                    lodash.escape = escape;
                    lodash.escapeRegExp = escapeRegExp;
                    lodash.every = every;
                    lodash.find = find;
                    lodash.findIndex = findIndex;
                    lodash.findKey = findKey;
                    lodash.findLast = findLast;
                    lodash.findLastIndex = findLastIndex;
                    lodash.findLastKey = findLastKey;
                    lodash.findWhere = findWhere;
                    lodash.first = first;
                    lodash.floor = floor;
                    lodash.get = get;
                    lodash.gt = gt;
                    lodash.gte = gte;
                    lodash.has = has;
                    lodash.identity = identity;
                    lodash.includes = includes;
                    lodash.indexOf = indexOf;
                    lodash.inRange = inRange;
                    lodash.isArguments = isArguments;
                    lodash.isArray = isArray;
                    lodash.isBoolean = isBoolean;
                    lodash.isDate = isDate;
                    lodash.isElement = isElement;
                    lodash.isEmpty = isEmpty;
                    lodash.isEqual = isEqual;
                    lodash.isError = isError;
                    lodash.isFinite = isFinite;
                    lodash.isFunction = isFunction;
                    lodash.isMatch = isMatch;
                    lodash.isNaN = isNaN;
                    lodash.isNative = isNative;
                    lodash.isNull = isNull;
                    lodash.isNumber = isNumber;
                    lodash.isObject = isObject;
                    lodash.isPlainObject = isPlainObject;
                    lodash.isRegExp = isRegExp;
                    lodash.isString = isString;
                    lodash.isTypedArray = isTypedArray;
                    lodash.isUndefined = isUndefined;
                    lodash.kebabCase = kebabCase;
                    lodash.last = last;
                    lodash.lastIndexOf = lastIndexOf;
                    lodash.lt = lt;
                    lodash.lte = lte;
                    lodash.max = max;
                    lodash.min = min;
                    lodash.noConflict = noConflict;
                    lodash.noop = noop;
                    lodash.now = now;
                    lodash.pad = pad;
                    lodash.padLeft = padLeft;
                    lodash.padRight = padRight;
                    lodash.parseInt = parseInt;
                    lodash.random = random;
                    lodash.reduce = reduce;
                    lodash.reduceRight = reduceRight;
                    lodash.repeat = repeat;
                    lodash.result = result;
                    lodash.round = round;
                    lodash.runInContext = runInContext;
                    lodash.size = size;
                    lodash.snakeCase = snakeCase;
                    lodash.some = some;
                    lodash.sortedIndex = sortedIndex;
                    lodash.sortedLastIndex = sortedLastIndex;
                    lodash.startCase = startCase;
                    lodash.startsWith = startsWith;
                    lodash.sum = sum;
                    lodash.template = template;
                    lodash.trim = trim;
                    lodash.trimLeft = trimLeft;
                    lodash.trimRight = trimRight;
                    lodash.trunc = trunc;
                    lodash.unescape = unescape;
                    lodash.uniqueId = uniqueId;
                    lodash.words = words;

                    // Add aliases.
                    lodash.all = every;
                    lodash.any = some;
                    lodash.contains = includes;
                    lodash.eq = isEqual;
                    lodash.detect = find;
                    lodash.foldl = reduce;
                    lodash.foldr = reduceRight;
                    lodash.head = first;
                    lodash.include = includes;
                    lodash.inject = reduce;

                    mixin(lodash, (function () {
                        var source = {};
                        baseForOwn(lodash, function (func, methodName) {
                            if (!lodash.prototype[methodName]) {
                                source[methodName] = func;
                            }
                        });
                        return source;
                    }()), false);

                    /*------------------------------------------------------------------------*/

                    // Add functions capable of returning wrapped and unwrapped values when chaining.
                    lodash.sample = sample;

                    lodash.prototype.sample = function (n) {
                        if (!this.__chain__ && n == null) {
                            return sample(this.value());
                        }
                        return this.thru(function (value) {
                            return sample(value, n);
                        });
                    };

                    /*------------------------------------------------------------------------*/

                    /**
                     * The semantic version number.
                     *
                     * @static
                     * @memberOf _
                     * @type string
                     */
                    lodash.VERSION = VERSION;

                    // Assign default placeholders.
                    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function (methodName) {
                        lodash[methodName].placeholder = lodash;
                    });

                    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
                    arrayEach(['drop', 'take'], function (methodName, index) {
                        LazyWrapper.prototype[methodName] = function (n) {
                            var filtered = this.__filtered__;
                            if (filtered && !index) {
                                return new LazyWrapper(this);
                            }
                            n = n == null ? 1 : nativeMax(nativeFloor(n) || 0, 0);

                            var result = this.clone();
                            if (filtered) {
                                result.__takeCount__ = nativeMin(result.__takeCount__, n);
                            } else {
                                result.__views__.push({ 'size': n, 'type': methodName + (result.__dir__ < 0 ? 'Right' : '') });
                            }
                            return result;
                        };

                        LazyWrapper.prototype[methodName + 'Right'] = function (n) {
                            return this.reverse()[methodName](n).reverse();
                        };
                    });

                    // Add `LazyWrapper` methods that accept an `iteratee` value.
                    arrayEach(['filter', 'map', 'takeWhile'], function (methodName, index) {
                        var type = index + 1,
                            isFilter = type != LAZY_MAP_FLAG;

                        LazyWrapper.prototype[methodName] = function (iteratee, thisArg) {
                            var result = this.clone();
                            result.__iteratees__.push({ 'iteratee': getCallback(iteratee, thisArg, 1), 'type': type });
                            result.__filtered__ = result.__filtered__ || isFilter;
                            return result;
                        };
                    });

                    // Add `LazyWrapper` methods for `_.first` and `_.last`.
                    arrayEach(['first', 'last'], function (methodName, index) {
                        var takeName = 'take' + (index ? 'Right' : '');

                        LazyWrapper.prototype[methodName] = function () {
                            return this[takeName](1).value()[0];
                        };
                    });

                    // Add `LazyWrapper` methods for `_.initial` and `_.rest`.
                    arrayEach(['initial', 'rest'], function (methodName, index) {
                        var dropName = 'drop' + (index ? '' : 'Right');

                        LazyWrapper.prototype[methodName] = function () {
                            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
                        };
                    });

                    // Add `LazyWrapper` methods for `_.pluck` and `_.where`.
                    arrayEach(['pluck', 'where'], function (methodName, index) {
                        var operationName = index ? 'filter' : 'map',
                            createCallback = index ? baseMatches : property;

                        LazyWrapper.prototype[methodName] = function (value) {
                            return this[operationName](createCallback(value));
                        };
                    });

                    LazyWrapper.prototype.compact = function () {
                        return this.filter(identity);
                    };

                    LazyWrapper.prototype.reject = function (predicate, thisArg) {
                        predicate = getCallback(predicate, thisArg, 1);
                        return this.filter(function (value) {
                            return !predicate(value);
                        });
                    };

                    LazyWrapper.prototype.slice = function (start, end) {
                        start = start == null ? 0 : (+start || 0);

                        var result = this;
                        if (result.__filtered__ && (start > 0 || end < 0)) {
                            return new LazyWrapper(result);
                        }
                        if (start < 0) {
                            result = result.takeRight(-start);
                        } else if (start) {
                            result = result.drop(start);
                        }
                        if (end !== undefined) {
                            end = (+end || 0);
                            result = end < 0 ? result.dropRight(-end) : result.take(end - start);
                        }
                        return result;
                    };

                    LazyWrapper.prototype.takeRightWhile = function (predicate, thisArg) {
                        return this.reverse().takeWhile(predicate, thisArg).reverse();
                    };

                    LazyWrapper.prototype.toArray = function () {
                        return this.take(POSITIVE_INFINITY);
                    };

                    // Add `LazyWrapper` methods to `lodash.prototype`.
                    baseForOwn(LazyWrapper.prototype, function (func, methodName) {
                        var checkIteratee = /^(?:filter|map|reject)|While$/.test(methodName),
                            retUnwrapped = /^(?:first|last)$/.test(methodName),
                            lodashFunc = lodash[retUnwrapped ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName];

                        if (!lodashFunc) {
                            return;
                        }
                        lodash.prototype[methodName] = function () {
                            var args = retUnwrapped ? [1] : arguments,
                                chainAll = this.__chain__,
                                value = this.__wrapped__,
                                isHybrid = !!this.__actions__.length,
                                isLazy = value instanceof LazyWrapper,
                                iteratee = args[0],
                                useLazy = isLazy || isArray(value);

                            if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
                                // Avoid lazy use if the iteratee has a "length" value other than `1`.
                                isLazy = useLazy = false;
                            }
                            var interceptor = function (value) {
                                return (retUnwrapped && chainAll)
                                    ? lodashFunc(value, 1)[0]
                                    : lodashFunc.apply(undefined, arrayPush([value], args));
                            };

                            var action = { 'func': thru, 'args': [interceptor], 'thisArg': undefined },
                                onlyLazy = isLazy && !isHybrid;

                            if (retUnwrapped && !chainAll) {
                                if (onlyLazy) {
                                    value = value.clone();
                                    value.__actions__.push(action);
                                    return func.call(value);
                                }
                                return lodashFunc.call(undefined, this.value())[0];
                            }
                            if (!retUnwrapped && useLazy) {
                                value = onlyLazy ? value : new LazyWrapper(this);
                                var result = func.apply(value, args);
                                result.__actions__.push(action);
                                return new LodashWrapper(result, chainAll);
                            }
                            return this.thru(interceptor);
                        };
                    });

                    // Add `Array` and `String` methods to `lodash.prototype`.
                    arrayEach(['join', 'pop', 'push', 'replace', 'shift', 'sort', 'splice', 'split', 'unshift'], function (methodName) {
                        var func = (/^(?:replace|split)$/.test(methodName) ? stringProto : arrayProto)[methodName],
                            chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
                            retUnwrapped = /^(?:join|pop|replace|shift)$/.test(methodName);

                        lodash.prototype[methodName] = function () {
                            var args = arguments;
                            if (retUnwrapped && !this.__chain__) {
                                return func.apply(this.value(), args);
                            }
                            return this[chainName](function (value) {
                                return func.apply(value, args);
                            });
                        };
                    });

                    // Map minified function names to their real names.
                    baseForOwn(LazyWrapper.prototype, function (func, methodName) {
                        var lodashFunc = lodash[methodName];
                        if (lodashFunc) {
                            var key = lodashFunc.name,
                                names = realNames[key] || (realNames[key] = []);

                            names.push({ 'name': methodName, 'func': lodashFunc });
                        }
                    });

                    realNames[createHybridWrapper(undefined, BIND_KEY_FLAG).name] = [{ 'name': 'wrapper', 'func': undefined }];

                    // Add functions to the lazy wrapper.
                    LazyWrapper.prototype.clone = lazyClone;
                    LazyWrapper.prototype.reverse = lazyReverse;
                    LazyWrapper.prototype.value = lazyValue;

                    // Add chaining functions to the `lodash` wrapper.
                    lodash.prototype.chain = wrapperChain;
                    lodash.prototype.commit = wrapperCommit;
                    lodash.prototype.concat = wrapperConcat;
                    lodash.prototype.plant = wrapperPlant;
                    lodash.prototype.reverse = wrapperReverse;
                    lodash.prototype.toString = wrapperToString;
                    lodash.prototype.run = lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

                    // Add function aliases to the `lodash` wrapper.
                    lodash.prototype.collect = lodash.prototype.map;
                    lodash.prototype.head = lodash.prototype.first;
                    lodash.prototype.select = lodash.prototype.filter;
                    lodash.prototype.tail = lodash.prototype.rest;

                    return lodash;
                }

                /*--------------------------------------------------------------------------*/

                // Export lodash.
                var _ = runInContext();

                // Some AMD build optimizers like r.js check for condition patterns like the following:
                if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
                    // Expose lodash to the global object when an AMD loader is present to avoid
                    // errors in cases where lodash is loaded by a script tag and not intended
                    // as an AMD module. See http://requirejs.org/docs/errors.html#mismatch for
                    // more details.
                    root._ = _;

                    // Define as an anonymous module so, through path mapping, it can be
                    // referenced as the "underscore" module.
                    define(function () {
                        return _;
                    });
                }
                // Check for `exports` after `define` in case a build optimizer adds an `exports` object.
                else if (freeExports && freeModule) {
                    // Export for Node.js or RingoJS.
                    if (moduleExports) {
                        (freeModule.exports = _)._ = _;
                    }
                    // Export for Rhino with CommonJS support.
                    else {
                        freeExports._ = _;
                    }
                }
                else {
                    // Export for a browser or Rhino.
                    root._ = _;
                }
            }.call(this));

        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    }, {}], 318: [function (require, module, exports) {
        var baseCreate = require('./baseCreate'),
            baseLodash = require('./baseLodash');

        /** Used as references for `-Infinity` and `Infinity`. */
        var POSITIVE_INFINITY = Number.POSITIVE_INFINITY;

        /**
         * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
         *
         * @private
         * @param {*} value The value to wrap.
         */
        function LazyWrapper(value) {
            this.__wrapped__ = value;
            this.__actions__ = [];
            this.__dir__ = 1;
            this.__filtered__ = false;
            this.__iteratees__ = [];
            this.__takeCount__ = POSITIVE_INFINITY;
            this.__views__ = [];
        }

        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;

        module.exports = LazyWrapper;

    }, { "./baseCreate": 335, "./baseLodash": 352 }], 319: [function (require, module, exports) {
        var baseCreate = require('./baseCreate'),
            baseLodash = require('./baseLodash');

        /**
         * The base constructor for creating `lodash` wrapper objects.
         *
         * @private
         * @param {*} value The value to wrap.
         * @param {boolean} [chainAll] Enable chaining for all wrapper methods.
         * @param {Array} [actions=[]] Actions to peform to resolve the unwrapped value.
         */
        function LodashWrapper(value, chainAll, actions) {
            this.__wrapped__ = value;
            this.__actions__ = actions || [];
            this.__chain__ = !!chainAll;
        }

        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;

        module.exports = LodashWrapper;

    }, { "./baseCreate": 335, "./baseLodash": 352 }], 320: [function (require, module, exports) {
        (function (global) {
            var cachePush = require('./cachePush'),
                getNative = require('./getNative');

            /** Native method references. */
            var Set = getNative(global, 'Set');

            /* Native method references for those with the same name as other `lodash` methods. */
            var nativeCreate = getNative(Object, 'create');

            /**
             *
             * Creates a cache object to store unique values.
             *
             * @private
             * @param {Array} [values] The values to cache.
             */
            function SetCache(values) {
                var length = values ? values.length : 0;

                this.data = { 'hash': nativeCreate(null), 'set': new Set };
                while (length--) {
                    this.push(values[length]);
                }
            }

            // Add functions to the `Set` cache.
            SetCache.prototype.push = cachePush;

            module.exports = SetCache;

        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    }, { "./cachePush": 371, "./getNative": 396 }], 321: [function (require, module, exports) {
        /**
         * Copies the values of `source` to `array`.
         *
         * @private
         * @param {Array} source The array to copy values from.
         * @param {Array} [array=[]] The array to copy values to.
         * @returns {Array} Returns `array`.
         */
        function arrayCopy(source, array) {
            var index = -1,
                length = source.length;

            array || (array = Array(length));
            while (++index < length) {
                array[index] = source[index];
            }
            return array;
        }

        module.exports = arrayCopy;

    }, {}], 322: [function (require, module, exports) {
        /**
         * A specialized version of `_.forEach` for arrays without support for callback
         * shorthands and `this` binding.
         *
         * @private
         * @param {Array} array The array to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array} Returns `array`.
         */
        function arrayEach(array, iteratee) {
            var index = -1,
                length = array.length;

            while (++index < length) {
                if (iteratee(array[index], index, array) === false) {
                    break;
                }
            }
            return array;
        }

        module.exports = arrayEach;

    }, {}], 323: [function (require, module, exports) {
        /**
         * A specialized version of `_.every` for arrays without support for callback
         * shorthands and `this` binding.
         *
         * @private
         * @param {Array} array The array to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {boolean} Returns `true` if all elements pass the predicate check,
         *  else `false`.
         */
        function arrayEvery(array, predicate) {
            var index = -1,
                length = array.length;

            while (++index < length) {
                if (!predicate(array[index], index, array)) {
                    return false;
                }
            }
            return true;
        }

        module.exports = arrayEvery;

    }, {}], 324: [function (require, module, exports) {
        /**
         * A specialized version of `_.filter` for arrays without support for callback
         * shorthands and `this` binding.
         *
         * @private
         * @param {Array} array The array to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {Array} Returns the new filtered array.
         */
        function arrayFilter(array, predicate) {
            var index = -1,
                length = array.length,
                resIndex = -1,
                result = [];

            while (++index < length) {
                var value = array[index];
                if (predicate(value, index, array)) {
                    result[++resIndex] = value;
                }
            }
            return result;
        }

        module.exports = arrayFilter;

    }, {}], 325: [function (require, module, exports) {
        /**
         * A specialized version of `_.map` for arrays without support for callback
         * shorthands and `this` binding.
         *
         * @private
         * @param {Array} array The array to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array} Returns the new mapped array.
         */
        function arrayMap(array, iteratee) {
            var index = -1,
                length = array.length,
                result = Array(length);

            while (++index < length) {
                result[index] = iteratee(array[index], index, array);
            }
            return result;
        }

        module.exports = arrayMap;

    }, {}], 326: [function (require, module, exports) {
        /**
         * Appends the elements of `values` to `array`.
         *
         * @private
         * @param {Array} array The array to modify.
         * @param {Array} values The values to append.
         * @returns {Array} Returns `array`.
         */
        function arrayPush(array, values) {
            var index = -1,
                length = values.length,
                offset = array.length;

            while (++index < length) {
                array[offset + index] = values[index];
            }
            return array;
        }

        module.exports = arrayPush;

    }, {}], 327: [function (require, module, exports) {
        /**
         * A specialized version of `_.reduce` for arrays without support for callback
         * shorthands and `this` binding.
         *
         * @private
         * @param {Array} array The array to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @param {*} [accumulator] The initial value.
         * @param {boolean} [initFromArray] Specify using the first element of `array`
         *  as the initial value.
         * @returns {*} Returns the accumulated value.
         */
        function arrayReduce(array, iteratee, accumulator, initFromArray) {
            var index = -1,
                length = array.length;

            if (initFromArray && length) {
                accumulator = array[++index];
            }
            while (++index < length) {
                accumulator = iteratee(accumulator, array[index], index, array);
            }
            return accumulator;
        }

        module.exports = arrayReduce;

    }, {}], 328: [function (require, module, exports) {
        /**
         * A specialized version of `_.some` for arrays without support for callback
         * shorthands and `this` binding.
         *
         * @private
         * @param {Array} array The array to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {boolean} Returns `true` if any element passes the predicate check,
         *  else `false`.
         */
        function arraySome(array, predicate) {
            var index = -1,
                length = array.length;

            while (++index < length) {
                if (predicate(array[index], index, array)) {
                    return true;
                }
            }
            return false;
        }

        module.exports = arraySome;

    }, {}], 329: [function (require, module, exports) {
        var keys = require('../object/keys');

        /**
         * A specialized version of `_.assign` for customizing assigned values without
         * support for argument juggling, multiple sources, and `this` binding `customizer`
         * functions.
         *
         * @private
         * @param {Object} object The destination object.
         * @param {Object} source The source object.
         * @param {Function} customizer The function to customize assigned values.
         * @returns {Object} Returns `object`.
         */
        function assignWith(object, source, customizer) {
            var index = -1,
                props = keys(source),
                length = props.length;

            while (++index < length) {
                var key = props[index],
                    value = object[key],
                    result = customizer(value, source[key], key, object, source);

                if ((result === result ? (result !== value) : (value === value)) ||
                    (value === undefined && !(key in object))) {
                    object[key] = result;
                }
            }
            return object;
        }

        module.exports = assignWith;

    }, { "../object/keys": 435 }], 330: [function (require, module, exports) {
        var baseCopy = require('./baseCopy'),
            keys = require('../object/keys');

        /**
         * The base implementation of `_.assign` without support for argument juggling,
         * multiple sources, and `customizer` functions.
         *
         * @private
         * @param {Object} object The destination object.
         * @param {Object} source The source object.
         * @returns {Object} Returns `object`.
         */
        function baseAssign(object, source) {
            return source == null
                ? object
                : baseCopy(source, keys(source), object);
        }

        module.exports = baseAssign;

    }, { "../object/keys": 435, "./baseCopy": 334 }], 331: [function (require, module, exports) {
        var baseMatches = require('./baseMatches'),
            baseMatchesProperty = require('./baseMatchesProperty'),
            bindCallback = require('./bindCallback'),
            identity = require('../utility/identity'),
            property = require('../utility/property');

        /**
         * The base implementation of `_.callback` which supports specifying the
         * number of arguments to provide to `func`.
         *
         * @private
         * @param {*} [func=_.identity] The value to convert to a callback.
         * @param {*} [thisArg] The `this` binding of `func`.
         * @param {number} [argCount] The number of arguments to provide to `func`.
         * @returns {Function} Returns the callback.
         */
        function baseCallback(func, thisArg, argCount) {
            var type = typeof func;
            if (type == 'function') {
                return thisArg === undefined
                    ? func
                    : bindCallback(func, thisArg, argCount);
            }
            if (func == null) {
                return identity;
            }
            if (type == 'object') {
                return baseMatches(func);
            }
            return thisArg === undefined
                ? property(func)
                : baseMatchesProperty(func, thisArg);
        }

        module.exports = baseCallback;

    }, { "../utility/identity": 443, "../utility/property": 445, "./baseMatches": 354, "./baseMatchesProperty": 355, "./bindCallback": 368 }], 332: [function (require, module, exports) {
        var arrayCopy = require('./arrayCopy'),
            arrayEach = require('./arrayEach'),
            baseAssign = require('./baseAssign'),
            baseForOwn = require('./baseForOwn'),
            initCloneArray = require('./initCloneArray'),
            initCloneByTag = require('./initCloneByTag'),
            initCloneObject = require('./initCloneObject'),
            isArray = require('../lang/isArray'),
            isObject = require('../lang/isObject');

        /** `Object#toString` result references. */
        var argsTag = '[object Arguments]',
            arrayTag = '[object Array]',
            boolTag = '[object Boolean]',
            dateTag = '[object Date]',
            errorTag = '[object Error]',
            funcTag = '[object Function]',
            mapTag = '[object Map]',
            numberTag = '[object Number]',
            objectTag = '[object Object]',
            regexpTag = '[object RegExp]',
            setTag = '[object Set]',
            stringTag = '[object String]',
            weakMapTag = '[object WeakMap]';

        var arrayBufferTag = '[object ArrayBuffer]',
            float32Tag = '[object Float32Array]',
            float64Tag = '[object Float64Array]',
            int8Tag = '[object Int8Array]',
            int16Tag = '[object Int16Array]',
            int32Tag = '[object Int32Array]',
            uint8Tag = '[object Uint8Array]',
            uint8ClampedTag = '[object Uint8ClampedArray]',
            uint16Tag = '[object Uint16Array]',
            uint32Tag = '[object Uint32Array]';

        /** Used to identify `toStringTag` values supported by `_.clone`. */
        var cloneableTags = {};
        cloneableTags[argsTag] = cloneableTags[arrayTag] =
            cloneableTags[arrayBufferTag] = cloneableTags[boolTag] =
            cloneableTags[dateTag] = cloneableTags[float32Tag] =
            cloneableTags[float64Tag] = cloneableTags[int8Tag] =
            cloneableTags[int16Tag] = cloneableTags[int32Tag] =
            cloneableTags[numberTag] = cloneableTags[objectTag] =
            cloneableTags[regexpTag] = cloneableTags[stringTag] =
            cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
            cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
        cloneableTags[errorTag] = cloneableTags[funcTag] =
            cloneableTags[mapTag] = cloneableTags[setTag] =
            cloneableTags[weakMapTag] = false;

        /** Used for native method references. */
        var objectProto = Object.prototype;

        /**
         * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
         * of values.
         */
        var objToString = objectProto.toString;

        /**
         * The base implementation of `_.clone` without support for argument juggling
         * and `this` binding `customizer` functions.
         *
         * @private
         * @param {*} value The value to clone.
         * @param {boolean} [isDeep] Specify a deep clone.
         * @param {Function} [customizer] The function to customize cloning values.
         * @param {string} [key] The key of `value`.
         * @param {Object} [object] The object `value` belongs to.
         * @param {Array} [stackA=[]] Tracks traversed source objects.
         * @param {Array} [stackB=[]] Associates clones with source counterparts.
         * @returns {*} Returns the cloned value.
         */
        function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {
            var result;
            if (customizer) {
                result = object ? customizer(value, key, object) : customizer(value);
            }
            if (result !== undefined) {
                return result;
            }
            if (!isObject(value)) {
                return value;
            }
            var isArr = isArray(value);
            if (isArr) {
                result = initCloneArray(value);
                if (!isDeep) {
                    return arrayCopy(value, result);
                }
            } else {
                var tag = objToString.call(value),
                    isFunc = tag == funcTag;

                if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
                    result = initCloneObject(isFunc ? {} : value);
                    if (!isDeep) {
                        return baseAssign(result, value);
                    }
                } else {
                    return cloneableTags[tag]
                        ? initCloneByTag(value, tag, isDeep)
                        : (object ? value : {});
                }
            }
            // Check for circular references and return its corresponding clone.
            stackA || (stackA = []);
            stackB || (stackB = []);

            var length = stackA.length;
            while (length--) {
                if (stackA[length] == value) {
                    return stackB[length];
                }
            }
            // Add the source value to the stack of traversed objects and associate it with its clone.
            stackA.push(value);
            stackB.push(result);

            // Recursively populate clone (susceptible to call stack limits).
            (isArr ? arrayEach : baseForOwn)(value, function (subValue, key) {
                result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);
            });
            return result;
        }

        module.exports = baseClone;

    }, { "../lang/isArray": 424, "../lang/isObject": 428, "./arrayCopy": 321, "./arrayEach": 322, "./baseAssign": 330, "./baseForOwn": 346, "./initCloneArray": 398, "./initCloneByTag": 399, "./initCloneObject": 400 }], 333: [function (require, module, exports) {
        /**
         * The base implementation of `compareAscending` which compares values and
         * sorts them in ascending order without guaranteeing a stable sort.
         *
         * @private
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {number} Returns the sort order indicator for `value`.
         */
        function baseCompareAscending(value, other) {
            if (value !== other) {
                var valIsNull = value === null,
                    valIsUndef = value === undefined,
                    valIsReflexive = value === value;

                var othIsNull = other === null,
                    othIsUndef = other === undefined,
                    othIsReflexive = other === other;

                if ((value > other && !othIsNull) || !valIsReflexive ||
                    (valIsNull && !othIsUndef && othIsReflexive) ||
                    (valIsUndef && othIsReflexive)) {
                    return 1;
                }
                if ((value < other && !valIsNull) || !othIsReflexive ||
                    (othIsNull && !valIsUndef && valIsReflexive) ||
                    (othIsUndef && valIsReflexive)) {
                    return -1;
                }
            }
            return 0;
        }

        module.exports = baseCompareAscending;

    }, {}], 334: [function (require, module, exports) {
        /**
         * Copies properties of `source` to `object`.
         *
         * @private
         * @param {Object} source The object to copy properties from.
         * @param {Array} props The property names to copy.
         * @param {Object} [object={}] The object to copy properties to.
         * @returns {Object} Returns `object`.
         */
        function baseCopy(source, props, object) {
            object || (object = {});

            var index = -1,
                length = props.length;

            while (++index < length) {
                var key = props[index];
                object[key] = source[key];
            }
            return object;
        }

        module.exports = baseCopy;

    }, {}], 335: [function (require, module, exports) {
        var isObject = require('../lang/isObject');

        /**
         * The base implementation of `_.create` without support for assigning
         * properties to the created object.
         *
         * @private
         * @param {Object} prototype The object to inherit from.
         * @returns {Object} Returns the new object.
         */
        var baseCreate = (function () {
            function object() { }
            return function (prototype) {
                if (isObject(prototype)) {
                    object.prototype = prototype;
                    var result = new object;
                    object.prototype = undefined;
                }
                return result || {};
            };
        }());

        module.exports = baseCreate;

    }, { "../lang/isObject": 428 }], 336: [function (require, module, exports) {
        /** Used as the `TypeError` message for "Functions" methods. */
        var FUNC_ERROR_TEXT = 'Expected a function';

        /**
         * The base implementation of `_.delay` and `_.defer` which accepts an index
         * of where to slice the arguments to provide to `func`.
         *
         * @private
         * @param {Function} func The function to delay.
         * @param {number} wait The number of milliseconds to delay invocation.
         * @param {Object} args The arguments provide to `func`.
         * @returns {number} Returns the timer id.
         */
        function baseDelay(func, wait, args) {
            if (typeof func != 'function') {
                throw new TypeError(FUNC_ERROR_TEXT);
            }
            return setTimeout(function () { func.apply(undefined, args); }, wait);
        }

        module.exports = baseDelay;

    }, {}], 337: [function (require, module, exports) {
        var baseIndexOf = require('./baseIndexOf'),
            cacheIndexOf = require('./cacheIndexOf'),
            createCache = require('./createCache');

        /** Used as the size to enable large array optimizations. */
        var LARGE_ARRAY_SIZE = 200;

        /**
         * The base implementation of `_.difference` which accepts a single array
         * of values to exclude.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {Array} values The values to exclude.
         * @returns {Array} Returns the new array of filtered values.
         */
        function baseDifference(array, values) {
            var length = array ? array.length : 0,
                result = [];

            if (!length) {
                return result;
            }
            var index = -1,
                indexOf = baseIndexOf,
                isCommon = true,
                cache = (isCommon && values.length >= LARGE_ARRAY_SIZE) ? createCache(values) : null,
                valuesLength = values.length;

            if (cache) {
                indexOf = cacheIndexOf;
                isCommon = false;
                values = cache;
            }
            outer:
            while (++index < length) {
                var value = array[index];

                if (isCommon && value === value) {
                    var valuesIndex = valuesLength;
                    while (valuesIndex--) {
                        if (values[valuesIndex] === value) {
                            continue outer;
                        }
                    }
                    result.push(value);
                }
                else if (indexOf(values, value, 0) < 0) {
                    result.push(value);
                }
            }
            return result;
        }

        module.exports = baseDifference;

    }, { "./baseIndexOf": 348, "./cacheIndexOf": 370, "./createCache": 380 }], 338: [function (require, module, exports) {
        var baseForOwn = require('./baseForOwn'),
            createBaseEach = require('./createBaseEach');

        /**
         * The base implementation of `_.forEach` without support for callback
         * shorthands and `this` binding.
         *
         * @private
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array|Object|string} Returns `collection`.
         */
        var baseEach = createBaseEach(baseForOwn);

        module.exports = baseEach;

    }, { "./baseForOwn": 346, "./createBaseEach": 377 }], 339: [function (require, module, exports) {
        var baseEach = require('./baseEach');

        /**
         * The base implementation of `_.every` without support for callback
         * shorthands and `this` binding.
         *
         * @private
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {boolean} Returns `true` if all elements pass the predicate check,
         *  else `false`
         */
        function baseEvery(collection, predicate) {
            var result = true;
            baseEach(collection, function (value, index, collection) {
                result = !!predicate(value, index, collection);
                return result;
            });
            return result;
        }

        module.exports = baseEvery;

    }, { "./baseEach": 338 }], 340: [function (require, module, exports) {
        var baseEach = require('./baseEach');

        /**
         * The base implementation of `_.filter` without support for callback
         * shorthands and `this` binding.
         *
         * @private
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {Array} Returns the new filtered array.
         */
        function baseFilter(collection, predicate) {
            var result = [];
            baseEach(collection, function (value, index, collection) {
                if (predicate(value, index, collection)) {
                    result.push(value);
                }
            });
            return result;
        }

        module.exports = baseFilter;

    }, { "./baseEach": 338 }], 341: [function (require, module, exports) {
        /**
         * The base implementation of `_.find`, `_.findLast`, `_.findKey`, and `_.findLastKey`,
         * without support for callback shorthands and `this` binding, which iterates
         * over `collection` using the provided `eachFunc`.
         *
         * @private
         * @param {Array|Object|string} collection The collection to search.
         * @param {Function} predicate The function invoked per iteration.
         * @param {Function} eachFunc The function to iterate over `collection`.
         * @param {boolean} [retKey] Specify returning the key of the found element
         *  instead of the element itself.
         * @returns {*} Returns the found element or its key, else `undefined`.
         */
        function baseFind(collection, predicate, eachFunc, retKey) {
            var result;
            eachFunc(collection, function (value, key, collection) {
                if (predicate(value, key, collection)) {
                    result = retKey ? key : value;
                    return false;
                }
            });
            return result;
        }

        module.exports = baseFind;

    }, {}], 342: [function (require, module, exports) {
        /**
         * The base implementation of `_.findIndex` and `_.findLastIndex` without
         * support for callback shorthands and `this` binding.
         *
         * @private
         * @param {Array} array The array to search.
         * @param {Function} predicate The function invoked per iteration.
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {number} Returns the index of the matched value, else `-1`.
         */
        function baseFindIndex(array, predicate, fromRight) {
            var length = array.length,
                index = fromRight ? length : -1;

            while ((fromRight ? index-- : ++index < length)) {
                if (predicate(array[index], index, array)) {
                    return index;
                }
            }
            return -1;
        }

        module.exports = baseFindIndex;

    }, {}], 343: [function (require, module, exports) {
        var arrayPush = require('./arrayPush'),
            isArguments = require('../lang/isArguments'),
            isArray = require('../lang/isArray'),
            isArrayLike = require('./isArrayLike'),
            isObjectLike = require('./isObjectLike');

        /**
         * The base implementation of `_.flatten` with added support for restricting
         * flattening and specifying the start index.
         *
         * @private
         * @param {Array} array The array to flatten.
         * @param {boolean} [isDeep] Specify a deep flatten.
         * @param {boolean} [isStrict] Restrict flattening to arrays-like objects.
         * @param {Array} [result=[]] The initial result value.
         * @returns {Array} Returns the new flattened array.
         */
        function baseFlatten(array, isDeep, isStrict, result) {
            result || (result = []);

            var index = -1,
                length = array.length;

            while (++index < length) {
                var value = array[index];
                if (isObjectLike(value) && isArrayLike(value) &&
                    (isStrict || isArray(value) || isArguments(value))) {
                    if (isDeep) {
                        // Recursively flatten arrays (susceptible to call stack limits).
                        baseFlatten(value, isDeep, isStrict, result);
                    } else {
                        arrayPush(result, value);
                    }
                } else if (!isStrict) {
                    result[result.length] = value;
                }
            }
            return result;
        }

        module.exports = baseFlatten;

    }, { "../lang/isArguments": 423, "../lang/isArray": 424, "./arrayPush": 326, "./isArrayLike": 401, "./isObjectLike": 407 }], 344: [function (require, module, exports) {
        var createBaseFor = require('./createBaseFor');

        /**
         * The base implementation of `baseForIn` and `baseForOwn` which iterates
         * over `object` properties returned by `keysFunc` invoking `iteratee` for
         * each property. Iteratee functions may exit iteration early by explicitly
         * returning `false`.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @param {Function} keysFunc The function to get the keys of `object`.
         * @returns {Object} Returns `object`.
         */
        var baseFor = createBaseFor();

        module.exports = baseFor;

    }, { "./createBaseFor": 378 }], 345: [function (require, module, exports) {
        var baseFor = require('./baseFor'),
            keysIn = require('../object/keysIn');

        /**
         * The base implementation of `_.forIn` without support for callback
         * shorthands and `this` binding.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Object} Returns `object`.
         */
        function baseForIn(object, iteratee) {
            return baseFor(object, iteratee, keysIn);
        }

        module.exports = baseForIn;

    }, { "../object/keysIn": 436, "./baseFor": 344 }], 346: [function (require, module, exports) {
        var baseFor = require('./baseFor'),
            keys = require('../object/keys');

        /**
         * The base implementation of `_.forOwn` without support for callback
         * shorthands and `this` binding.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Object} Returns `object`.
         */
        function baseForOwn(object, iteratee) {
            return baseFor(object, iteratee, keys);
        }

        module.exports = baseForOwn;

    }, { "../object/keys": 435, "./baseFor": 344 }], 347: [function (require, module, exports) {
        var toObject = require('./toObject');

        /**
         * The base implementation of `get` without support for string paths
         * and default values.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array} path The path of the property to get.
         * @param {string} [pathKey] The key representation of path.
         * @returns {*} Returns the resolved value.
         */
        function baseGet(object, path, pathKey) {
            if (object == null) {
                return;
            }
            if (pathKey !== undefined && pathKey in toObject(object)) {
                path = [pathKey];
            }
            var index = 0,
                length = path.length;

            while (object != null && index < length) {
                object = object[path[index++]];
            }
            return (index && index == length) ? object : undefined;
        }

        module.exports = baseGet;

    }, { "./toObject": 419 }], 348: [function (require, module, exports) {
        var indexOfNaN = require('./indexOfNaN');

        /**
         * The base implementation of `_.indexOf` without support for binary searches.
         *
         * @private
         * @param {Array} array The array to search.
         * @param {*} value The value to search for.
         * @param {number} fromIndex The index to search from.
         * @returns {number} Returns the index of the matched value, else `-1`.
         */
        function baseIndexOf(array, value, fromIndex) {
            if (value !== value) {
                return indexOfNaN(array, fromIndex);
            }
            var index = fromIndex - 1,
                length = array.length;

            while (++index < length) {
                if (array[index] === value) {
                    return index;
                }
            }
            return -1;
        }

        module.exports = baseIndexOf;

    }, { "./indexOfNaN": 397 }], 349: [function (require, module, exports) {
        var baseIsEqualDeep = require('./baseIsEqualDeep'),
            isObject = require('../lang/isObject'),
            isObjectLike = require('./isObjectLike');

        /**
         * The base implementation of `_.isEqual` without support for `this` binding
         * `customizer` functions.
         *
         * @private
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @param {Function} [customizer] The function to customize comparing values.
         * @param {boolean} [isLoose] Specify performing partial comparisons.
         * @param {Array} [stackA] Tracks traversed `value` objects.
         * @param {Array} [stackB] Tracks traversed `other` objects.
         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
         */
        function baseIsEqual(value, other, customizer, isLoose, stackA, stackB) {
            if (value === other) {
                return true;
            }
            if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
                return value !== value && other !== other;
            }
            return baseIsEqualDeep(value, other, baseIsEqual, customizer, isLoose, stackA, stackB);
        }

        module.exports = baseIsEqual;

    }, { "../lang/isObject": 428, "./baseIsEqualDeep": 350, "./isObjectLike": 407 }], 350: [function (require, module, exports) {
        var equalArrays = require('./equalArrays'),
            equalByTag = require('./equalByTag'),
            equalObjects = require('./equalObjects'),
            isArray = require('../lang/isArray'),
            isTypedArray = require('../lang/isTypedArray');

        /** `Object#toString` result references. */
        var argsTag = '[object Arguments]',
            arrayTag = '[object Array]',
            objectTag = '[object Object]';

        /** Used for native method references. */
        var objectProto = Object.prototype;

        /** Used to check objects for own properties. */
        var hasOwnProperty = objectProto.hasOwnProperty;

        /**
         * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
         * of values.
         */
        var objToString = objectProto.toString;

        /**
         * A specialized version of `baseIsEqual` for arrays and objects which performs
         * deep comparisons and tracks traversed objects enabling objects with circular
         * references to be compared.
         *
         * @private
         * @param {Object} object The object to compare.
         * @param {Object} other The other object to compare.
         * @param {Function} equalFunc The function to determine equivalents of values.
         * @param {Function} [customizer] The function to customize comparing objects.
         * @param {boolean} [isLoose] Specify performing partial comparisons.
         * @param {Array} [stackA=[]] Tracks traversed `value` objects.
         * @param {Array} [stackB=[]] Tracks traversed `other` objects.
         * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
         */
        function baseIsEqualDeep(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
            var objIsArr = isArray(object),
                othIsArr = isArray(other),
                objTag = arrayTag,
                othTag = arrayTag;

            if (!objIsArr) {
                objTag = objToString.call(object);
                if (objTag == argsTag) {
                    objTag = objectTag;
                } else if (objTag != objectTag) {
                    objIsArr = isTypedArray(object);
                }
            }
            if (!othIsArr) {
                othTag = objToString.call(other);
                if (othTag == argsTag) {
                    othTag = objectTag;
                } else if (othTag != objectTag) {
                    othIsArr = isTypedArray(other);
                }
            }
            var objIsObj = objTag == objectTag,
                othIsObj = othTag == objectTag,
                isSameTag = objTag == othTag;

            if (isSameTag && !(objIsArr || objIsObj)) {
                return equalByTag(object, other, objTag);
            }
            if (!isLoose) {
                var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
                    othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

                if (objIsWrapped || othIsWrapped) {
                    return equalFunc(objIsWrapped ? object.value() : object, othIsWrapped ? other.value() : other, customizer, isLoose, stackA, stackB);
                }
            }
            if (!isSameTag) {
                return false;
            }
            // Assume cyclic values are equal.
            // For more information on detecting circular references see https://es5.github.io/#JO.
            stackA || (stackA = []);
            stackB || (stackB = []);

            var length = stackA.length;
            while (length--) {
                if (stackA[length] == object) {
                    return stackB[length] == other;
                }
            }
            // Add `object` and `other` to the stack of traversed objects.
            stackA.push(object);
            stackB.push(other);

            var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isLoose, stackA, stackB);

            stackA.pop();
            stackB.pop();

            return result;
        }

        module.exports = baseIsEqualDeep;

    }, { "../lang/isArray": 424, "../lang/isTypedArray": 431, "./equalArrays": 389, "./equalByTag": 390, "./equalObjects": 391 }], 351: [function (require, module, exports) {
        var baseIsEqual = require('./baseIsEqual'),
            toObject = require('./toObject');

        /**
         * The base implementation of `_.isMatch` without support for callback
         * shorthands and `this` binding.
         *
         * @private
         * @param {Object} object The object to inspect.
         * @param {Array} matchData The propery names, values, and compare flags to match.
         * @param {Function} [customizer] The function to customize comparing objects.
         * @returns {boolean} Returns `true` if `object` is a match, else `false`.
         */
        function baseIsMatch(object, matchData, customizer) {
            var index = matchData.length,
                length = index,
                noCustomizer = !customizer;

            if (object == null) {
                return !length;
            }
            object = toObject(object);
            while (index--) {
                var data = matchData[index];
                if ((noCustomizer && data[2])
                    ? data[1] !== object[data[0]]
                    : !(data[0] in object)
                ) {
                    return false;
                }
            }
            while (++index < length) {
                data = matchData[index];
                var key = data[0],
                    objValue = object[key],
                    srcValue = data[1];

                if (noCustomizer && data[2]) {
                    if (objValue === undefined && !(key in object)) {
                        return false;
                    }
                } else {
                    var result = customizer ? customizer(objValue, srcValue, key) : undefined;
                    if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, true) : result)) {
                        return false;
                    }
                }
            }
            return true;
        }

        module.exports = baseIsMatch;

    }, { "./baseIsEqual": 349, "./toObject": 419 }], 352: [function (require, module, exports) {
        /**
         * The function whose prototype all chaining wrappers inherit from.
         *
         * @private
         */
        function baseLodash() {
            // No operation performed.
        }

        module.exports = baseLodash;

    }, {}], 353: [function (require, module, exports) {
        var baseEach = require('./baseEach'),
            isArrayLike = require('./isArrayLike');

        /**
         * The base implementation of `_.map` without support for callback shorthands
         * and `this` binding.
         *
         * @private
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array} Returns the new mapped array.
         */
        function baseMap(collection, iteratee) {
            var index = -1,
                result = isArrayLike(collection) ? Array(collection.length) : [];

            baseEach(collection, function (value, key, collection) {
                result[++index] = iteratee(value, key, collection);
            });
            return result;
        }

        module.exports = baseMap;

    }, { "./baseEach": 338, "./isArrayLike": 401 }], 354: [function (require, module, exports) {
        var baseIsMatch = require('./baseIsMatch'),
            getMatchData = require('./getMatchData'),
            toObject = require('./toObject');

        /**
         * The base implementation of `_.matches` which does not clone `source`.
         *
         * @private
         * @param {Object} source The object of property values to match.
         * @returns {Function} Returns the new function.
         */
        function baseMatches(source) {
            var matchData = getMatchData(source);
            if (matchData.length == 1 && matchData[0][2]) {
                var key = matchData[0][0],
                    value = matchData[0][1];

                return function (object) {
                    if (object == null) {
                        return false;
                    }
                    return object[key] === value && (value !== undefined || (key in toObject(object)));
                };
            }
            return function (object) {
                return baseIsMatch(object, matchData);
            };
        }

        module.exports = baseMatches;

    }, { "./baseIsMatch": 351, "./getMatchData": 395, "./toObject": 419 }], 355: [function (require, module, exports) {
        var baseGet = require('./baseGet'),
            baseIsEqual = require('./baseIsEqual'),
            baseSlice = require('./baseSlice'),
            isArray = require('../lang/isArray'),
            isKey = require('./isKey'),
            isStrictComparable = require('./isStrictComparable'),
            last = require('../array/last'),
            toObject = require('./toObject'),
            toPath = require('./toPath');

        /**
         * The base implementation of `_.matchesProperty` which does not clone `srcValue`.
         *
         * @private
         * @param {string} path The path of the property to get.
         * @param {*} srcValue The value to compare.
         * @returns {Function} Returns the new function.
         */
        function baseMatchesProperty(path, srcValue) {
            var isArr = isArray(path),
                isCommon = isKey(path) && isStrictComparable(srcValue),
                pathKey = (path + '');

            path = toPath(path);
            return function (object) {
                if (object == null) {
                    return false;
                }
                var key = pathKey;
                object = toObject(object);
                if ((isArr || !isCommon) && !(key in object)) {
                    object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
                    if (object == null) {
                        return false;
                    }
                    key = last(path);
                    object = toObject(object);
                }
                return object[key] === srcValue
                    ? (srcValue !== undefined || (key in object))
                    : baseIsEqual(srcValue, object[key], undefined, true);
            };
        }

        module.exports = baseMatchesProperty;

    }, { "../array/last": 294, "../lang/isArray": 424, "./baseGet": 347, "./baseIsEqual": 349, "./baseSlice": 362, "./isKey": 404, "./isStrictComparable": 408, "./toObject": 419, "./toPath": 420 }], 356: [function (require, module, exports) {
        var arrayEach = require('./arrayEach'),
            baseMergeDeep = require('./baseMergeDeep'),
            isArray = require('../lang/isArray'),
            isArrayLike = require('./isArrayLike'),
            isObject = require('../lang/isObject'),
            isObjectLike = require('./isObjectLike'),
            isTypedArray = require('../lang/isTypedArray'),
            keys = require('../object/keys');

        /**
         * The base implementation of `_.merge` without support for argument juggling,
         * multiple sources, and `this` binding `customizer` functions.
         *
         * @private
         * @param {Object} object The destination object.
         * @param {Object} source The source object.
         * @param {Function} [customizer] The function to customize merged values.
         * @param {Array} [stackA=[]] Tracks traversed source objects.
         * @param {Array} [stackB=[]] Associates values with source counterparts.
         * @returns {Object} Returns `object`.
         */
        function baseMerge(object, source, customizer, stackA, stackB) {
            if (!isObject(object)) {
                return object;
            }
            var isSrcArr = isArrayLike(source) && (isArray(source) || isTypedArray(source)),
                props = isSrcArr ? undefined : keys(source);

            arrayEach(props || source, function (srcValue, key) {
                if (props) {
                    key = srcValue;
                    srcValue = source[key];
                }
                if (isObjectLike(srcValue)) {
                    stackA || (stackA = []);
                    stackB || (stackB = []);
                    baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);
                }
                else {
                    var value = object[key],
                        result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
                        isCommon = result === undefined;

                    if (isCommon) {
                        result = srcValue;
                    }
                    if ((result !== undefined || (isSrcArr && !(key in object))) &&
                        (isCommon || (result === result ? (result !== value) : (value === value)))) {
                        object[key] = result;
                    }
                }
            });
            return object;
        }

        module.exports = baseMerge;

    }, { "../lang/isArray": 424, "../lang/isObject": 428, "../lang/isTypedArray": 431, "../object/keys": 435, "./arrayEach": 322, "./baseMergeDeep": 357, "./isArrayLike": 401, "./isObjectLike": 407 }], 357: [function (require, module, exports) {
        var arrayCopy = require('./arrayCopy'),
            isArguments = require('../lang/isArguments'),
            isArray = require('../lang/isArray'),
            isArrayLike = require('./isArrayLike'),
            isPlainObject = require('../lang/isPlainObject'),
            isTypedArray = require('../lang/isTypedArray'),
            toPlainObject = require('../lang/toPlainObject');

        /**
         * A specialized version of `baseMerge` for arrays and objects which performs
         * deep merges and tracks traversed objects enabling objects with circular
         * references to be merged.
         *
         * @private
         * @param {Object} object The destination object.
         * @param {Object} source The source object.
         * @param {string} key The key of the value to merge.
         * @param {Function} mergeFunc The function to merge values.
         * @param {Function} [customizer] The function to customize merged values.
         * @param {Array} [stackA=[]] Tracks traversed source objects.
         * @param {Array} [stackB=[]] Associates values with source counterparts.
         * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
         */
        function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {
            var length = stackA.length,
                srcValue = source[key];

            while (length--) {
                if (stackA[length] == srcValue) {
                    object[key] = stackB[length];
                    return;
                }
            }
            var value = object[key],
                result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
                isCommon = result === undefined;

            if (isCommon) {
                result = srcValue;
                if (isArrayLike(srcValue) && (isArray(srcValue) || isTypedArray(srcValue))) {
                    result = isArray(value)
                        ? value
                        : (isArrayLike(value) ? arrayCopy(value) : []);
                }
                else if (isPlainObject(srcValue) || isArguments(srcValue)) {
                    result = isArguments(value)
                        ? toPlainObject(value)
                        : (isPlainObject(value) ? value : {});
                }
                else {
                    isCommon = false;
                }
            }
            // Add the source value to the stack of traversed objects and associate
            // it with its merged value.
            stackA.push(srcValue);
            stackB.push(result);

            if (isCommon) {
                // Recursively merge objects and arrays (susceptible to call stack limits).
                object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);
            } else if (result === result ? (result !== value) : (value === value)) {
                object[key] = result;
            }
        }

        module.exports = baseMergeDeep;

    }, { "../lang/isArguments": 423, "../lang/isArray": 424, "../lang/isPlainObject": 429, "../lang/isTypedArray": 431, "../lang/toPlainObject": 432, "./arrayCopy": 321, "./isArrayLike": 401 }], 358: [function (require, module, exports) {
        /**
         * The base implementation of `_.property` without support for deep paths.
         *
         * @private
         * @param {string} key The key of the property to get.
         * @returns {Function} Returns the new function.
         */
        function baseProperty(key) {
            return function (object) {
                return object == null ? undefined : object[key];
            };
        }

        module.exports = baseProperty;

    }, {}], 359: [function (require, module, exports) {
        var baseGet = require('./baseGet'),
            toPath = require('./toPath');

        /**
         * A specialized version of `baseProperty` which supports deep paths.
         *
         * @private
         * @param {Array|string} path The path of the property to get.
         * @returns {Function} Returns the new function.
         */
        function basePropertyDeep(path) {
            var pathKey = (path + '');
            path = toPath(path);
            return function (object) {
                return baseGet(object, path, pathKey);
            };
        }

        module.exports = basePropertyDeep;

    }, { "./baseGet": 347, "./toPath": 420 }], 360: [function (require, module, exports) {
        /**
         * The base implementation of `_.reduce` and `_.reduceRight` without support
         * for callback shorthands and `this` binding, which iterates over `collection`
         * using the provided `eachFunc`.
         *
         * @private
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @param {*} accumulator The initial value.
         * @param {boolean} initFromCollection Specify using the first or last element
         *  of `collection` as the initial value.
         * @param {Function} eachFunc The function to iterate over `collection`.
         * @returns {*} Returns the accumulated value.
         */
        function baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {
            eachFunc(collection, function (value, index, collection) {
                accumulator = initFromCollection
                    ? (initFromCollection = false, value)
                    : iteratee(accumulator, value, index, collection);
            });
            return accumulator;
        }

        module.exports = baseReduce;

    }, {}], 361: [function (require, module, exports) {
        var identity = require('../utility/identity'),
            metaMap = require('./metaMap');

        /**
         * The base implementation of `setData` without support for hot loop detection.
         *
         * @private
         * @param {Function} func The function to associate metadata with.
         * @param {*} data The metadata.
         * @returns {Function} Returns `func`.
         */
        var baseSetData = !metaMap ? identity : function (func, data) {
            metaMap.set(func, data);
            return func;
        };

        module.exports = baseSetData;

    }, { "../utility/identity": 443, "./metaMap": 410 }], 362: [function (require, module, exports) {
        /**
         * The base implementation of `_.slice` without an iteratee call guard.
         *
         * @private
         * @param {Array} array The array to slice.
         * @param {number} [start=0] The start position.
         * @param {number} [end=array.length] The end position.
         * @returns {Array} Returns the slice of `array`.
         */
        function baseSlice(array, start, end) {
            var index = -1,
                length = array.length;

            start = start == null ? 0 : (+start || 0);
            if (start < 0) {
                start = -start > length ? 0 : (length + start);
            }
            end = (end === undefined || end > length) ? length : (+end || 0);
            if (end < 0) {
                end += length;
            }
            length = start > end ? 0 : ((end - start) >>> 0);
            start >>>= 0;

            var result = Array(length);
            while (++index < length) {
                result[index] = array[index + start];
            }
            return result;
        }

        module.exports = baseSlice;

    }, {}], 363: [function (require, module, exports) {
        var baseEach = require('./baseEach');

        /**
         * The base implementation of `_.some` without support for callback shorthands
         * and `this` binding.
         *
         * @private
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {boolean} Returns `true` if any element passes the predicate check,
         *  else `false`.
         */
        function baseSome(collection, predicate) {
            var result;

            baseEach(collection, function (value, index, collection) {
                result = predicate(value, index, collection);
                return !result;
            });
            return !!result;
        }

        module.exports = baseSome;

    }, { "./baseEach": 338 }], 364: [function (require, module, exports) {
        /**
         * The base implementation of `_.sortBy` which uses `comparer` to define
         * the sort order of `array` and replaces criteria objects with their
         * corresponding values.
         *
         * @private
         * @param {Array} array The array to sort.
         * @param {Function} comparer The function to define sort order.
         * @returns {Array} Returns `array`.
         */
        function baseSortBy(array, comparer) {
            var length = array.length;

            array.sort(comparer);
            while (length--) {
                array[length] = array[length].value;
            }
            return array;
        }

        module.exports = baseSortBy;

    }, {}], 365: [function (require, module, exports) {
        /**
         * Converts `value` to a string if it's not one. An empty string is returned
         * for `null` or `undefined` values.
         *
         * @private
         * @param {*} value The value to process.
         * @returns {string} Returns the string.
         */
        function baseToString(value) {
            return value == null ? '' : (value + '');
        }

        module.exports = baseToString;

    }, {}], 366: [function (require, module, exports) {
        var baseIndexOf = require('./baseIndexOf'),
            cacheIndexOf = require('./cacheIndexOf'),
            createCache = require('./createCache');

        /** Used as the size to enable large array optimizations. */
        var LARGE_ARRAY_SIZE = 200;

        /**
         * The base implementation of `_.uniq` without support for callback shorthands
         * and `this` binding.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {Function} [iteratee] The function invoked per iteration.
         * @returns {Array} Returns the new duplicate free array.
         */
        function baseUniq(array, iteratee) {
            var index = -1,
                indexOf = baseIndexOf,
                length = array.length,
                isCommon = true,
                isLarge = isCommon && length >= LARGE_ARRAY_SIZE,
                seen = isLarge ? createCache() : null,
                result = [];

            if (seen) {
                indexOf = cacheIndexOf;
                isCommon = false;
            } else {
                isLarge = false;
                seen = iteratee ? [] : result;
            }
            outer:
            while (++index < length) {
                var value = array[index],
                    computed = iteratee ? iteratee(value, index, array) : value;

                if (isCommon && value === value) {
                    var seenIndex = seen.length;
                    while (seenIndex--) {
                        if (seen[seenIndex] === computed) {
                            continue outer;
                        }
                    }
                    if (iteratee) {
                        seen.push(computed);
                    }
                    result.push(value);
                }
                else if (indexOf(seen, computed, 0) < 0) {
                    if (iteratee || isLarge) {
                        seen.push(computed);
                    }
                    result.push(value);
                }
            }
            return result;
        }

        module.exports = baseUniq;

    }, { "./baseIndexOf": 348, "./cacheIndexOf": 370, "./createCache": 380 }], 367: [function (require, module, exports) {
        /**
         * The base implementation of `_.values` and `_.valuesIn` which creates an
         * array of `object` property values corresponding to the property names
         * of `props`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array} props The property names to get values for.
         * @returns {Object} Returns the array of property values.
         */
        function baseValues(object, props) {
            var index = -1,
                length = props.length,
                result = Array(length);

            while (++index < length) {
                result[index] = object[props[index]];
            }
            return result;
        }

        module.exports = baseValues;

    }, {}], 368: [function (require, module, exports) {
        var identity = require('../utility/identity');

        /**
         * A specialized version of `baseCallback` which only supports `this` binding
         * and specifying the number of arguments to provide to `func`.
         *
         * @private
         * @param {Function} func The function to bind.
         * @param {*} thisArg The `this` binding of `func`.
         * @param {number} [argCount] The number of arguments to provide to `func`.
         * @returns {Function} Returns the callback.
         */
        function bindCallback(func, thisArg, argCount) {
            if (typeof func != 'function') {
                return identity;
            }
            if (thisArg === undefined) {
                return func;
            }
            switch (argCount) {
                case 1: return function (value) {
                    return func.call(thisArg, value);
                };
                case 3: return function (value, index, collection) {
                    return func.call(thisArg, value, index, collection);
                };
                case 4: return function (accumulator, value, index, collection) {
                    return func.call(thisArg, accumulator, value, index, collection);
                };
                case 5: return function (value, other, key, object, source) {
                    return func.call(thisArg, value, other, key, object, source);
                };
            }
            return function () {
                return func.apply(thisArg, arguments);
            };
        }

        module.exports = bindCallback;

    }, { "../utility/identity": 443 }], 369: [function (require, module, exports) {
        (function (global) {
            /** Native method references. */
            var ArrayBuffer = global.ArrayBuffer,
                Uint8Array = global.Uint8Array;

            /**
             * Creates a clone of the given array buffer.
             *
             * @private
             * @param {ArrayBuffer} buffer The array buffer to clone.
             * @returns {ArrayBuffer} Returns the cloned array buffer.
             */
            function bufferClone(buffer) {
                var result = new ArrayBuffer(buffer.byteLength),
                    view = new Uint8Array(result);

                view.set(new Uint8Array(buffer));
                return result;
            }

            module.exports = bufferClone;

        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    }, {}], 370: [function (require, module, exports) {
        var isObject = require('../lang/isObject');

        /**
         * Checks if `value` is in `cache` mimicking the return signature of
         * `_.indexOf` by returning `0` if the value is found, else `-1`.
         *
         * @private
         * @param {Object} cache The cache to search.
         * @param {*} value The value to search for.
         * @returns {number} Returns `0` if `value` is found, else `-1`.
         */
        function cacheIndexOf(cache, value) {
            var data = cache.data,
                result = (typeof value == 'string' || isObject(value)) ? data.set.has(value) : data.hash[value];

            return result ? 0 : -1;
        }

        module.exports = cacheIndexOf;

    }, { "../lang/isObject": 428 }], 371: [function (require, module, exports) {
        var isObject = require('../lang/isObject');

        /**
         * Adds `value` to the cache.
         *
         * @private
         * @name push
         * @memberOf SetCache
         * @param {*} value The value to cache.
         */
        function cachePush(value) {
            var data = this.data;
            if (typeof value == 'string' || isObject(value)) {
                data.set.add(value);
            } else {
                data.hash[value] = true;
            }
        }

        module.exports = cachePush;

    }, { "../lang/isObject": 428 }], 372: [function (require, module, exports) {
        var baseCompareAscending = require('./baseCompareAscending');

        /**
         * Used by `_.sortBy` to compare transformed elements of a collection and stable
         * sort them in ascending order.
         *
         * @private
         * @param {Object} object The object to compare.
         * @param {Object} other The other object to compare.
         * @returns {number} Returns the sort order indicator for `object`.
         */
        function compareAscending(object, other) {
            return baseCompareAscending(object.criteria, other.criteria) || (object.index - other.index);
        }

        module.exports = compareAscending;

    }, { "./baseCompareAscending": 333 }], 373: [function (require, module, exports) {
        /* Native method references for those with the same name as other `lodash` methods. */
        var nativeMax = Math.max;

        /**
         * Creates an array that is the composition of partially applied arguments,
         * placeholders, and provided arguments into a single array of arguments.
         *
         * @private
         * @param {Array|Object} args The provided arguments.
         * @param {Array} partials The arguments to prepend to those provided.
         * @param {Array} holders The `partials` placeholder indexes.
         * @returns {Array} Returns the new array of composed arguments.
         */
        function composeArgs(args, partials, holders) {
            var holdersLength = holders.length,
                argsIndex = -1,
                argsLength = nativeMax(args.length - holdersLength, 0),
                leftIndex = -1,
                leftLength = partials.length,
                result = Array(leftLength + argsLength);

            while (++leftIndex < leftLength) {
                result[leftIndex] = partials[leftIndex];
            }
            while (++argsIndex < holdersLength) {
                result[holders[argsIndex]] = args[argsIndex];
            }
            while (argsLength--) {
                result[leftIndex++] = args[argsIndex++];
            }
            return result;
        }

        module.exports = composeArgs;

    }, {}], 374: [function (require, module, exports) {
        /* Native method references for those with the same name as other `lodash` methods. */
        var nativeMax = Math.max;

        /**
         * This function is like `composeArgs` except that the arguments composition
         * is tailored for `_.partialRight`.
         *
         * @private
         * @param {Array|Object} args The provided arguments.
         * @param {Array} partials The arguments to append to those provided.
         * @param {Array} holders The `partials` placeholder indexes.
         * @returns {Array} Returns the new array of composed arguments.
         */
        function composeArgsRight(args, partials, holders) {
            var holdersIndex = -1,
                holdersLength = holders.length,
                argsIndex = -1,
                argsLength = nativeMax(args.length - holdersLength, 0),
                rightIndex = -1,
                rightLength = partials.length,
                result = Array(argsLength + rightLength);

            while (++argsIndex < argsLength) {
                result[argsIndex] = args[argsIndex];
            }
            var offset = argsIndex;
            while (++rightIndex < rightLength) {
                result[offset + rightIndex] = partials[rightIndex];
            }
            while (++holdersIndex < holdersLength) {
                result[offset + holders[holdersIndex]] = args[argsIndex++];
            }
            return result;
        }

        module.exports = composeArgsRight;

    }, {}], 375: [function (require, module, exports) {
        var baseCallback = require('./baseCallback'),
            baseEach = require('./baseEach'),
            isArray = require('../lang/isArray');

        /**
         * Creates a `_.countBy`, `_.groupBy`, `_.indexBy`, or `_.partition` function.
         *
         * @private
         * @param {Function} setter The function to set keys and values of the accumulator object.
         * @param {Function} [initializer] The function to initialize the accumulator object.
         * @returns {Function} Returns the new aggregator function.
         */
        function createAggregator(setter, initializer) {
            return function (collection, iteratee, thisArg) {
                var result = initializer ? initializer() : {};
                iteratee = baseCallback(iteratee, thisArg, 3);

                if (isArray(collection)) {
                    var index = -1,
                        length = collection.length;

                    while (++index < length) {
                        var value = collection[index];
                        setter(result, value, iteratee(value, index, collection), collection);
                    }
                } else {
                    baseEach(collection, function (value, key, collection) {
                        setter(result, value, iteratee(value, key, collection), collection);
                    });
                }
                return result;
            };
        }

        module.exports = createAggregator;

    }, { "../lang/isArray": 424, "./baseCallback": 331, "./baseEach": 338 }], 376: [function (require, module, exports) {
        var bindCallback = require('./bindCallback'),
            isIterateeCall = require('./isIterateeCall'),
            restParam = require('../function/restParam');

        /**
         * Creates a `_.assign`, `_.defaults`, or `_.merge` function.
         *
         * @private
         * @param {Function} assigner The function to assign values.
         * @returns {Function} Returns the new assigner function.
         */
        function createAssigner(assigner) {
            return restParam(function (object, sources) {
                var index = -1,
                    length = object == null ? 0 : sources.length,
                    customizer = length > 2 ? sources[length - 2] : undefined,
                    guard = length > 2 ? sources[2] : undefined,
                    thisArg = length > 1 ? sources[length - 1] : undefined;

                if (typeof customizer == 'function') {
                    customizer = bindCallback(customizer, thisArg, 5);
                    length -= 2;
                } else {
                    customizer = typeof thisArg == 'function' ? thisArg : undefined;
                    length -= (customizer ? 1 : 0);
                }
                if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                    customizer = length < 3 ? undefined : customizer;
                    length = 1;
                }
                while (++index < length) {
                    var source = sources[index];
                    if (source) {
                        assigner(object, source, customizer);
                    }
                }
                return object;
            });
        }

        module.exports = createAssigner;

    }, { "../function/restParam": 316, "./bindCallback": 368, "./isIterateeCall": 403 }], 377: [function (require, module, exports) {
        var getLength = require('./getLength'),
            isLength = require('./isLength'),
            toObject = require('./toObject');

        /**
         * Creates a `baseEach` or `baseEachRight` function.
         *
         * @private
         * @param {Function} eachFunc The function to iterate over a collection.
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Function} Returns the new base function.
         */
        function createBaseEach(eachFunc, fromRight) {
            return function (collection, iteratee) {
                var length = collection ? getLength(collection) : 0;
                if (!isLength(length)) {
                    return eachFunc(collection, iteratee);
                }
                var index = fromRight ? length : -1,
                    iterable = toObject(collection);

                while ((fromRight ? index-- : ++index < length)) {
                    if (iteratee(iterable[index], index, iterable) === false) {
                        break;
                    }
                }
                return collection;
            };
        }

        module.exports = createBaseEach;

    }, { "./getLength": 394, "./isLength": 406, "./toObject": 419 }], 378: [function (require, module, exports) {
        var toObject = require('./toObject');

        /**
         * Creates a base function for `_.forIn` or `_.forInRight`.
         *
         * @private
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Function} Returns the new base function.
         */
        function createBaseFor(fromRight) {
            return function (object, iteratee, keysFunc) {
                var iterable = toObject(object),
                    props = keysFunc(object),
                    length = props.length,
                    index = fromRight ? length : -1;

                while ((fromRight ? index-- : ++index < length)) {
                    var key = props[index];
                    if (iteratee(iterable[key], key, iterable) === false) {
                        break;
                    }
                }
                return object;
            };
        }

        module.exports = createBaseFor;

    }, { "./toObject": 419 }], 379: [function (require, module, exports) {
        (function (global) {
            var createCtorWrapper = require('./createCtorWrapper');

            /**
             * Creates a function that wraps `func` and invokes it with the `this`
             * binding of `thisArg`.
             *
             * @private
             * @param {Function} func The function to bind.
             * @param {*} [thisArg] The `this` binding of `func`.
             * @returns {Function} Returns the new bound function.
             */
            function createBindWrapper(func, thisArg) {
                var Ctor = createCtorWrapper(func);

                function wrapper() {
                    var fn = (this && this !== global && this instanceof wrapper) ? Ctor : func;
                    return fn.apply(thisArg, arguments);
                }
                return wrapper;
            }

            module.exports = createBindWrapper;

        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    }, { "./createCtorWrapper": 381 }], 380: [function (require, module, exports) {
        (function (global) {
            var SetCache = require('./SetCache'),
                getNative = require('./getNative');

            /** Native method references. */
            var Set = getNative(global, 'Set');

            /* Native method references for those with the same name as other `lodash` methods. */
            var nativeCreate = getNative(Object, 'create');

            /**
             * Creates a `Set` cache object to optimize linear searches of large arrays.
             *
             * @private
             * @param {Array} [values] The values to cache.
             * @returns {null|Object} Returns the new cache object if `Set` is supported, else `null`.
             */
            function createCache(values) {
                return (nativeCreate && Set) ? new SetCache(values) : null;
            }

            module.exports = createCache;

        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    }, { "./SetCache": 320, "./getNative": 396 }], 381: [function (require, module, exports) {
        var baseCreate = require('./baseCreate'),
            isObject = require('../lang/isObject');

        /**
         * Creates a function that produces an instance of `Ctor` regardless of
         * whether it was invoked as part of a `new` expression or by `call` or `apply`.
         *
         * @private
         * @param {Function} Ctor The constructor to wrap.
         * @returns {Function} Returns the new wrapped function.
         */
        function createCtorWrapper(Ctor) {
            return function () {
                // Use a `switch` statement to work with class constructors.
                // See http://ecma-international.org/ecma-262/6.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
                // for more details.
                var args = arguments;
                switch (args.length) {
                    case 0: return new Ctor;
                    case 1: return new Ctor(args[0]);
                    case 2: return new Ctor(args[0], args[1]);
                    case 3: return new Ctor(args[0], args[1], args[2]);
                    case 4: return new Ctor(args[0], args[1], args[2], args[3]);
                    case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
                    case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
                    case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
                }
                var thisBinding = baseCreate(Ctor.prototype),
                    result = Ctor.apply(thisBinding, args);

                // Mimic the constructor's `return` behavior.
                // See https://es5.github.io/#x13.2.2 for more details.
                return isObject(result) ? result : thisBinding;
            };
        }

        module.exports = createCtorWrapper;

    }, { "../lang/isObject": 428, "./baseCreate": 335 }], 382: [function (require, module, exports) {
        var baseCallback = require('./baseCallback'),
            baseFind = require('./baseFind'),
            baseFindIndex = require('./baseFindIndex'),
            isArray = require('../lang/isArray');

        /**
         * Creates a `_.find` or `_.findLast` function.
         *
         * @private
         * @param {Function} eachFunc The function to iterate over a collection.
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Function} Returns the new find function.
         */
        function createFind(eachFunc, fromRight) {
            return function (collection, predicate, thisArg) {
                predicate = baseCallback(predicate, thisArg, 3);
                if (isArray(collection)) {
                    var index = baseFindIndex(collection, predicate, fromRight);
                    return index > -1 ? collection[index] : undefined;
                }
                return baseFind(collection, predicate, eachFunc);
            };
        }

        module.exports = createFind;

    }, { "../lang/isArray": 424, "./baseCallback": 331, "./baseFind": 341, "./baseFindIndex": 342 }], 383: [function (require, module, exports) {
        var baseCallback = require('./baseCallback'),
            baseFindIndex = require('./baseFindIndex');

        /**
         * Creates a `_.findIndex` or `_.findLastIndex` function.
         *
         * @private
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Function} Returns the new find function.
         */
        function createFindIndex(fromRight) {
            return function (array, predicate, thisArg) {
                if (!(array && array.length)) {
                    return -1;
                }
                predicate = baseCallback(predicate, thisArg, 3);
                return baseFindIndex(array, predicate, fromRight);
            };
        }

        module.exports = createFindIndex;

    }, { "./baseCallback": 331, "./baseFindIndex": 342 }], 384: [function (require, module, exports) {
        var bindCallback = require('./bindCallback'),
            isArray = require('../lang/isArray');

        /**
         * Creates a function for `_.forEach` or `_.forEachRight`.
         *
         * @private
         * @param {Function} arrayFunc The function to iterate over an array.
         * @param {Function} eachFunc The function to iterate over a collection.
         * @returns {Function} Returns the new each function.
         */
        function createForEach(arrayFunc, eachFunc) {
            return function (collection, iteratee, thisArg) {
                return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))
                    ? arrayFunc(collection, iteratee)
                    : eachFunc(collection, bindCallback(iteratee, thisArg, 3));
            };
        }

        module.exports = createForEach;

    }, { "../lang/isArray": 424, "./bindCallback": 368 }], 385: [function (require, module, exports) {
        (function (global) {
            var arrayCopy = require('./arrayCopy'),
                composeArgs = require('./composeArgs'),
                composeArgsRight = require('./composeArgsRight'),
                createCtorWrapper = require('./createCtorWrapper'),
                isLaziable = require('./isLaziable'),
                reorder = require('./reorder'),
                replaceHolders = require('./replaceHolders'),
                setData = require('./setData');

            /** Used to compose bitmasks for wrapper metadata. */
            var BIND_FLAG = 1,
                BIND_KEY_FLAG = 2,
                CURRY_BOUND_FLAG = 4,
                CURRY_FLAG = 8,
                CURRY_RIGHT_FLAG = 16,
                PARTIAL_FLAG = 32,
                PARTIAL_RIGHT_FLAG = 64,
                ARY_FLAG = 128;

            /* Native method references for those with the same name as other `lodash` methods. */
            var nativeMax = Math.max;

            /**
             * Creates a function that wraps `func` and invokes it with optional `this`
             * binding of, partial application, and currying.
             *
             * @private
             * @param {Function|string} func The function or method name to reference.
             * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
             * @param {*} [thisArg] The `this` binding of `func`.
             * @param {Array} [partials] The arguments to prepend to those provided to the new function.
             * @param {Array} [holders] The `partials` placeholder indexes.
             * @param {Array} [partialsRight] The arguments to append to those provided to the new function.
             * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
             * @param {Array} [argPos] The argument positions of the new function.
             * @param {number} [ary] The arity cap of `func`.
             * @param {number} [arity] The arity of `func`.
             * @returns {Function} Returns the new wrapped function.
             */
            function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
                var isAry = bitmask & ARY_FLAG,
                    isBind = bitmask & BIND_FLAG,
                    isBindKey = bitmask & BIND_KEY_FLAG,
                    isCurry = bitmask & CURRY_FLAG,
                    isCurryBound = bitmask & CURRY_BOUND_FLAG,
                    isCurryRight = bitmask & CURRY_RIGHT_FLAG,
                    Ctor = isBindKey ? undefined : createCtorWrapper(func);

                function wrapper() {
                    // Avoid `arguments` object use disqualifying optimizations by
                    // converting it to an array before providing it to other functions.
                    var length = arguments.length,
                        index = length,
                        args = Array(length);

                    while (index--) {
                        args[index] = arguments[index];
                    }
                    if (partials) {
                        args = composeArgs(args, partials, holders);
                    }
                    if (partialsRight) {
                        args = composeArgsRight(args, partialsRight, holdersRight);
                    }
                    if (isCurry || isCurryRight) {
                        var placeholder = wrapper.placeholder,
                            argsHolders = replaceHolders(args, placeholder);

                        length -= argsHolders.length;
                        if (length < arity) {
                            var newArgPos = argPos ? arrayCopy(argPos) : undefined,
                                newArity = nativeMax(arity - length, 0),
                                newsHolders = isCurry ? argsHolders : undefined,
                                newHoldersRight = isCurry ? undefined : argsHolders,
                                newPartials = isCurry ? args : undefined,
                                newPartialsRight = isCurry ? undefined : args;

                            bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);
                            bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);

                            if (!isCurryBound) {
                                bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
                            }
                            var newData = [func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, newArity],
                                result = createHybridWrapper.apply(undefined, newData);

                            if (isLaziable(func)) {
                                setData(result, newData);
                            }
                            result.placeholder = placeholder;
                            return result;
                        }
                    }
                    var thisBinding = isBind ? thisArg : this,
                        fn = isBindKey ? thisBinding[func] : func;

                    if (argPos) {
                        args = reorder(args, argPos);
                    }
                    if (isAry && ary < args.length) {
                        args.length = ary;
                    }
                    if (this && this !== global && this instanceof wrapper) {
                        fn = Ctor || createCtorWrapper(func);
                    }
                    return fn.apply(thisBinding, args);
                }
                return wrapper;
            }

            module.exports = createHybridWrapper;

        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    }, { "./arrayCopy": 321, "./composeArgs": 373, "./composeArgsRight": 374, "./createCtorWrapper": 381, "./isLaziable": 405, "./reorder": 414, "./replaceHolders": 415, "./setData": 416 }], 386: [function (require, module, exports) {
        (function (global) {
            var createCtorWrapper = require('./createCtorWrapper');

            /** Used to compose bitmasks for wrapper metadata. */
            var BIND_FLAG = 1;

            /**
             * Creates a function that wraps `func` and invokes it with the optional `this`
             * binding of `thisArg` and the `partials` prepended to those provided to
             * the wrapper.
             *
             * @private
             * @param {Function} func The function to partially apply arguments to.
             * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
             * @param {*} thisArg The `this` binding of `func`.
             * @param {Array} partials The arguments to prepend to those provided to the new function.
             * @returns {Function} Returns the new bound function.
             */
            function createPartialWrapper(func, bitmask, thisArg, partials) {
                var isBind = bitmask & BIND_FLAG,
                    Ctor = createCtorWrapper(func);

                function wrapper() {
                    // Avoid `arguments` object use disqualifying optimizations by
                    // converting it to an array before providing it `func`.
                    var argsIndex = -1,
                        argsLength = arguments.length,
                        leftIndex = -1,
                        leftLength = partials.length,
                        args = Array(leftLength + argsLength);

                    while (++leftIndex < leftLength) {
                        args[leftIndex] = partials[leftIndex];
                    }
                    while (argsLength--) {
                        args[leftIndex++] = arguments[++argsIndex];
                    }
                    var fn = (this && this !== global && this instanceof wrapper) ? Ctor : func;
                    return fn.apply(isBind ? thisArg : this, args);
                }
                return wrapper;
            }

            module.exports = createPartialWrapper;

        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    }, { "./createCtorWrapper": 381 }], 387: [function (require, module, exports) {
        var baseCallback = require('./baseCallback'),
            baseReduce = require('./baseReduce'),
            isArray = require('../lang/isArray');

        /**
         * Creates a function for `_.reduce` or `_.reduceRight`.
         *
         * @private
         * @param {Function} arrayFunc The function to iterate over an array.
         * @param {Function} eachFunc The function to iterate over a collection.
         * @returns {Function} Returns the new each function.
         */
        function createReduce(arrayFunc, eachFunc) {
            return function (collection, iteratee, accumulator, thisArg) {
                var initFromArray = arguments.length < 3;
                return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))
                    ? arrayFunc(collection, iteratee, accumulator, initFromArray)
                    : baseReduce(collection, baseCallback(iteratee, thisArg, 4), accumulator, initFromArray, eachFunc);
            };
        }

        module.exports = createReduce;

    }, { "../lang/isArray": 424, "./baseCallback": 331, "./baseReduce": 360 }], 388: [function (require, module, exports) {
        var baseSetData = require('./baseSetData'),
            createBindWrapper = require('./createBindWrapper'),
            createHybridWrapper = require('./createHybridWrapper'),
            createPartialWrapper = require('./createPartialWrapper'),
            getData = require('./getData'),
            mergeData = require('./mergeData'),
            setData = require('./setData');

        /** Used to compose bitmasks for wrapper metadata. */
        var BIND_FLAG = 1,
            BIND_KEY_FLAG = 2,
            PARTIAL_FLAG = 32,
            PARTIAL_RIGHT_FLAG = 64;

        /** Used as the `TypeError` message for "Functions" methods. */
        var FUNC_ERROR_TEXT = 'Expected a function';

        /* Native method references for those with the same name as other `lodash` methods. */
        var nativeMax = Math.max;

        /**
         * Creates a function that either curries or invokes `func` with optional
         * `this` binding and partially applied arguments.
         *
         * @private
         * @param {Function|string} func The function or method name to reference.
         * @param {number} bitmask The bitmask of flags.
         *  The bitmask may be composed of the following flags:
         *     1 - `_.bind`
         *     2 - `_.bindKey`
         *     4 - `_.curry` or `_.curryRight` of a bound function
         *     8 - `_.curry`
         *    16 - `_.curryRight`
         *    32 - `_.partial`
         *    64 - `_.partialRight`
         *   128 - `_.rearg`
         *   256 - `_.ary`
         * @param {*} [thisArg] The `this` binding of `func`.
         * @param {Array} [partials] The arguments to be partially applied.
         * @param {Array} [holders] The `partials` placeholder indexes.
         * @param {Array} [argPos] The argument positions of the new function.
         * @param {number} [ary] The arity cap of `func`.
         * @param {number} [arity] The arity of `func`.
         * @returns {Function} Returns the new wrapped function.
         */
        function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
            var isBindKey = bitmask & BIND_KEY_FLAG;
            if (!isBindKey && typeof func != 'function') {
                throw new TypeError(FUNC_ERROR_TEXT);
            }
            var length = partials ? partials.length : 0;
            if (!length) {
                bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
                partials = holders = undefined;
            }
            length -= (holders ? holders.length : 0);
            if (bitmask & PARTIAL_RIGHT_FLAG) {
                var partialsRight = partials,
                    holdersRight = holders;

                partials = holders = undefined;
            }
            var data = isBindKey ? undefined : getData(func),
                newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];

            if (data) {
                mergeData(newData, data);
                bitmask = newData[1];
                arity = newData[9];
            }
            newData[9] = arity == null
                ? (isBindKey ? 0 : func.length)
                : (nativeMax(arity - length, 0) || 0);

            if (bitmask == BIND_FLAG) {
                var result = createBindWrapper(newData[0], newData[2]);
            } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !newData[4].length) {
                result = createPartialWrapper.apply(undefined, newData);
            } else {
                result = createHybridWrapper.apply(undefined, newData);
            }
            var setter = data ? baseSetData : setData;
            return setter(result, newData);
        }

        module.exports = createWrapper;

    }, { "./baseSetData": 361, "./createBindWrapper": 379, "./createHybridWrapper": 385, "./createPartialWrapper": 386, "./getData": 392, "./mergeData": 409, "./setData": 416 }], 389: [function (require, module, exports) {
        var arraySome = require('./arraySome');

        /**
         * A specialized version of `baseIsEqualDeep` for arrays with support for
         * partial deep comparisons.
         *
         * @private
         * @param {Array} array The array to compare.
         * @param {Array} other The other array to compare.
         * @param {Function} equalFunc The function to determine equivalents of values.
         * @param {Function} [customizer] The function to customize comparing arrays.
         * @param {boolean} [isLoose] Specify performing partial comparisons.
         * @param {Array} [stackA] Tracks traversed `value` objects.
         * @param {Array} [stackB] Tracks traversed `other` objects.
         * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
         */
        function equalArrays(array, other, equalFunc, customizer, isLoose, stackA, stackB) {
            var index = -1,
                arrLength = array.length,
                othLength = other.length;

            if (arrLength != othLength && !(isLoose && othLength > arrLength)) {
                return false;
            }
            // Ignore non-index properties.
            while (++index < arrLength) {
                var arrValue = array[index],
                    othValue = other[index],
                    result = customizer ? customizer(isLoose ? othValue : arrValue, isLoose ? arrValue : othValue, index) : undefined;

                if (result !== undefined) {
                    if (result) {
                        continue;
                    }
                    return false;
                }
                // Recursively compare arrays (susceptible to call stack limits).
                if (isLoose) {
                    if (!arraySome(other, function (othValue) {
                        return arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);
                    })) {
                        return false;
                    }
                } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB))) {
                    return false;
                }
            }
            return true;
        }

        module.exports = equalArrays;

    }, { "./arraySome": 328 }], 390: [function (require, module, exports) {
        /** `Object#toString` result references. */
        var boolTag = '[object Boolean]',
            dateTag = '[object Date]',
            errorTag = '[object Error]',
            numberTag = '[object Number]',
            regexpTag = '[object RegExp]',
            stringTag = '[object String]';

        /**
         * A specialized version of `baseIsEqualDeep` for comparing objects of
         * the same `toStringTag`.
         *
         * **Note:** This function only supports comparing values with tags of
         * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
         *
         * @private
         * @param {Object} object The object to compare.
         * @param {Object} other The other object to compare.
         * @param {string} tag The `toStringTag` of the objects to compare.
         * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
         */
        function equalByTag(object, other, tag) {
            switch (tag) {
                case boolTag:
                case dateTag:
                    // Coerce dates and booleans to numbers, dates to milliseconds and booleans
                    // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.
                    return +object == +other;

                case errorTag:
                    return object.name == other.name && object.message == other.message;

                case numberTag:
                    // Treat `NaN` vs. `NaN` as equal.
                    return (object != +object)
                        ? other != +other
                        : object == +other;

                case regexpTag:
                case stringTag:
                    // Coerce regexes to strings and treat strings primitives and string
                    // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.
                    return object == (other + '');
            }
            return false;
        }

        module.exports = equalByTag;

    }, {}], 391: [function (require, module, exports) {
        var keys = require('../object/keys');

        /** Used for native method references. */
        var objectProto = Object.prototype;

        /** Used to check objects for own properties. */
        var hasOwnProperty = objectProto.hasOwnProperty;

        /**
         * A specialized version of `baseIsEqualDeep` for objects with support for
         * partial deep comparisons.
         *
         * @private
         * @param {Object} object The object to compare.
         * @param {Object} other The other object to compare.
         * @param {Function} equalFunc The function to determine equivalents of values.
         * @param {Function} [customizer] The function to customize comparing values.
         * @param {boolean} [isLoose] Specify performing partial comparisons.
         * @param {Array} [stackA] Tracks traversed `value` objects.
         * @param {Array} [stackB] Tracks traversed `other` objects.
         * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
         */
        function equalObjects(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
            var objProps = keys(object),
                objLength = objProps.length,
                othProps = keys(other),
                othLength = othProps.length;

            if (objLength != othLength && !isLoose) {
                return false;
            }
            var index = objLength;
            while (index--) {
                var key = objProps[index];
                if (!(isLoose ? key in other : hasOwnProperty.call(other, key))) {
                    return false;
                }
            }
            var skipCtor = isLoose;
            while (++index < objLength) {
                key = objProps[index];
                var objValue = object[key],
                    othValue = other[key],
                    result = customizer ? customizer(isLoose ? othValue : objValue, isLoose ? objValue : othValue, key) : undefined;

                // Recursively compare objects (susceptible to call stack limits).
                if (!(result === undefined ? equalFunc(objValue, othValue, customizer, isLoose, stackA, stackB) : result)) {
                    return false;
                }
                skipCtor || (skipCtor = key == 'constructor');
            }
            if (!skipCtor) {
                var objCtor = object.constructor,
                    othCtor = other.constructor;

                // Non `Object` object instances with different constructors are not equal.
                if (objCtor != othCtor &&
                    ('constructor' in object && 'constructor' in other) &&
                    !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
                        typeof othCtor == 'function' && othCtor instanceof othCtor)) {
                    return false;
                }
            }
            return true;
        }

        module.exports = equalObjects;

    }, { "../object/keys": 435 }], 392: [function (require, module, exports) {
        var metaMap = require('./metaMap'),
            noop = require('../utility/noop');

        /**
         * Gets metadata for `func`.
         *
         * @private
         * @param {Function} func The function to query.
         * @returns {*} Returns the metadata for `func`.
         */
        var getData = !metaMap ? noop : function (func) {
            return metaMap.get(func);
        };

        module.exports = getData;

    }, { "../utility/noop": 444, "./metaMap": 410 }], 393: [function (require, module, exports) {
        var realNames = require('./realNames');

        /**
         * Gets the name of `func`.
         *
         * @private
         * @param {Function} func The function to query.
         * @returns {string} Returns the function name.
         */
        function getFuncName(func) {
            var result = (func.name + ''),
                array = realNames[result],
                length = array ? array.length : 0;

            while (length--) {
                var data = array[length],
                    otherFunc = data.func;
                if (otherFunc == null || otherFunc == func) {
                    return data.name;
                }
            }
            return result;
        }

        module.exports = getFuncName;

    }, { "./realNames": 413 }], 394: [function (require, module, exports) {
        var baseProperty = require('./baseProperty');

        /**
         * Gets the "length" property value of `object`.
         *
         * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
         * that affects Safari on at least iOS 8.1-8.3 ARM64.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {*} Returns the "length" value.
         */
        var getLength = baseProperty('length');

        module.exports = getLength;

    }, { "./baseProperty": 358 }], 395: [function (require, module, exports) {
        var isStrictComparable = require('./isStrictComparable'),
            pairs = require('../object/pairs');

        /**
         * Gets the propery names, values, and compare flags of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the match data of `object`.
         */
        function getMatchData(object) {
            var result = pairs(object),
                length = result.length;

            while (length--) {
                result[length][2] = isStrictComparable(result[length][1]);
            }
            return result;
        }

        module.exports = getMatchData;

    }, { "../object/pairs": 439, "./isStrictComparable": 408 }], 396: [function (require, module, exports) {
        var isNative = require('../lang/isNative');

        /**
         * Gets the native function at `key` of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {string} key The key of the method to get.
         * @returns {*} Returns the function if it's native, else `undefined`.
         */
        function getNative(object, key) {
            var value = object == null ? undefined : object[key];
            return isNative(value) ? value : undefined;
        }

        module.exports = getNative;

    }, { "../lang/isNative": 426 }], 397: [function (require, module, exports) {
        /**
         * Gets the index at which the first occurrence of `NaN` is found in `array`.
         *
         * @private
         * @param {Array} array The array to search.
         * @param {number} fromIndex The index to search from.
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {number} Returns the index of the matched `NaN`, else `-1`.
         */
        function indexOfNaN(array, fromIndex, fromRight) {
            var length = array.length,
                index = fromIndex + (fromRight ? 0 : -1);

            while ((fromRight ? index-- : ++index < length)) {
                var other = array[index];
                if (other !== other) {
                    return index;
                }
            }
            return -1;
        }

        module.exports = indexOfNaN;

    }, {}], 398: [function (require, module, exports) {
        /** Used for native method references. */
        var objectProto = Object.prototype;

        /** Used to check objects for own properties. */
        var hasOwnProperty = objectProto.hasOwnProperty;

        /**
         * Initializes an array clone.
         *
         * @private
         * @param {Array} array The array to clone.
         * @returns {Array} Returns the initialized clone.
         */
        function initCloneArray(array) {
            var length = array.length,
                result = new array.constructor(length);

            // Add array properties assigned by `RegExp#exec`.
            if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
                result.index = array.index;
                result.input = array.input;
            }
            return result;
        }

        module.exports = initCloneArray;

    }, {}], 399: [function (require, module, exports) {
        var bufferClone = require('./bufferClone');

        /** `Object#toString` result references. */
        var boolTag = '[object Boolean]',
            dateTag = '[object Date]',
            numberTag = '[object Number]',
            regexpTag = '[object RegExp]',
            stringTag = '[object String]';

        var arrayBufferTag = '[object ArrayBuffer]',
            float32Tag = '[object Float32Array]',
            float64Tag = '[object Float64Array]',
            int8Tag = '[object Int8Array]',
            int16Tag = '[object Int16Array]',
            int32Tag = '[object Int32Array]',
            uint8Tag = '[object Uint8Array]',
            uint8ClampedTag = '[object Uint8ClampedArray]',
            uint16Tag = '[object Uint16Array]',
            uint32Tag = '[object Uint32Array]';

        /** Used to match `RegExp` flags from their coerced string values. */
        var reFlags = /\w*$/;

        /**
         * Initializes an object clone based on its `toStringTag`.
         *
         * **Note:** This function only supports cloning values with tags of
         * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
         *
         * @private
         * @param {Object} object The object to clone.
         * @param {string} tag The `toStringTag` of the object to clone.
         * @param {boolean} [isDeep] Specify a deep clone.
         * @returns {Object} Returns the initialized clone.
         */
        function initCloneByTag(object, tag, isDeep) {
            var Ctor = object.constructor;
            switch (tag) {
                case arrayBufferTag:
                    return bufferClone(object);

                case boolTag:
                case dateTag:
                    return new Ctor(+object);

                case float32Tag: case float64Tag:
                case int8Tag: case int16Tag: case int32Tag:
                case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
                    var buffer = object.buffer;
                    return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);

                case numberTag:
                case stringTag:
                    return new Ctor(object);

                case regexpTag:
                    var result = new Ctor(object.source, reFlags.exec(object));
                    result.lastIndex = object.lastIndex;
            }
            return result;
        }

        module.exports = initCloneByTag;

    }, { "./bufferClone": 369 }], 400: [function (require, module, exports) {
        /**
         * Initializes an object clone.
         *
         * @private
         * @param {Object} object The object to clone.
         * @returns {Object} Returns the initialized clone.
         */
        function initCloneObject(object) {
            var Ctor = object.constructor;
            if (!(typeof Ctor == 'function' && Ctor instanceof Ctor)) {
                Ctor = Object;
            }
            return new Ctor;
        }

        module.exports = initCloneObject;

    }, {}], 401: [function (require, module, exports) {
        var getLength = require('./getLength'),
            isLength = require('./isLength');

        /**
         * Checks if `value` is array-like.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
         */
        function isArrayLike(value) {
            return value != null && isLength(getLength(value));
        }

        module.exports = isArrayLike;

    }, { "./getLength": 394, "./isLength": 406 }], 402: [function (require, module, exports) {
        /** Used to detect unsigned integer values. */
        var reIsUint = /^\d+$/;

        /**
         * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
         * of an array-like value.
         */
        var MAX_SAFE_INTEGER = 9007199254740991;

        /**
         * Checks if `value` is a valid array-like index.
         *
         * @private
         * @param {*} value The value to check.
         * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
         * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
         */
        function isIndex(value, length) {
            value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
            length = length == null ? MAX_SAFE_INTEGER : length;
            return value > -1 && value % 1 == 0 && value < length;
        }

        module.exports = isIndex;

    }, {}], 403: [function (require, module, exports) {
        var isArrayLike = require('./isArrayLike'),
            isIndex = require('./isIndex'),
            isObject = require('../lang/isObject');

        /**
         * Checks if the provided arguments are from an iteratee call.
         *
         * @private
         * @param {*} value The potential iteratee value argument.
         * @param {*} index The potential iteratee index or key argument.
         * @param {*} object The potential iteratee object argument.
         * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.
         */
        function isIterateeCall(value, index, object) {
            if (!isObject(object)) {
                return false;
            }
            var type = typeof index;
            if (type == 'number'
                ? (isArrayLike(object) && isIndex(index, object.length))
                : (type == 'string' && index in object)) {
                var other = object[index];
                return value === value ? (value === other) : (other !== other);
            }
            return false;
        }

        module.exports = isIterateeCall;

    }, { "../lang/isObject": 428, "./isArrayLike": 401, "./isIndex": 402 }], 404: [function (require, module, exports) {
        var isArray = require('../lang/isArray'),
            toObject = require('./toObject');

        /** Used to match property names within property paths. */
        var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\n\\]|\\.)*?\1)\]/,
            reIsPlainProp = /^\w*$/;

        /**
         * Checks if `value` is a property name and not a property path.
         *
         * @private
         * @param {*} value The value to check.
         * @param {Object} [object] The object to query keys on.
         * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
         */
        function isKey(value, object) {
            var type = typeof value;
            if ((type == 'string' && reIsPlainProp.test(value)) || type == 'number') {
                return true;
            }
            if (isArray(value)) {
                return false;
            }
            var result = !reIsDeepProp.test(value);
            return result || (object != null && value in toObject(object));
        }

        module.exports = isKey;

    }, { "../lang/isArray": 424, "./toObject": 419 }], 405: [function (require, module, exports) {
        var LazyWrapper = require('./LazyWrapper'),
            getData = require('./getData'),
            getFuncName = require('./getFuncName'),
            lodash = require('../chain/lodash');

        /**
         * Checks if `func` has a lazy counterpart.
         *
         * @private
         * @param {Function} func The function to check.
         * @returns {boolean} Returns `true` if `func` has a lazy counterpart, else `false`.
         */
        function isLaziable(func) {
            var funcName = getFuncName(func),
                other = lodash[funcName];

            if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
                return false;
            }
            if (func === other) {
                return true;
            }
            var data = getData(other);
            return !!data && func === data[0];
        }

        module.exports = isLaziable;

    }, { "../chain/lodash": 299, "./LazyWrapper": 318, "./getData": 392, "./getFuncName": 393 }], 406: [function (require, module, exports) {
        /**
         * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
         * of an array-like value.
         */
        var MAX_SAFE_INTEGER = 9007199254740991;

        /**
         * Checks if `value` is a valid array-like length.
         *
         * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
         */
        function isLength(value) {
            return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }

        module.exports = isLength;

    }, {}], 407: [function (require, module, exports) {
        /**
         * Checks if `value` is object-like.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
         */
        function isObjectLike(value) {
            return !!value && typeof value == 'object';
        }

        module.exports = isObjectLike;

    }, {}], 408: [function (require, module, exports) {
        var isObject = require('../lang/isObject');

        /**
         * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` if suitable for strict
         *  equality comparisons, else `false`.
         */
        function isStrictComparable(value) {
            return value === value && !isObject(value);
        }

        module.exports = isStrictComparable;

    }, { "../lang/isObject": 428 }], 409: [function (require, module, exports) {
        var arrayCopy = require('./arrayCopy'),
            composeArgs = require('./composeArgs'),
            composeArgsRight = require('./composeArgsRight'),
            replaceHolders = require('./replaceHolders');

        /** Used to compose bitmasks for wrapper metadata. */
        var BIND_FLAG = 1,
            CURRY_BOUND_FLAG = 4,
            CURRY_FLAG = 8,
            ARY_FLAG = 128,
            REARG_FLAG = 256;

        /** Used as the internal argument placeholder. */
        var PLACEHOLDER = '__lodash_placeholder__';

        /* Native method references for those with the same name as other `lodash` methods. */
        var nativeMin = Math.min;

        /**
         * Merges the function metadata of `source` into `data`.
         *
         * Merging metadata reduces the number of wrappers required to invoke a function.
         * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
         * may be applied regardless of execution order. Methods like `_.ary` and `_.rearg`
         * augment function arguments, making the order in which they are executed important,
         * preventing the merging of metadata. However, we make an exception for a safe
         * common case where curried functions have `_.ary` and or `_.rearg` applied.
         *
         * @private
         * @param {Array} data The destination metadata.
         * @param {Array} source The source metadata.
         * @returns {Array} Returns `data`.
         */
        function mergeData(data, source) {
            var bitmask = data[1],
                srcBitmask = source[1],
                newBitmask = bitmask | srcBitmask,
                isCommon = newBitmask < ARY_FLAG;

            var isCombo =
                (srcBitmask == ARY_FLAG && bitmask == CURRY_FLAG) ||
                (srcBitmask == ARY_FLAG && bitmask == REARG_FLAG && data[7].length <= source[8]) ||
                (srcBitmask == (ARY_FLAG | REARG_FLAG) && bitmask == CURRY_FLAG);

            // Exit early if metadata can't be merged.
            if (!(isCommon || isCombo)) {
                return data;
            }
            // Use source `thisArg` if available.
            if (srcBitmask & BIND_FLAG) {
                data[2] = source[2];
                // Set when currying a bound function.
                newBitmask |= (bitmask & BIND_FLAG) ? 0 : CURRY_BOUND_FLAG;
            }
            // Compose partial arguments.
            var value = source[3];
            if (value) {
                var partials = data[3];
                data[3] = partials ? composeArgs(partials, value, source[4]) : arrayCopy(value);
                data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : arrayCopy(source[4]);
            }
            // Compose partial right arguments.
            value = source[5];
            if (value) {
                partials = data[5];
                data[5] = partials ? composeArgsRight(partials, value, source[6]) : arrayCopy(value);
                data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : arrayCopy(source[6]);
            }
            // Use source `argPos` if available.
            value = source[7];
            if (value) {
                data[7] = arrayCopy(value);
            }
            // Use source `ary` if it's smaller.
            if (srcBitmask & ARY_FLAG) {
                data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
            }
            // Use source `arity` if one is not provided.
            if (data[9] == null) {
                data[9] = source[9];
            }
            // Use source `func` and merge bitmasks.
            data[0] = source[0];
            data[1] = newBitmask;

            return data;
        }

        module.exports = mergeData;

    }, { "./arrayCopy": 321, "./composeArgs": 373, "./composeArgsRight": 374, "./replaceHolders": 415 }], 410: [function (require, module, exports) {
        (function (global) {
            var getNative = require('./getNative');

            /** Native method references. */
            var WeakMap = getNative(global, 'WeakMap');

            /** Used to store function metadata. */
            var metaMap = WeakMap && new WeakMap;

            module.exports = metaMap;

        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    }, { "./getNative": 396 }], 411: [function (require, module, exports) {
        var toObject = require('./toObject');

        /**
         * A specialized version of `_.pick` which picks `object` properties specified
         * by `props`.
         *
         * @private
         * @param {Object} object The source object.
         * @param {string[]} props The property names to pick.
         * @returns {Object} Returns the new object.
         */
        function pickByArray(object, props) {
            object = toObject(object);

            var index = -1,
                length = props.length,
                result = {};

            while (++index < length) {
                var key = props[index];
                if (key in object) {
                    result[key] = object[key];
                }
            }
            return result;
        }

        module.exports = pickByArray;

    }, { "./toObject": 419 }], 412: [function (require, module, exports) {
        var baseForIn = require('./baseForIn');

        /**
         * A specialized version of `_.pick` which picks `object` properties `predicate`
         * returns truthy for.
         *
         * @private
         * @param {Object} object The source object.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {Object} Returns the new object.
         */
        function pickByCallback(object, predicate) {
            var result = {};
            baseForIn(object, function (value, key, object) {
                if (predicate(value, key, object)) {
                    result[key] = value;
                }
            });
            return result;
        }

        module.exports = pickByCallback;

    }, { "./baseForIn": 345 }], 413: [function (require, module, exports) {
        /** Used to lookup unminified function names. */
        var realNames = {};

        module.exports = realNames;

    }, {}], 414: [function (require, module, exports) {
        var arrayCopy = require('./arrayCopy'),
            isIndex = require('./isIndex');

        /* Native method references for those with the same name as other `lodash` methods. */
        var nativeMin = Math.min;

        /**
         * Reorder `array` according to the specified indexes where the element at
         * the first index is assigned as the first element, the element at
         * the second index is assigned as the second element, and so on.
         *
         * @private
         * @param {Array} array The array to reorder.
         * @param {Array} indexes The arranged array indexes.
         * @returns {Array} Returns `array`.
         */
        function reorder(array, indexes) {
            var arrLength = array.length,
                length = nativeMin(indexes.length, arrLength),
                oldArray = arrayCopy(array);

            while (length--) {
                var index = indexes[length];
                array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
            }
            return array;
        }

        module.exports = reorder;

    }, { "./arrayCopy": 321, "./isIndex": 402 }], 415: [function (require, module, exports) {
        /** Used as the internal argument placeholder. */
        var PLACEHOLDER = '__lodash_placeholder__';

        /**
         * Replaces all `placeholder` elements in `array` with an internal placeholder
         * and returns an array of their indexes.
         *
         * @private
         * @param {Array} array The array to modify.
         * @param {*} placeholder The placeholder to replace.
         * @returns {Array} Returns the new array of placeholder indexes.
         */
        function replaceHolders(array, placeholder) {
            var index = -1,
                length = array.length,
                resIndex = -1,
                result = [];

            while (++index < length) {
                if (array[index] === placeholder) {
                    array[index] = PLACEHOLDER;
                    result[++resIndex] = index;
                }
            }
            return result;
        }

        module.exports = replaceHolders;

    }, {}], 416: [function (require, module, exports) {
        var baseSetData = require('./baseSetData'),
            now = require('../date/now');

        /** Used to detect when a function becomes hot. */
        var HOT_COUNT = 150,
            HOT_SPAN = 16;

        /**
         * Sets metadata for `func`.
         *
         * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
         * period of time, it will trip its breaker and transition to an identity function
         * to avoid garbage collection pauses in V8. See [V8 issue 2070](https://code.google.com/p/v8/issues/detail?id=2070)
         * for more details.
         *
         * @private
         * @param {Function} func The function to associate metadata with.
         * @param {*} data The metadata.
         * @returns {Function} Returns `func`.
         */
        var setData = (function () {
            var count = 0,
                lastCalled = 0;

            return function (key, value) {
                var stamp = now(),
                    remaining = HOT_SPAN - (stamp - lastCalled);

                lastCalled = stamp;
                if (remaining > 0) {
                    if (++count >= HOT_COUNT) {
                        return key;
                    }
                } else {
                    count = 0;
                }
                return baseSetData(key, value);
            };
        }());

        module.exports = setData;

    }, { "../date/now": 312, "./baseSetData": 361 }], 417: [function (require, module, exports) {
        var isArguments = require('../lang/isArguments'),
            isArray = require('../lang/isArray'),
            isIndex = require('./isIndex'),
            isLength = require('./isLength'),
            keysIn = require('../object/keysIn');

        /** Used for native method references. */
        var objectProto = Object.prototype;

        /** Used to check objects for own properties. */
        var hasOwnProperty = objectProto.hasOwnProperty;

        /**
         * A fallback implementation of `Object.keys` which creates an array of the
         * own enumerable property names of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         */
        function shimKeys(object) {
            var props = keysIn(object),
                propsLength = props.length,
                length = propsLength && object.length;

            var allowIndexes = !!length && isLength(length) &&
                (isArray(object) || isArguments(object));

            var index = -1,
                result = [];

            while (++index < propsLength) {
                var key = props[index];
                if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
                    result.push(key);
                }
            }
            return result;
        }

        module.exports = shimKeys;

    }, { "../lang/isArguments": 423, "../lang/isArray": 424, "../object/keysIn": 436, "./isIndex": 402, "./isLength": 406 }], 418: [function (require, module, exports) {
        /**
         * An implementation of `_.uniq` optimized for sorted arrays without support
         * for callback shorthands and `this` binding.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {Function} [iteratee] The function invoked per iteration.
         * @returns {Array} Returns the new duplicate free array.
         */
        function sortedUniq(array, iteratee) {
            var seen,
                index = -1,
                length = array.length,
                resIndex = -1,
                result = [];

            while (++index < length) {
                var value = array[index],
                    computed = iteratee ? iteratee(value, index, array) : value;

                if (!index || seen !== computed) {
                    seen = computed;
                    result[++resIndex] = value;
                }
            }
            return result;
        }

        module.exports = sortedUniq;

    }, {}], 419: [function (require, module, exports) {
        var isObject = require('../lang/isObject');

        /**
         * Converts `value` to an object if it's not one.
         *
         * @private
         * @param {*} value The value to process.
         * @returns {Object} Returns the object.
         */
        function toObject(value) {
            return isObject(value) ? value : Object(value);
        }

        module.exports = toObject;

    }, { "../lang/isObject": 428 }], 420: [function (require, module, exports) {
        var baseToString = require('./baseToString'),
            isArray = require('../lang/isArray');

        /** Used to match property names within property paths. */
        var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g;

        /** Used to match backslashes in property paths. */
        var reEscapeChar = /\\(\\)?/g;

        /**
         * Converts `value` to property path array if it's not one.
         *
         * @private
         * @param {*} value The value to process.
         * @returns {Array} Returns the property path array.
         */
        function toPath(value) {
            if (isArray(value)) {
                return value;
            }
            var result = [];
            baseToString(value).replace(rePropName, function (match, number, quote, string) {
                result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
            });
            return result;
        }

        module.exports = toPath;

    }, { "../lang/isArray": 424, "./baseToString": 365 }], 421: [function (require, module, exports) {
        var LazyWrapper = require('./LazyWrapper'),
            LodashWrapper = require('./LodashWrapper'),
            arrayCopy = require('./arrayCopy');

        /**
         * Creates a clone of `wrapper`.
         *
         * @private
         * @param {Object} wrapper The wrapper to clone.
         * @returns {Object} Returns the cloned wrapper.
         */
        function wrapperClone(wrapper) {
            return wrapper instanceof LazyWrapper
                ? wrapper.clone()
                : new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__, arrayCopy(wrapper.__actions__));
        }

        module.exports = wrapperClone;

    }, { "./LazyWrapper": 318, "./LodashWrapper": 319, "./arrayCopy": 321 }], 422: [function (require, module, exports) {
        var baseClone = require('../internal/baseClone'),
            bindCallback = require('../internal/bindCallback'),
            isIterateeCall = require('../internal/isIterateeCall');

        /**
         * Creates a clone of `value`. If `isDeep` is `true` nested objects are cloned,
         * otherwise they are assigned by reference. If `customizer` is provided it's
         * invoked to produce the cloned values. If `customizer` returns `undefined`
         * cloning is handled by the method instead. The `customizer` is bound to
         * `thisArg` and invoked with up to three argument; (value [, index|key, object]).
         *
         * **Note:** This method is loosely based on the
         * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).
         * The enumerable properties of `arguments` objects and objects created by
         * constructors other than `Object` are cloned to plain `Object` objects. An
         * empty object is returned for uncloneable values such as functions, DOM nodes,
         * Maps, Sets, and WeakMaps.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to clone.
         * @param {boolean} [isDeep] Specify a deep clone.
         * @param {Function} [customizer] The function to customize cloning values.
         * @param {*} [thisArg] The `this` binding of `customizer`.
         * @returns {*} Returns the cloned value.
         * @example
         *
         * var users = [
         *   { 'user': 'barney' },
         *   { 'user': 'fred' }
         * ];
         *
         * var shallow = _.clone(users);
         * shallow[0] === users[0];
         * // => true
         *
         * var deep = _.clone(users, true);
         * deep[0] === users[0];
         * // => false
         *
         * // using a customizer callback
         * var el = _.clone(document.body, function(value) {
         *   if (_.isElement(value)) {
         *     return value.cloneNode(false);
         *   }
         * });
         *
         * el === document.body
         * // => false
         * el.nodeName
         * // => BODY
         * el.childNodes.length;
         * // => 0
         */
        function clone(value, isDeep, customizer, thisArg) {
            if (isDeep && typeof isDeep != 'boolean' && isIterateeCall(value, isDeep, customizer)) {
                isDeep = false;
            }
            else if (typeof isDeep == 'function') {
                thisArg = customizer;
                customizer = isDeep;
                isDeep = false;
            }
            return typeof customizer == 'function'
                ? baseClone(value, isDeep, bindCallback(customizer, thisArg, 3))
                : baseClone(value, isDeep);
        }

        module.exports = clone;

    }, { "../internal/baseClone": 332, "../internal/bindCallback": 368, "../internal/isIterateeCall": 403 }], 423: [function (require, module, exports) {
        var isArrayLike = require('../internal/isArrayLike'),
            isObjectLike = require('../internal/isObjectLike');

        /** Used for native method references. */
        var objectProto = Object.prototype;

        /** Used to check objects for own properties. */
        var hasOwnProperty = objectProto.hasOwnProperty;

        /** Native method references. */
        var propertyIsEnumerable = objectProto.propertyIsEnumerable;

        /**
         * Checks if `value` is classified as an `arguments` object.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
         * @example
         *
         * _.isArguments(function() { return arguments; }());
         * // => true
         *
         * _.isArguments([1, 2, 3]);
         * // => false
         */
        function isArguments(value) {
            return isObjectLike(value) && isArrayLike(value) &&
                hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
        }

        module.exports = isArguments;

    }, { "../internal/isArrayLike": 401, "../internal/isObjectLike": 407 }], 424: [function (require, module, exports) {
        var getNative = require('../internal/getNative'),
            isLength = require('../internal/isLength'),
            isObjectLike = require('../internal/isObjectLike');

        /** `Object#toString` result references. */
        var arrayTag = '[object Array]';

        /** Used for native method references. */
        var objectProto = Object.prototype;

        /**
         * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
         * of values.
         */
        var objToString = objectProto.toString;

        /* Native method references for those with the same name as other `lodash` methods. */
        var nativeIsArray = getNative(Array, 'isArray');

        /**
         * Checks if `value` is classified as an `Array` object.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
         * @example
         *
         * _.isArray([1, 2, 3]);
         * // => true
         *
         * _.isArray(function() { return arguments; }());
         * // => false
         */
        var isArray = nativeIsArray || function (value) {
            return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
        };

        module.exports = isArray;

    }, { "../internal/getNative": 396, "../internal/isLength": 406, "../internal/isObjectLike": 407 }], 425: [function (require, module, exports) {
        var isObject = require('./isObject');

        /** `Object#toString` result references. */
        var funcTag = '[object Function]';

        /** Used for native method references. */
        var objectProto = Object.prototype;

        /**
         * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
         * of values.
         */
        var objToString = objectProto.toString;

        /**
         * Checks if `value` is classified as a `Function` object.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
         * @example
         *
         * _.isFunction(_);
         * // => true
         *
         * _.isFunction(/abc/);
         * // => false
         */
        function isFunction(value) {
            // The use of `Object#toString` avoids issues with the `typeof` operator
            // in older versions of Chrome and Safari which return 'function' for regexes
            // and Safari 8 which returns 'object' for typed array constructors.
            return isObject(value) && objToString.call(value) == funcTag;
        }

        module.exports = isFunction;

    }, { "./isObject": 428 }], 426: [function (require, module, exports) {
        var isFunction = require('./isFunction'),
            isObjectLike = require('../internal/isObjectLike');

        /** Used to detect host constructors (Safari > 5). */
        var reIsHostCtor = /^\[object .+?Constructor\]$/;

        /** Used for native method references. */
        var objectProto = Object.prototype;

        /** Used to resolve the decompiled source of functions. */
        var fnToString = Function.prototype.toString;

        /** Used to check objects for own properties. */
        var hasOwnProperty = objectProto.hasOwnProperty;

        /** Used to detect if a method is native. */
        var reIsNative = RegExp('^' +
            fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
                .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
        );

        /**
         * Checks if `value` is a native function.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
         * @example
         *
         * _.isNative(Array.prototype.push);
         * // => true
         *
         * _.isNative(_);
         * // => false
         */
        function isNative(value) {
            if (value == null) {
                return false;
            }
            if (isFunction(value)) {
                return reIsNative.test(fnToString.call(value));
            }
            return isObjectLike(value) && reIsHostCtor.test(value);
        }

        module.exports = isNative;

    }, { "../internal/isObjectLike": 407, "./isFunction": 425 }], 427: [function (require, module, exports) {
        var isObjectLike = require('../internal/isObjectLike');

        /** `Object#toString` result references. */
        var numberTag = '[object Number]';

        /** Used for native method references. */
        var objectProto = Object.prototype;

        /**
         * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
         * of values.
         */
        var objToString = objectProto.toString;

        /**
         * Checks if `value` is classified as a `Number` primitive or object.
         *
         * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are classified
         * as numbers, use the `_.isFinite` method.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
         * @example
         *
         * _.isNumber(8.4);
         * // => true
         *
         * _.isNumber(NaN);
         * // => true
         *
         * _.isNumber('8.4');
         * // => false
         */
        function isNumber(value) {
            return typeof value == 'number' || (isObjectLike(value) && objToString.call(value) == numberTag);
        }

        module.exports = isNumber;

    }, { "../internal/isObjectLike": 407 }], 428: [function (require, module, exports) {
        /**
         * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
         * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an object, else `false`.
         * @example
         *
         * _.isObject({});
         * // => true
         *
         * _.isObject([1, 2, 3]);
         * // => true
         *
         * _.isObject(1);
         * // => false
         */
        function isObject(value) {
            // Avoid a V8 JIT bug in Chrome 19-20.
            // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
            var type = typeof value;
            return !!value && (type == 'object' || type == 'function');
        }

        module.exports = isObject;

    }, {}], 429: [function (require, module, exports) {
        var baseForIn = require('../internal/baseForIn'),
            isArguments = require('./isArguments'),
            isObjectLike = require('../internal/isObjectLike');

        /** `Object#toString` result references. */
        var objectTag = '[object Object]';

        /** Used for native method references. */
        var objectProto = Object.prototype;

        /** Used to check objects for own properties. */
        var hasOwnProperty = objectProto.hasOwnProperty;

        /**
         * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
         * of values.
         */
        var objToString = objectProto.toString;

        /**
         * Checks if `value` is a plain object, that is, an object created by the
         * `Object` constructor or one with a `[[Prototype]]` of `null`.
         *
         * **Note:** This method assumes objects created by the `Object` constructor
         * have no inherited enumerable properties.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         * }
         *
         * _.isPlainObject(new Foo);
         * // => false
         *
         * _.isPlainObject([1, 2, 3]);
         * // => false
         *
         * _.isPlainObject({ 'x': 0, 'y': 0 });
         * // => true
         *
         * _.isPlainObject(Object.create(null));
         * // => true
         */
        function isPlainObject(value) {
            var Ctor;

            // Exit early for non `Object` objects.
            if (!(isObjectLike(value) && objToString.call(value) == objectTag && !isArguments(value)) ||
                (!hasOwnProperty.call(value, 'constructor') && (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor)))) {
                return false;
            }
            // IE < 9 iterates inherited properties before own properties. If the first
            // iterated property is an object's own property then there are no inherited
            // enumerable properties.
            var result;
            // In most environments an object's own properties are iterated before
            // its inherited properties. If the last iterated property is an object's
            // own property then there are no inherited enumerable properties.
            baseForIn(value, function (subValue, key) {
                result = key;
            });
            return result === undefined || hasOwnProperty.call(value, result);
        }

        module.exports = isPlainObject;

    }, { "../internal/baseForIn": 345, "../internal/isObjectLike": 407, "./isArguments": 423 }], 430: [function (require, module, exports) {
        var isObjectLike = require('../internal/isObjectLike');

        /** `Object#toString` result references. */
        var stringTag = '[object String]';

        /** Used for native method references. */
        var objectProto = Object.prototype;

        /**
         * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
         * of values.
         */
        var objToString = objectProto.toString;

        /**
         * Checks if `value` is classified as a `String` primitive or object.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
         * @example
         *
         * _.isString('abc');
         * // => true
         *
         * _.isString(1);
         * // => false
         */
        function isString(value) {
            return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag);
        }

        module.exports = isString;

    }, { "../internal/isObjectLike": 407 }], 431: [function (require, module, exports) {
        var isLength = require('../internal/isLength'),
            isObjectLike = require('../internal/isObjectLike');

        /** `Object#toString` result references. */
        var argsTag = '[object Arguments]',
            arrayTag = '[object Array]',
            boolTag = '[object Boolean]',
            dateTag = '[object Date]',
            errorTag = '[object Error]',
            funcTag = '[object Function]',
            mapTag = '[object Map]',
            numberTag = '[object Number]',
            objectTag = '[object Object]',
            regexpTag = '[object RegExp]',
            setTag = '[object Set]',
            stringTag = '[object String]',
            weakMapTag = '[object WeakMap]';

        var arrayBufferTag = '[object ArrayBuffer]',
            float32Tag = '[object Float32Array]',
            float64Tag = '[object Float64Array]',
            int8Tag = '[object Int8Array]',
            int16Tag = '[object Int16Array]',
            int32Tag = '[object Int32Array]',
            uint8Tag = '[object Uint8Array]',
            uint8ClampedTag = '[object Uint8ClampedArray]',
            uint16Tag = '[object Uint16Array]',
            uint32Tag = '[object Uint32Array]';

        /** Used to identify `toStringTag` values of typed arrays. */
        var typedArrayTags = {};
        typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
            typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
            typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
            typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
            typedArrayTags[uint32Tag] = true;
        typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
            typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
            typedArrayTags[dateTag] = typedArrayTags[errorTag] =
            typedArrayTags[funcTag] = typedArrayTags[mapTag] =
            typedArrayTags[numberTag] = typedArrayTags[objectTag] =
            typedArrayTags[regexpTag] = typedArrayTags[setTag] =
            typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

        /** Used for native method references. */
        var objectProto = Object.prototype;

        /**
         * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
         * of values.
         */
        var objToString = objectProto.toString;

        /**
         * Checks if `value` is classified as a typed array.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
         * @example
         *
         * _.isTypedArray(new Uint8Array);
         * // => true
         *
         * _.isTypedArray([]);
         * // => false
         */
        function isTypedArray(value) {
            return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];
        }

        module.exports = isTypedArray;

    }, { "../internal/isLength": 406, "../internal/isObjectLike": 407 }], 432: [function (require, module, exports) {
        var baseCopy = require('../internal/baseCopy'),
            keysIn = require('../object/keysIn');

        /**
         * Converts `value` to a plain object flattening inherited enumerable
         * properties of `value` to own properties of the plain object.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {Object} Returns the converted plain object.
         * @example
         *
         * function Foo() {
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.assign({ 'a': 1 }, new Foo);
         * // => { 'a': 1, 'b': 2 }
         *
         * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
         * // => { 'a': 1, 'b': 2, 'c': 3 }
         */
        function toPlainObject(value) {
            return baseCopy(value, keysIn(value));
        }

        module.exports = toPlainObject;

    }, { "../internal/baseCopy": 334, "../object/keysIn": 436 }], 433: [function (require, module, exports) {
        var assignWith = require('../internal/assignWith'),
            baseAssign = require('../internal/baseAssign'),
            createAssigner = require('../internal/createAssigner');

        /**
         * Assigns own enumerable properties of source object(s) to the destination
         * object. Subsequent sources overwrite property assignments of previous sources.
         * If `customizer` is provided it's invoked to produce the assigned values.
         * The `customizer` is bound to `thisArg` and invoked with five arguments:
         * (objectValue, sourceValue, key, object, source).
         *
         * **Note:** This method mutates `object` and is based on
         * [`Object.assign`](http://ecma-international.org/ecma-262/6.0/#sec-object.assign).
         *
         * @static
         * @memberOf _
         * @alias extend
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} [sources] The source objects.
         * @param {Function} [customizer] The function to customize assigned values.
         * @param {*} [thisArg] The `this` binding of `customizer`.
         * @returns {Object} Returns `object`.
         * @example
         *
         * _.assign({ 'user': 'barney' }, { 'age': 40 }, { 'user': 'fred' });
         * // => { 'user': 'fred', 'age': 40 }
         *
         * // using a customizer callback
         * var defaults = _.partialRight(_.assign, function(value, other) {
         *   return _.isUndefined(value) ? other : value;
         * });
         *
         * defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
         * // => { 'user': 'barney', 'age': 36 }
         */
        var assign = createAssigner(function (object, source, customizer) {
            return customizer
                ? assignWith(object, source, customizer)
                : baseAssign(object, source);
        });

        module.exports = assign;

    }, { "../internal/assignWith": 329, "../internal/baseAssign": 330, "../internal/createAssigner": 376 }], 434: [function (require, module, exports) {
        var baseGet = require('../internal/baseGet'),
            baseSlice = require('../internal/baseSlice'),
            isArguments = require('../lang/isArguments'),
            isArray = require('../lang/isArray'),
            isIndex = require('../internal/isIndex'),
            isKey = require('../internal/isKey'),
            isLength = require('../internal/isLength'),
            last = require('../array/last'),
            toPath = require('../internal/toPath');

        /** Used for native method references. */
        var objectProto = Object.prototype;

        /** Used to check objects for own properties. */
        var hasOwnProperty = objectProto.hasOwnProperty;

        /**
         * Checks if `path` is a direct property.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @param {Array|string} path The path to check.
         * @returns {boolean} Returns `true` if `path` is a direct property, else `false`.
         * @example
         *
         * var object = { 'a': { 'b': { 'c': 3 } } };
         *
         * _.has(object, 'a');
         * // => true
         *
         * _.has(object, 'a.b.c');
         * // => true
         *
         * _.has(object, ['a', 'b', 'c']);
         * // => true
         */
        function has(object, path) {
            if (object == null) {
                return false;
            }
            var result = hasOwnProperty.call(object, path);
            if (!result && !isKey(path)) {
                path = toPath(path);
                object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
                if (object == null) {
                    return false;
                }
                path = last(path);
                result = hasOwnProperty.call(object, path);
            }
            return result || (isLength(object.length) && isIndex(path, object.length) &&
                (isArray(object) || isArguments(object)));
        }

        module.exports = has;

    }, { "../array/last": 294, "../internal/baseGet": 347, "../internal/baseSlice": 362, "../internal/isIndex": 402, "../internal/isKey": 404, "../internal/isLength": 406, "../internal/toPath": 420, "../lang/isArguments": 423, "../lang/isArray": 424 }], 435: [function (require, module, exports) {
        var getNative = require('../internal/getNative'),
            isArrayLike = require('../internal/isArrayLike'),
            isObject = require('../lang/isObject'),
            shimKeys = require('../internal/shimKeys');

        /* Native method references for those with the same name as other `lodash` methods. */
        var nativeKeys = getNative(Object, 'keys');

        /**
         * Creates an array of the own enumerable property names of `object`.
         *
         * **Note:** Non-object values are coerced to objects. See the
         * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
         * for more details.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.keys(new Foo);
         * // => ['a', 'b'] (iteration order is not guaranteed)
         *
         * _.keys('hi');
         * // => ['0', '1']
         */
        var keys = !nativeKeys ? shimKeys : function (object) {
            var Ctor = object == null ? undefined : object.constructor;
            if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
                (typeof object != 'function' && isArrayLike(object))) {
                return shimKeys(object);
            }
            return isObject(object) ? nativeKeys(object) : [];
        };

        module.exports = keys;

    }, { "../internal/getNative": 396, "../internal/isArrayLike": 401, "../internal/shimKeys": 417, "../lang/isObject": 428 }], 436: [function (require, module, exports) {
        var isArguments = require('../lang/isArguments'),
            isArray = require('../lang/isArray'),
            isIndex = require('../internal/isIndex'),
            isLength = require('../internal/isLength'),
            isObject = require('../lang/isObject');

        /** Used for native method references. */
        var objectProto = Object.prototype;

        /** Used to check objects for own properties. */
        var hasOwnProperty = objectProto.hasOwnProperty;

        /**
         * Creates an array of the own and inherited enumerable property names of `object`.
         *
         * **Note:** Non-object values are coerced to objects.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.keysIn(new Foo);
         * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
         */
        function keysIn(object) {
            if (object == null) {
                return [];
            }
            if (!isObject(object)) {
                object = Object(object);
            }
            var length = object.length;
            length = (length && isLength(length) &&
                (isArray(object) || isArguments(object)) && length) || 0;

            var Ctor = object.constructor,
                index = -1,
                isProto = typeof Ctor == 'function' && Ctor.prototype === object,
                result = Array(length),
                skipIndexes = length > 0;

            while (++index < length) {
                result[index] = (index + '');
            }
            for (var key in object) {
                if (!(skipIndexes && isIndex(key, length)) &&
                    !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
                    result.push(key);
                }
            }
            return result;
        }

        module.exports = keysIn;

    }, { "../internal/isIndex": 402, "../internal/isLength": 406, "../lang/isArguments": 423, "../lang/isArray": 424, "../lang/isObject": 428 }], 437: [function (require, module, exports) {
        var baseMerge = require('../internal/baseMerge'),
            createAssigner = require('../internal/createAssigner');

        /**
         * Recursively merges own enumerable properties of the source object(s), that
         * don't resolve to `undefined` into the destination object. Subsequent sources
         * overwrite property assignments of previous sources. If `customizer` is
         * provided it's invoked to produce the merged values of the destination and
         * source properties. If `customizer` returns `undefined` merging is handled
         * by the method instead. The `customizer` is bound to `thisArg` and invoked
         * with five arguments: (objectValue, sourceValue, key, object, source).
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} [sources] The source objects.
         * @param {Function} [customizer] The function to customize assigned values.
         * @param {*} [thisArg] The `this` binding of `customizer`.
         * @returns {Object} Returns `object`.
         * @example
         *
         * var users = {
         *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]
         * };
         *
         * var ages = {
         *   'data': [{ 'age': 36 }, { 'age': 40 }]
         * };
         *
         * _.merge(users, ages);
         * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }
         *
         * // using a customizer callback
         * var object = {
         *   'fruits': ['apple'],
         *   'vegetables': ['beet']
         * };
         *
         * var other = {
         *   'fruits': ['banana'],
         *   'vegetables': ['carrot']
         * };
         *
         * _.merge(object, other, function(a, b) {
         *   if (_.isArray(a)) {
         *     return a.concat(b);
         *   }
         * });
         * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }
         */
        var merge = createAssigner(baseMerge);

        module.exports = merge;

    }, { "../internal/baseMerge": 356, "../internal/createAssigner": 376 }], 438: [function (require, module, exports) {
        var arrayMap = require('../internal/arrayMap'),
            baseDifference = require('../internal/baseDifference'),
            baseFlatten = require('../internal/baseFlatten'),
            bindCallback = require('../internal/bindCallback'),
            keysIn = require('./keysIn'),
            pickByArray = require('../internal/pickByArray'),
            pickByCallback = require('../internal/pickByCallback'),
            restParam = require('../function/restParam');

        /**
         * The opposite of `_.pick`; this method creates an object composed of the
         * own and inherited enumerable properties of `object` that are not omitted.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The source object.
         * @param {Function|...(string|string[])} [predicate] The function invoked per
         *  iteration or property names to omit, specified as individual property
         *  names or arrays of property names.
         * @param {*} [thisArg] The `this` binding of `predicate`.
         * @returns {Object} Returns the new object.
         * @example
         *
         * var object = { 'user': 'fred', 'age': 40 };
         *
         * _.omit(object, 'age');
         * // => { 'user': 'fred' }
         *
         * _.omit(object, _.isNumber);
         * // => { 'user': 'fred' }
         */
        var omit = restParam(function (object, props) {
            if (object == null) {
                return {};
            }
            if (typeof props[0] != 'function') {
                var props = arrayMap(baseFlatten(props), String);
                return pickByArray(object, baseDifference(keysIn(object), props));
            }
            var predicate = bindCallback(props[0], props[1], 3);
            return pickByCallback(object, function (value, key, object) {
                return !predicate(value, key, object);
            });
        });

        module.exports = omit;

    }, { "../function/restParam": 316, "../internal/arrayMap": 325, "../internal/baseDifference": 337, "../internal/baseFlatten": 343, "../internal/bindCallback": 368, "../internal/pickByArray": 411, "../internal/pickByCallback": 412, "./keysIn": 436 }], 439: [function (require, module, exports) {
        var keys = require('./keys'),
            toObject = require('../internal/toObject');

        /**
         * Creates a two dimensional array of the key-value pairs for `object`,
         * e.g. `[[key1, value1], [key2, value2]]`.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the new array of key-value pairs.
         * @example
         *
         * _.pairs({ 'barney': 36, 'fred': 40 });
         * // => [['barney', 36], ['fred', 40]] (iteration order is not guaranteed)
         */
        function pairs(object) {
            object = toObject(object);

            var index = -1,
                props = keys(object),
                length = props.length,
                result = Array(length);

            while (++index < length) {
                var key = props[index];
                result[index] = [key, object[key]];
            }
            return result;
        }

        module.exports = pairs;

    }, { "../internal/toObject": 419, "./keys": 435 }], 440: [function (require, module, exports) {
        var baseFlatten = require('../internal/baseFlatten'),
            bindCallback = require('../internal/bindCallback'),
            pickByArray = require('../internal/pickByArray'),
            pickByCallback = require('../internal/pickByCallback'),
            restParam = require('../function/restParam');

        /**
         * Creates an object composed of the picked `object` properties. Property
         * names may be specified as individual arguments or as arrays of property
         * names. If `predicate` is provided it's invoked for each property of `object`
         * picking the properties `predicate` returns truthy for. The predicate is
         * bound to `thisArg` and invoked with three arguments: (value, key, object).
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The source object.
         * @param {Function|...(string|string[])} [predicate] The function invoked per
         *  iteration or property names to pick, specified as individual property
         *  names or arrays of property names.
         * @param {*} [thisArg] The `this` binding of `predicate`.
         * @returns {Object} Returns the new object.
         * @example
         *
         * var object = { 'user': 'fred', 'age': 40 };
         *
         * _.pick(object, 'user');
         * // => { 'user': 'fred' }
         *
         * _.pick(object, _.isString);
         * // => { 'user': 'fred' }
         */
        var pick = restParam(function (object, props) {
            if (object == null) {
                return {};
            }
            return typeof props[0] == 'function'
                ? pickByCallback(object, bindCallback(props[0], props[1], 3))
                : pickByArray(object, baseFlatten(props));
        });

        module.exports = pick;

    }, { "../function/restParam": 316, "../internal/baseFlatten": 343, "../internal/bindCallback": 368, "../internal/pickByArray": 411, "../internal/pickByCallback": 412 }], 441: [function (require, module, exports) {
        var arrayEach = require('../internal/arrayEach'),
            baseCallback = require('../internal/baseCallback'),
            baseCreate = require('../internal/baseCreate'),
            baseForOwn = require('../internal/baseForOwn'),
            isArray = require('../lang/isArray'),
            isFunction = require('../lang/isFunction'),
            isObject = require('../lang/isObject'),
            isTypedArray = require('../lang/isTypedArray');

        /**
         * An alternative to `_.reduce`; this method transforms `object` to a new
         * `accumulator` object which is the result of running each of its own enumerable
         * properties through `iteratee`, with each invocation potentially mutating
         * the `accumulator` object. The `iteratee` is bound to `thisArg` and invoked
         * with four arguments: (accumulator, value, key, object). Iteratee functions
         * may exit iteration early by explicitly returning `false`.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Array|Object} object The object to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @param {*} [accumulator] The custom accumulator value.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {*} Returns the accumulated value.
         * @example
         *
         * _.transform([2, 3, 4], function(result, n) {
         *   result.push(n *= n);
         *   return n % 2 == 0;
         * });
         * // => [4, 9]
         *
         * _.transform({ 'a': 1, 'b': 2 }, function(result, n, key) {
         *   result[key] = n * 3;
         * });
         * // => { 'a': 3, 'b': 6 }
         */
        function transform(object, iteratee, accumulator, thisArg) {
            var isArr = isArray(object) || isTypedArray(object);
            iteratee = baseCallback(iteratee, thisArg, 4);

            if (accumulator == null) {
                if (isArr || isObject(object)) {
                    var Ctor = object.constructor;
                    if (isArr) {
                        accumulator = isArray(object) ? new Ctor : [];
                    } else {
                        accumulator = baseCreate(isFunction(Ctor) ? Ctor.prototype : undefined);
                    }
                } else {
                    accumulator = {};
                }
            }
            (isArr ? arrayEach : baseForOwn)(object, function (value, index, object) {
                return iteratee(accumulator, value, index, object);
            });
            return accumulator;
        }

        module.exports = transform;

    }, { "../internal/arrayEach": 322, "../internal/baseCallback": 331, "../internal/baseCreate": 335, "../internal/baseForOwn": 346, "../lang/isArray": 424, "../lang/isFunction": 425, "../lang/isObject": 428, "../lang/isTypedArray": 431 }], 442: [function (require, module, exports) {
        var baseValues = require('../internal/baseValues'),
            keys = require('./keys');

        /**
         * Creates an array of the own enumerable property values of `object`.
         *
         * **Note:** Non-object values are coerced to objects.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property values.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.values(new Foo);
         * // => [1, 2] (iteration order is not guaranteed)
         *
         * _.values('hi');
         * // => ['h', 'i']
         */
        function values(object) {
            return baseValues(object, keys(object));
        }

        module.exports = values;

    }, { "../internal/baseValues": 367, "./keys": 435 }], 443: [function (require, module, exports) {
        /**
         * This method returns the first argument provided to it.
         *
         * @static
         * @memberOf _
         * @category Utility
         * @param {*} value Any value.
         * @returns {*} Returns `value`.
         * @example
         *
         * var object = { 'user': 'fred' };
         *
         * _.identity(object) === object;
         * // => true
         */
        function identity(value) {
            return value;
        }

        module.exports = identity;

    }, {}], 444: [function (require, module, exports) {
        /**
         * A no-operation function that returns `undefined` regardless of the
         * arguments it receives.
         *
         * @static
         * @memberOf _
         * @category Utility
         * @example
         *
         * var object = { 'user': 'fred' };
         *
         * _.noop(object) === undefined;
         * // => true
         */
        function noop() {
            // No operation performed.
        }

        module.exports = noop;

    }, {}], 445: [function (require, module, exports) {
        var baseProperty = require('../internal/baseProperty'),
            basePropertyDeep = require('../internal/basePropertyDeep'),
            isKey = require('../internal/isKey');

        /**
         * Creates a function that returns the property value at `path` on a
         * given object.
         *
         * @static
         * @memberOf _
         * @category Utility
         * @param {Array|string} path The path of the property to get.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var objects = [
         *   { 'a': { 'b': { 'c': 2 } } },
         *   { 'a': { 'b': { 'c': 1 } } }
         * ];
         *
         * _.map(objects, _.property('a.b.c'));
         * // => [2, 1]
         *
         * _.pluck(_.sortBy(objects, _.property(['a', 'b', 'c'])), 'a.b.c');
         * // => [1, 2]
         */
        function property(path) {
            return isKey(path) ? baseProperty(path) : basePropertyDeep(path);
        }

        module.exports = property;

    }, { "../internal/baseProperty": 358, "../internal/basePropertyDeep": 359, "../internal/isKey": 404 }], 446: [function (require, module, exports) {
        /**
         * Set attribute `name` to `val`, or get attr `name`.
         *
         * @param {Element} el
         * @param {String} name
         * @param {String} [val]
         * @api public
         */

        module.exports = function (el, name, val) {
            // get
            if (arguments.length == 2) {
                return el.getAttribute(name);
            }

            // remove
            if (val === null) {
                return el.removeAttribute(name);
            }

            // set
            el.setAttribute(name, val);

            return el;
        };
    }, {}], 447: [function (require, module, exports) {
        module.exports = require('component-classes');
    }, { "component-classes": 107 }], 448: [function (require, module, exports) {
        module.exports = function (el) {

            var c;

            while (el.childNodes.length) {
                c = el.childNodes[0];
                el.removeChild(c);
            }

            return el;
        };
    }, {}], 449: [function (require, module, exports) {
        module.exports = require('component-closest');
    }, { "component-closest": 108 }], 450: [function (require, module, exports) {
        module.exports = require('component-delegate');
    }, { "component-delegate": 109 }], 451: [function (require, module, exports) {
        module.exports = require('domify');
    }, { "domify": 285 }], 452: [function (require, module, exports) {
        module.exports = require('component-event');
    }, { "component-event": 110 }], 453: [function (require, module, exports) {
        module.exports = require('component-matches-selector');
    }, { "component-matches-selector": 112 }], 454: [function (require, module, exports) {
        module.exports = require('component-query');
    }, { "component-query": 113 }], 455: [function (require, module, exports) {
        module.exports = function (el) {
            el.parentNode && el.parentNode.removeChild(el);
        };
    }, {}], 456: [function (require, module, exports) {
        'use strict';

        function capitalize(string) {
            return string.charAt(0).toUpperCase() + string.slice(1);
        }

        function lower(string) {
            return string.charAt(0).toLowerCase() + string.slice(1);
        }

        function hasLowerCaseAlias(pkg) {
            return pkg.xml && pkg.xml.tagAlias === 'lowerCase';
        }


        module.exports.aliasToName = function (alias, pkg) {
            if (hasLowerCaseAlias(pkg)) {
                return capitalize(alias);
            } else {
                return alias;
            }
        };

        module.exports.nameToAlias = function (name, pkg) {
            if (hasLowerCaseAlias(pkg)) {
                return lower(name);
            } else {
                return name;
            }
        };

        module.exports.DEFAULT_NS_MAP = {
            'xsi': 'http://www.w3.org/2001/XMLSchema-instance'
        };

        var XSI_TYPE = module.exports.XSI_TYPE = 'xsi:type';

        function serializeFormat(element) {
            return element.xml && element.xml.serialize;
        }

        module.exports.serializeAsType = function (element) {
            return serializeFormat(element) === XSI_TYPE;
        };

        module.exports.serializeAsProperty = function (element) {
            return serializeFormat(element) === 'property';
        };
    }, {}], 457: [function (require, module, exports) {
        'use strict';

        var reduce = require('lodash/collection/reduce'),
            forEach = require('lodash/collection/forEach'),
            find = require('lodash/collection/find'),
            assign = require('lodash/object/assign'),
            defer = require('lodash/function/defer');

        var Stack = require('tiny-stack'),
            SaxParser = require('sax').parser,
            Moddle = require('moddle'),
            parseNameNs = require('moddle/lib/ns').parseName,
            Types = require('moddle/lib/types'),
            coerceType = Types.coerceType,
            isSimpleType = Types.isSimple,
            common = require('./common'),
            XSI_TYPE = common.XSI_TYPE,
            XSI_URI = common.DEFAULT_NS_MAP.xsi,
            serializeAsType = common.serializeAsType,
            aliasToName = common.aliasToName;

        function parseNodeAttributes(node) {
            var nodeAttrs = node.attributes;

            return reduce(nodeAttrs, function (result, v, k) {
                var name, ns;

                if (!v.local) {
                    name = v.prefix;
                } else {
                    ns = parseNameNs(v.name, v.prefix);
                    name = ns.name;
                }

                result[name] = v.value;
                return result;
            }, {});
        }

        function normalizeType(node, attr, model) {
            var nameNs = parseNameNs(attr.value);

            var uri = node.ns[nameNs.prefix || ''],
                localName = nameNs.localName,
                pkg = uri && model.getPackage(uri),
                typePrefix;

            if (pkg) {
                typePrefix = pkg.xml && pkg.xml.typePrefix;

                if (typePrefix && localName.indexOf(typePrefix) === 0) {
                    localName = localName.slice(typePrefix.length);
                }

                attr.value = pkg.prefix + ':' + localName;
            }
        }

        /**
         * Normalizes namespaces for a node given an optional default namespace and a
         * number of mappings from uris to default prefixes.
         *
         * @param  {XmlNode} node
         * @param  {Model} model the model containing all registered namespaces
         * @param  {Uri} defaultNsUri
         */
        function normalizeNamespaces(node, model, defaultNsUri) {
            var uri, prefix;

            uri = node.uri || defaultNsUri;

            if (uri) {
                var pkg = model.getPackage(uri);

                if (pkg) {
                    prefix = pkg.prefix;
                } else {
                    prefix = node.prefix;
                }

                node.prefix = prefix;
                node.uri = uri;
            }

            forEach(node.attributes, function (attr) {

                // normalize xsi:type attributes because the
                // assigned type may or may not be namespace prefixed
                if (attr.uri === XSI_URI && attr.local === 'type') {
                    normalizeType(node, attr, model);
                }

                normalizeNamespaces(attr, model, null);
            });
        }


        function error(message) {
            return new Error(message);
        }

        /**
         * Get the moddle descriptor for a given instance or type.
         *
         * @param  {ModdleElement|Function} element
         *
         * @return {Object} the moddle descriptor
         */
        function getModdleDescriptor(element) {
            return element.$descriptor;
        }

        /**
         * A parse context.
         *
         * @class
         *
         * @param {Object} options
         * @param {ElementHandler} options.rootHandler the root handler for parsing a document
         * @param {boolean} [options.lax=false] whether or not to ignore invalid elements
         */
        function Context(options) {

            /**
             * @property {ElementHandler} rootHandler
             */

            /**
             * @property {Boolean} lax
             */

            assign(this, options);

            this.elementsById = {};
            this.references = [];
            this.warnings = [];

            /**
             * Add an unresolved reference.
             *
             * @param {Object} reference
             */
            this.addReference = function (reference) {
                this.references.push(reference);
            };

            /**
             * Add a processed element.
             *
             * @param {ModdleElement} element
             */
            this.addElement = function (element) {

                if (!element) {
                    throw error('expected element');
                }

                var elementsById = this.elementsById;

                var descriptor = getModdleDescriptor(element);

                var idProperty = descriptor.idProperty,
                    id;

                if (idProperty) {
                    id = element.get(idProperty.name);

                    if (id) {

                        if (elementsById[id]) {
                            throw error('duplicate ID <' + id + '>');
                        }

                        elementsById[id] = element;
                    }
                }
            };

            /**
             * Add an import warning.
             *
             * @param {Object} warning
             * @param {String} warning.message
             * @param {Error} [warning.error]
             */
            this.addWarning = function (warning) {
                this.warnings.push(warning);
            };
        }

        function BaseHandler() { }

        BaseHandler.prototype.handleEnd = function () { };
        BaseHandler.prototype.handleText = function () { };
        BaseHandler.prototype.handleNode = function () { };


        /**
         * A simple pass through handler that does nothing except for
         * ignoring all input it receives.
         *
         * This is used to ignore unknown elements and
         * attributes.
         */
        function NoopHandler() { }

        NoopHandler.prototype = Object.create(BaseHandler.prototype);

        NoopHandler.prototype.handleNode = function () {
            return this;
        };

        function BodyHandler() { }

        BodyHandler.prototype = Object.create(BaseHandler.prototype);

        BodyHandler.prototype.handleText = function (text) {
            this.body = (this.body || '') + text;
        };

        function ReferenceHandler(property, context) {
            this.property = property;
            this.context = context;
        }

        ReferenceHandler.prototype = Object.create(BodyHandler.prototype);

        ReferenceHandler.prototype.handleNode = function (node) {

            if (this.element) {
                throw error('expected no sub nodes');
            } else {
                this.element = this.createReference(node);
            }

            return this;
        };

        ReferenceHandler.prototype.handleEnd = function () {
            this.element.id = this.body;
        };

        ReferenceHandler.prototype.createReference = function (node) {
            return {
                property: this.property.ns.name,
                id: ''
            };
        };

        function ValueHandler(propertyDesc, element) {
            this.element = element;
            this.propertyDesc = propertyDesc;
        }

        ValueHandler.prototype = Object.create(BodyHandler.prototype);

        ValueHandler.prototype.handleEnd = function () {

            var value = this.body || '',
                element = this.element,
                propertyDesc = this.propertyDesc;

            value = coerceType(propertyDesc.type, value);

            if (propertyDesc.isMany) {
                element.get(propertyDesc.name).push(value);
            } else {
                element.set(propertyDesc.name, value);
            }
        };


        function BaseElementHandler() { }

        BaseElementHandler.prototype = Object.create(BodyHandler.prototype);

        BaseElementHandler.prototype.handleNode = function (node) {
            var parser = this,
                element = this.element;

            if (!element) {
                element = this.element = this.createElement(node);

                this.context.addElement(element);
            } else {
                parser = this.handleChild(node);
            }

            return parser;
        };

        /**
         * @class XMLReader.ElementHandler
         *
         */
        function ElementHandler(model, type, context) {
            this.model = model;
            this.type = model.getType(type);
            this.context = context;
        }

        ElementHandler.prototype = Object.create(BaseElementHandler.prototype);

        ElementHandler.prototype.addReference = function (reference) {
            this.context.addReference(reference);
        };

        ElementHandler.prototype.handleEnd = function () {

            var value = this.body,
                element = this.element,
                descriptor = getModdleDescriptor(element),
                bodyProperty = descriptor.bodyProperty;

            if (bodyProperty && value !== undefined) {
                value = coerceType(bodyProperty.type, value);
                element.set(bodyProperty.name, value);
            }
        };

        /**
         * Create an instance of the model from the given node.
         *
         * @param  {Element} node the xml node
         */
        ElementHandler.prototype.createElement = function (node) {
            var attributes = parseNodeAttributes(node),
                Type = this.type,
                descriptor = getModdleDescriptor(Type),
                context = this.context,
                instance = new Type({});

            forEach(attributes, function (value, name) {

                var prop = descriptor.propertiesByName[name],
                    values;

                if (prop && prop.isReference) {

                    if (!prop.isMany) {
                        context.addReference({
                            element: instance,
                            property: prop.ns.name,
                            id: value
                        });
                    } else {
                        // IDREFS: parse references as whitespace-separated list
                        values = value.split(' ');

                        forEach(values, function (v) {
                            context.addReference({
                                element: instance,
                                property: prop.ns.name,
                                id: v
                            });
                        });
                    }

                } else {
                    if (prop) {
                        value = coerceType(prop.type, value);
                    }

                    instance.set(name, value);
                }
            });

            return instance;
        };

        ElementHandler.prototype.getPropertyForNode = function (node) {

            var nameNs = parseNameNs(node.local, node.prefix);

            var type = this.type,
                model = this.model,
                descriptor = getModdleDescriptor(type);

            var propertyName = nameNs.name,
                property = descriptor.propertiesByName[propertyName],
                elementTypeName,
                elementType,
                typeAnnotation;

            // search for properties by name first

            if (property) {

                if (serializeAsType(property)) {
                    typeAnnotation = node.attributes[XSI_TYPE];

                    // xsi type is optional, if it does not exists the
                    // default type is assumed
                    if (typeAnnotation) {

                        elementTypeName = typeAnnotation.value;

                        // TODO: extract real name from attribute
                        elementType = model.getType(elementTypeName);

                        return assign({}, property, { effectiveType: getModdleDescriptor(elementType).name });
                    }
                }

                // search for properties by name first
                return property;
            }


            var pkg = model.getPackage(nameNs.prefix);

            if (pkg) {
                elementTypeName = nameNs.prefix + ':' + aliasToName(nameNs.localName, descriptor.$pkg);
                elementType = model.getType(elementTypeName);

                // search for collection members later
                property = find(descriptor.properties, function (p) {
                    return !p.isVirtual && !p.isReference && !p.isAttribute && elementType.hasType(p.type);
                });

                if (property) {
                    return assign({}, property, { effectiveType: getModdleDescriptor(elementType).name });
                }
            } else {
                // parse unknown element (maybe extension)
                property = find(descriptor.properties, function (p) {
                    return !p.isReference && !p.isAttribute && p.type === 'Element';
                });

                if (property) {
                    return property;
                }
            }

            throw error('unrecognized element <' + nameNs.name + '>');
        };

        ElementHandler.prototype.toString = function () {
            return 'ElementDescriptor[' + getModdleDescriptor(this.type).name + ']';
        };

        ElementHandler.prototype.valueHandler = function (propertyDesc, element) {
            return new ValueHandler(propertyDesc, element);
        };

        ElementHandler.prototype.referenceHandler = function (propertyDesc) {
            return new ReferenceHandler(propertyDesc, this.context);
        };

        ElementHandler.prototype.handler = function (type) {
            if (type === 'Element') {
                return new GenericElementHandler(this.model, type, this.context);
            } else {
                return new ElementHandler(this.model, type, this.context);
            }
        };

        /**
         * Handle the child element parsing
         *
         * @param  {Element} node the xml node
         */
        ElementHandler.prototype.handleChild = function (node) {
            var propertyDesc, type, element, childHandler;

            propertyDesc = this.getPropertyForNode(node);
            element = this.element;

            type = propertyDesc.effectiveType || propertyDesc.type;

            if (isSimpleType(type)) {
                return this.valueHandler(propertyDesc, element);
            }

            if (propertyDesc.isReference) {
                childHandler = this.referenceHandler(propertyDesc).handleNode(node);
            } else {
                childHandler = this.handler(type).handleNode(node);
            }

            var newElement = childHandler.element;

            // child handles may decide to skip elements
            // by not returning anything
            if (newElement !== undefined) {

                if (propertyDesc.isMany) {
                    element.get(propertyDesc.name).push(newElement);
                } else {
                    element.set(propertyDesc.name, newElement);
                }

                if (propertyDesc.isReference) {
                    assign(newElement, {
                        element: element
                    });

                    this.context.addReference(newElement);
                } else {
                    // establish child -> parent relationship
                    newElement.$parent = element;
                }
            }

            return childHandler;
        };


        function GenericElementHandler(model, type, context) {
            this.model = model;
            this.context = context;
        }

        GenericElementHandler.prototype = Object.create(BaseElementHandler.prototype);

        GenericElementHandler.prototype.createElement = function (node) {

            var name = node.name,
                prefix = node.prefix,
                uri = node.ns[prefix],
                attributes = node.attributes;

            return this.model.createAny(name, uri, attributes);
        };

        GenericElementHandler.prototype.handleChild = function (node) {

            var handler = new GenericElementHandler(this.model, 'Element', this.context).handleNode(node),
                element = this.element;

            var newElement = handler.element,
                children;

            if (newElement !== undefined) {
                children = element.$children = element.$children || [];
                children.push(newElement);

                // establish child -> parent relationship
                newElement.$parent = element;
            }

            return handler;
        };

        GenericElementHandler.prototype.handleText = function (text) {
            this.body = this.body || '' + text;
        };

        GenericElementHandler.prototype.handleEnd = function () {
            if (this.body) {
                this.element.$body = this.body;
            }
        };

        /**
         * A reader for a meta-model
         *
         * @param {Object} options
         * @param {Model} options.model used to read xml files
         * @param {Boolean} options.lax whether to make parse errors warnings
         */
        function XMLReader(options) {

            if (options instanceof Moddle) {
                options = {
                    model: options
                };
            }

            assign(this, { lax: false }, options);
        }


        /**
         * Parse the given XML into a moddle document tree.
         *
         * @param {String} xml
         * @param {ElementHandler|Object} options or rootHandler
         * @param  {Function} done
         */
        XMLReader.prototype.fromXML = function (xml, options, done) {

            var rootHandler = options.rootHandler;

            if (options instanceof ElementHandler) {
                // root handler passed via (xml, { rootHandler: ElementHandler }, ...)
                rootHandler = options;
                options = {};
            } else {
                if (typeof options === 'string') {
                    // rootHandler passed via (xml, 'someString', ...)
                    rootHandler = this.handler(options);
                    options = {};
                } else if (typeof rootHandler === 'string') {
                    // rootHandler passed via (xml, { rootHandler: 'someString' }, ...)
                    rootHandler = this.handler(rootHandler);
                }
            }

            var model = this.model,
                lax = this.lax;

            var context = new Context(assign({}, options, { rootHandler: rootHandler })),
                parser = new SaxParser(true, { xmlns: true, trim: true }),
                stack = new Stack();

            rootHandler.context = context;

            // push root handler
            stack.push(rootHandler);


            function resolveReferences() {

                var elementsById = context.elementsById;
                var references = context.references;

                var i, r;

                for (i = 0; !!(r = references[i]); i++) {
                    var element = r.element;
                    var reference = elementsById[r.id];
                    var property = getModdleDescriptor(element).propertiesByName[r.property];

                    if (!reference) {
                        context.addWarning({
                            message: 'unresolved reference <' + r.id + '>',
                            element: r.element,
                            property: r.property,
                            value: r.id
                        });
                    }

                    if (property.isMany) {
                        var collection = element.get(property.name),
                            idx = collection.indexOf(r);

                        // we replace an existing place holder (idx != -1) or
                        // append to the collection instead
                        if (idx === -1) {
                            idx = collection.length;
                        }

                        if (!reference) {
                            // remove unresolvable reference
                            collection.splice(idx, 1);
                        } else {
                            // add or update reference in collection
                            collection[idx] = reference;
                        }
                    } else {
                        element.set(property.name, reference);
                    }
                }
            }

            function handleClose(tagName) {
                stack.pop().handleEnd();
            }

            function handleOpen(node) {
                var handler = stack.peek();

                normalizeNamespaces(node, model);

                try {
                    stack.push(handler.handleNode(node));
                } catch (e) {

                    var line = this.line,
                        column = this.column;

                    var message =
                        'unparsable content <' + node.name + '> detected\n\t' +
                        'line: ' + line + '\n\t' +
                        'column: ' + column + '\n\t' +
                        'nested error: ' + e.message;

                    if (lax) {
                        context.addWarning({
                            message: message,
                            error: e
                        });

                        console.warn('could not parse node');
                        console.warn(e);

                        stack.push(new NoopHandler());
                    } else {
                        console.error('could not parse document');
                        console.error(e);

                        throw error(message);
                    }
                }
            }

            function handleText(text) {
                stack.peek().handleText(text);
            }

            parser.onopentag = handleOpen;
            parser.oncdata = parser.ontext = handleText;
            parser.onclosetag = handleClose;
            parser.onend = resolveReferences;

            // deferred parse XML to make loading really ascnchronous
            // this ensures the execution environment (node or browser)
            // is kept responsive and that certain optimization strategies
            // can kick in
            defer(function () {
                var error;

                try {
                    parser.write(xml).close();
                } catch (e) {
                    error = e;
                }

                done(error, error ? undefined : rootHandler.element, context);
            });
        };

        XMLReader.prototype.handler = function (name) {
            return new ElementHandler(this.model, name);
        };

        module.exports = XMLReader;
        module.exports.ElementHandler = ElementHandler;
    }, { "./common": 456, "lodash/collection/find": 303, "lodash/collection/forEach": 304, "lodash/collection/reduce": 307, "lodash/function/defer": 315, "lodash/object/assign": 433, "moddle": 459, "moddle/lib/ns": 464, "moddle/lib/types": 467, "sax": 471, "tiny-stack": 472 }], 458: [function (require, module, exports) {
        'use strict';

        var map = require('lodash/collection/map'),
            forEach = require('lodash/collection/forEach'),
            isString = require('lodash/lang/isString'),
            filter = require('lodash/collection/filter'),
            assign = require('lodash/object/assign');

        var Types = require('moddle/lib/types'),
            parseNameNs = require('moddle/lib/ns').parseName,
            common = require('./common'),
            nameToAlias = common.nameToAlias,
            serializeAsType = common.serializeAsType,
            serializeAsProperty = common.serializeAsProperty;

        var XML_PREAMBLE = '<?xml version="1.0" encoding="UTF-8"?>\n',
            ESCAPE_CHARS = /(<|>|'|"|&|\n\r|\n)/g,
            DEFAULT_NS_MAP = common.DEFAULT_NS_MAP,
            XSI_TYPE = common.XSI_TYPE;


        function nsName(ns) {
            if (isString(ns)) {
                return ns;
            } else {
                return (ns.prefix ? ns.prefix + ':' : '') + ns.localName;
            }
        }

        function getNsAttrs(namespaces) {

            function isUsed(ns) {
                return namespaces.used[ns.uri];
            }

            function toAttr(ns) {
                var name = 'xmlns' + (ns.prefix ? ':' + ns.prefix : '');
                return { name: name, value: ns.uri };
            }

            var allNs = [].concat(namespaces.wellknown, namespaces.custom);

            return map(filter(allNs, isUsed), toAttr);
        }

        function getElementNs(ns, descriptor) {
            if (descriptor.isGeneric) {
                return descriptor.name;
            } else {
                return assign({ localName: nameToAlias(descriptor.ns.localName, descriptor.$pkg) }, ns);
            }
        }

        function getPropertyNs(ns, descriptor) {
            return assign({ localName: descriptor.ns.localName }, ns);
        }

        function getSerializableProperties(element) {
            var descriptor = element.$descriptor;

            return filter(descriptor.properties, function (p) {
                var name = p.name;

                if (p.isVirtual) {
                    return false;
                }

                // do not serialize defaults
                if (!element.hasOwnProperty(name)) {
                    return false;
                }

                var value = element[name];

                // do not serialize default equals
                if (value === p.default) {
                    return false;
                }

                // do not serialize null properties
                if (value === null) {
                    return false;
                }

                return p.isMany ? value.length : true;
            });
        }

        var ESCAPE_MAP = {
            '\n': '10',
            '\n\r': '10',
            '"': '34',
            '\'': '39',
            '<': '60',
            '>': '62',
            '&': '38'
        };

        /**
         * Escape a string attribute to not contain any bad values (line breaks, '"', ...)
         *
         * @param {String} str the string to escape
         * @return {String} the escaped string
         */
        function escapeAttr(str) {

            // ensure we are handling strings here
            str = isString(str) ? str : '' + str;

            return str.replace(ESCAPE_CHARS, function (str) {
                return '&#' + ESCAPE_MAP[str] + ';';
            });
        }

        function filterAttributes(props) {
            return filter(props, function (p) { return p.isAttr; });
        }

        function filterContained(props) {
            return filter(props, function (p) { return !p.isAttr; });
        }


        function ReferenceSerializer(parent, ns) {
            this.ns = ns;
        }

        ReferenceSerializer.prototype.build = function (element) {
            this.element = element;
            return this;
        };

        ReferenceSerializer.prototype.serializeTo = function (writer) {
            writer
                .appendIndent()
                .append('<' + nsName(this.ns) + '>' + this.element.id + '</' + nsName(this.ns) + '>')
                .appendNewLine();
        };

        function BodySerializer() { }

        BodySerializer.prototype.serializeValue = BodySerializer.prototype.serializeTo = function (writer) {
            var escape = this.escape;

            if (escape) {
                writer.append('<![CDATA[');
            }

            writer.append(this.value);

            if (escape) {
                writer.append(']]>');
            }
        };

        BodySerializer.prototype.build = function (prop, value) {
            this.value = value;

            if (prop.type === 'String' && value.search(ESCAPE_CHARS) !== -1) {
                this.escape = true;
            }

            return this;
        };

        function ValueSerializer(ns) {
            this.ns = ns;
        }

        ValueSerializer.prototype = new BodySerializer();

        ValueSerializer.prototype.serializeTo = function (writer) {

            writer
                .appendIndent()
                .append('<' + nsName(this.ns) + '>');

            this.serializeValue(writer);

            writer
                .append('</' + nsName(this.ns) + '>')
                .appendNewLine();
        };

        function ElementSerializer(parent, ns) {
            this.body = [];
            this.attrs = [];

            this.parent = parent;
            this.ns = ns;
        }

        ElementSerializer.prototype.build = function (element) {
            this.element = element;

            var otherAttrs = this.parseNsAttributes(element);

            if (!this.ns) {
                this.ns = this.nsTagName(element.$descriptor);
            }

            if (element.$descriptor.isGeneric) {
                this.parseGeneric(element);
            } else {
                var properties = getSerializableProperties(element);

                this.parseAttributes(filterAttributes(properties));
                this.parseContainments(filterContained(properties));

                this.parseGenericAttributes(element, otherAttrs);
            }

            return this;
        };

        ElementSerializer.prototype.nsTagName = function (descriptor) {
            var effectiveNs = this.logNamespaceUsed(descriptor.ns);
            return getElementNs(effectiveNs, descriptor);
        };

        ElementSerializer.prototype.nsPropertyTagName = function (descriptor) {
            var effectiveNs = this.logNamespaceUsed(descriptor.ns);
            return getPropertyNs(effectiveNs, descriptor);
        };

        ElementSerializer.prototype.isLocalNs = function (ns) {
            return ns.uri === this.ns.uri;
        };

        /**
         * Get the actual ns attribute name for the given element.
         *
         * @param {Object} element
         * @param {Boolean} [inherited=false]
         *
         * @return {Object} nsName
         */
        ElementSerializer.prototype.nsAttributeName = function (element) {

            var ns;

            if (isString(element)) {
                ns = parseNameNs(element);
            } else {
                ns = element.ns;
            }

            // return just local name for inherited attributes
            if (element.inherited) {
                return { localName: ns.localName };
            }

            // parse + log effective ns
            var effectiveNs = this.logNamespaceUsed(ns);

            // strip prefix if same namespace like parent
            if (this.isLocalNs(effectiveNs)) {
                return { localName: ns.localName };
            } else {
                return assign({ localName: ns.localName }, effectiveNs);
            }
        };

        ElementSerializer.prototype.parseGeneric = function (element) {

            var self = this,
                body = this.body,
                attrs = this.attrs;

            forEach(element, function (val, key) {

                if (key === '$body') {
                    body.push(new BodySerializer().build({ type: 'String' }, val));
                } else
                    if (key === '$children') {
                        forEach(val, function (child) {
                            body.push(new ElementSerializer(self).build(child));
                        });
                    } else
                        if (key.indexOf('$') !== 0) {
                            attrs.push({ name: key, value: escapeAttr(val) });
                        }
            });
        };

        /**
         * Parse namespaces and return a list of left over generic attributes
         *
         * @param  {Object} element
         * @return {Array<Object>}
         */
        ElementSerializer.prototype.parseNsAttributes = function (element) {
            var self = this;

            var genericAttrs = element.$attrs;

            var model = element.$model;

            var attributes = [];

            // parse namespace attributes first
            // and log them. push non namespace attributes to a list
            // and process them later
            forEach(genericAttrs, function (value, name) {
                var nameNs = parseNameNs(name);

                var ns;

                // parse xmlns:foo="http://foo.bar"
                if (nameNs.prefix === 'xmlns') {
                    ns = { prefix: nameNs.localName, uri: value };
                }

                // parse xmlns="http://foo.bar"
                if (!nameNs.prefix && nameNs.localName === 'xmlns') {
                    ns = { uri: value };
                }

                if (ns) {
                    if (model.getPackage(value)) {
                        // register well known namespace
                        self.logNamespace(ns, true);
                    } else {
                        // log custom namespace directly as used
                        self.logNamespaceUsed(ns);
                    }
                } else {
                    attributes.push({ name: name, value: value });
                }
            });

            return attributes;
        };

        ElementSerializer.prototype.parseGenericAttributes = function (element, attributes) {

            var self = this;

            forEach(attributes, function (attr) {

                // do not serialize xsi:type attribute
                // it is set manually based on the actual implementation type
                if (attr.name === XSI_TYPE) {
                    return;
                }

                try {
                    self.addAttribute(self.nsAttributeName(attr.name), attr.value);
                } catch (e) {
                    console.warn(
                        'missing namespace information for ',
                        attr.name, '=', attr.value, 'on', element,
                        e);
                }
            });
        };

        ElementSerializer.prototype.parseContainments = function (properties) {

            var self = this,
                body = this.body,
                element = this.element;

            forEach(properties, function (p) {
                var value = element.get(p.name),
                    isReference = p.isReference,
                    isMany = p.isMany;

                var ns = self.nsPropertyTagName(p);

                if (!isMany) {
                    value = [value];
                }

                if (p.isBody) {
                    body.push(new BodySerializer().build(p, value[0]));
                } else
                    if (Types.isSimple(p.type)) {
                        forEach(value, function (v) {
                            body.push(new ValueSerializer(ns).build(p, v));
                        });
                    } else
                        if (isReference) {
                            forEach(value, function (v) {
                                body.push(new ReferenceSerializer(self, ns).build(v));
                            });
                        } else {
                            // allow serialization via type
                            // rather than element name
                            var asType = serializeAsType(p),
                                asProperty = serializeAsProperty(p);

                            forEach(value, function (v) {
                                var serializer;

                                if (asType) {
                                    serializer = new TypeSerializer(self, ns);
                                } else
                                    if (asProperty) {
                                        serializer = new ElementSerializer(self, ns);
                                    } else {
                                        serializer = new ElementSerializer(self);
                                    }

                                body.push(serializer.build(v));
                            });
                        }
            });
        };

        ElementSerializer.prototype.getNamespaces = function () {

            var namespaces = this.namespaces,
                parent = this.parent;

            if (!namespaces) {
                namespaces = this.namespaces = parent ? parent.getNamespaces() : {
                    prefixMap: {},
                    uriMap: {},
                    used: {},
                    wellknown: [],
                    custom: []
                };
            }

            return namespaces;
        };

        ElementSerializer.prototype.logNamespace = function (ns, wellknown) {
            var namespaces = this.getNamespaces();

            var nsUri = ns.uri;

            var existing = namespaces.uriMap[nsUri];

            if (!existing) {
                namespaces.uriMap[nsUri] = ns;

                if (wellknown) {
                    namespaces.wellknown.push(ns);
                } else {
                    namespaces.custom.push(ns);
                }
            }

            namespaces.prefixMap[ns.prefix] = nsUri;

            return ns;
        };

        ElementSerializer.prototype.logNamespaceUsed = function (ns) {
            var element = this.element,
                model = element.$model,
                namespaces = this.getNamespaces();

            // ns may be
            //
            //   * prefix only
            //   * prefix:uri

            var prefix = ns.prefix;

            var wellknownUri = DEFAULT_NS_MAP[prefix] || model && (model.getPackage(prefix) || {}).uri;

            var uri = ns.uri || namespaces.prefixMap[prefix] || wellknownUri;

            if (!uri) {
                throw new Error('no namespace uri given for prefix <' + ns.prefix + '>');
            }

            ns = namespaces.uriMap[uri];

            if (!ns) {
                ns = this.logNamespace({ prefix: prefix, uri: uri }, wellknownUri);
            }

            if (!namespaces.used[ns.uri]) {
                namespaces.used[ns.uri] = ns;
            }

            return ns;
        };

        ElementSerializer.prototype.parseAttributes = function (properties) {
            var self = this,
                element = this.element;

            forEach(properties, function (p) {

                var value = element.get(p.name);

                if (p.isReference) {

                    if (!p.isMany) {
                        value = value.id;
                    }
                    else {
                        var values = [];
                        forEach(value, function (v) {
                            values.push(v.id);
                        });
                        // IDREFS is a whitespace-separated list of references.
                        value = values.join(' ');
                    }

                }

                self.addAttribute(self.nsAttributeName(p), value);
            });
        };

        ElementSerializer.prototype.addAttribute = function (name, value) {
            var attrs = this.attrs;

            if (isString(value)) {
                value = escapeAttr(value);
            }

            attrs.push({ name: name, value: value });
        };

        ElementSerializer.prototype.serializeAttributes = function (writer) {
            var attrs = this.attrs,
                root = !this.parent;

            if (root) {
                attrs = getNsAttrs(this.namespaces).concat(attrs);
            }

            forEach(attrs, function (a) {
                writer
                    .append(' ')
                    .append(nsName(a.name)).append('="').append(a.value).append('"');
            });
        };

        ElementSerializer.prototype.serializeTo = function (writer) {
            var hasBody = this.body.length,
                indent = !(this.body.length === 1 && this.body[0] instanceof BodySerializer);

            writer
                .appendIndent()
                .append('<' + nsName(this.ns));

            this.serializeAttributes(writer);

            writer.append(hasBody ? '>' : ' />');

            if (hasBody) {

                if (indent) {
                    writer
                        .appendNewLine()
                        .indent();
                }

                forEach(this.body, function (b) {
                    b.serializeTo(writer);
                });

                if (indent) {
                    writer
                        .unindent()
                        .appendIndent();
                }

                writer.append('</' + nsName(this.ns) + '>');
            }

            writer.appendNewLine();
        };

        /**
         * A serializer for types that handles serialization of data types
         */
        function TypeSerializer(parent, ns) {
            ElementSerializer.call(this, parent, ns);
        }

        TypeSerializer.prototype = new ElementSerializer();

        TypeSerializer.prototype.build = function (element) {
            var descriptor = element.$descriptor;

            this.element = element;

            this.typeNs = this.nsTagName(descriptor);

            // add xsi:type attribute to represent the elements
            // actual type

            var typeNs = this.typeNs,
                pkg = element.$model.getPackage(typeNs.uri),
                typePrefix = (pkg.xml && pkg.xml.typePrefix) || '';

            this.addAttribute(this.nsAttributeName(XSI_TYPE),
                (typeNs.prefix ? typeNs.prefix + ':' : '') +
                typePrefix + descriptor.ns.localName);

            // do the usual stuff
            return ElementSerializer.prototype.build.call(this, element);
        };

        TypeSerializer.prototype.isLocalNs = function (ns) {
            return ns.uri === this.typeNs.uri;
        };

        function SavingWriter() {
            this.value = '';

            this.write = function (str) {
                this.value += str;
            };
        }

        function FormatingWriter(out, format) {

            var indent = [''];

            this.append = function (str) {
                out.write(str);

                return this;
            };

            this.appendNewLine = function () {
                if (format) {
                    out.write('\n');
                }

                return this;
            };

            this.appendIndent = function () {
                if (format) {
                    out.write(indent.join('  '));
                }

                return this;
            };

            this.indent = function () {
                indent.push('');
                return this;
            };

            this.unindent = function () {
                indent.pop();
                return this;
            };
        }

        /**
         * A writer for meta-model backed document trees
         *
         * @param {Object} options output options to pass into the writer
         */
        function XMLWriter(options) {

            options = assign({ format: false, preamble: true }, options || {});

            function toXML(tree, writer) {
                var internalWriter = writer || new SavingWriter();
                var formatingWriter = new FormatingWriter(internalWriter, options.format);

                if (options.preamble) {
                    formatingWriter.append(XML_PREAMBLE);
                }

                new ElementSerializer().build(tree).serializeTo(formatingWriter);

                if (!writer) {
                    return internalWriter.value;
                }
            }

            return {
                toXML: toXML
            };
        }

        module.exports = XMLWriter;

    }, { "./common": 456, "lodash/collection/filter": 302, "lodash/collection/forEach": 304, "lodash/collection/map": 306, "lodash/lang/isString": 430, "lodash/object/assign": 433, "moddle/lib/ns": 464, "moddle/lib/types": 467 }], 459: [function (require, module, exports) {
        module.exports = require('./lib/moddle');
    }, { "./lib/moddle": 463 }], 460: [function (require, module, exports) {
        'use strict';

        function Base() { }

        Base.prototype.get = function (name) {
            return this.$model.properties.get(this, name);
        };

        Base.prototype.set = function (name, value) {
            this.$model.properties.set(this, name, value);
        };


        module.exports = Base;
    }, {}], 461: [function (require, module, exports) {
        'use strict';

        var pick = require('lodash/object/pick'),
            assign = require('lodash/object/assign'),
            forEach = require('lodash/collection/forEach');

        var parseNameNs = require('./ns').parseName;


        function DescriptorBuilder(nameNs) {
            this.ns = nameNs;
            this.name = nameNs.name;
            this.allTypes = [];
            this.properties = [];
            this.propertiesByName = {};
        }

        module.exports = DescriptorBuilder;


        DescriptorBuilder.prototype.build = function () {
            return pick(this, [
                'ns',
                'name',
                'allTypes',
                'properties',
                'propertiesByName',
                'bodyProperty',
                'idProperty'
            ]);
        };

        /**
         * Add property at given index.
         *
         * @param {Object} p
         * @param {Number} [idx]
         * @param {Boolean} [validate=true]
         */
        DescriptorBuilder.prototype.addProperty = function (p, idx, validate) {

            if (typeof idx === 'boolean') {
                validate = idx;
                idx = undefined;
            }

            this.addNamedProperty(p, validate !== false);

            var properties = this.properties;

            if (idx !== undefined) {
                properties.splice(idx, 0, p);
            } else {
                properties.push(p);
            }
        };


        DescriptorBuilder.prototype.replaceProperty = function (oldProperty, newProperty, replace) {
            var oldNameNs = oldProperty.ns;

            var props = this.properties,
                propertiesByName = this.propertiesByName,
                rename = oldProperty.name !== newProperty.name;

            if (oldProperty.isId) {
                if (!newProperty.isId) {
                    throw new Error(
                        'property <' + newProperty.ns.name + '> must be id property ' +
                        'to refine <' + oldProperty.ns.name + '>');
                }

                this.setIdProperty(newProperty, false);
            }

            if (oldProperty.isBody) {

                if (!newProperty.isBody) {
                    throw new Error(
                        'property <' + newProperty.ns.name + '> must be body property ' +
                        'to refine <' + oldProperty.ns.name + '>');
                }

                // TODO: Check compatibility
                this.setBodyProperty(newProperty, false);
            }

            // validate existence and get location of old property
            var idx = props.indexOf(oldProperty);
            if (idx === -1) {
                throw new Error('property <' + oldNameNs.name + '> not found in property list');
            }

            // remove old property
            props.splice(idx, 1);

            // replacing the named property is intentional
            //
            //  * validate only if this is a "rename" operation
            //  * add at specific index unless we "replace"
            //
            this.addProperty(newProperty, replace ? undefined : idx, rename);

            // make new property available under old name
            propertiesByName[oldNameNs.name] = propertiesByName[oldNameNs.localName] = newProperty;
        };


        DescriptorBuilder.prototype.redefineProperty = function (p, targetPropertyName, replace) {

            var nsPrefix = p.ns.prefix;
            var parts = targetPropertyName.split('#');

            var name = parseNameNs(parts[0], nsPrefix);
            var attrName = parseNameNs(parts[1], name.prefix).name;

            var redefinedProperty = this.propertiesByName[attrName];
            if (!redefinedProperty) {
                throw new Error('refined property <' + attrName + '> not found');
            } else {
                this.replaceProperty(redefinedProperty, p, replace);
            }

            delete p.redefines;
        };

        DescriptorBuilder.prototype.addNamedProperty = function (p, validate) {
            var ns = p.ns,
                propsByName = this.propertiesByName;

            if (validate) {
                this.assertNotDefined(p, ns.name);
                this.assertNotDefined(p, ns.localName);
            }

            propsByName[ns.name] = propsByName[ns.localName] = p;
        };

        DescriptorBuilder.prototype.removeNamedProperty = function (p) {
            var ns = p.ns,
                propsByName = this.propertiesByName;

            delete propsByName[ns.name];
            delete propsByName[ns.localName];
        };

        DescriptorBuilder.prototype.setBodyProperty = function (p, validate) {

            if (validate && this.bodyProperty) {
                throw new Error(
                    'body property defined multiple times ' +
                    '(<' + this.bodyProperty.ns.name + '>, <' + p.ns.name + '>)');
            }

            this.bodyProperty = p;
        };

        DescriptorBuilder.prototype.setIdProperty = function (p, validate) {

            if (validate && this.idProperty) {
                throw new Error(
                    'id property defined multiple times ' +
                    '(<' + this.idProperty.ns.name + '>, <' + p.ns.name + '>)');
            }

            this.idProperty = p;
        };

        DescriptorBuilder.prototype.assertNotDefined = function (p, name) {
            var propertyName = p.name,
                definedProperty = this.propertiesByName[propertyName];

            if (definedProperty) {
                throw new Error(
                    'property <' + propertyName + '> already defined; ' +
                    'override of <' + definedProperty.definedBy.ns.name + '#' + definedProperty.ns.name + '> by ' +
                    '<' + p.definedBy.ns.name + '#' + p.ns.name + '> not allowed without redefines');
            }
        };

        DescriptorBuilder.prototype.hasProperty = function (name) {
            return this.propertiesByName[name];
        };

        DescriptorBuilder.prototype.addTrait = function (t, inherited) {

            var allTypes = this.allTypes;

            if (allTypes.indexOf(t) !== -1) {
                return;
            }

            forEach(t.properties, function (p) {

                // clone property to allow extensions
                p = assign({}, p, {
                    name: p.ns.localName,
                    inherited: inherited
                });

                Object.defineProperty(p, 'definedBy', {
                    value: t
                });

                var replaces = p.replaces,
                    redefines = p.redefines;

                // add replace/redefine support
                if (replaces || redefines) {
                    this.redefineProperty(p, replaces || redefines, replaces);
                } else {
                    if (p.isBody) {
                        this.setBodyProperty(p);
                    }
                    if (p.isId) {
                        this.setIdProperty(p);
                    }
                    this.addProperty(p);
                }
            }, this);

            allTypes.push(t);
        };

    }, { "./ns": 464, "lodash/collection/forEach": 304, "lodash/object/assign": 433, "lodash/object/pick": 440 }], 462: [function (require, module, exports) {
        'use strict';

        var forEach = require('lodash/collection/forEach');

        var Base = require('./base');


        function Factory(model, properties) {
            this.model = model;
            this.properties = properties;
        }

        module.exports = Factory;


        Factory.prototype.createType = function (descriptor) {

            var model = this.model;

            var props = this.properties,
                prototype = Object.create(Base.prototype);

            // initialize default values
            forEach(descriptor.properties, function (p) {
                if (!p.isMany && p.default !== undefined) {
                    prototype[p.name] = p.default;
                }
            });

            props.defineModel(prototype, model);
            props.defineDescriptor(prototype, descriptor);

            var name = descriptor.ns.name;

            /**
             * The new type constructor
             */
            function ModdleElement(attrs) {
                props.define(this, '$type', { value: name, enumerable: true });
                props.define(this, '$attrs', { value: {} });
                props.define(this, '$parent', { writable: true });

                forEach(attrs, function (val, key) {
                    this.set(key, val);
                }, this);
            }

            ModdleElement.prototype = prototype;

            ModdleElement.hasType = prototype.$instanceOf = this.model.hasType;

            // static links
            props.defineModel(ModdleElement, model);
            props.defineDescriptor(ModdleElement, descriptor);

            return ModdleElement;
        };
    }, { "./base": 460, "lodash/collection/forEach": 304 }], 463: [function (require, module, exports) {
        'use strict';

        var isString = require('lodash/lang/isString'),
            isObject = require('lodash/lang/isObject'),
            forEach = require('lodash/collection/forEach'),
            find = require('lodash/collection/find');


        var Factory = require('./factory'),
            Registry = require('./registry'),
            Properties = require('./properties');

        var parseNameNs = require('./ns').parseName;


        //// Moddle implementation /////////////////////////////////////////////////

        /**
         * @class Moddle
         *
         * A model that can be used to create elements of a specific type.
         *
         * @example
         *
         * var Moddle = require('moddle');
         *
         * var pkg = {
         *   name: 'mypackage',
         *   prefix: 'my',
         *   types: [
         *     { name: 'Root' }
         *   ]
         * };
         *
         * var moddle = new Moddle([pkg]);
         *
         * @param {Array<Package>} packages the packages to contain
         */
        function Moddle(packages) {

            this.properties = new Properties(this);

            this.factory = new Factory(this, this.properties);
            this.registry = new Registry(packages, this.properties);

            this.typeCache = {};
        }

        module.exports = Moddle;


        /**
         * Create an instance of the specified type.
         *
         * @method Moddle#create
         *
         * @example
         *
         * var foo = moddle.create('my:Foo');
         * var bar = moddle.create('my:Bar', { id: 'BAR_1' });
         *
         * @param  {String|Object} descriptor the type descriptor or name know to the model
         * @param  {Object} attrs   a number of attributes to initialize the model instance with
         * @return {Object}         model instance
         */
        Moddle.prototype.create = function (descriptor, attrs) {
            var Type = this.getType(descriptor);

            if (!Type) {
                throw new Error('unknown type <' + descriptor + '>');
            }

            return new Type(attrs);
        };


        /**
         * Returns the type representing a given descriptor
         *
         * @method Moddle#getType
         *
         * @example
         *
         * var Foo = moddle.getType('my:Foo');
         * var foo = new Foo({ 'id' : 'FOO_1' });
         *
         * @param  {String|Object} descriptor the type descriptor or name know to the model
         * @return {Object}         the type representing the descriptor
         */
        Moddle.prototype.getType = function (descriptor) {

            var cache = this.typeCache;

            var name = isString(descriptor) ? descriptor : descriptor.ns.name;

            var type = cache[name];

            if (!type) {
                descriptor = this.registry.getEffectiveDescriptor(name);
                type = cache[name] = this.factory.createType(descriptor);
            }

            return type;
        };


        /**
         * Creates an any-element type to be used within model instances.
         *
         * This can be used to create custom elements that lie outside the meta-model.
         * The created element contains all the meta-data required to serialize it
         * as part of meta-model elements.
         *
         * @method Moddle#createAny
         *
         * @example
         *
         * var foo = moddle.createAny('vendor:Foo', 'http://vendor', {
         *   value: 'bar'
         * });
         *
         * var container = moddle.create('my:Container', 'http://my', {
         *   any: [ foo ]
         * });
         *
         * // go ahead and serialize the stuff
         *
         *
         * @param  {String} name  the name of the element
         * @param  {String} nsUri the namespace uri of the element
         * @param  {Object} [properties] a map of properties to initialize the instance with
         * @return {Object} the any type instance
         */
        Moddle.prototype.createAny = function (name, nsUri, properties) {

            var nameNs = parseNameNs(name);

            var element = {
                $type: name
            };

            var descriptor = {
                name: name,
                isGeneric: true,
                ns: {
                    prefix: nameNs.prefix,
                    localName: nameNs.localName,
                    uri: nsUri
                }
            };

            this.properties.defineDescriptor(element, descriptor);
            this.properties.defineModel(element, this);
            this.properties.define(element, '$parent', { enumerable: false, writable: true });

            forEach(properties, function (a, key) {
                if (isObject(a) && a.value !== undefined) {
                    element[a.name] = a.value;
                } else {
                    element[key] = a;
                }
            });

            return element;
        };

        /**
         * Returns a registered package by uri or prefix
         *
         * @return {Object} the package
         */
        Moddle.prototype.getPackage = function (uriOrPrefix) {
            return this.registry.getPackage(uriOrPrefix);
        };

        /**
         * Returns a snapshot of all known packages
         *
         * @return {Object} the package
         */
        Moddle.prototype.getPackages = function () {
            return this.registry.getPackages();
        };

        /**
         * Returns the descriptor for an element
         */
        Moddle.prototype.getElementDescriptor = function (element) {
            return element.$descriptor;
        };

        /**
         * Returns true if the given descriptor or instance
         * represents the given type.
         *
         * May be applied to this, if element is omitted.
         */
        Moddle.prototype.hasType = function (element, type) {
            if (type === undefined) {
                type = element;
                element = this;
            }

            var descriptor = element.$model.getElementDescriptor(element);

            return !!find(descriptor.allTypes, function (t) {
                return t.name === type;
            });
        };

        /**
         * Returns the descriptor of an elements named property
         */
        Moddle.prototype.getPropertyDescriptor = function (element, property) {
            return this.getElementDescriptor(element).propertiesByName[property];
        };

        /**
         * Returns a mapped type's descriptor
         */
        Moddle.prototype.getTypeDescriptor = function (type) {
            return this.registry.typeMap[type];
        };

    }, { "./factory": 462, "./ns": 464, "./properties": 465, "./registry": 466, "lodash/collection/find": 303, "lodash/collection/forEach": 304, "lodash/lang/isObject": 428, "lodash/lang/isString": 430 }], 464: [function (require, module, exports) {
        'use strict';

        /**
         * Parses a namespaced attribute name of the form (ns:)localName to an object,
         * given a default prefix to assume in case no explicit namespace is given.
         *
         * @param {String} name
         * @param {String} [defaultPrefix] the default prefix to take, if none is present.
         *
         * @return {Object} the parsed name
         */
        module.exports.parseName = function (name, defaultPrefix) {
            var parts = name.split(/:/),
                localName, prefix;

            // no prefix (i.e. only local name)
            if (parts.length === 1) {
                localName = name;
                prefix = defaultPrefix;
            } else
                // prefix + local name
                if (parts.length === 2) {
                    localName = parts[1];
                    prefix = parts[0];
                } else {
                    throw new Error('expected <prefix:localName> or <localName>, got ' + name);
                }

            name = (prefix ? prefix + ':' : '') + localName;

            return {
                name: name,
                prefix: prefix,
                localName: localName
            };
        };
    }, {}], 465: [function (require, module, exports) {
        'use strict';


        /**
         * A utility that gets and sets properties of model elements.
         *
         * @param {Model} model
         */
        function Properties(model) {
            this.model = model;
        }

        module.exports = Properties;


        /**
         * Sets a named property on the target element.
         * If the value is undefined, the property gets deleted.
         *
         * @param {Object} target
         * @param {String} name
         * @param {Object} value
         */
        Properties.prototype.set = function (target, name, value) {

            var property = this.model.getPropertyDescriptor(target, name);

            var propertyName = property && property.name;

            if (isUndefined(value)) {
                // unset the property, if the specified value is undefined;
                // delete from $attrs (for extensions) or the target itself
                if (property) {
                    delete target[propertyName];
                } else {
                    delete target.$attrs[name];
                }
            } else {
                // set the property, defining well defined properties on the fly
                // or simply updating them in target.$attrs (for extensions)
                if (property) {
                    if (propertyName in target) {
                        target[propertyName] = value;
                    } else {
                        defineProperty(target, property, value);
                    }
                } else {
                    target.$attrs[name] = value;
                }
            }
        };

        /**
         * Returns the named property of the given element
         *
         * @param  {Object} target
         * @param  {String} name
         *
         * @return {Object}
         */
        Properties.prototype.get = function (target, name) {

            var property = this.model.getPropertyDescriptor(target, name);

            if (!property) {
                return target.$attrs[name];
            }

            var propertyName = property.name;

            // check if access to collection property and lazily initialize it
            if (!target[propertyName] && property.isMany) {
                defineProperty(target, property, []);
            }

            return target[propertyName];
        };


        /**
         * Define a property on the target element
         *
         * @param  {Object} target
         * @param  {String} name
         * @param  {Object} options
         */
        Properties.prototype.define = function (target, name, options) {
            Object.defineProperty(target, name, options);
        };


        /**
         * Define the descriptor for an element
         */
        Properties.prototype.defineDescriptor = function (target, descriptor) {
            this.define(target, '$descriptor', { value: descriptor });
        };

        /**
         * Define the model for an element
         */
        Properties.prototype.defineModel = function (target, model) {
            this.define(target, '$model', { value: model });
        };


        function isUndefined(val) {
            return typeof val === 'undefined';
        }

        function defineProperty(target, property, value) {
            Object.defineProperty(target, property.name, {
                enumerable: !property.isReference,
                writable: true,
                value: value,
                configurable: true
            });
        }
    }, {}], 466: [function (require, module, exports) {
        'use strict';

        var assign = require('lodash/object/assign'),
            forEach = require('lodash/collection/forEach');

        var Types = require('./types'),
            DescriptorBuilder = require('./descriptor-builder');

        var parseNameNs = require('./ns').parseName,
            isBuiltInType = Types.isBuiltIn;


        function Registry(packages, properties) {
            this.packageMap = {};
            this.typeMap = {};

            this.packages = [];

            this.properties = properties;

            forEach(packages, this.registerPackage, this);
        }

        module.exports = Registry;


        Registry.prototype.getPackage = function (uriOrPrefix) {
            return this.packageMap[uriOrPrefix];
        };

        Registry.prototype.getPackages = function () {
            return this.packages;
        };


        Registry.prototype.registerPackage = function (pkg) {

            // copy package
            pkg = assign({}, pkg);

            // register types
            forEach(pkg.types, function (descriptor) {
                this.registerType(descriptor, pkg);
            }, this);

            this.packageMap[pkg.uri] = this.packageMap[pkg.prefix] = pkg;
            this.packages.push(pkg);
        };


        /**
         * Register a type from a specific package with us
         */
        Registry.prototype.registerType = function (type, pkg) {

            type = assign({}, type, {
                superClass: (type.superClass || []).slice(),
                extends: (type.extends || []).slice(),
                properties: (type.properties || []).slice(),
                meta: assign(({}, type.meta || {}))
            });

            var ns = parseNameNs(type.name, pkg.prefix),
                name = ns.name,
                propertiesByName = {};

            // parse properties
            forEach(type.properties, function (p) {

                // namespace property names
                var propertyNs = parseNameNs(p.name, ns.prefix),
                    propertyName = propertyNs.name;

                // namespace property types
                if (!isBuiltInType(p.type)) {
                    p.type = parseNameNs(p.type, propertyNs.prefix).name;
                }

                assign(p, {
                    ns: propertyNs,
                    name: propertyName
                });

                propertiesByName[propertyName] = p;
            });

            // update ns + name
            assign(type, {
                ns: ns,
                name: name,
                propertiesByName: propertiesByName
            });

            forEach(type.extends, function (extendsName) {
                var extended = this.typeMap[extendsName];

                extended.traits = extended.traits || [];
                extended.traits.push(name);
            }, this);

            // link to package
            this.definePackage(type, pkg);

            // register
            this.typeMap[name] = type;
        };


        /**
         * Traverse the type hierarchy from bottom to top,
         * calling iterator with (type, inherited) for all elements in
         * the inheritance chain.
         *
         * @param {Object} nsName
         * @param {Function} iterator
         * @param {Boolean} [trait=false]
         */
        Registry.prototype.mapTypes = function (nsName, iterator, trait) {

            var type = isBuiltInType(nsName.name) ? { name: nsName.name } : this.typeMap[nsName.name];

            var self = this;

            /**
             * Traverse the selected trait.
             *
             * @param {String} cls
             */
            function traverseTrait(cls) {
                return traverseSuper(cls, true);
            }

            /**
             * Traverse the selected super type or trait
             *
             * @param {String} cls
             * @param {Boolean} [trait=false]
             */
            function traverseSuper(cls, trait) {
                var parentNs = parseNameNs(cls, isBuiltInType(cls) ? '' : nsName.prefix);
                self.mapTypes(parentNs, iterator, trait);
            }

            if (!type) {
                throw new Error('unknown type <' + nsName.name + '>');
            }

            forEach(type.superClass, trait ? traverseTrait : traverseSuper);

            // call iterator with (type, inherited=!trait)
            iterator(type, !trait);

            forEach(type.traits, traverseTrait);
        };


        /**
         * Returns the effective descriptor for a type.
         *
         * @param  {String} type the namespaced name (ns:localName) of the type
         *
         * @return {Descriptor} the resulting effective descriptor
         */
        Registry.prototype.getEffectiveDescriptor = function (name) {

            var nsName = parseNameNs(name);

            var builder = new DescriptorBuilder(nsName);

            this.mapTypes(nsName, function (type, inherited) {
                builder.addTrait(type, inherited);
            });

            var descriptor = builder.build();

            // define package link
            this.definePackage(descriptor, descriptor.allTypes[descriptor.allTypes.length - 1].$pkg);

            return descriptor;
        };


        Registry.prototype.definePackage = function (target, pkg) {
            this.properties.define(target, '$pkg', { value: pkg });
        };

    }, { "./descriptor-builder": 461, "./ns": 464, "./types": 467, "lodash/collection/forEach": 304, "lodash/object/assign": 433 }], 467: [function (require, module, exports) {
        'use strict';

        /**
         * Built-in moddle types
         */
        var BUILTINS = {
            String: true,
            Boolean: true,
            Integer: true,
            Real: true,
            Element: true
        };

        /**
         * Converters for built in types from string representations
         */
        var TYPE_CONVERTERS = {
            String: function (s) { return s; },
            Boolean: function (s) { return s === 'true'; },
            Integer: function (s) { return parseInt(s, 10); },
            Real: function (s) { return parseFloat(s, 10); }
        };

        /**
         * Convert a type to its real representation
         */
        module.exports.coerceType = function (type, value) {

            var converter = TYPE_CONVERTERS[type];

            if (converter) {
                return converter(value);
            } else {
                return value;
            }
        };

        /**
         * Return whether the given type is built-in
         */
        module.exports.isBuiltIn = function (type) {
            return !!BUILTINS[type];
        };

        /**
         * Return whether the given type is simple
         */
        module.exports.isSimple = function (type) {
            return !!TYPE_CONVERTERS[type];
        };
    }, {}], 468: [function (require, module, exports) {
        module.exports = require('./lib/refs');

        module.exports.Collection = require('./lib/collection');
    }, { "./lib/collection": 469, "./lib/refs": 470 }], 469: [function (require, module, exports) {
        'use strict';

        /**
         * An empty collection stub. Use {@link RefsCollection.extend} to extend a
         * collection with ref semantics.
         *
         * @class RefsCollection
         */

        /**
         * Extends a collection with {@link Refs} aware methods
         *
         * @memberof RefsCollection
         * @static
         *
         * @param  {Array<Object>} collection
         * @param  {Refs} refs instance
         * @param  {Object} property represented by the collection
         * @param  {Object} target object the collection is attached to
         *
         * @return {RefsCollection<Object>} the extended array
         */
        function extend(collection, refs, property, target) {

            var inverseProperty = property.inverse;

            /**
             * Removes the given element from the array and returns it.
             *
             * @method RefsCollection#remove
             *
             * @param {Object} element the element to remove
             */
            Object.defineProperty(collection, 'remove', {
                value: function (element) {
                    var idx = this.indexOf(element);
                    if (idx !== -1) {
                        this.splice(idx, 1);

                        // unset inverse
                        refs.unset(element, inverseProperty, target);
                    }

                    return element;
                }
            });

            /**
             * Returns true if the collection contains the given element
             *
             * @method RefsCollection#contains
             *
             * @param {Object} element the element to check for
             */
            Object.defineProperty(collection, 'contains', {
                value: function (element) {
                    return this.indexOf(element) !== -1;
                }
            });

            /**
             * Adds an element to the array, unless it exists already (set semantics).
             *
             * @method RefsCollection#add
             *
             * @param {Object} element the element to add
             */
            Object.defineProperty(collection, 'add', {
                value: function (element) {

                    if (!this.contains(element)) {
                        this.push(element);

                        // set inverse
                        refs.set(element, inverseProperty, target);
                    }
                }
            });

            // a simple marker, identifying this element
            // as being a refs collection
            Object.defineProperty(collection, '__refs_collection', {
                value: true
            });

            return collection;
        }


        function isExtended(collection) {
            return collection.__refs_collection === true;
        }

        module.exports.extend = extend;

        module.exports.isExtended = isExtended;
    }, {}], 470: [function (require, module, exports) {
        'use strict';

        var Collection = require('./collection');

        function hasOwnProperty(e, property) {
            return Object.prototype.hasOwnProperty.call(e, property.name || property);
        }

        function defineCollectionProperty(ref, property, target) {
            Object.defineProperty(target, property.name, {
                enumerable: property.enumerable,
                value: Collection.extend(target[property.name] || [], ref, property, target)
            });
        }


        function defineProperty(ref, property, target) {

            var inverseProperty = property.inverse;

            var _value = target[property.name];

            Object.defineProperty(target, property.name, {
                enumerable: property.enumerable,

                get: function () {
                    return _value;
                },

                set: function (value) {

                    // return if we already performed all changes
                    if (value === _value) {
                        return;
                    }

                    var old = _value;

                    // temporary set null
                    _value = null;

                    if (old) {
                        ref.unset(old, inverseProperty, target);
                    }

                    // set new value
                    _value = value;

                    // set inverse value
                    ref.set(_value, inverseProperty, target);
                }
            });

        }

        /**
         * Creates a new references object defining two inversly related
         * attribute descriptors a and b.
         *
         * <p>
         *   When bound to an object using {@link Refs#bind} the references
         *   get activated and ensure that add and remove operations are applied
         *   reversely, too.
         * </p>
         *
         * <p>
         *   For attributes represented as collections {@link Refs} provides the
         *   {@link RefsCollection#add}, {@link RefsCollection#remove} and {@link RefsCollection#contains} extensions
         *   that must be used to properly hook into the inverse change mechanism.
         * </p>
         *
         * @class Refs
         *
         * @classdesc A bi-directional reference between two attributes.
         *
         * @param {Refs.AttributeDescriptor} a property descriptor
         * @param {Refs.AttributeDescriptor} b property descriptor
         *
         * @example
         *
         * var refs = Refs({ name: 'wheels', collection: true, enumerable: true }, { name: 'car' });
         *
         * var car = { name: 'toyota' };
         * var wheels = [{ pos: 'front-left' }, { pos: 'front-right' }];
         *
         * refs.bind(car, 'wheels');
         *
         * car.wheels // []
         * car.wheels.add(wheels[0]);
         * car.wheels.add(wheels[1]);
         *
         * car.wheels // [{ pos: 'front-left' }, { pos: 'front-right' }]
         *
         * wheels[0].car // { name: 'toyota' };
         * car.wheels.remove(wheels[0]);
         *
         * wheels[0].car // undefined
         */
        function Refs(a, b) {

            if (!(this instanceof Refs)) {
                return new Refs(a, b);
            }

            // link
            a.inverse = b;
            b.inverse = a;

            this.props = {};
            this.props[a.name] = a;
            this.props[b.name] = b;
        }

        /**
         * Binds one side of a bi-directional reference to a
         * target object.
         *
         * @memberOf Refs
         *
         * @param  {Object} target
         * @param  {String} property
         */
        Refs.prototype.bind = function (target, property) {
            if (typeof property === 'string') {
                if (!this.props[property]) {
                    throw new Error('no property <' + property + '> in ref');
                }
                property = this.props[property];
            }

            if (property.collection) {
                defineCollectionProperty(this, property, target);
            } else {
                defineProperty(this, property, target);
            }
        };

        Refs.prototype.ensureRefsCollection = function (target, property) {

            var collection = target[property.name];

            if (!Collection.isExtended(collection)) {
                defineCollectionProperty(this, property, target);
            }

            return collection;
        };

        Refs.prototype.ensureBound = function (target, property) {
            if (!hasOwnProperty(target, property)) {
                this.bind(target, property);
            }
        };

        Refs.prototype.unset = function (target, property, value) {

            if (target) {
                this.ensureBound(target, property);

                if (property.collection) {
                    this.ensureRefsCollection(target, property).remove(value);
                } else {
                    target[property.name] = undefined;
                }
            }
        };

        Refs.prototype.set = function (target, property, value) {

            if (target) {
                this.ensureBound(target, property);

                if (property.collection) {
                    this.ensureRefsCollection(target, property).add(value);
                } else {
                    target[property.name] = value;
                }
            }
        };

        module.exports = Refs;


        /**
         * An attribute descriptor to be used specify an attribute in a {@link Refs} instance
         *
         * @typedef {Object} Refs.AttributeDescriptor
         * @property {String} name
         * @property {boolean} [collection=false]
         * @property {boolean} [enumerable=false]
         */
    }, { "./collection": 469 }], 471: [function (require, module, exports) {
        (function (Buffer) {
            // wrapper for non-node envs
            ; (function (sax) {

                sax.parser = function (strict, opt) { return new SAXParser(strict, opt) }
                sax.SAXParser = SAXParser
                sax.SAXStream = SAXStream
                sax.createStream = createStream

                // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.
                // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),
                // since that's the earliest that a buffer overrun could occur.  This way, checks are
                // as rare as required, but as often as necessary to ensure never crossing this bound.
                // Furthermore, buffers are only tested at most once per write(), so passing a very
                // large string into write() might have undesirable effects, but this is manageable by
                // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme
                // edge case, result in creating at most one complete copy of the string passed in.
                // Set to Infinity to have unlimited buffers.
                sax.MAX_BUFFER_LENGTH = 64 * 1024

                var buffers = [
                    "comment", "sgmlDecl", "textNode", "tagName", "doctype",
                    "procInstName", "procInstBody", "entity", "attribName",
                    "attribValue", "cdata", "script"
                ]

                sax.EVENTS = // for discoverability.
                    ["text"
                        , "processinginstruction"
                        , "sgmldeclaration"
                        , "doctype"
                        , "comment"
                        , "attribute"
                        , "opentag"
                        , "closetag"
                        , "opencdata"
                        , "cdata"
                        , "closecdata"
                        , "error"
                        , "end"
                        , "ready"
                        , "script"
                        , "opennamespace"
                        , "closenamespace"
                    ]

                function SAXParser(strict, opt) {
                    if (!(this instanceof SAXParser)) return new SAXParser(strict, opt)

                    var parser = this
                    clearBuffers(parser)
                    parser.q = parser.c = ""
                    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH
                    parser.opt = opt || {}
                    parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags
                    parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase"
                    parser.tags = []
                    parser.closed = parser.closedRoot = parser.sawRoot = false
                    parser.tag = parser.error = null
                    parser.strict = !!strict
                    parser.noscript = !!(strict || parser.opt.noscript)
                    parser.state = S.BEGIN
                    parser.ENTITIES = Object.create(sax.ENTITIES)
                    parser.attribList = []

                    // namespaces form a prototype chain.
                    // it always points at the current tag,
                    // which protos to its parent tag.
                    if (parser.opt.xmlns) parser.ns = Object.create(rootNS)

                    // mostly just for error reporting
                    parser.trackPosition = parser.opt.position !== false
                    if (parser.trackPosition) {
                        parser.position = parser.line = parser.column = 0
                    }
                    emit(parser, "onready")
                }

                if (!Object.create) Object.create = function (o) {
                    function f() { this.__proto__ = o }
                    f.prototype = o
                    return new f
                }

                if (!Object.getPrototypeOf) Object.getPrototypeOf = function (o) {
                    return o.__proto__
                }

                if (!Object.keys) Object.keys = function (o) {
                    var a = []
                    for (var i in o) if (o.hasOwnProperty(i)) a.push(i)
                    return a
                }

                function checkBufferLength(parser) {
                    var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10)
                        , maxActual = 0
                    for (var i = 0, l = buffers.length; i < l; i++) {
                        var len = parser[buffers[i]].length
                        if (len > maxAllowed) {
                            // Text/cdata nodes can get big, and since they're buffered,
                            // we can get here under normal conditions.
                            // Avoid issues by emitting the text node now,
                            // so at least it won't get any bigger.
                            switch (buffers[i]) {
                                case "textNode":
                                    closeText(parser)
                                    break

                                case "cdata":
                                    emitNode(parser, "oncdata", parser.cdata)
                                    parser.cdata = ""
                                    break

                                case "script":
                                    emitNode(parser, "onscript", parser.script)
                                    parser.script = ""
                                    break

                                default:
                                    error(parser, "Max buffer length exceeded: " + buffers[i])
                            }
                        }
                        maxActual = Math.max(maxActual, len)
                    }
                    // schedule the next check for the earliest possible buffer overrun.
                    parser.bufferCheckPosition = (sax.MAX_BUFFER_LENGTH - maxActual)
                        + parser.position
                }

                function clearBuffers(parser) {
                    for (var i = 0, l = buffers.length; i < l; i++) {
                        parser[buffers[i]] = ""
                    }
                }

                function flushBuffers(parser) {
                    closeText(parser)
                    if (parser.cdata !== "") {
                        emitNode(parser, "oncdata", parser.cdata)
                        parser.cdata = ""
                    }
                    if (parser.script !== "") {
                        emitNode(parser, "onscript", parser.script)
                        parser.script = ""
                    }
                }

                SAXParser.prototype =
                {
                    end: function () { end(this) }
                    , write: write
                    , resume: function () { this.error = null; return this }
                    , close: function () { return this.write(null) }
                    , flush: function () { flushBuffers(this) }
                }

                try {
                    var Stream = require("stream").Stream
                } catch (ex) {
                    var Stream = function () { }
                }


                var streamWraps = sax.EVENTS.filter(function (ev) {
                    return ev !== "error" && ev !== "end"
                })

                function createStream(strict, opt) {
                    return new SAXStream(strict, opt)
                }

                function SAXStream(strict, opt) {
                    if (!(this instanceof SAXStream)) return new SAXStream(strict, opt)

                    Stream.apply(this)

                    this._parser = new SAXParser(strict, opt)
                    this.writable = true
                    this.readable = true


                    var me = this

                    this._parser.onend = function () {
                        me.emit("end")
                    }

                    this._parser.onerror = function (er) {
                        me.emit("error", er)

                        // if didn't throw, then means error was handled.
                        // go ahead and clear error, so we can write again.
                        me._parser.error = null
                    }

                    this._decoder = null;

                    streamWraps.forEach(function (ev) {
                        Object.defineProperty(me, "on" + ev, {
                            get: function () { return me._parser["on" + ev] },
                            set: function (h) {
                                if (!h) {
                                    me.removeAllListeners(ev)
                                    return me._parser["on" + ev] = h
                                }
                                me.on(ev, h)
                            },
                            enumerable: true,
                            configurable: false
                        })
                    })
                }

                SAXStream.prototype = Object.create(Stream.prototype,
                    { constructor: { value: SAXStream } })

                SAXStream.prototype.write = function (data) {
                    if (typeof Buffer === 'function' &&
                        typeof Buffer.isBuffer === 'function' &&
                        Buffer.isBuffer(data)) {
                        if (!this._decoder) {
                            var SD = require('string_decoder').StringDecoder
                            this._decoder = new SD('utf8')
                        }
                        data = this._decoder.write(data);
                    }

                    this._parser.write(data.toString())
                    this.emit("data", data)
                    return true
                }

                SAXStream.prototype.end = function (chunk) {
                    if (chunk && chunk.length) this.write(chunk)
                    this._parser.end()
                    return true
                }

                SAXStream.prototype.on = function (ev, handler) {
                    var me = this
                    if (!me._parser["on" + ev] && streamWraps.indexOf(ev) !== -1) {
                        me._parser["on" + ev] = function () {
                            var args = arguments.length === 1 ? [arguments[0]]
                                : Array.apply(null, arguments)
                            args.splice(0, 0, ev)
                            me.emit.apply(me, args)
                        }
                    }

                    return Stream.prototype.on.call(me, ev, handler)
                }



                // character classes and tokens
                var whitespace = "\r\n\t "
                    // this really needs to be replaced with character classes.
                    // XML allows all manner of ridiculous numbers and digits.
                    , number = "0124356789"
                    , letter = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
                    // (Letter | "_" | ":")
                    , quote = "'\""
                    , entity = number + letter + "#"
                    , attribEnd = whitespace + ">"
                    , CDATA = "[CDATA["
                    , DOCTYPE = "DOCTYPE"
                    , XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace"
                    , XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/"
                    , rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE }

                // turn all the string character sets into character class objects.
                whitespace = charClass(whitespace)
                number = charClass(number)
                letter = charClass(letter)

                // http://www.w3.org/TR/REC-xml/#NT-NameStartChar
                // This implementation works on strings, a single character at a time
                // as such, it cannot ever support astral-plane characters (10000-EFFFF)
                // without a significant breaking change to either this  parser, or the
                // JavaScript language.  Implementation of an emoji-capable xml parser
                // is left as an exercise for the reader.
                var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/

                var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040\.\d-]/

                quote = charClass(quote)
                entity = charClass(entity)
                attribEnd = charClass(attribEnd)

                function charClass(str) {
                    return str.split("").reduce(function (s, c) {
                        s[c] = true
                        return s
                    }, {})
                }

                function isRegExp(c) {
                    return Object.prototype.toString.call(c) === '[object RegExp]'
                }

                function is(charclass, c) {
                    return isRegExp(charclass) ? !!c.match(charclass) : charclass[c]
                }

                function not(charclass, c) {
                    return !is(charclass, c)
                }

                var S = 0
                sax.STATE =
                {
                    BEGIN: S++
                    , TEXT: S++ // general stuff
                    , TEXT_ENTITY: S++ // &amp and such.
                    , OPEN_WAKA: S++ // <
                    , SGML_DECL: S++ // <!BLARG
                    , SGML_DECL_QUOTED: S++ // <!BLARG foo "bar
                    , DOCTYPE: S++ // <!DOCTYPE
                    , DOCTYPE_QUOTED: S++ // <!DOCTYPE "//blah
                    , DOCTYPE_DTD: S++ // <!DOCTYPE "//blah" [ ...
                    , DOCTYPE_DTD_QUOTED: S++ // <!DOCTYPE "//blah" [ "foo
                    , COMMENT_STARTING: S++ // <!-
                    , COMMENT: S++ // <!--
                    , COMMENT_ENDING: S++ // <!-- blah -
                    , COMMENT_ENDED: S++ // <!-- blah --
                    , CDATA: S++ // <![CDATA[ something
                    , CDATA_ENDING: S++ // ]
                    , CDATA_ENDING_2: S++ // ]]
                    , PROC_INST: S++ // <?hi
                    , PROC_INST_BODY: S++ // <?hi there
                    , PROC_INST_ENDING: S++ // <?hi "there" ?
                    , OPEN_TAG: S++ // <strong
                    , OPEN_TAG_SLASH: S++ // <strong /
                    , ATTRIB: S++ // <a
                    , ATTRIB_NAME: S++ // <a foo
                    , ATTRIB_NAME_SAW_WHITE: S++ // <a foo _
                    , ATTRIB_VALUE: S++ // <a foo=
                    , ATTRIB_VALUE_QUOTED: S++ // <a foo="bar
                    , ATTRIB_VALUE_CLOSED: S++ // <a foo="bar"
                    , ATTRIB_VALUE_UNQUOTED: S++ // <a foo=bar
                    , ATTRIB_VALUE_ENTITY_Q: S++ // <foo bar="&quot;"
                    , ATTRIB_VALUE_ENTITY_U: S++ // <foo bar=&quot;
                    , CLOSE_TAG: S++ // </a
                    , CLOSE_TAG_SAW_WHITE: S++ // </a   >
                    , SCRIPT: S++ // <script> ...
                    , SCRIPT_ENDING: S++ // <script> ... <
                }

                sax.ENTITIES =
                {
                    "amp": "&"
                    , "gt": ">"
                    , "lt": "<"
                    , "quot": "\""
                    , "apos": "'"
                    , "AElig": 198
                    , "Aacute": 193
                    , "Acirc": 194
                    , "Agrave": 192
                    , "Aring": 197
                    , "Atilde": 195
                    , "Auml": 196
                    , "Ccedil": 199
                    , "ETH": 208
                    , "Eacute": 201
                    , "Ecirc": 202
                    , "Egrave": 200
                    , "Euml": 203
                    , "Iacute": 205
                    , "Icirc": 206
                    , "Igrave": 204
                    , "Iuml": 207
                    , "Ntilde": 209
                    , "Oacute": 211
                    , "Ocirc": 212
                    , "Ograve": 210
                    , "Oslash": 216
                    , "Otilde": 213
                    , "Ouml": 214
                    , "THORN": 222
                    , "Uacute": 218
                    , "Ucirc": 219
                    , "Ugrave": 217
                    , "Uuml": 220
                    , "Yacute": 221
                    , "aacute": 225
                    , "acirc": 226
                    , "aelig": 230
                    , "agrave": 224
                    , "aring": 229
                    , "atilde": 227
                    , "auml": 228
                    , "ccedil": 231
                    , "eacute": 233
                    , "ecirc": 234
                    , "egrave": 232
                    , "eth": 240
                    , "euml": 235
                    , "iacute": 237
                    , "icirc": 238
                    , "igrave": 236
                    , "iuml": 239
                    , "ntilde": 241
                    , "oacute": 243
                    , "ocirc": 244
                    , "ograve": 242
                    , "oslash": 248
                    , "otilde": 245
                    , "ouml": 246
                    , "szlig": 223
                    , "thorn": 254
                    , "uacute": 250
                    , "ucirc": 251
                    , "ugrave": 249
                    , "uuml": 252
                    , "yacute": 253
                    , "yuml": 255
                    , "copy": 169
                    , "reg": 174
                    , "nbsp": 160
                    , "iexcl": 161
                    , "cent": 162
                    , "pound": 163
                    , "curren": 164
                    , "yen": 165
                    , "brvbar": 166
                    , "sect": 167
                    , "uml": 168
                    , "ordf": 170
                    , "laquo": 171
                    , "not": 172
                    , "shy": 173
                    , "macr": 175
                    , "deg": 176
                    , "plusmn": 177
                    , "sup1": 185
                    , "sup2": 178
                    , "sup3": 179
                    , "acute": 180
                    , "micro": 181
                    , "para": 182
                    , "middot": 183
                    , "cedil": 184
                    , "ordm": 186
                    , "raquo": 187
                    , "frac14": 188
                    , "frac12": 189
                    , "frac34": 190
                    , "iquest": 191
                    , "times": 215
                    , "divide": 247
                    , "OElig": 338
                    , "oelig": 339
                    , "Scaron": 352
                    , "scaron": 353
                    , "Yuml": 376
                    , "fnof": 402
                    , "circ": 710
                    , "tilde": 732
                    , "Alpha": 913
                    , "Beta": 914
                    , "Gamma": 915
                    , "Delta": 916
                    , "Epsilon": 917
                    , "Zeta": 918
                    , "Eta": 919
                    , "Theta": 920
                    , "Iota": 921
                    , "Kappa": 922
                    , "Lambda": 923
                    , "Mu": 924
                    , "Nu": 925
                    , "Xi": 926
                    , "Omicron": 927
                    , "Pi": 928
                    , "Rho": 929
                    , "Sigma": 931
                    , "Tau": 932
                    , "Upsilon": 933
                    , "Phi": 934
                    , "Chi": 935
                    , "Psi": 936
                    , "Omega": 937
                    , "alpha": 945
                    , "beta": 946
                    , "gamma": 947
                    , "delta": 948
                    , "epsilon": 949
                    , "zeta": 950
                    , "eta": 951
                    , "theta": 952
                    , "iota": 953
                    , "kappa": 954
                    , "lambda": 955
                    , "mu": 956
                    , "nu": 957
                    , "xi": 958
                    , "omicron": 959
                    , "pi": 960
                    , "rho": 961
                    , "sigmaf": 962
                    , "sigma": 963
                    , "tau": 964
                    , "upsilon": 965
                    , "phi": 966
                    , "chi": 967
                    , "psi": 968
                    , "omega": 969
                    , "thetasym": 977
                    , "upsih": 978
                    , "piv": 982
                    , "ensp": 8194
                    , "emsp": 8195
                    , "thinsp": 8201
                    , "zwnj": 8204
                    , "zwj": 8205
                    , "lrm": 8206
                    , "rlm": 8207
                    , "ndash": 8211
                    , "mdash": 8212
                    , "lsquo": 8216
                    , "rsquo": 8217
                    , "sbquo": 8218
                    , "ldquo": 8220
                    , "rdquo": 8221
                    , "bdquo": 8222
                    , "dagger": 8224
                    , "Dagger": 8225
                    , "bull": 8226
                    , "hellip": 8230
                    , "permil": 8240
                    , "prime": 8242
                    , "Prime": 8243
                    , "lsaquo": 8249
                    , "rsaquo": 8250
                    , "oline": 8254
                    , "frasl": 8260
                    , "euro": 8364
                    , "image": 8465
                    , "weierp": 8472
                    , "real": 8476
                    , "trade": 8482
                    , "alefsym": 8501
                    , "larr": 8592
                    , "uarr": 8593
                    , "rarr": 8594
                    , "darr": 8595
                    , "harr": 8596
                    , "crarr": 8629
                    , "lArr": 8656
                    , "uArr": 8657
                    , "rArr": 8658
                    , "dArr": 8659
                    , "hArr": 8660
                    , "forall": 8704
                    , "part": 8706
                    , "exist": 8707
                    , "empty": 8709
                    , "nabla": 8711
                    , "isin": 8712
                    , "notin": 8713
                    , "ni": 8715
                    , "prod": 8719
                    , "sum": 8721
                    , "minus": 8722
                    , "lowast": 8727
                    , "radic": 8730
                    , "prop": 8733
                    , "infin": 8734
                    , "ang": 8736
                    , "and": 8743
                    , "or": 8744
                    , "cap": 8745
                    , "cup": 8746
                    , "int": 8747
                    , "there4": 8756
                    , "sim": 8764
                    , "cong": 8773
                    , "asymp": 8776
                    , "ne": 8800
                    , "equiv": 8801
                    , "le": 8804
                    , "ge": 8805
                    , "sub": 8834
                    , "sup": 8835
                    , "nsub": 8836
                    , "sube": 8838
                    , "supe": 8839
                    , "oplus": 8853
                    , "otimes": 8855
                    , "perp": 8869
                    , "sdot": 8901
                    , "lceil": 8968
                    , "rceil": 8969
                    , "lfloor": 8970
                    , "rfloor": 8971
                    , "lang": 9001
                    , "rang": 9002
                    , "loz": 9674
                    , "spades": 9824
                    , "clubs": 9827
                    , "hearts": 9829
                    , "diams": 9830
                }

                Object.keys(sax.ENTITIES).forEach(function (key) {
                    var e = sax.ENTITIES[key]
                    var s = typeof e === 'number' ? String.fromCharCode(e) : e
                    sax.ENTITIES[key] = s
                })

                for (var S in sax.STATE) sax.STATE[sax.STATE[S]] = S

                // shorthand
                S = sax.STATE

                function emit(parser, event, data) {
                    parser[event] && parser[event](data)
                }

                function emitNode(parser, nodeType, data) {
                    if (parser.textNode) closeText(parser)
                    emit(parser, nodeType, data)
                }

                function closeText(parser) {
                    parser.textNode = textopts(parser.opt, parser.textNode)
                    if (parser.textNode) emit(parser, "ontext", parser.textNode)
                    parser.textNode = ""
                }

                function textopts(opt, text) {
                    if (opt.trim) text = text.trim()
                    if (opt.normalize) text = text.replace(/\s+/g, " ")
                    return text
                }

                function error(parser, er) {
                    closeText(parser)
                    if (parser.trackPosition) {
                        er += "\nLine: " + parser.line +
                            "\nColumn: " + parser.column +
                            "\nChar: " + parser.c
                    }
                    er = new Error(er)
                    parser.error = er
                    emit(parser, "onerror", er)
                    return parser
                }

                function end(parser) {
                    if (!parser.closedRoot) strictFail(parser, "Unclosed root tag")
                    if ((parser.state !== S.BEGIN) && (parser.state !== S.TEXT)) error(parser, "Unexpected end")
                    closeText(parser)
                    parser.c = ""
                    parser.closed = true
                    emit(parser, "onend")
                    SAXParser.call(parser, parser.strict, parser.opt)
                    return parser
                }

                function strictFail(parser, message) {
                    if (typeof parser !== 'object' || !(parser instanceof SAXParser))
                        throw new Error('bad call to strictFail');
                    if (parser.strict) error(parser, message)
                }

                function newTag(parser) {
                    if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]()
                    var parent = parser.tags[parser.tags.length - 1] || parser
                        , tag = parser.tag = { name: parser.tagName, attributes: {} }

                    // will be overridden if tag contails an xmlns="foo" or xmlns:foo="bar"
                    if (parser.opt.xmlns) tag.ns = parent.ns
                    parser.attribList.length = 0
                }

                function qname(name, attribute) {
                    var i = name.indexOf(":")
                        , qualName = i < 0 ? ["", name] : name.split(":")
                        , prefix = qualName[0]
                        , local = qualName[1]

                    // <x "xmlns"="http://foo">
                    if (attribute && name === "xmlns") {
                        prefix = "xmlns"
                        local = ""
                    }

                    return { prefix: prefix, local: local }
                }

                function attrib(parser) {
                    if (!parser.strict) parser.attribName = parser.attribName[parser.looseCase]()

                    if (parser.attribList.indexOf(parser.attribName) !== -1 ||
                        parser.tag.attributes.hasOwnProperty(parser.attribName)) {
                        return parser.attribName = parser.attribValue = ""
                    }

                    if (parser.opt.xmlns) {
                        var qn = qname(parser.attribName, true)
                            , prefix = qn.prefix
                            , local = qn.local

                        if (prefix === "xmlns") {
                            // namespace binding attribute; push the binding into scope
                            if (local === "xml" && parser.attribValue !== XML_NAMESPACE) {
                                strictFail(parser
                                    , "xml: prefix must be bound to " + XML_NAMESPACE + "\n"
                                    + "Actual: " + parser.attribValue)
                            } else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE) {
                                strictFail(parser
                                    , "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\n"
                                    + "Actual: " + parser.attribValue)
                            } else {
                                var tag = parser.tag
                                    , parent = parser.tags[parser.tags.length - 1] || parser
                                if (tag.ns === parent.ns) {
                                    tag.ns = Object.create(parent.ns)
                                }
                                tag.ns[local] = parser.attribValue
                            }
                        }

                        // defer onattribute events until all attributes have been seen
                        // so any new bindings can take effect; preserve attribute order
                        // so deferred events can be emitted in document order
                        parser.attribList.push([parser.attribName, parser.attribValue])
                    } else {
                        // in non-xmlns mode, we can emit the event right away
                        parser.tag.attributes[parser.attribName] = parser.attribValue
                        emitNode(parser
                            , "onattribute"
                            , {
                                name: parser.attribName
                                , value: parser.attribValue
                            })
                    }

                    parser.attribName = parser.attribValue = ""
                }

                function openTag(parser, selfClosing) {
                    if (parser.opt.xmlns) {
                        // emit namespace binding events
                        var tag = parser.tag

                        // add namespace info to tag
                        var qn = qname(parser.tagName)
                        tag.prefix = qn.prefix
                        tag.local = qn.local
                        tag.uri = tag.ns[qn.prefix] || ""

                        if (tag.prefix && !tag.uri) {
                            strictFail(parser, "Unbound namespace prefix: "
                                + JSON.stringify(parser.tagName))
                            tag.uri = qn.prefix
                        }

                        var parent = parser.tags[parser.tags.length - 1] || parser
                        if (tag.ns && parent.ns !== tag.ns) {
                            Object.keys(tag.ns).forEach(function (p) {
                                emitNode(parser
                                    , "onopennamespace"
                                    , { prefix: p, uri: tag.ns[p] })
                            })
                        }

                        // handle deferred onattribute events
                        // Note: do not apply default ns to attributes:
                        //   http://www.w3.org/TR/REC-xml-names/#defaulting
                        for (var i = 0, l = parser.attribList.length; i < l; i++) {
                            var nv = parser.attribList[i]
                            var name = nv[0]
                                , value = nv[1]
                                , qualName = qname(name, true)
                                , prefix = qualName.prefix
                                , local = qualName.local
                                , uri = prefix == "" ? "" : (tag.ns[prefix] || "")
                                , a = {
                                    name: name
                                    , value: value
                                    , prefix: prefix
                                    , local: local
                                    , uri: uri
                                }

                            // if there's any attributes with an undefined namespace,
                            // then fail on them now.
                            if (prefix && prefix != "xmlns" && !uri) {
                                strictFail(parser, "Unbound namespace prefix: "
                                    + JSON.stringify(prefix))
                                a.uri = prefix
                            }
                            parser.tag.attributes[name] = a
                            emitNode(parser, "onattribute", a)
                        }
                        parser.attribList.length = 0
                    }

                    parser.tag.isSelfClosing = !!selfClosing

                    // process the tag
                    parser.sawRoot = true
                    parser.tags.push(parser.tag)
                    emitNode(parser, "onopentag", parser.tag)
                    if (!selfClosing) {
                        // special case for <script> in non-strict mode.
                        if (!parser.noscript && parser.tagName.toLowerCase() === "script") {
                            parser.state = S.SCRIPT
                        } else {
                            parser.state = S.TEXT
                        }
                        parser.tag = null
                        parser.tagName = ""
                    }
                    parser.attribName = parser.attribValue = ""
                    parser.attribList.length = 0
                }

                function closeTag(parser) {
                    if (!parser.tagName) {
                        strictFail(parser, "Weird empty close tag.")
                        parser.textNode += "</>"
                        parser.state = S.TEXT
                        return
                    }

                    if (parser.script) {
                        if (parser.tagName !== "script") {
                            parser.script += "</" + parser.tagName + ">"
                            parser.tagName = ""
                            parser.state = S.SCRIPT
                            return
                        }
                        emitNode(parser, "onscript", parser.script)
                        parser.script = ""
                    }

                    // first make sure that the closing tag actually exists.
                    // <a><b></c></b></a> will close everything, otherwise.
                    var t = parser.tags.length
                    var tagName = parser.tagName
                    if (!parser.strict) tagName = tagName[parser.looseCase]()
                    var closeTo = tagName
                    while (t--) {
                        var close = parser.tags[t]
                        if (close.name !== closeTo) {
                            // fail the first time in strict mode
                            strictFail(parser, "Unexpected close tag")
                        } else break
                    }

                    // didn't find it.  we already failed for strict, so just abort.
                    if (t < 0) {
                        strictFail(parser, "Unmatched closing tag: " + parser.tagName)
                        parser.textNode += "</" + parser.tagName + ">"
                        parser.state = S.TEXT
                        return
                    }
                    parser.tagName = tagName
                    var s = parser.tags.length
                    while (s-- > t) {
                        var tag = parser.tag = parser.tags.pop()
                        parser.tagName = parser.tag.name
                        emitNode(parser, "onclosetag", parser.tagName)

                        var x = {}
                        for (var i in tag.ns) x[i] = tag.ns[i]

                        var parent = parser.tags[parser.tags.length - 1] || parser
                        if (parser.opt.xmlns && tag.ns !== parent.ns) {
                            // remove namespace bindings introduced by tag
                            Object.keys(tag.ns).forEach(function (p) {
                                var n = tag.ns[p]
                                emitNode(parser, "onclosenamespace", { prefix: p, uri: n })
                            })
                        }
                    }
                    if (t === 0) parser.closedRoot = true
                    parser.tagName = parser.attribValue = parser.attribName = ""
                    parser.attribList.length = 0
                    parser.state = S.TEXT
                }

                function parseEntity(parser) {
                    var entity = parser.entity
                        , entityLC = entity.toLowerCase()
                        , num
                        , numStr = ""
                    if (parser.ENTITIES[entity])
                        return parser.ENTITIES[entity]
                    if (parser.ENTITIES[entityLC])
                        return parser.ENTITIES[entityLC]
                    entity = entityLC
                    if (entity.charAt(0) === "#") {
                        if (entity.charAt(1) === "x") {
                            entity = entity.slice(2)
                            num = parseInt(entity, 16)
                            numStr = num.toString(16)
                        } else {
                            entity = entity.slice(1)
                            num = parseInt(entity, 10)
                            numStr = num.toString(10)
                        }
                    }
                    entity = entity.replace(/^0+/, "")
                    if (numStr.toLowerCase() !== entity) {
                        strictFail(parser, "Invalid character entity")
                        return "&" + parser.entity + ";"
                    }

                    return String.fromCodePoint(num)
                }

                function write(chunk) {
                    var parser = this
                    if (this.error) throw this.error
                    if (parser.closed) return error(parser,
                        "Cannot write after close. Assign an onready handler.")
                    if (chunk === null) return end(parser)
                    var i = 0, c = ""
                    while (parser.c = c = chunk.charAt(i++)) {
                        if (parser.trackPosition) {
                            parser.position++
                            if (c === "\n") {
                                parser.line++
                                parser.column = 0
                            } else parser.column++
                        }
                        switch (parser.state) {

                            case S.BEGIN:
                                if (c === "<") {
                                    parser.state = S.OPEN_WAKA
                                    parser.startTagPosition = parser.position
                                } else if (not(whitespace, c)) {
                                    // have to process this as a text node.
                                    // weird, but happens.
                                    strictFail(parser, "Non-whitespace before first tag.")
                                    parser.textNode = c
                                    parser.state = S.TEXT
                                }
                                continue

                            case S.TEXT:
                                if (parser.sawRoot && !parser.closedRoot) {
                                    var starti = i - 1
                                    while (c && c !== "<" && c !== "&") {
                                        c = chunk.charAt(i++)
                                        if (c && parser.trackPosition) {
                                            parser.position++
                                            if (c === "\n") {
                                                parser.line++
                                                parser.column = 0
                                            } else parser.column++
                                        }
                                    }
                                    parser.textNode += chunk.substring(starti, i - 1)
                                }
                                if (c === "<") {
                                    parser.state = S.OPEN_WAKA
                                    parser.startTagPosition = parser.position
                                } else {
                                    if (not(whitespace, c) && (!parser.sawRoot || parser.closedRoot))
                                        strictFail(parser, "Text data outside of root node.")
                                    if (c === "&") parser.state = S.TEXT_ENTITY
                                    else parser.textNode += c
                                }
                                continue

                            case S.SCRIPT:
                                // only non-strict
                                if (c === "<") {
                                    parser.state = S.SCRIPT_ENDING
                                } else parser.script += c
                                continue

                            case S.SCRIPT_ENDING:
                                if (c === "/") {
                                    parser.state = S.CLOSE_TAG
                                } else {
                                    parser.script += "<" + c
                                    parser.state = S.SCRIPT
                                }
                                continue

                            case S.OPEN_WAKA:
                                // either a /, ?, !, or text is coming next.
                                if (c === "!") {
                                    parser.state = S.SGML_DECL
                                    parser.sgmlDecl = ""
                                } else if (is(whitespace, c)) {
                                    // wait for it...
                                } else if (is(nameStart, c)) {
                                    parser.state = S.OPEN_TAG
                                    parser.tagName = c
                                } else if (c === "/") {
                                    parser.state = S.CLOSE_TAG
                                    parser.tagName = ""
                                } else if (c === "?") {
                                    parser.state = S.PROC_INST
                                    parser.procInstName = parser.procInstBody = ""
                                } else {
                                    strictFail(parser, "Unencoded <")
                                    // if there was some whitespace, then add that in.
                                    if (parser.startTagPosition + 1 < parser.position) {
                                        var pad = parser.position - parser.startTagPosition
                                        c = new Array(pad).join(" ") + c
                                    }
                                    parser.textNode += "<" + c
                                    parser.state = S.TEXT
                                }
                                continue

                            case S.SGML_DECL:
                                if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
                                    emitNode(parser, "onopencdata")
                                    parser.state = S.CDATA
                                    parser.sgmlDecl = ""
                                    parser.cdata = ""
                                } else if (parser.sgmlDecl + c === "--") {
                                    parser.state = S.COMMENT
                                    parser.comment = ""
                                    parser.sgmlDecl = ""
                                } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
                                    parser.state = S.DOCTYPE
                                    if (parser.doctype || parser.sawRoot) strictFail(parser,
                                        "Inappropriately located doctype declaration")
                                    parser.doctype = ""
                                    parser.sgmlDecl = ""
                                } else if (c === ">") {
                                    emitNode(parser, "onsgmldeclaration", parser.sgmlDecl)
                                    parser.sgmlDecl = ""
                                    parser.state = S.TEXT
                                } else if (is(quote, c)) {
                                    parser.state = S.SGML_DECL_QUOTED
                                    parser.sgmlDecl += c
                                } else parser.sgmlDecl += c
                                continue

                            case S.SGML_DECL_QUOTED:
                                if (c === parser.q) {
                                    parser.state = S.SGML_DECL
                                    parser.q = ""
                                }
                                parser.sgmlDecl += c
                                continue

                            case S.DOCTYPE:
                                if (c === ">") {
                                    parser.state = S.TEXT
                                    emitNode(parser, "ondoctype", parser.doctype)
                                    parser.doctype = true // just remember that we saw it.
                                } else {
                                    parser.doctype += c
                                    if (c === "[") parser.state = S.DOCTYPE_DTD
                                    else if (is(quote, c)) {
                                        parser.state = S.DOCTYPE_QUOTED
                                        parser.q = c
                                    }
                                }
                                continue

                            case S.DOCTYPE_QUOTED:
                                parser.doctype += c
                                if (c === parser.q) {
                                    parser.q = ""
                                    parser.state = S.DOCTYPE
                                }
                                continue

                            case S.DOCTYPE_DTD:
                                parser.doctype += c
                                if (c === "]") parser.state = S.DOCTYPE
                                else if (is(quote, c)) {
                                    parser.state = S.DOCTYPE_DTD_QUOTED
                                    parser.q = c
                                }
                                continue

                            case S.DOCTYPE_DTD_QUOTED:
                                parser.doctype += c
                                if (c === parser.q) {
                                    parser.state = S.DOCTYPE_DTD
                                    parser.q = ""
                                }
                                continue

                            case S.COMMENT:
                                if (c === "-") parser.state = S.COMMENT_ENDING
                                else parser.comment += c
                                continue

                            case S.COMMENT_ENDING:
                                if (c === "-") {
                                    parser.state = S.COMMENT_ENDED
                                    parser.comment = textopts(parser.opt, parser.comment)
                                    if (parser.comment) emitNode(parser, "oncomment", parser.comment)
                                    parser.comment = ""
                                } else {
                                    parser.comment += "-" + c
                                    parser.state = S.COMMENT
                                }
                                continue

                            case S.COMMENT_ENDED:
                                if (c !== ">") {
                                    strictFail(parser, "Malformed comment")
                                    // allow <!-- blah -- bloo --> in non-strict mode,
                                    // which is a comment of " blah -- bloo "
                                    parser.comment += "--" + c
                                    parser.state = S.COMMENT
                                } else parser.state = S.TEXT
                                continue

                            case S.CDATA:
                                if (c === "]") parser.state = S.CDATA_ENDING
                                else parser.cdata += c
                                continue

                            case S.CDATA_ENDING:
                                if (c === "]") parser.state = S.CDATA_ENDING_2
                                else {
                                    parser.cdata += "]" + c
                                    parser.state = S.CDATA
                                }
                                continue

                            case S.CDATA_ENDING_2:
                                if (c === ">") {
                                    if (parser.cdata) emitNode(parser, "oncdata", parser.cdata)
                                    emitNode(parser, "onclosecdata")
                                    parser.cdata = ""
                                    parser.state = S.TEXT
                                } else if (c === "]") {
                                    parser.cdata += "]"
                                } else {
                                    parser.cdata += "]]" + c
                                    parser.state = S.CDATA
                                }
                                continue

                            case S.PROC_INST:
                                if (c === "?") parser.state = S.PROC_INST_ENDING
                                else if (is(whitespace, c)) parser.state = S.PROC_INST_BODY
                                else parser.procInstName += c
                                continue

                            case S.PROC_INST_BODY:
                                if (!parser.procInstBody && is(whitespace, c)) continue
                                else if (c === "?") parser.state = S.PROC_INST_ENDING
                                else parser.procInstBody += c
                                continue

                            case S.PROC_INST_ENDING:
                                if (c === ">") {
                                    emitNode(parser, "onprocessinginstruction", {
                                        name: parser.procInstName,
                                        body: parser.procInstBody
                                    })
                                    parser.procInstName = parser.procInstBody = ""
                                    parser.state = S.TEXT
                                } else {
                                    parser.procInstBody += "?" + c
                                    parser.state = S.PROC_INST_BODY
                                }
                                continue

                            case S.OPEN_TAG:
                                if (is(nameBody, c)) parser.tagName += c
                                else {
                                    newTag(parser)
                                    if (c === ">") openTag(parser)
                                    else if (c === "/") parser.state = S.OPEN_TAG_SLASH
                                    else {
                                        if (not(whitespace, c)) strictFail(
                                            parser, "Invalid character in tag name")
                                        parser.state = S.ATTRIB
                                    }
                                }
                                continue

                            case S.OPEN_TAG_SLASH:
                                if (c === ">") {
                                    openTag(parser, true)
                                    closeTag(parser)
                                } else {
                                    strictFail(parser, "Forward-slash in opening tag not followed by >")
                                    parser.state = S.ATTRIB
                                }
                                continue

                            case S.ATTRIB:
                                // haven't read the attribute name yet.
                                if (is(whitespace, c)) continue
                                else if (c === ">") openTag(parser)
                                else if (c === "/") parser.state = S.OPEN_TAG_SLASH
                                else if (is(nameStart, c)) {
                                    parser.attribName = c
                                    parser.attribValue = ""
                                    parser.state = S.ATTRIB_NAME
                                } else strictFail(parser, "Invalid attribute name")
                                continue

                            case S.ATTRIB_NAME:
                                if (c === "=") parser.state = S.ATTRIB_VALUE
                                else if (c === ">") {
                                    strictFail(parser, "Attribute without value")
                                    parser.attribValue = parser.attribName
                                    attrib(parser)
                                    openTag(parser)
                                }
                                else if (is(whitespace, c)) parser.state = S.ATTRIB_NAME_SAW_WHITE
                                else if (is(nameBody, c)) parser.attribName += c
                                else strictFail(parser, "Invalid attribute name")
                                continue

                            case S.ATTRIB_NAME_SAW_WHITE:
                                if (c === "=") parser.state = S.ATTRIB_VALUE
                                else if (is(whitespace, c)) continue
                                else {
                                    strictFail(parser, "Attribute without value")
                                    parser.tag.attributes[parser.attribName] = ""
                                    parser.attribValue = ""
                                    emitNode(parser, "onattribute",
                                        { name: parser.attribName, value: "" })
                                    parser.attribName = ""
                                    if (c === ">") openTag(parser)
                                    else if (is(nameStart, c)) {
                                        parser.attribName = c
                                        parser.state = S.ATTRIB_NAME
                                    } else {
                                        strictFail(parser, "Invalid attribute name")
                                        parser.state = S.ATTRIB
                                    }
                                }
                                continue

                            case S.ATTRIB_VALUE:
                                if (is(whitespace, c)) continue
                                else if (is(quote, c)) {
                                    parser.q = c
                                    parser.state = S.ATTRIB_VALUE_QUOTED
                                } else {
                                    strictFail(parser, "Unquoted attribute value")
                                    parser.state = S.ATTRIB_VALUE_UNQUOTED
                                    parser.attribValue = c
                                }
                                continue

                            case S.ATTRIB_VALUE_QUOTED:
                                if (c !== parser.q) {
                                    if (c === "&") parser.state = S.ATTRIB_VALUE_ENTITY_Q
                                    else parser.attribValue += c
                                    continue
                                }
                                attrib(parser)
                                parser.q = ""
                                parser.state = S.ATTRIB_VALUE_CLOSED
                                continue

                            case S.ATTRIB_VALUE_CLOSED:
                                if (is(whitespace, c)) {
                                    parser.state = S.ATTRIB
                                } else if (c === ">") openTag(parser)
                                else if (c === "/") parser.state = S.OPEN_TAG_SLASH
                                else if (is(nameStart, c)) {
                                    strictFail(parser, "No whitespace between attributes")
                                    parser.attribName = c
                                    parser.attribValue = ""
                                    parser.state = S.ATTRIB_NAME
                                } else strictFail(parser, "Invalid attribute name")
                                continue

                            case S.ATTRIB_VALUE_UNQUOTED:
                                if (not(attribEnd, c)) {
                                    if (c === "&") parser.state = S.ATTRIB_VALUE_ENTITY_U
                                    else parser.attribValue += c
                                    continue
                                }
                                attrib(parser)
                                if (c === ">") openTag(parser)
                                else parser.state = S.ATTRIB
                                continue

                            case S.CLOSE_TAG:
                                if (!parser.tagName) {
                                    if (is(whitespace, c)) continue
                                    else if (not(nameStart, c)) {
                                        if (parser.script) {
                                            parser.script += "</" + c
                                            parser.state = S.SCRIPT
                                        } else {
                                            strictFail(parser, "Invalid tagname in closing tag.")
                                        }
                                    } else parser.tagName = c
                                }
                                else if (c === ">") closeTag(parser)
                                else if (is(nameBody, c)) parser.tagName += c
                                else if (parser.script) {
                                    parser.script += "</" + parser.tagName
                                    parser.tagName = ""
                                    parser.state = S.SCRIPT
                                } else {
                                    if (not(whitespace, c)) strictFail(parser,
                                        "Invalid tagname in closing tag")
                                    parser.state = S.CLOSE_TAG_SAW_WHITE
                                }
                                continue

                            case S.CLOSE_TAG_SAW_WHITE:
                                if (is(whitespace, c)) continue
                                if (c === ">") closeTag(parser)
                                else strictFail(parser, "Invalid characters in closing tag")
                                continue

                            case S.TEXT_ENTITY:
                            case S.ATTRIB_VALUE_ENTITY_Q:
                            case S.ATTRIB_VALUE_ENTITY_U:
                                switch (parser.state) {
                                    case S.TEXT_ENTITY:
                                        var returnState = S.TEXT, buffer = "textNode"
                                        break

                                    case S.ATTRIB_VALUE_ENTITY_Q:
                                        var returnState = S.ATTRIB_VALUE_QUOTED, buffer = "attribValue"
                                        break

                                    case S.ATTRIB_VALUE_ENTITY_U:
                                        var returnState = S.ATTRIB_VALUE_UNQUOTED, buffer = "attribValue"
                                        break
                                }
                                if (c === ";") {
                                    parser[buffer] += parseEntity(parser)
                                    parser.entity = ""
                                    parser.state = returnState
                                }
                                else if (is(entity, c)) parser.entity += c
                                else {
                                    strictFail(parser, "Invalid character entity")
                                    parser[buffer] += "&" + parser.entity + c
                                    parser.entity = ""
                                    parser.state = returnState
                                }
                                continue

                            default:
                                throw new Error(parser, "Unknown state: " + parser.state)
                        }
                    } // while
                    // cdata blocks can get very big under normal conditions. emit and move on.
                    // if (parser.state === S.CDATA && parser.cdata) {
                    //   emitNode(parser, "oncdata", parser.cdata)
                    //   parser.cdata = ""
                    // }
                    if (parser.position >= parser.bufferCheckPosition) checkBufferLength(parser)
                    return parser
                }

                /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
                if (!String.fromCodePoint) {
                    (function () {
                        var stringFromCharCode = String.fromCharCode;
                        var floor = Math.floor;
                        var fromCodePoint = function () {
                            var MAX_SIZE = 0x4000;
                            var codeUnits = [];
                            var highSurrogate;
                            var lowSurrogate;
                            var index = -1;
                            var length = arguments.length;
                            if (!length) {
                                return '';
                            }
                            var result = '';
                            while (++index < length) {
                                var codePoint = Number(arguments[index]);
                                if (
                                    !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
                                    codePoint < 0 || // not a valid Unicode code point
                                    codePoint > 0x10FFFF || // not a valid Unicode code point
                                    floor(codePoint) != codePoint // not an integer
                                ) {
                                    throw RangeError('Invalid code point: ' + codePoint);
                                }
                                if (codePoint <= 0xFFFF) { // BMP code point
                                    codeUnits.push(codePoint);
                                } else { // Astral code point; split in surrogate halves
                                    // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
                                    codePoint -= 0x10000;
                                    highSurrogate = (codePoint >> 10) + 0xD800;
                                    lowSurrogate = (codePoint % 0x400) + 0xDC00;
                                    codeUnits.push(highSurrogate, lowSurrogate);
                                }
                                if (index + 1 == length || codeUnits.length > MAX_SIZE) {
                                    result += stringFromCharCode.apply(null, codeUnits);
                                    codeUnits.length = 0;
                                }
                            }
                            return result;
                        };
                        if (Object.defineProperty) {
                            Object.defineProperty(String, 'fromCodePoint', {
                                'value': fromCodePoint,
                                'configurable': true,
                                'writable': true
                            });
                        } else {
                            String.fromCodePoint = fromCodePoint;
                        }
                    }());
                }

            })(typeof exports === "undefined" ? sax = {} : exports);

        }).call(this, undefined)
    }, { "stream": undefined, "string_decoder": undefined }], 472: [function (require, module, exports) {
        /**
         * Tiny stack for browser or server
         *
         * @author Jason Mulligan <jason.mulligan@avoidwork.com>
         * @copyright 2014 Jason Mulligan
         * @license BSD-3 <https://raw.github.com/avoidwork/tiny-stack/master/LICENSE>
         * @link http://avoidwork.github.io/tiny-stack
         * @module tiny-stack
         * @version 0.1.0
         */

        (function (global) {

            "use strict";

            /**
             * TinyStack
             *
             * @constructor
             */
            function TinyStack() {
                this.data = [null];
                this.top = 0;
            }

            /**
             * Clears the stack
             *
             * @method clear
             * @memberOf TinyStack
             * @return {Object} {@link TinyStack}
             */
            TinyStack.prototype.clear = function clear() {
                this.data = [null];
                this.top = 0;

                return this;
            };

            /**
             * Gets the size of the stack
             *
             * @method length
             * @memberOf TinyStack
             * @return {Number} Size of stack
             */
            TinyStack.prototype.length = function length() {
                return this.top;
            };

            /**
             * Gets the item at the top of the stack
             *
             * @method peek
             * @memberOf TinyStack
             * @return {Mixed} Item at the top of the stack
             */
            TinyStack.prototype.peek = function peek() {
                return this.data[this.top];
            };

            /**
             * Gets & removes the item at the top of the stack
             *
             * @method pop
             * @memberOf TinyStack
             * @return {Mixed} Item at the top of the stack
             */
            TinyStack.prototype.pop = function pop() {
                if (this.top > 0) {
                    this.top--;

                    return this.data.pop();
                }
                else {
                    return undefined;
                }
            };

            /**
             * Pushes an item onto the stack
             *
             * @method push
             * @memberOf TinyStack
             * @return {Object} {@link TinyStack}
             */
            TinyStack.prototype.push = function push(arg) {
                this.data[++this.top] = arg;

                return this;
            };

            /**
             * TinyStack factory
             *
             * @method factory
             * @return {Object} {@link TinyStack}
             */
            function factory() {
                return new TinyStack();
            }

            // Node, AMD & window supported
            if (typeof exports != "undefined") {
                module.exports = factory;
            }
            else if (typeof define == "function") {
                define(function () {
                    return factory;
                });
            }
            else {
                global.stack = factory;
            }
        })(this);

    }, {}], 473: [function (require, module, exports) {
        /**
         * append utility
         */

        module.exports = append;

        var appendTo = require('./appendTo');

        /**
         * Append a node to an element
         *
         * @param  {SVGElement} element
         * @param  {SVGElement} node
         *
         * @return {SVGElement} the element
         */
        function append(element, node) {
            appendTo(node, element);
            return element;
        }
    }, { "./appendTo": 474 }], 474: [function (require, module, exports) {
        /**
         * appendTo utility
         */
        module.exports = appendTo;

        var ensureImported = require('./util/ensureImported');

        /**
         * Append a node to a target element and return the appended node.
         *
         * @param  {SVGElement} element
         * @param  {SVGElement} node
         *
         * @return {SVGElement} the appended node
         */
        function appendTo(element, target) {
            target.appendChild(ensureImported(element, target));
            return element;
        }
    }, { "./util/ensureImported": 484 }], 475: [function (require, module, exports) {
        /**
         * attribute accessor utility
         */

        module.exports = attr;


        var LENGTH_ATTR = 2;

        var CSS_PROPERTIES = {
            'alignment-baseline': 1,
            'baseline-shift': 1,
            'clip': 1,
            'clip-path': 1,
            'clip-rule': 1,
            'color': 1,
            'color-interpolation': 1,
            'color-interpolation-filters': 1,
            'color-profile': 1,
            'color-rendering': 1,
            'cursor': 1,
            'direction': 1,
            'display': 1,
            'dominant-baseline': 1,
            'enable-background': 1,
            'fill': 1,
            'fill-opacity': 1,
            'fill-rule': 1,
            'filter': 1,
            'flood-color': 1,
            'flood-opacity': 1,
            'font': 1,
            'font-family': 1,
            'font-size': LENGTH_ATTR,
            'font-size-adjust': 1,
            'font-stretch': 1,
            'font-style': 1,
            'font-variant': 1,
            'font-weight': 1,
            'glyph-orientation-horizontal': 1,
            'glyph-orientation-vertical': 1,
            'image-rendering': 1,
            'kerning': 1,
            'letter-spacing': 1,
            'lighting-color': 1,
            'marker': 1,
            'marker-end': 1,
            'marker-mid': 1,
            'marker-start': 1,
            'mask': 1,
            'opacity': 1,
            'overflow': 1,
            'pointer-events': 1,
            'shape-rendering': 1,
            'stop-color': 1,
            'stop-opacity': 1,
            'stroke': 1,
            'stroke-dasharray': 1,
            'stroke-dashoffset': 1,
            'stroke-linecap': 1,
            'stroke-linejoin': 1,
            'stroke-miterlimit': 1,
            'stroke-opacity': 1,
            'stroke-width': LENGTH_ATTR,
            'text-anchor': 1,
            'text-decoration': 1,
            'text-rendering': 1,
            'unicode-bidi': 1,
            'visibility': 1,
            'word-spacing': 1,
            'writing-mode': 1
        };


        function getAttribute(node, name) {
            if (CSS_PROPERTIES[name]) {
                return node.style[name];
            } else {
                return node.getAttributeNS(null, name);
            }
        }

        function setAttribute(node, name, value) {
            var hyphenated = name.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();

            var type = CSS_PROPERTIES[hyphenated];

            if (type) {
                // append pixel unit, unless present
                if (type === LENGTH_ATTR && typeof value === 'number') {
                    value = String(value) + 'px';
                }

                node.style[hyphenated] = value;
            } else {
                node.setAttributeNS(null, name, value);
            }
        }

        function setAttributes(node, attrs) {

            var names = Object.keys(attrs), i, name;

            for (i = 0, name; (name = names[i]); i++) {
                setAttribute(node, name, attrs[name]);
            }
        }

        /**
         * Gets or sets raw attributes on a node.
         *
         * @param  {SVGElement} node
         * @param  {Object} [attrs]
         * @param  {String} [name]
         * @param  {String} [value]
         *
         * @return {String}
         */
        function attr(node, name, value) {
            if (typeof name === 'string') {
                if (value !== undefined) {
                    setAttribute(node, name, value);
                } else {
                    return getAttribute(node, name);
                }
            } else {
                setAttributes(node, name);
            }

            return node;
        }

    }, {}], 476: [function (require, module, exports) {
        /**
         * Clear utility
         */
        module.exports = classes;

        var index = function (arr, obj) {
            if (arr.indexOf) {
                return arr.indexOf(obj);
            }


            for (var i = 0; i < arr.length; ++i) {
                if (arr[i] === obj) {
                    return i;
                }
            }

            return -1;
        };

        var re = /\s+/;

        var toString = Object.prototype.toString;

        function defined(o) {
            return typeof o !== 'undefined';
        }

        /**
         * Wrap `el` in a `ClassList`.
         *
         * @param {Element} el
         * @return {ClassList}
         * @api public
         */

        function classes(el) {
            return new ClassList(el);
        }

        function ClassList(el) {
            if (!el || !el.nodeType) {
                throw new Error('A DOM element reference is required');
            }
            this.el = el;
            this.list = el.classList;
        }

        /**
         * Add class `name` if not already present.
         *
         * @param {String} name
         * @return {ClassList}
         * @api public
         */

        ClassList.prototype.add = function (name) {

            // classList
            if (this.list) {
                this.list.add(name);
                return this;
            }

            // fallback
            var arr = this.array();
            var i = index(arr, name);
            if (!~i) {
                arr.push(name);
            }

            if (defined(this.el.className.baseVal)) {
                this.el.className.baseVal = arr.join(' ');
            } else {
                this.el.className = arr.join(' ');
            }

            return this;
        };

        /**
         * Remove class `name` when present, or
         * pass a regular expression to remove
         * any which match.
         *
         * @param {String|RegExp} name
         * @return {ClassList}
         * @api public
         */

        ClassList.prototype.remove = function (name) {
            if ('[object RegExp]' === toString.call(name)) {
                return this.removeMatching(name);
            }

            // classList
            if (this.list) {
                this.list.remove(name);
                return this;
            }

            // fallback
            var arr = this.array();
            var i = index(arr, name);
            if (~i) {
                arr.splice(i, 1);
            }
            this.el.className.baseVal = arr.join(' ');
            return this;
        };

        /**
         * Remove all classes matching `re`.
         *
         * @param {RegExp} re
         * @return {ClassList}
         * @api private
         */

        ClassList.prototype.removeMatching = function (re) {
            var arr = this.array();
            for (var i = 0; i < arr.length; i++) {
                if (re.test(arr[i])) {
                    this.remove(arr[i]);
                }
            }
            return this;
        };

        /**
         * Toggle class `name`, can force state via `force`.
         *
         * For browsers that support classList, but do not support `force` yet,
         * the mistake will be detected and corrected.
         *
         * @param {String} name
         * @param {Boolean} force
         * @return {ClassList}
         * @api public
         */

        ClassList.prototype.toggle = function (name, force) {
            // classList
            if (this.list) {
                if (defined(force)) {
                    if (force !== this.list.toggle(name, force)) {
                        this.list.toggle(name); // toggle again to correct
                    }
                } else {
                    this.list.toggle(name);
                }
                return this;
            }

            // fallback
            if (defined(force)) {
                if (!force) {
                    this.remove(name);
                } else {
                    this.add(name);
                }
            } else {
                if (this.has(name)) {
                    this.remove(name);
                } else {
                    this.add(name);
                }
            }

            return this;
        };

        /**
         * Return an array of classes.
         *
         * @return {Array}
         * @api public
         */

        ClassList.prototype.array = function () {
            var className = this.el.getAttribute('class') || '';
            var str = className.replace(/^\s+|\s+$/g, '');
            var arr = str.split(re);
            if ('' === arr[0]) {
                arr.shift();
            }
            return arr;
        };

        /**
         * Check if class `name` is present.
         *
         * @param {String} name
         * @return {ClassList}
         * @api public
         */

        ClassList.prototype.has =
            ClassList.prototype.contains = function (name) {
                return (
                    this.list ?
                        this.list.contains(name) :
                        !! ~index(this.array(), name)
                );
            };

    }, {}], 477: [function (require, module, exports) {
        /**
         * Clear utility
         */

        module.exports = clear;


        var remove = require('./remove');

        /**
         * Removes all children from the given element
         *
         * @param  {DOMElement} element
         * @return {DOMElement} the element (for chaining)
         */
        function clear(element) {
            var child;

            while ((child = element.firstChild)) {
                remove(child);
            }

            return element;
        }
    }, { "./remove": 482 }], 478: [function (require, module, exports) {
        module.exports = clone;

        function clone(element) {
            return element.cloneNode(true);
        }
    }, {}], 479: [function (require, module, exports) {
        /**
         * Create utility for SVG elements
         */

        module.exports = create;


        var attr = require('./attr');
        var parse = require('./util/parse');
        var ns = require('./util/ns');


        /**
         * Create a specific type from name or SVG markup.
         *
         * @param {String} name the name or markup of the element
         * @param {Object} [attrs] attributes to set on the element
         *
         * @returns {SVGElement}
         */
        function create(name, attrs) {
            var element;

            if (name.charAt(0) === '<') {
                element = parse(name).firstChild;
                element = document.importNode(element, true);
            } else {
                element = document.createElementNS(ns.svg, name);
            }

            if (attrs) {
                attr(element, attrs);
            }

            return element;
        }
    }, { "./attr": 475, "./util/ns": 485, "./util/parse": 486 }], 480: [function (require, module, exports) {
        /**
         * Geometry helpers
         */

        module.exports = { createPoint: createPoint, createMatrix: createMatrix, createTransform: createTransform };


        var create = require('./create');

        // fake node used to instantiate svg geometry elements
        var node = create('svg');

        function extend(object, props) {
            var i, k, keys = Object.keys(props);

            for (i = 0; (k = keys[i]); i++) {
                object[k] = props[k];
            }

            return object;
        }


        function createPoint(x, y) {
            var point = node.createSVGPoint();

            switch (arguments.length) {
                case 0:
                    return point;
                case 2:
                    x = {
                        x: x,
                        y: y
                    };
                    break;
            }

            return extend(point, x);
        }

        function createMatrix(a, b, c, d, e, f) {
            var matrix = node.createSVGMatrix();

            switch (arguments.length) {
                case 0:
                    return matrix;
                case 6:
                    a = {
                        a: a,
                        b: b,
                        c: c,
                        d: d,
                        e: e,
                        f: f
                    };
                    break;
            }

            return extend(matrix, a);
        }

        function createTransform(matrix) {
            if (matrix) {
                return node.createSVGTransformFromMatrix(matrix);
            } else {
                return node.createSVGTransform();
            }
        }
    }, { "./create": 479 }], 481: [function (require, module, exports) {
        /**
         * innerHTML like functionality for SVG elements.
         * based on innerSVG (https://code.google.com/p/innersvg)
         */

        module.exports = innerSVG;


        var clear = require('./clear');
        var appendTo = require('./appendTo');
        var parse = require('./util/parse');
        var serialize = require('./util/serialize');


        function set(element, svg) {

            var node,
                documentElement = parse(svg).documentElement;

            // clear element contents
            clear(element);

            if (!svg) {
                return;
            }

            // import + append each node
            node = documentElement.firstChild;

            while (node) {
                appendTo(node, element);
                node = node.nextSibling;
            }
        }

        function get(element) {
            var child = element.firstChild,
                output = [];

            while (child) {
                serialize(child, output);
                child = child.nextSibling;
            }

            return output.join('');
        }

        function innerSVG(element, svg) {

            if (svg !== undefined) {

                try {
                    set(element, svg);
                } catch (e) {
                    throw new Error('error parsing SVG: ' + e.message);
                }

                return element;
            } else {
                return get(element);
            }
        }
    }, { "./appendTo": 474, "./clear": 477, "./util/parse": 486, "./util/serialize": 487 }], 482: [function (require, module, exports) {
        module.exports = remove;

        function remove(element) {
            element.parentNode.removeChild(element);
            return element;
        }
    }, {}], 483: [function (require, module, exports) {
        /**
         * transform accessor utility
         */

        module.exports = transform;

        function wrapMatrix(transformList, transform) {
            if (transform instanceof SVGMatrix) {
                return transformList.createSVGTransformFromMatrix(transform);
            } else {
                return transform;
            }
        }

        function setTransforms(transformList, transforms) {
            var i, t;

            transformList.clear();

            for (i = 0; (t = transforms[i]); i++) {
                transformList.appendItem(wrapMatrix(transformList, t));
            }

            transformList.consolidate();
        }

        function transform(node, transforms) {
            var transformList = node.transform.baseVal;

            if (arguments.length === 1) {
                return transformList.consolidate();
            } else {
                if (transforms.length) {
                    setTransforms(transformList, transforms);
                } else {
                    transformList.initialize(wrapMatrix(transformList, transforms));
                }
            }
        }
    }, {}], 484: [function (require, module, exports) {
        module.exports = ensureImported;

        function ensureImported(element, target) {

            if (element.ownerDocument !== target.ownerDocument) {
                try {
                    // may fail on webkit
                    return target.ownerDocument.importNode(element, true);
                } catch (e) {
                    // ignore
                }
            }

            return element;
        }
    }, {}], 485: [function (require, module, exports) {
        var ns = {
            svg: 'http://www.w3.org/2000/svg'
        };

        module.exports = ns;
    }, {}], 486: [function (require, module, exports) {
        /**
         * DOM parsing utility
         */

        module.exports = parse;


        var ns = require('./ns');

        var SVG_START = '<svg xmlns="' + ns.svg + '"';

        function parse(svg) {

            // ensure we import a valid svg document
            if (svg.substring(0, 4) === '<svg') {
                if (svg.indexOf(ns.svg) === -1) {
                    svg = SVG_START + svg.substring(4);
                }
            } else {
                // namespace svg
                svg = SVG_START + '>' + svg + '</svg>';
            }

            return parseDocument(svg);
        }

        function parseDocument(svg) {

            var parser;

            // parse
            parser = new DOMParser();
            parser.async = false;

            return parser.parseFromString(svg, 'text/xml');
        }
    }, { "./ns": 485 }], 487: [function (require, module, exports) {
        /**
         * Serialization util
         */

        module.exports = serialize;


        var TEXT_ENTITIES = /([&<>]{1})/g;
        var ATTR_ENTITIES = /([\n\r"]{1})/g;

        var ENTITY_REPLACEMENT = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '\''
        };

        function escape(str, pattern) {

            function replaceFn(match, entity) {
                return ENTITY_REPLACEMENT[entity] || entity;
            }

            return str.replace(pattern, replaceFn);
        }

        function serialize(node, output) {

            var i, len, attrMap, attrNode, childNodes;

            switch (node.nodeType) {
                // TEXT
                case 3:
                    // replace special XML characters
                    output.push(escape(node.textContent, TEXT_ENTITIES));
                    break;

                // ELEMENT
                case 1:
                    output.push('<', node.tagName);

                    if (node.hasAttributes()) {
                        attrMap = node.attributes;
                        for (i = 0, len = attrMap.length; i < len; ++i) {
                            attrNode = attrMap.item(i);
                            output.push(' ', attrNode.name, '="', escape(attrNode.value, ATTR_ENTITIES), '"');
                        }
                    }

                    if (node.hasChildNodes()) {
                        output.push('>');
                        childNodes = node.childNodes;
                        for (i = 0, len = childNodes.length; i < len; ++i) {
                            serialize(childNodes.item(i), output);
                        }
                        output.push('</', node.tagName, '>');
                    } else {
                        output.push('/>');
                    }
                    break;

                // COMMENT
                case 8:
                    output.push('<!--', escape(node.nodeValue, TEXT_ENTITIES), '-->');
                    break;

                // CDATA
                case 4:
                    output.push('<![CDATA[', node.nodeValue, ']]>');
                    break;

                default:
                    throw new Error('unable to handle node ' + node.nodeType);
            }

            return output;
        }
    }, {}]
}, {}, [1]);
